<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>奇思妙想</title>
  
  <subtitle>越努力越幸运！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zlia.tech/"/>
  <updated>2019-11-09T15:41:06.707Z</updated>
  <id>http://zlia.tech/</id>
  
  <author>
    <name>zlia</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解String与new String</title>
    <link href="http://zlia.tech/2019/11/09/string-newString-compare/"/>
    <id>http://zlia.tech/2019/11/09/string-newString-compare/</id>
    <published>2019-11-09T15:41:06.000Z</published>
    <updated>2019-11-09T15:41:06.707Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>字符串是最常用的类型之一，趁此机会准备探索下它的源码。有关该类的注释作一个总结：</p><blockquote><p>String-字符串，是个常量，它们被创建后<code>其值</code>就不允许被改变，由于它是不可变的，所以它们可以被共享，在内部提供了多个方法来操作字符串。</p></blockquote><p>探索之前我曾看过其他人写的有关于此的文章，发现<code>JDK1.7版本前后的内存模型</code>不一样，而这部分的内容还没有排上行程，简单来说，我还不懂…所以不敢妄下结论，这篇文章的内容也不会从这方面展开来讲，此次探索是基于<code>JDK1.8</code>。</p><a id="more"></a><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a><div><span>原理</span></div></h3><p>字符串是存放在<code>常量池</code>中，至于什么是常量池不准备讨论它。先来个简单的示例方便分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String testOne = <span class="keyword">new</span> String(<span class="string">"testOne"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例就是这么简单…先让我们来看看仅仅是这么一句话，而它的底层都做了什么。紧接着反编译它的字节码文件，命令是<code>javap -v TestString</code>，输出的信息内容比较多，咱们只要常量池的内容，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/java/string/constant-pool-1.png" alt="常量池-1"></p><p>实际上我也看的不是很懂，但有几个点咱们是能确定的，也就是说<code>常量池中有&quot;testOne&quot;字符串</code>，而此时的字节码文件是编译而来的，并未实际上的运行，所以该字符串对象在堆内存中还未创建，这就说明了在编译阶段时字符串就存在于常量池中，同时也验证了一点：<code>常量池中的字符串对象</code>与运行时在<code>堆内存中创建的字符串对象</code>完全是两个对象，因为在编译时期堆内存中的对象还未出生呢，所以不可能引用到它…不知道我讲明白了没有。接着我们从另外一个角度去分析这段示例，因为后续的其他示例可能会羞涩难懂，所以先从简单的示例开始逐渐熟悉起来，最终也是希望读者能够理解这方面的知识。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    Constant pool:</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 编号  类型                值              注释            --------&gt; 这里的注释不一定对，只是作一个标记方便理解        </span></span><br><span class="line">    #1 = Methodref          #6.#22         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">    #2 = Class              #23            // java/lang/String</span><br><span class="line">    #3 = String             #18            // testOne</span><br><span class="line">    #4 = Methodref          #2.#24         // java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V</span><br><span class="line">    #5 = Class              #25            // test20190820/TestString</span><br><span class="line">    #6 = Class              #26            // java/lang/Object</span><br><span class="line">    #7 = Utf8               &lt;init&gt;</span><br><span class="line">    #8 = Utf8               ()V</span><br><span class="line">    #9 = Utf8               Code</span><br><span class="line">    #10 = Utf8               LineNumberTable</span><br><span class="line">    #11 = Utf8               LocalVariableTable</span><br><span class="line">    #12 = Utf8               this</span><br><span class="line">    #13 = Utf8               Ltest20190820/TestString;</span><br><span class="line">    #14 = Utf8               main</span><br><span class="line">    #15 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">    #16 = Utf8               args</span><br><span class="line">    #17 = Utf8               [Ljava/lang/String;</span><br><span class="line">    #18 = Utf8               testOne</span><br><span class="line">    #19 = Utf8               Ljava/lang/String;</span><br><span class="line">    #20 = Utf8               SourceFile</span><br><span class="line">    #21 = Utf8               TestString.java</span><br><span class="line">    #22 = NameAndType        #7:#8          // "&lt;init&gt;":()V</span><br><span class="line">    #23 = Utf8               java/lang/String</span><br><span class="line">    #24 = NameAndType        #7:#27         // "&lt;init&gt;":(Ljava/lang/String;)V</span><br><span class="line">    #25 = Utf8               test20190820/TestString</span><br><span class="line">    #26 = Utf8               java/lang/Object</span><br><span class="line">    #27 = Utf8               (Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><p>执行<code>javap -c TestString</code>获取底层代码执行逻辑，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/java/string/constant-pool-2.png" alt="常量池-2"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test20190820</span>.<span class="title">TestString</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> test20190820.TestString(); <span class="comment">//这里是构造器的执行逻辑，咱们忽略它，毕竟不是重点</span></span><br><span class="line">        Code:</span><br><span class="line">        <span class="number">0</span>: aload_0</span><br><span class="line">        1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">        <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>; <span class="comment">//下面的内容涉及到字节码的指令，网上很多资料，可自行查阅</span></span><br><span class="line">    Code:</span><br><span class="line">    <span class="comment">// #2：对应常量池中编号#2，加上注释我们得出这里是创建字符串对象  -&gt; new String();</span></span><br><span class="line">    0: new           #2                  // class java/lang/String</span><br><span class="line">    <span class="comment">// dup：复制0序号中的引用并压入栈中  -&gt; 也就是将字符串对象的引用放入到栈中</span></span><br><span class="line">    <span class="number">3</span>: dup</span><br><span class="line">    <span class="comment">// ldc：从常量池中加载指定项的引用到栈  #3：同上，对应着常量池的编号#3 -&gt; 将"testOne"字符串的引用加载到栈中</span></span><br><span class="line">    4: ldc           #3                  // String testOne</span><br><span class="line">    <span class="comment">// invokespecial：初始化常量池中的指定项  -&gt; 调用字符串对象的初始化并将4序号中的引用作为参数传入，形成new String("testOne")</span></span><br><span class="line">    6: invokespecial #4                  // Method java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V</span><br><span class="line">    <span class="comment">// astore_n：将引用赋值给第n个局部变量  -&gt; 将6序号的引用赋值给第一个局部变量，String testOne = new String("testOne")，jvm中是有记录局部变量的信息</span></span><br><span class="line">    <span class="number">9</span>: astore_1</span><br><span class="line">    <span class="comment">// 退出方法的标志</span></span><br><span class="line">    <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的分析可以知道：<code>常量池中的字符串对象与在堆内存中创建的字符串对象是两个对象</code>，这一点很重要！接下来是各种示例，我们将采用上面的方式进行分析。</p><h4 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String testOne = <span class="keyword">new</span> String(<span class="string">"testOne"</span>);</span><br><span class="line">        String testOneAnother = <span class="string">"testOne"</span>;</span><br><span class="line">        System.out.println(testOne == testOneAnother); <span class="comment">//false -&gt; 上面说了testOne和testOneAnother是两个对象，所以很容易得出结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        String s2 = <span class="string">"a"</span>;</span><br><span class="line">        String s3 = <span class="string">"bc"</span>;</span><br><span class="line">        String s4 = s2 + s3; <span class="comment">// StringBuilder.append(a).append(bc) -&gt; StringBuilder.toString() -&gt; new String("abc")</span></span><br><span class="line">        System.out.println(s1 == s4); <span class="comment">//false, s1指向了常量池中的字符串abc，s4相当于生成了新的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里就不贴常量池的信息了，反正我们能确定的是在编译时期字符串已经加载到常量池中了，所以常量池中应该存在abc、a、bc字符串</span></span><br><span class="line"><span class="comment"> * 贴出代码的执行逻辑：</span></span><br><span class="line"><span class="comment"> *  public static void main(java.lang.String[]);</span></span><br><span class="line"><span class="comment"> *      Code:</span></span><br><span class="line"><span class="comment"> *          0: ldc           #2                  // String abc   -&gt;  ldc：从常量池中加载指定项的引用到栈</span></span><br><span class="line"><span class="comment"> *          2: astore_1                                          -&gt;  abstor_1：将引用赋值给第1个局部变量， 即 s1 = "abc"</span></span><br><span class="line"><span class="comment"> *          3: ldc           #3                  // String a</span></span><br><span class="line"><span class="comment"> *          5: astore_2                                          -&gt;  s2 = "a"</span></span><br><span class="line"><span class="comment"> *          6: ldc           #4                  // String bc</span></span><br><span class="line"><span class="comment"> *          8: astore_3                                          -&gt;  s3 = "bc"</span></span><br><span class="line"><span class="comment"> *          9: new           #5                  // class java/lang/StringBuilder    -&gt; 创建StringBuilder对象</span></span><br><span class="line"><span class="comment"> *          12: dup    -&gt;  复制StringBuilder对象的引用并压入栈中</span></span><br><span class="line"><span class="comment"> *          13: invokespecial #6                  // Method java/lang/StringBuilder."&lt;init&gt;":()V    -&gt; 初始化StringBuilder对象</span></span><br><span class="line"><span class="comment"> *          16: aload_2                            -&gt; 加载第二个局部变量的值</span></span><br><span class="line"><span class="comment"> *          17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;  -&gt; 调用常量池中指定项的方法，即调用StringBuilder对象中的append方法，并传入序号 *                                                                                                                                           16中的引用，所以最终是StringBuilder#append(a)</span></span><br><span class="line"><span class="comment"> *          20: aload_3</span></span><br><span class="line"><span class="comment"> *          21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line"><span class="comment"> *          24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;      -&gt; StringBuilder#toString, 可以看下该类的toString方法，生成了一个新的对象，该对象中的字符串不会再*                                                                                                                        常量池中生成</span></span><br><span class="line"><span class="comment"> *          27: astore        4                    -&gt; 将序号24中的引用赋值给第4个局部变量 s4 = StringBuilder.toString = new String()</span></span><br><span class="line"><span class="comment"> *          29: getstatic     #9                  // Field java/lang/System.out:Ljava/io/PrintStream;   -&gt; 下面的就讨论了，执行的是System.out.println代码片段了</span></span><br><span class="line"><span class="comment"> *          32: aload_1</span></span><br><span class="line"><span class="comment"> *          33: aload         4</span></span><br><span class="line"><span class="comment"> *          35: if_acmpne     42</span></span><br><span class="line"><span class="comment"> *          38: iconst_1</span></span><br><span class="line"><span class="comment"> *          39: goto          43</span></span><br><span class="line"><span class="comment"> *          42: iconst_0</span></span><br><span class="line"><span class="comment"> *          43: invokevirtual #10                 // Method java/io/PrintStream.println:(Z)V</span></span><br><span class="line"><span class="comment"> *          46: return</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 从上面的分析中我们得出结论：s1指向常量池中的字符串对象abc，而从序号16-27我们知道生成了新的对象，相当于是执行了new String("abc")，而这不就又回到了示例一了吗，结果自然是false</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        <span class="keyword">final</span> String s2 = <span class="string">"a"</span>;</span><br><span class="line">        <span class="keyword">final</span> String s3 = <span class="string">"bc"</span>;</span><br><span class="line">        String s4 = s2 + s3; <span class="comment">//由于s2、s3被final修饰了，故而直接替换变量的值，最后s4 = "abc"，直接使用了常量池中的字符串对象abc</span></span><br><span class="line">        System.out.println(s1 == s4); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同样贴出代码的执行逻辑：</span></span><br><span class="line"><span class="comment"> *  public static void main(java.lang.String[]);</span></span><br><span class="line"><span class="comment"> *      Code:</span></span><br><span class="line"><span class="comment"> *          0: ldc           #2                  // String abc  -&gt; ldc：从常量池中加载指定项的引用到栈</span></span><br><span class="line"><span class="comment"> *          2: astore_1                                         -&gt; s1 = "abc"</span></span><br><span class="line"><span class="comment"> *          3: ldc           #3                  // String a</span></span><br><span class="line"><span class="comment"> *          5: astore_2                                         -&gt; s2 = "a" </span></span><br><span class="line"><span class="comment"> *          6: ldc           #4                  // String bc</span></span><br><span class="line"><span class="comment"> *          8: astore_3                                         -&gt; s3 = "bc"</span></span><br><span class="line"><span class="comment"> *          9: ldc           #2                  // String abc</span></span><br><span class="line"><span class="comment"> *          11: astore        4                                 -&gt; s4 = "abc"  示例三与示例二的区别在于加了final修饰，被final修饰的变量会在编译阶段直接替换成对应的值，即"a" + "bc"，而这个在示例四中我们也会分析到，是直接采用</span></span><br><span class="line"><span class="comment"> *                                                                             字符串合并，而合并后的字符串abc在常量池中已经存在了，故直接使用</span></span><br><span class="line"><span class="comment"> *          13: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line"><span class="comment"> *          16: aload_1</span></span><br><span class="line"><span class="comment"> *          17: aload         4</span></span><br><span class="line"><span class="comment"> *          19: if_acmpne     26</span></span><br><span class="line"><span class="comment"> *          22: iconst_1</span></span><br><span class="line"><span class="comment"> *          23: goto          27</span></span><br><span class="line"><span class="comment"> *          26: iconst_0</span></span><br><span class="line"><span class="comment"> *          27: invokevirtual #6                  // Method java/io/PrintStream.println:(Z)V</span></span><br><span class="line"><span class="comment"> *          30: return</span></span><br><span class="line"><span class="comment"> * 从上面的分析中我们得出结论：s1指向了常量池中的字符串对象abc，s4也是指向了常量池中的字符串对象abc</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="示例四"><a href="#示例四" class="headerlink" title="示例四"></a>示例四</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        String s2 = <span class="string">"a"</span> + <span class="string">"bc"</span>; <span class="comment">//s1、s2指向同一个字符串</span></span><br><span class="line">        String s3 = <span class="string">"test"</span> + <span class="string">"One"</span>; <span class="comment">//说明常量池是直接存储合并后的字符串</span></span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里多贴出常量池的信息，为了说明s3的行为</span></span><br><span class="line"><span class="comment"> * Constant pool:</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * #30 = Utf8               abc</span></span><br><span class="line"><span class="comment"> * #31 = Utf8               testOne</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * 省略了一部分信息，说明常量池是直接存储合并后的字符串，而并分开存储，所以常量池中只会有"testOne"，并没有"test"或"One"</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  public static void main(java.lang.String[]);</span></span><br><span class="line"><span class="comment"> *       Code:</span></span><br><span class="line"><span class="comment"> *          0: ldc           #2                  // String abc</span></span><br><span class="line"><span class="comment"> *          2: astore_1                            -&gt; s1 = "abc" 指向常量池中#2的引用</span></span><br><span class="line"><span class="comment"> *          3: ldc           #2                  // String abc</span></span><br><span class="line"><span class="comment"> *          5: astore_2                            -&gt; s2 = "abc" 从常量池中#2的引用，可以看到引用的字符串对象是同一个</span></span><br><span class="line"><span class="comment"> *          6: ldc           #3                  // String testOne</span></span><br><span class="line"><span class="comment"> *          8: astore_3</span></span><br><span class="line"><span class="comment"> *          9: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line"><span class="comment"> *          12: aload_1</span></span><br><span class="line"><span class="comment"> *          13: aload_2</span></span><br><span class="line"><span class="comment"> *          14: if_acmpne     21</span></span><br><span class="line"><span class="comment"> *          17: iconst_1</span></span><br><span class="line"><span class="comment"> *          18: goto          22</span></span><br><span class="line"><span class="comment"> *          21: iconst_0</span></span><br><span class="line"><span class="comment"> *          22: invokevirtual #5                  // Method java/io/PrintStream.println:(Z)V</span></span><br><span class="line"><span class="comment"> *          25: return</span></span><br><span class="line"><span class="comment"> * 从上面的分析中我们得出结论：s1、s2指向了常量池中的同一个字符串对象</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="示例五"><a href="#示例五" class="headerlink" title="示例五"></a>示例五</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        String s2 = <span class="string">"a"</span>;</span><br><span class="line">        String s3 = s2 + <span class="string">"bc"</span>; <span class="comment">// StringBuilder.append(a).append(bc) -&gt; StringBuilder.toString() -&gt; new String("abc")</span></span><br><span class="line">        System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * public static void main(java.lang.String[]);</span></span><br><span class="line"><span class="comment"> *       Code:</span></span><br><span class="line"><span class="comment"> *          0: ldc           #2                  // String abc</span></span><br><span class="line"><span class="comment"> *          2: astore_1                             -&gt; s1 = "abc"</span></span><br><span class="line"><span class="comment"> *          3: ldc           #3                  // String a</span></span><br><span class="line"><span class="comment"> *          5: astore_2                             -&gt; s2 = "a"</span></span><br><span class="line"><span class="comment"> *          6: new           #4                  // class java/lang/StringBuilder   -&gt; 创建StringBuilder对象</span></span><br><span class="line"><span class="comment"> *          9: dup           -&gt;  复制StringBuilder对象的引用并压入栈中</span></span><br><span class="line"><span class="comment"> *          10: invokespecial #5                  // Method java/lang/StringBuilder."&lt;init&gt;":()V   -&gt; 初始化StringBuilder</span></span><br><span class="line"><span class="comment"> *          13: aload_2                             -&gt; 加载第二个局部变量的值</span></span><br><span class="line"><span class="comment"> *          14: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;   -&gt; StringBuilder.append("a")</span></span><br><span class="line"><span class="comment"> *          17: ldc           #7                  // String bc</span></span><br><span class="line"><span class="comment"> *          19: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;   -&gt; StringBuilder.append("bc")</span></span><br><span class="line"><span class="comment"> *          22: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;    -&gt; StringBuilder.toString</span></span><br><span class="line"><span class="comment"> *          25: astore_3                           -&gt; s3 = "abc"</span></span><br><span class="line"><span class="comment"> *          26: getstatic     #9                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line"><span class="comment"> *          29: aload_1</span></span><br><span class="line"><span class="comment"> *          30: aload_3</span></span><br><span class="line"><span class="comment"> *          31: if_acmpne     38</span></span><br><span class="line"><span class="comment"> *          34: iconst_1</span></span><br><span class="line"><span class="comment"> *          35: goto          39</span></span><br><span class="line"><span class="comment"> *          38: iconst_0</span></span><br><span class="line"><span class="comment"> *          39: invokevirtual #10                 // Method java/io/PrintStream.println:(Z)V</span></span><br><span class="line"><span class="comment"> *          42: return</span></span><br><span class="line"><span class="comment"> * 从上面的分析中我们得出结论：s1指向常量池中的字符串对象abc，而从序号9-25我们知道生成了新的对象，相当于是执行了new String("abc")，结果自然是false</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="示例六"><a href="#示例六" class="headerlink" title="示例六"></a>示例六</h4><p>先来看下String#intern方法作了什么动作，还是采用此分析方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String testOne = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"bc"</span>); <span class="comment">//常量池中存储字符串a、bc，最终testOne指向堆内存中的对象，而该对象对应的字符串是不会在常量池中存在</span></span><br><span class="line">        String testOneAnother = testOne.intern(); <span class="comment">//先去常量池中查询是否已经存在该字符串，如果存在，则返回常量池中的引用，若不存在则不会将该对象的字符串拷贝到常量池中，而是在常量池中持有对该对象的引用</span></span><br><span class="line">                                                  <span class="comment">//这里的引用没办法从该方式得出，可能需要看下native的方法，反正我是看了别人的分析，虽然我是知道原理但还是忍不住看了以下底层实现</span></span><br><span class="line">        System.out.println(testOne == testOneAnther) <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constant pool:</span></span><br><span class="line"><span class="comment"> *  ...</span></span><br><span class="line"><span class="comment"> * #31 = Utf8               a</span></span><br><span class="line"><span class="comment"> *  ...</span></span><br><span class="line"><span class="comment"> * #34 = Utf8               bc</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="示例七"><a href="#示例七" class="headerlink" title="示例七"></a>示例七</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"bc"</span>);</span><br><span class="line">        s1.intern(); <span class="comment">//执行该方法后，常量池中已经存在指向s1对象的引用，即"abc"字符串的引用</span></span><br><span class="line">        String s2 = <span class="string">"abc"</span>; <span class="comment">// 常量池中已经存在"abc"字符串的引用，即为s1对象的引用</span></span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * public static void main(java.lang.String[]);</span></span><br><span class="line"><span class="comment"> *      Code:</span></span><br><span class="line"><span class="comment"> *          0: new           #2                  // class java/lang/StringBuilder    -&gt; 创建StringBuilder对象</span></span><br><span class="line"><span class="comment"> *          3: dup                                -&gt; 复制StringBuilder对象的引用并压入栈中</span></span><br><span class="line"><span class="comment"> *          4: invokespecial #3                  // Method java/lang/StringBuilder."&lt;init&gt;":()V  -&gt; 初始化StringBuilder</span></span><br><span class="line"><span class="comment"> *          7: new           #4                  // class java/lang/String    -&gt; 创建字符串对象 new String()</span></span><br><span class="line"><span class="comment"> *          10: dup                               -&gt; 复制String对象的引用并压入栈中</span></span><br><span class="line"><span class="comment"> *          11: ldc           #5                  // String a</span></span><br><span class="line"><span class="comment"> *          13: invokespecial #6                  // Method java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V    -&gt; new String("a")</span></span><br><span class="line"><span class="comment"> *          16: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; -&gt; StringBuilder.append()</span></span><br><span class="line"><span class="comment"> *          19: new           #4                  // class java/lang/String    -&gt;  创建字符串对象 new String()</span></span><br><span class="line"><span class="comment"> *          22: dup                               -&gt; 复制String对象的引用并压入栈中</span></span><br><span class="line"><span class="comment"> *          23: ldc           #8                  // String bc</span></span><br><span class="line"><span class="comment"> *          25: invokespecial #6                  // Method java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V   -&gt; new String("bc")</span></span><br><span class="line"><span class="comment"> *          28: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; -&gt; StringBuilder.append()</span></span><br><span class="line"><span class="comment"> *          31: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;  -&gt; StringBuilder.toString()</span></span><br><span class="line"><span class="comment"> *          34: astore_1                          -&gt; s1 = "abc", 由StringBuilder#toString创建的字符串对象</span></span><br><span class="line"><span class="comment"> *          35: aload_1                           -&gt; 加载第一个局部变量的值</span></span><br><span class="line"><span class="comment"> *          36: invokevirtual #10                 // Method java/lang/String.intern:()Ljava/lang/String;  -&gt; s1.intern()</span></span><br><span class="line"><span class="comment"> *          39: pop                               -&gt; pop：移除栈顶的值</span></span><br><span class="line"><span class="comment"> *          40: ldc           #11                 // String abc</span></span><br><span class="line"><span class="comment"> *          42: astore_2                          -&gt; s2 = "abc"</span></span><br><span class="line"><span class="comment"> *          43: getstatic     #12                 // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line"><span class="comment"> *          46: aload_1</span></span><br><span class="line"><span class="comment"> *          47: aload_2</span></span><br><span class="line"><span class="comment"> *          48: if_acmpne     55</span></span><br><span class="line"><span class="comment"> *          51: iconst_1</span></span><br><span class="line"><span class="comment"> *          52: goto          56</span></span><br><span class="line"><span class="comment"> *          55: iconst_0</span></span><br><span class="line"><span class="comment"> *          56: invokevirtual #13                 // Method java/io/PrintStream.println:(Z)V</span></span><br><span class="line"><span class="comment"> *          59: return</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="示例八"><a href="#示例八" class="headerlink" title="示例八"></a>示例八</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>); <span class="comment">//生成两个对象，堆内存一个，常量池一个</span></span><br><span class="line">        s1.intern(); <span class="comment">//常量池中已经存在该字符串对象，故而直接返回</span></span><br><span class="line">        String s2 = <span class="string">"abc"</span>; <span class="comment">//指向常量池的字符串对象</span></span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//false  -&gt; s1指向堆内存中的对象，s2指向常量池的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>在编译阶段，字符串已经被存储与常量池中</p></li><li><p>new String(“abc”)：一共有两个不同的对象，一个在堆内存、一个在常量池</p></li><li><p>s2 + s3拼接（s2、s3未被final修饰）：底层创建StringBuilder对象，通过append拼接起来，最终调用toString生成一个新的对象</p></li><li><p>“a” + “bc”直接拼接：直接将拼接后的字符串存储于常量池中</p></li><li><p>s2 + “bc”拼接（s2未被final修饰）：底层创建StringBuilder对象，通过append拼接起来，最终调用toString生成一个新的对象</p></li><li><p>s.intern：若常量池中存在字符串，则直接返回引用，若不存在，则在常量池中生成指向该字符串对象的引用，后续若有声明此字符串，会返回指向该字符串对象的引用，也就是同一个引用（参考示例七、八）</p></li></ul><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a><div><span>重点</span></div></h3><p><code>new String与String的区别</code> <code>(s1 + s2)与(&quot;a&quot; + &quot;bc&quot;)的区别</code> <code>intern</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;字符串是最常用的类型之一，趁此机会准备探索下它的源码。有关该类的注释作一个总结：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;String-字符串，是个常量，它们被创建后&lt;code&gt;其值&lt;/code&gt;就不允许被改变，由于它是不可变的，所以它们可以被共享，在内部提供了多个方法来操作字符串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;探索之前我曾看过其他人写的有关于此的文章，发现&lt;code&gt;JDK1.7版本前后的内存模型&lt;/code&gt;不一样，而这部分的内容还没有排上行程，简单来说，我还不懂…所以不敢妄下结论，这篇文章的内容也不会从这方面展开来讲，此次探索是基于&lt;code&gt;JDK1.8&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Comparable VS Comparator</title>
    <link href="http://zlia.tech/2019/11/06/comparable-comparator-compare/"/>
    <id>http://zlia.tech/2019/11/06/comparable-comparator-compare/</id>
    <published>2019-11-06T10:45:42.000Z</published>
    <updated>2019-11-06T10:45:42.075Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>在阅读TreeMap源码时发现了Comparable与Comparator，光是名字看起来就很像，既然都是比较器，那有何区别呢？实际上我对于比较器的使用场景并不是很多，所以这篇还是借鉴了别人的想法。</p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a><div><span>比较</span></div></h3><p>通过下面的这段代码来说明问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Apple appleOne = <span class="keyword">new</span> Apple(<span class="number">1</span>, <span class="string">"red"</span>);</span><br><span class="line">        Apple appleTwo = <span class="keyword">new</span> Apple(<span class="number">2</span>, <span class="string">"green"</span>);</span><br><span class="line">        appleOne.compareTo(appleTwo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Apple</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    Apple(<span class="keyword">int</span> size, String color)&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Apple o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size &gt; o.size ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">//比较Apple的大小</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getter、setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>代码上挺简单的，只是比较了Apple的大小，现在来思考一下，哪一天突然想比较Apple的颜色了，那岂不是要改代码了，而对于新需求我们通常说现有代码尽量保持不变，通过新增类的方式来满足，所以Comparable的缺点很明显，一旦某个类指定了比较方式后就无法做修改（除非是修改代码…），即使能修改代码我们也不知道会不会造成新的问题或新的需求产生，所以这是行不通的。而对于Comparator来说，它就显得更加灵活了，支持多个比较器，只要新增类即可，看如下的代码展示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Apple appleOne = <span class="keyword">new</span> Apple(<span class="number">1</span>, <span class="string">"red"</span>);</span><br><span class="line">        Apple appleTwo = <span class="keyword">new</span> Apple(<span class="number">2</span>, <span class="string">"green"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较Apple的大小</span></span><br><span class="line">        AppleCompareSize acs = <span class="keyword">new</span> AppleCompareSize();</span><br><span class="line">        acs.compare(appleOne, appleTwo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较Apple的颜色</span></span><br><span class="line">        AppleCompareColor acc = <span class="keyword">new</span> AppleCompareColor();</span><br><span class="line">        acc.compare(appleOne, appleTwo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    Apple(<span class="keyword">int</span> size, String color) &#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getter、setter</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleCompareSize</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Apple</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Apple o1, Apple o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getSize() &gt; o2.getSize() ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleCompareColor</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Apple</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Apple o1, Apple o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getColor().compareTo(o2.getColor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该很容易就能看出效果了，即使别人已经写好了一个比较器，对于新需求，我们只要增加即可，并不会出现修改或污染其他人代码的情况。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><div><span>总结</span></div></h3><p>Comparator与Comaparable的最大区别在于<code>Comparator能够定义多种不同的比较策略</code>，即新增多个比较来，同时避免往比较对象（Apple）中添加其他代码（比较）</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;在阅读TreeMap源码时发现了Comparable与Comparator，光是名字看起来就很像，既然都是比较器，那有何区别呢？实际上我对于比较器的使用场景并不是很多，所以这篇还是借鉴了别人的想法。&lt;/p&gt;
&lt;h3 id=&quot;比较&quot;&gt;&lt;a href=&quot;#比较&quot; class=&quot;headerlink&quot; title=&quot;比较&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;比较&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;通过下面的这段代码来说明问题。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Apple appleOne = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Apple(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Apple appleTwo = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Apple(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        appleOne.compareTo(appleTwo);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Apple&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Comparable&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;Apple&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String color;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Apple(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; size, String color)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.size = size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.color = color;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;compareTo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Apple o)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; size &amp;gt; o.size ? &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; : &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//比较Apple的大小&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//getter、setter&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索LinkedHashSet底层实现</title>
    <link href="http://zlia.tech/2019/11/06/explain-linkedhashset-sourcecode/"/>
    <id>http://zlia.tech/2019/11/06/explain-linkedhashset-sourcecode/</id>
    <published>2019-11-06T06:24:42.000Z</published>
    <updated>2019-11-06T06:24:42.323Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>额… 底层实现了LinkedHashMap，它的数据结构是<code>数组 + 链表 + 红黑树</code>，内部通过一条<code>链表</code>来维护<code>有序性</code>，按照插入顺序进行排列。代码只有100行…</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定初始容量与加载因子来初始化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loadFactor 指定加载因子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定初始容量来初始化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">16</span>, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定集合来初始化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Math.max(<span class="number">2</span>*c.size(), <span class="number">11</span>), .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>LinkedHashSet底层基于LinkedHashMap</p></li><li><p>LinkedHashSet有序、不可重复、非线程安全</p></li><li><p>LinkedHashSet允许空元素</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>基于LinkedHashMap</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;额… 底层实现了LinkedHashMap，它的数据结构是&lt;code&gt;数组 + 链表 + 红黑树&lt;/code&gt;，内部通过一条&lt;code&gt;链表&lt;/code&gt;来维护&lt;code&gt;有序性&lt;/code&gt;，按照插入顺序进行排列。代码只有100行…&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索TreeSet底层实现</title>
    <link href="http://zlia.tech/2019/11/06/explain-treeset-sourcecode/"/>
    <id>http://zlia.tech/2019/11/06/explain-treeset-sourcecode/</id>
    <published>2019-11-06T03:20:51.000Z</published>
    <updated>2019-11-06T03:20:51.091Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>TreeSet的内部实现基于TreeMap，所以它的数据结构是<code>红黑树</code>。注释也不总结了，此探索是基于<code>JDK1.8</code>，直接进入正题。</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//存储元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//既然用了TreeMap就要考虑值应该存什么，就是它了，不管新增的元素是什么，它都作为值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定NavigableMap实现类来初始化</span></span><br><span class="line"><span class="comment"> * ConcurrentSkipListMap是NavigableMap的实现类！！！埋下伏笔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class="line">    <span class="keyword">this</span>.m = m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定比较器进行初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> comparator 比较器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;&gt;(comparator));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定集合进行初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定Set集合进行初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s Set集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(SortedSet&lt;E&gt; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(s.comparator());</span><br><span class="line">    addAll(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.navigableKeySet().iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取按降序排列的迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 降序排列的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.descendingKeySet().iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取按降序排列的Set集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 降序排列的Set集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">descendingSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeSet&lt;&gt;(m.descendingMap());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TreeSet集合的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TreeSet集合是否为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TreeSet是否包含指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.containsKey(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否新增成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量添加指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Use linear-time version if applicable</span></span><br><span class="line">    <span class="keyword">if</span> (m.size()==<span class="number">0</span> &amp;&amp; c.size() &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        c <span class="keyword">instanceof</span> SortedSet &amp;&amp;</span><br><span class="line">        m <span class="keyword">instanceof</span> TreeMap) &#123;</span><br><span class="line">        SortedSet&lt;? extends E&gt; set = (SortedSet&lt;? extends E&gt;) c;</span><br><span class="line">        TreeMap&lt;E,Object&gt; map = (TreeMap&lt;E, Object&gt;) m;</span><br><span class="line">        Comparator&lt;?&gt; cc = set.comparator();</span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> E&gt; mc = map.comparator();</span><br><span class="line">        <span class="keyword">if</span> (cc==mc || (cc != <span class="keyword">null</span> &amp;&amp; cc.equals(mc))) &#123;</span><br><span class="line">            map.addAllForTreeSet(set, PRESENT); <span class="comment">//指定集合来添加一颗红黑树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定起始元素与结束元素及是否包含起始、结束元素来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * 当前对象是已经排好序了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromElement 起始元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromInclusive 子集中是否包含起始元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toElement 结束元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toInclusive 子集中是否包含结束元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, <span class="keyword">boolean</span> fromInclusive, E toElement,   <span class="keyword">boolean</span> toInclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeSet&lt;&gt;(m.subMap(fromElement, fromInclusive, toElement, toInclusive));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定结束元素及是否包含结束元素来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * 当前对象是已经排好序了，相当于起始元素已经指定好了</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toElement 结束元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inclusive 子集中是否包含结束元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement, <span class="keyword">boolean</span> inclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeSet&lt;&gt;(m.headMap(toElement, inclusive));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定起始元素及是否包含起始元素来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * 相当于介绍元素已经指定好了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromElement 起始元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inclusive 子集中是否包含起始元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement, <span class="keyword">boolean</span> inclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeSet&lt;&gt;(m.tailMap(fromElement, inclusive));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定起始元素与结束元素来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * 包含起始元素、不包含结束元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromElement 起始元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toElement 结束元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SortedSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, E toElement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> subSet(fromElement, <span class="keyword">true</span>, toElement, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取比较器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 比较器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator() &#123;</span><br><span class="line">    <span class="keyword">return</span> m.comparator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取排序后的第一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 排序后的第一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.firstKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取排序后的最后一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 排序后的最后一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">last</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.lastKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取小于指定元素的最大值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 小于指定元素的最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">lower</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.lowerKey(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取等于或小于指定元素的最大值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 等于或小于指定元素的最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">floor</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.floorKey(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取等于或大于指定元素的最小值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 等于或大于指定元素的最小值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">ceiling</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.ceilingKey(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取大于指定元素的最小值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 大于指定元素的最小值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">higher</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.higherKey(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取排序后的第一个元素并移除</span></span><br><span class="line"><span class="comment"> * 获取最左边的元素并移除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最左边的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map.Entry&lt;E,?&gt; e = m.pollFirstEntry();</span><br><span class="line">    <span class="keyword">return</span> (e == <span class="keyword">null</span>) ? <span class="keyword">null</span> : e.getKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取排序后的最后一个元素并移除</span></span><br><span class="line"><span class="comment"> * 获取最右边的元素并移除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最右边的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map.Entry&lt;E,?&gt; e = m.pollLastEntry();</span><br><span class="line">    <span class="keyword">return</span> (e == <span class="keyword">null</span>) ? <span class="keyword">null</span> : e.getKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>TreeSet底层是TreeMa，所以它的数据结构是红黑树</p></li><li><p>TreeSet有序、不可重复、非线程安全</p></li><li><p>TreeSet默认按照自然顺序排列元素，可指定比较器来自定义排序</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>基于TreeMap</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;TreeSet的内部实现基于TreeMap，所以它的数据结构是&lt;code&gt;红黑树&lt;/code&gt;。注释也不总结了，此探索是基于&lt;code&gt;JDK1.8&lt;/code&gt;，直接进入正题。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索HashSet底层实现</title>
    <link href="http://zlia.tech/2019/11/05/explain-hashset-sourcecode/"/>
    <id>http://zlia.tech/2019/11/05/explain-hashset-sourcecode/</id>
    <published>2019-11-05T12:59:05.000Z</published>
    <updated>2019-11-05T12:59:05.138Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>HashSet的底层实现依赖于HashMap，所以它的数据结构也是<code>数组 + 链表 + 红黑树</code>，而对于它的类注释也没什么好总结的，探索HashSet底层实现是基于<code>JDK1.8</code>。仔细一想，HashSet存在的意义是什么？有时候需要添加元素时，也就是只有单个对象，并没有所谓的键值对，或许还有些用处，可这ArrayList也能做到啊！可是相比之下，HashSet由于有HashMap撑腰，它的性能要高于ArrayList，所以我认为HashSet是List和Map独有的特性结合后的产物。</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//可序列化、可克隆</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接使用了HashMap来存储它的元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//既然用了HashMap就要考虑值应该存什么，就是它了，不管新增的元素是什么，它都作为值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定集合来初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量与加载因子来初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor 指定加载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量来初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量与加载因子来初始化</span></span><br><span class="line"><span class="comment"> * 对比上面这里构造了LinkedHashMap，说明它是有序的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor 指定加载因子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dummy 无实际意义，为了与上面的构造函数区分开来</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取元素个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashSet是否为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashSet是否包含指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否新增成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 浅克隆</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        newSet.map = (HashMap&lt;E, Object&gt;) map.clone();</span><br><span class="line">        <span class="keyword">return</span> newSet;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>HashSet无序、不可重复、非线程安全</p></li><li><p>HashSet允许存放空元素</p></li><li><p>HashSet底层基于HashMap</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>基于HashMap</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;HashSet的底层实现依赖于HashMap，所以它的数据结构也是&lt;code&gt;数组 + 链表 + 红黑树&lt;/code&gt;，而对于它的类注释也没什么好总结的，探索HashSet底层实现是基于&lt;code&gt;JDK1.8&lt;/code&gt;。仔细一想，HashSet存在的意义是什么？有时候需要添加元素时，也就是只有单个对象，并没有所谓的键值对，或许还有些用处，可这ArrayList也能做到啊！可是相比之下，HashSet由于有HashMap撑腰，它的性能要高于ArrayList，所以我认为HashSet是List和Map独有的特性结合后的产物。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>比较Map实现类的不同点</title>
    <link href="http://zlia.tech/2019/11/05/map-different-compare/"/>
    <id>http://zlia.tech/2019/11/05/map-different-compare/</id>
    <published>2019-11-05T08:22:02.000Z</published>
    <updated>2019-11-05T13:10:22.159Z</updated>
    
    <content type="html"><![CDATA[<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a><div><span>比较</span></div></h3><p>趁热打铁！比较最近学习到的几个Map实现类，也正好总结下！此比较是基于<code>JDK1.8</code>，直接用表格展示。</p><table><thead><tr><th style="text-align:center">比较点</th><th style="text-align:center">HashMap</th><th style="text-align:center">Hashtable</th><th style="text-align:center">IdentityHashMap</th><th style="text-align:center">LinkedHashMap</th><th style="text-align:center">TreeMap</th><th style="text-align:center">WeakHashMap</th></tr></thead><tbody><tr><td style="text-align:center">数据结构</td><td style="text-align:center">数组<br>链表<br>红黑树</td><td style="text-align:center">数组<br>链表</td><td style="text-align:center">数组<br>（哈希探针表）</td><td style="text-align:center">数组<br>链表<br>红黑树</td><td style="text-align:center">红黑树</td><td style="text-align:center">数组<br>链表</td></tr><tr><td style="text-align:center">是否有序/可重复</td><td style="text-align:center">无序不可重复</td><td style="text-align:center">无序不可重复</td><td style="text-align:center">无序不可重复</td><td style="text-align:center">默认按插入顺序排列<br>可按访问顺序排列<br>不可重复</td><td style="text-align:center">默认按自然顺序<br>可指定比较器进行自定义排序<br>不可重复</td><td style="text-align:center">无序不可重复</td></tr><tr><td style="text-align:center">键值对为null</td><td style="text-align:center">允许</td><td style="text-align:center">不允许</td><td style="text-align:center">允许</td><td style="text-align:center">允许</td><td style="text-align:center">默认排序中键不允许，值允许<br>自定义排序中键值对都允许</td><td style="text-align:center">允许</td></tr><tr><td style="text-align:center">默认初始容量</td><td style="text-align:center">16</td><td style="text-align:center">11</td><td style="text-align:center">64</td><td style="text-align:center">16</td><td style="text-align:center"></td><td style="text-align:center">16</td></tr><tr><td style="text-align:center">默认加载因子</td><td style="text-align:center">0.75</td><td style="text-align:center">0.75</td><td style="text-align:center">1/3</td><td style="text-align:center">0.75</td><td style="text-align:center"></td><td style="text-align:center">0.75</td></tr><tr><td style="text-align:center">扩容策略</td><td style="text-align:center">2 * capacity</td><td style="text-align:center">2 * capacity + 1</td><td style="text-align:center">2 * capacity</td><td style="text-align:center">2 * capacity</td><td style="text-align:center"></td><td style="text-align:center">2 * capacity</td></tr><tr><td style="text-align:center">计算hash方式</td><td style="text-align:center">hash ^ (hash &gt;&gt;&gt; 16)</td><td style="text-align:center">hash &amp; 0x7FFFFFFF</td><td style="text-align:center">(hash &lt;&lt; 1) - (hash &lt;&lt; 8)</td><td style="text-align:center">hash ^ (hash &gt;&gt;&gt; 16)</td><td style="text-align:center"></td><td style="text-align:center">有点复杂，就不贴了</td></tr><tr><td style="text-align:center">计算索引</td><td style="text-align:center">hash &amp; (capacity - 1)</td><td style="text-align:center">hash % capacity</td><td style="text-align:center">hash &amp; (capacity - 1)</td><td style="text-align:center">hash &amp; (capacity - 1)</td><td style="text-align:center"></td><td style="text-align:center">hash &amp; (capacity - 1)</td></tr><tr><td style="text-align:center">新增节点</td><td style="text-align:center">尾插法</td><td style="text-align:center">头插法</td><td style="text-align:center"></td><td style="text-align:center">尾插法</td><td style="text-align:center"></td><td style="text-align:center">头插法</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;比较&quot;&gt;&lt;a href=&quot;#比较&quot; class=&quot;headerlink&quot; title=&quot;比较&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;比较&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;趁热打铁！比较最近学习到的几个Map实现类，也正好总结下！此比较是基于&lt;code&gt;JDK1.
      
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索EnumMap底层实现</title>
    <link href="http://zlia.tech/2019/11/05/explain-enummap-sourcecode/"/>
    <id>http://zlia.tech/2019/11/05/explain-enummap-sourcecode/</id>
    <published>2019-11-05T08:17:02.000Z</published>
    <updated>2019-11-05T09:28:40.140Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>EnumMap初次见面，请多多关照！对于该类的注释直接上总结：</p><blockquote><p>专门用于<code>枚举类型</code>的键的Map实现。EnumMap内部的数据结构是数组，按枚举常量的声明顺序排列它的键，与其他Map实现类不同的是，它的迭代器并不会抛出快速失败错误！</p></blockquote><p>该类的代码不到1000行，速速解决掉，探索EnumMap底层实现是基于<code>JDK1.8</code>。</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumMap</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">K</span>&gt;, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 枚举类型的类类型</span></span><br><span class="line"><span class="comment">     * 为什么需要类类型呢? </span></span><br><span class="line"><span class="comment">     * 因为在一开始初始化时，EnumMap就会将枚举类的所有对象加载到数组中，所以每次添加节点时，实际上只是添加了值对象而已</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;K&gt; keyType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 包含枚举类的所有对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> K[] keyUniverse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储值对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Object[] vals;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点个数</span></span><br><span class="line"><span class="comment">     * vals数组中存储的值对象个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存entrySet方法的返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化键数组与值数组</span></span><br><span class="line"><span class="comment"> * 这个就是上面我们所说将枚举类型的所有对象存储到键数组中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keyType 枚举类型的类类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EnumMap</span><span class="params">(Class&lt;K&gt; keyType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.keyType = keyType;</span><br><span class="line">    keyUniverse = getKeyUniverse(keyType);<span class="comment">//该方法会将枚举类的所有对象按照声明的顺序存放</span></span><br><span class="line">    vals = <span class="keyword">new</span> Object[keyUniverse.length];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定EnumMap来初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m EnumMap对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EnumMap</span><span class="params">(EnumMap&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    keyType = m.keyType;</span><br><span class="line">    keyUniverse = m.keyUniverse;</span><br><span class="line">    vals = m.vals.clone();</span><br><span class="line">    size = m.size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定集合来初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EnumMap</span><span class="params">(Map&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m <span class="keyword">instanceof</span> EnumMap) &#123;</span><br><span class="line">        EnumMap&lt;K, ? extends V&gt; em = (EnumMap&lt;K, ? extends V&gt;) m;</span><br><span class="line">        keyType = em.keyType;</span><br><span class="line">        keyUniverse = em.keyUniverse;</span><br><span class="line">        vals = em.vals.clone();</span><br><span class="line">        size = em.size;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (m.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Specified map is empty"</span>);</span><br><span class="line">        keyType = m.keySet().iterator().next().getDeclaringClass();</span><br><span class="line">        keyUniverse = getKeyUniverse(keyType);</span><br><span class="line">        vals = <span class="keyword">new</span> Object[keyUniverse.length];</span><br><span class="line">        putAll(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 倘若值为null则采用NULL_KEY作为值</span></span><br><span class="line"><span class="comment"> * 正如方法名一样，隐藏Null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> NULL_KEY或指定值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">maskNull</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (value == <span class="keyword">null</span> ? NULL : value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 倘若值为NULL_KEY则返回null</span></span><br><span class="line"><span class="comment"> * 正如方法名一样，揭露Null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或指定值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">unmaskNull</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (V)(value == NULL ? <span class="keyword">null</span> : value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取节点个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 节点个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组中是否包含指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    value = maskNull(value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object val : vals)</span><br><span class="line">        <span class="keyword">if</span> (value.equals(val))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组中是否包含指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isValidKey(key) &amp;&amp; vals[((Enum&lt;?&gt;)key).ordinal()] != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键是否有效</span></span><br><span class="line"><span class="comment"> * 是否符合指定的类类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否有效</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; keyClass = key.getClass();</span><br><span class="line">    <span class="keyword">return</span> keyClass == keyType || keyClass.getSuperclass() == keyType; <span class="comment">//keyClass.getSuperclass这个判断语句没有什么意义，枚举类既不能继承其他类，也不能被继承，两个类就无法发生关系，那这个判断结果只会是false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组中是否包含指定键值对</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含键值对</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">containsMapping</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isValidKey(key) &amp;&amp; maskNull(value).equals(vals[((Enum&lt;?&gt;)key).ordinal()]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键获取值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (isValidKey(key) ? unmaskNull(vals[((Enum&lt;?&gt;)key).ordinal()]) : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增键值对</span></span><br><span class="line"><span class="comment"> * 可能会发生替换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    typeCheck(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = key.ordinal();</span><br><span class="line">    Object oldValue = vals[index];</span><br><span class="line">    vals[index] = maskNull(value);</span><br><span class="line">    <span class="keyword">if</span> (oldValue == <span class="keyword">null</span>)</span><br><span class="line">        size++;</span><br><span class="line">    <span class="keyword">return</span> unmaskNull(oldValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键移除值对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isValidKey(key))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> index = ((Enum&lt;?&gt;)key).ordinal();</span><br><span class="line">    Object oldValue = vals[index];</span><br><span class="line">    vals[index] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldValue != <span class="keyword">null</span>)</span><br><span class="line">        size--;</span><br><span class="line">    <span class="keyword">return</span> unmaskNull(oldValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键值对移除值对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除值对象成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">removeMapping</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isValidKey(key))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> index = ((Enum&lt;?&gt;)key).ordinal();</span><br><span class="line">    <span class="keyword">if</span> (maskNull(value).equals(vals[index])) &#123;</span><br><span class="line">        vals[index] = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量添加集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123; <span class="comment">//枚举类之间无法继承，所以这里压根就只能指定K、V</span></span><br><span class="line">    <span class="keyword">if</span> (m <span class="keyword">instanceof</span> EnumMap) &#123;</span><br><span class="line">        EnumMap&lt;?, ?&gt; em = (EnumMap&lt;?, ?&gt;)m;</span><br><span class="line">        <span class="keyword">if</span> (em.keyType != keyType) &#123;</span><br><span class="line">            <span class="keyword">if</span> (em.isEmpty())</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException(em.keyType + <span class="string">" != "</span> + keyType);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; keyUniverse.length; i++) &#123;</span><br><span class="line">            Object emValue = em.vals[i];</span><br><span class="line">            <span class="keyword">if</span> (emValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vals[i] == <span class="keyword">null</span>)</span><br><span class="line">                    size++;</span><br><span class="line">                vals[i] = emValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.putAll(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中间省略了相关迭代器...较为简单相似，有兴趣的读者可自行查看</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空值数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Arrays.fill(vals, <span class="keyword">null</span>);</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取枚举类中所有对象的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keyType 枚举类类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有对象的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;K extends Enum&lt;K&gt;&gt; K[] getKeyUniverse(Class&lt;K&gt; keyType) &#123;</span><br><span class="line">    <span class="keyword">return</span> SharedSecrets.getJavaLangAccess().getEnumConstantsShared(keyType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>专门用于其键为<code>枚举类型</code>的Map实现</p></li><li><p>EnumMap的数据结构是数组，按枚举常量的声明顺序进行排列</p></li><li><p>EnumMap的键不允许为空，值允许为空</p></li><li><p>EnumMap的迭代器不会发生快速失败</p></li><li><p>EnumMap有序、不可重复、非线程安全</p></li><li><p>EnumMap在初始化时将枚举类中的所有对象存储到数组中，而后续的增删改查实际上都是对其值对象的操作</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>内部实现机制</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;EnumMap初次见面，请多多关照！对于该类的注释直接上总结：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;专门用于&lt;code&gt;枚举类型&lt;/code&gt;的键的Map实现。EnumMap内部的数据结构是数组，按枚举常量的声明顺序排列它的键，与其他Map实现类不同的是，它的迭代器并不会抛出快速失败错误！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该类的代码不到1000行，速速解决掉，探索EnumMap底层实现是基于&lt;code&gt;JDK1.8&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索WeakHashMap底层实现</title>
    <link href="http://zlia.tech/2019/11/04/explain-weakhashmap-sourcecode/"/>
    <id>http://zlia.tech/2019/11/04/explain-weakhashmap-sourcecode/</id>
    <published>2019-11-04T10:00:55.000Z</published>
    <updated>2019-11-05T06:34:25.218Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>探索<code>WeakHashMap</code>底层实现是基于<code>JDK1.8</code>，它的数据结构是<code>数组 + 链表</code>。就不贴它的注释了，直接总结一下吧：</p><blockquote><p>WeakHashMap基于<code>弱键</code>实现了Map接口，也就是说，当某个键不在使用时会被丢弃，对应的键值对将会被自动移除。如何确定不在使用取决于GC是否运行，而对于GC何时运行我们并不知道，所以某个键何时被丢弃我们也不得而知，至于GC如何运行就是另外一个话题了，有可能导致上一分钟与下一分钟获取到的结果是不一致的。另一个方面，WeakHashMap的值对象由强引用所持有（何为强引用下面会介绍），应确保值对象不会直接或间接引用自身的键或其他键，这会导致键无法被丢弃。</p></blockquote><ul><li><p>强引用：简单来说指向new出来的对象就是一个强引用，可以说是经常使用。对于强引用来说，它们不会被GC回收，即使内存空间不足，JVM宁愿抛出内存溢出错误也不敢动它们，总体来说还是很有威信的。</p></li><li><p>软引用：首先给强引用包裹上一层<code>SoftReference</code>，通过SoftReference获取到的引用即为软引用。对于软引用来说，在内存充足的情况下，GC可以选择性的清除，而一旦内存不足了，它们一个都跑不了，都会被清除掉。软引用最常用用于实现对内存敏感的缓存。</p></li><li><p>弱引用：首先给强引用包裹上一层<code>WeakReference</code>，通过WeakReference获取到的引用即为弱引用，看到这里你应该就已经明白了WeakHashMap内部的机制。对于弱引用来说，GC压根就不管内存是否充足，直接回收，很没有人性！</p></li><li><p>虚引用：首先给强引用包裹上一层<code>PhantomReference</code>，通过PhantomReference获取到的引用即为虚引用。对于虚引用来说，它在任何时候都可能被回收，常用于跟踪对象。</p></li></ul><p>还有一个方面，读者最好去了解下<code>Reference</code>类，内部通过队列实现了一些机制。</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><p>前奏都准备好了，开始进入正题吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始容量，必须是2的幂次方，可参考HashMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大容量，必须是2的幂次方</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认加载因子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希表，长度必须是2的幂次方</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Entry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希表中包含节点的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩容前需要判断的阈值</span></span><br><span class="line"><span class="comment">     * 若超过该值则扩容，若没超过则不需要</span></span><br><span class="line"><span class="comment">     * 该值的计算方式：capacity * load factor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载因子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用队列</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 为什么需要引用队列呢?</span></span><br><span class="line"><span class="comment">     * 通过上面的介绍我们可以知道哈希表中某些键可能会被移除掉，而移除是GC帮我们做的，那WeakHashMap怎么知道哪些键被移除掉了以便更新自己的键值对，就是该队列做了它们两个之间的媒介</span></span><br><span class="line"><span class="comment">     * 上面让读者去了解Reference类，下面讲的内容其实都在该类中有提到，比较简单</span></span><br><span class="line"><span class="comment">     * GC在丢弃某个键时会将它的键值对，也就是节点信息存放到Reference类中的pending队列中，Reference类在初始化时会启动一个线程，那么该线程会将pending队列中的节点信息放入到queue队列中</span></span><br><span class="line"><span class="comment">     * 也就是在告诉WeakHashMap，队列中的这些节点是我要删除的，你记得更新</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存entrySet方法的返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结构修改的次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> modCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量与加载因子构造哈希表</span></span><br><span class="line"><span class="comment"> * 在上面中我们提到了容量必须是2的幂次方，所以调用tableSizeFor方法来进行调整</span></span><br><span class="line"><span class="comment"> * Float.isNaN：检测是否是数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor 指定加载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeakHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Initial Capacity: "</span>+ initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Load factor: "</span>+ loadFactor);</span><br><span class="line">    <span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (capacity &lt; initialCapacity) <span class="comment">//这段代码有点精髓啊，个人感觉比HashMap中的算法简单，两者要表达的意思是一致的，都是获取大于initialCapacity的最小值</span></span><br><span class="line">        capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    table = newTable(capacity);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(capacity * loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量与默认加载因子（0.75）构造哈希表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeakHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始容量（16）与默认加载因子（0.75）构造哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeakHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定集合添加到哈希表中，采用默认加载因子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeakHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);<span class="comment">//Math.max是为了获取尽可能大的容量</span></span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定长度构造哈希表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 指定长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">private</span> Entry&lt;K,V&gt;[] newTable(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">return</span> (Entry&lt;K,V&gt;[]) <span class="keyword">new</span> Entry&lt;?,?&gt;[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 倘若键为null则采用NULL_KEY作为键</span></span><br><span class="line"><span class="comment"> * 正如方法名一样，隐藏Null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> NULL_KEY或指定键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">maskNull</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? NULL_KEY : key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 倘若键为NULL_KEY则返回null</span></span><br><span class="line"><span class="comment"> * 正如方法名一样，揭露Null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 哈希表中的键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或指定键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">unmaskNull</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (key == NULL_KEY) ? <span class="keyword">null</span> : key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 两个对象是否相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> y 另外一个对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否相等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">eq</span><span class="params">(Object x, Object y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == y || x.equals(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算哈希值</span></span><br><span class="line"><span class="comment"> * 这边的计算哈希值比HashMap复杂多了，涉及到算法的内容我感觉我没办法理解到位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = k.hashCode();</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算哈希表中的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h 哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length 哈希表的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清除哈希表中过时的节点信息</span></span><br><span class="line"><span class="comment"> * 过时指的是已经被丢弃的键，也可以说是被GC回收的键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object x; (x = queue.poll()) != <span class="keyword">null</span>; ) &#123;<span class="comment">//poll：队列中获取首部节点并删除</span></span><br><span class="line">        <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, table.length);</span><br><span class="line"></span><br><span class="line">            Entry&lt;K,V&gt; prev = table[i]; <span class="comment">//代表当前节点的上一个节点</span></span><br><span class="line">            Entry&lt;K,V&gt; p = prev;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (prev == e) <span class="comment">//说明当前节点是链表的首部节点</span></span><br><span class="line">                        table[i] = next;</span><br><span class="line">                    <span class="keyword">else</span> <span class="comment">//说明当前节点不是首部节点</span></span><br><span class="line">                        prev.next = next;</span><br><span class="line">                    <span class="comment">// Must not null out e.next;</span></span><br><span class="line">                    <span class="comment">// stale entries may be in use by a HashIterator</span></span><br><span class="line">                    e.value = <span class="keyword">null</span>; <span class="comment">// Help GC</span></span><br><span class="line">                    size--;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取哈希表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Entry&lt;K,V&gt;[] getTable() &#123;</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取哈希表的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希表的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表是否为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希表是否为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键获取指</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    <span class="keyword">int</span> h = hash(k);</span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    <span class="keyword">int</span> index = indexFor(h, tab.length);</span><br><span class="line">    Entry&lt;K,V&gt; e = tab[index];</span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == h &amp;&amp; eq(k, e.get()))</span><br><span class="line">            <span class="keyword">return</span> e.value;</span><br><span class="line">        e = e.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否包含指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getEntry(key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键获取节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    <span class="keyword">int</span> h = hash(k);</span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    <span class="keyword">int</span> index = indexFor(h, tab.length);</span><br><span class="line">    Entry&lt;K,V&gt; e = tab[index];</span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span> &amp;&amp; !(e.hash == h &amp;&amp; eq(k, e.get())))</span><br><span class="line">        e = e.next;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增节点</span></span><br><span class="line"><span class="comment"> * 链表中采用头插法的方式进行新增节点</span></span><br><span class="line"><span class="comment"> * 若超过阈值则会进行扩容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    <span class="keyword">int</span> h = hash(k);</span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(h, tab.length); <span class="comment">//获取索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123; <span class="comment">//链表中判断是否重复</span></span><br><span class="line">        <span class="keyword">if</span> (h == e.hash &amp;&amp; eq(k, e.get())) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (value != oldValue)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    Entry&lt;K,V&gt; e = tab[i];</span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry&lt;&gt;(k, value, queue, h, e);</span><br><span class="line">    <span class="keyword">if</span> (++size &gt;= threshold)</span><br><span class="line">        resize(tab.length * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt;[] oldTable = getTable();</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry&lt;K,V&gt;[] newTable = newTable(newCapacity);</span><br><span class="line">    transfer(oldTable, newTable); <span class="comment">//将源哈希表中的所有节点信息复制到目标哈希表中</span></span><br><span class="line">    table = newTable;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果忽略null元素并处理队列导致大量收缩，则还原旧表。 这应该很少见，但是可以避免持有大量无用节点的哈希表的无限扩展。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold / <span class="number">2</span>) &#123;</span><br><span class="line">        threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//GC回收了大量的节点后则不进行扩容</span></span><br><span class="line">        expungeStaleEntries(); <span class="comment">//检测新表中哪些节点已经被丢弃了</span></span><br><span class="line">        transfer(newTable, oldTable);</span><br><span class="line">        table = oldTable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将源哈希表中的所有节点信息复制到目标哈希表中</span></span><br><span class="line"><span class="comment"> * 源哈希表中可能出现被丢弃的键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src 源哈希表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dest 目标哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry&lt;K,V&gt;[] src, Entry&lt;K,V&gt;[] dest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; ++j) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        src[j] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            Object key = e.get(); <span class="comment">//若当前节点已经被GC回收了，则此方法返回将返回null</span></span><br><span class="line">            <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.next = <span class="keyword">null</span>;  <span class="comment">// Help GC</span></span><br><span class="line">                e.value = <span class="keyword">null</span>; <span class="comment">//  "   "</span></span><br><span class="line">                size--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, dest.length); <span class="comment">//该索引出现的可能应该跟HashMap是一样的，原索引或与原索引 + 旧容量的大小，只不过它是一个一个的计算并添加，而HashMap是分批计算，一次性添加</span></span><br><span class="line">                e.next = dest[i];</span><br><span class="line">                dest[i] = e;</span><br><span class="line">            &#125;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量添加节点到哈希表中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numKeysToBeAdded = m.size();</span><br><span class="line">    <span class="keyword">if</span> (numKeysToBeAdded == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 倘若指定集合的键值对数量超过阈值则进行扩容. 这是保守的；</span></span><br><span class="line"><span class="comment">      * 很明显的条件应该是 (m.size + size) &gt;= threshold， 但是这个条件会导致适当的容量变成2倍，如果被添加的键已经存在于哈希表中.</span></span><br><span class="line"><span class="comment">      * 通过使用保守的计算，我们最多只能调整一种尺寸。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">if</span> (numKeysToBeAdded &gt; threshold) &#123;</span><br><span class="line">        <span class="keyword">int</span> targetCapacity = (<span class="keyword">int</span>)(numKeysToBeAdded / loadFactor + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (targetCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            targetCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = table.length;</span><br><span class="line">        <span class="keyword">while</span> (newCapacity &lt; targetCapacity)</span><br><span class="line">            newCapacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity &gt; table.length) <span class="comment">//预先计算好要添加节点的数量以便进行一次性扩容</span></span><br><span class="line">            resize(newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</span><br><span class="line">        put(e.getKey(), e.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键移除节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    <span class="keyword">int</span> h = hash(k);</span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(h, tab.length);</span><br><span class="line">    Entry&lt;K,V&gt; prev = tab[i];</span><br><span class="line">    Entry&lt;K,V&gt; e = prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">        <span class="keyword">if</span> (h == e.hash &amp;&amp; eq(k, e.get())) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">if</span> (prev == e)</span><br><span class="line">                tab[i] = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                prev.next = next;</span><br><span class="line">            <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = e;</span><br><span class="line">        e = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键移除节点是否成功</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 移除节点是否成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeMapping</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">    Object k = maskNull(entry.getKey());</span><br><span class="line">    <span class="keyword">int</span> h = hash(k);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(h, tab.length);</span><br><span class="line">    Entry&lt;K,V&gt; prev = tab[i];</span><br><span class="line">    Entry&lt;K,V&gt; e = prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">        <span class="keyword">if</span> (h == e.hash &amp;&amp; e.equals(entry)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">if</span> (prev == e)</span><br><span class="line">                tab[i] = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                prev.next = next;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = e;</span><br><span class="line">        e = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (queue.poll() != <span class="keyword">null</span>) <span class="comment">//清空队列中只有一部分过时节点</span></span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    Arrays.fill(table, <span class="keyword">null</span>); <span class="comment">//清空哈希表后</span></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空哈希表后可能导致GC，另外一部分节点会被添加到队列中，所以此处需要再次清空队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (queue.poll() != <span class="keyword">null</span>)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表中是否包含指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> containsNullValue();</span><br><span class="line"></span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tab.length; i-- &gt; <span class="number">0</span>;)</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">            <span class="keyword">if</span> (value.equals(e.value))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表中是否包含null值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含null值 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">containsNullValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tab.length; i-- &gt; <span class="number">0</span>;)</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">            <span class="keyword">if</span> (e.value==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表中的节点，该类继承了WeakReference加上调用了父类的构造，说明它的键是个弱引用</span></span><br><span class="line"><span class="comment"> * 该类中的其他方法就不做展示了，比较简单</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    V value;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     * 指定键生成弱引用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queue 与弱引用关联的队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash 哈希值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> next 下一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Entry(Object key, V value, ReferenceQueue&lt;Object&gt; queue, <span class="keyword">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(key, queue);</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.hash  = hash;</span><br><span class="line">        <span class="keyword">this</span>.next  = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历所有键并执行指定动作</span></span><br><span class="line"><span class="comment"> * 遍历过程中不允许WeakHashMap调用任何会修改结构的方法，否则最后会抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action 指定动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    Entry&lt;K, V&gt;[] tab = getTable();</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K, V&gt; entry : tab) &#123;</span><br><span class="line">        <span class="keyword">while</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object key = entry.get();</span><br><span class="line">            <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                action.accept((K)WeakHashMap.unmaskNull(key), entry.value);</span><br><span class="line">            &#125;</span><br><span class="line">            entry = entry.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (expectedModCount != modCount) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历哈希表并执行指定动作后获取新值，利用新值替换所有节点的旧值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> function 指定动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; function)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(function);</span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    Entry&lt;K, V&gt;[] tab = getTable();;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K, V&gt; entry : tab) &#123;</span><br><span class="line">        <span class="keyword">while</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object key = entry.get();</span><br><span class="line">            <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                entry.value = function.apply((K)WeakHashMap.unmaskNull(key), entry.value);</span><br><span class="line">            &#125;</span><br><span class="line">            entry = entry.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (expectedModCount != modCount) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一些重复性的东西，比如包含键、值、键值对的迭代器、可分割迭代器就不讲解了，可参考HashMap</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>WeakHashMap的键值对允许为null</p></li><li><p>WeakHashMap采用弱键，当某个键不在使用时会被GC回收，而键对应的节点也会被移除掉</p></li><li><p>WeakHashMap无序不可重复、非线程安全</p></li><li><p>在添加节点，值对象最好不要与任何的键直接或间接的关联，否则GC无法丢弃该键</p></li><li><p>WeakHashMap#ReferendeQueue是用来查看哈希表中哪些键被丢球了，以便哈希表能够及时更新</p></li><li><p>WeakHashMap的容量必须是2的幂次方</p></li><li><p>WeakHashMap在新增节点时采用的是头插法</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>弱键</code> <code>ReferenceQueue</code> <code>头插法</code> <code>强、软、弱、虚引用</code> <code>Reference</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;探索&lt;code&gt;WeakHashMap&lt;/code&gt;底层实现是基于&lt;code&gt;JDK1.8&lt;/code&gt;，它的数据结构是&lt;code&gt;数组 + 链表&lt;/code&gt;。就不贴它的注释了，直接总结一下吧：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;WeakHashMap基于&lt;code&gt;弱键&lt;/code&gt;实现了Map接口，也就是说，当某个键不在使用时会被丢弃，对应的键值对将会被自动移除。如何确定不在使用取决于GC是否运行，而对于GC何时运行我们并不知道，所以某个键何时被丢弃我们也不得而知，至于GC如何运行就是另外一个话题了，有可能导致上一分钟与下一分钟获取到的结果是不一致的。另一个方面，WeakHashMap的值对象由强引用所持有（何为强引用下面会介绍），应确保值对象不会直接或间接引用自身的键或其他键，这会导致键无法被丢弃。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;强引用：简单来说指向new出来的对象就是一个强引用，可以说是经常使用。对于强引用来说，它们不会被GC回收，即使内存空间不足，JVM宁愿抛出内存溢出错误也不敢动它们，总体来说还是很有威信的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;软引用：首先给强引用包裹上一层&lt;code&gt;SoftReference&lt;/code&gt;，通过SoftReference获取到的引用即为软引用。对于软引用来说，在内存充足的情况下，GC可以选择性的清除，而一旦内存不足了，它们一个都跑不了，都会被清除掉。软引用最常用用于实现对内存敏感的缓存。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;弱引用：首先给强引用包裹上一层&lt;code&gt;WeakReference&lt;/code&gt;，通过WeakReference获取到的引用即为弱引用，看到这里你应该就已经明白了WeakHashMap内部的机制。对于弱引用来说，GC压根就不管内存是否充足，直接回收，很没有人性！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;虚引用：首先给强引用包裹上一层&lt;code&gt;PhantomReference&lt;/code&gt;，通过PhantomReference获取到的引用即为虚引用。对于虚引用来说，它在任何时候都可能被回收，常用于跟踪对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有一个方面，读者最好去了解下&lt;code&gt;Reference&lt;/code&gt;类，内部通过队列实现了一些机制。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索Hashtable底层实现</title>
    <link href="http://zlia.tech/2019/10/31/explain-hashtable-sourcecode/"/>
    <id>http://zlia.tech/2019/10/31/explain-hashtable-sourcecode/</id>
    <published>2019-10-31T10:15:34.000Z</published>
    <updated>2019-10-31T10:15:34.960Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>探索<code>Hashtable</code>底层实现是基于<code>JDK1.8</code>，它的数据结构是<code>数组 + 链表</code>。在不考虑线程是否安全的前提下，它的很多细节处理都不如HashMap，何况如今的HashMap又加了<code>红黑树</code>，查询修改肯定比不上，因为红黑树的时间复杂度是O（logN），而链表的时间复杂度是O（N），新增与删除无法比较，毕竟两者的策略不一致；而倘若比较讨论并发的话，<code>ConcurrentHashMap</code>比它更适合，Hashtable的作者也说了，看来是已经废弃的节奏了。</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><p>既然是与HashMap类似，那数据结构上肯定比它简单，我们就速速通过！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//可克隆、序列化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希表，负责存储节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希表中节点的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阈值 = 初始容量 * 加载因子    当超过指定阈值时会对哈希表重新散列，所有节点（链表）重新计算在新表中的索引，这就相当于所有节点都要参与计算、在新表中设置，效率非常地下</span></span><br><span class="line"><span class="comment">     * HashMap是先将所有节点分成两部分，最终只需要在新表中设置这两部分即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载因子，容量大小不变的情况下，加载因子过大减少空间开销，增加查询成本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结构修改的次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//包含所有键的迭代器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Set&lt;K&gt; keySet;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//包含所有键值对的迭代器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//包含所有值的迭代器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Collection&lt;V&gt; values;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大容量，若设置过高的话可能会发生内存泄露</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义键类型，用于迭代器或枚举</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEYS = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义值类型，用于迭代器或枚举</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALUES = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义键值对类型，用于迭代器或枚举</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ENTRIES = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量与加载因子构造哈希表</span></span><br><span class="line"><span class="comment"> * Float.isNaN：检测是否是数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor 指定加载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span> + initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Load: "</span>+loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</span><br><span class="line">        initialCapacity = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    table = <span class="keyword">new</span> Entry&lt;?,?&gt;[initialCapacity]; <span class="comment">//初始化哈希表</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>); <span class="comment">//设置阈值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量与默认加载因子（0.75）构造哈希表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始容量（11）与默认加载因子（0.75）构造哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定集合添加到哈希表中，采用默认加载因子</span></span><br><span class="line"><span class="comment"> * 设置尽可能大的初始容量以便减少重新散列的次数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(Map&lt;? extends K, ? extends V&gt; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Math.max(<span class="number">2</span>*t.size(), <span class="number">11</span>), <span class="number">0.75f</span>);</span><br><span class="line">    putAll(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取哈希表中的元素个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希表中的元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断哈希表是否为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希表是否为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有键的枚举</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有键的枚举</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Enumeration&lt;K&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.&lt;K&gt;getEnumeration(KEYS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有值的枚举</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有值的枚举</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Enumeration&lt;V&gt; <span class="title">elements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.&lt;V&gt;getEnumeration(VALUES);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表中是否包含指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tab.length ; i-- &gt; <span class="number">0</span> ;) &#123; <span class="comment">//遍历哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[i] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.value.equals(value)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表中是否包含指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> contains(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表中是否包含指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 0x7FFFFFFF = 0111 1111 1111 1111 1111 1111 1111 1111</span></span><br><span class="line"><span class="comment">     * hash &amp; 0x7FFFFFFF 是为了保证结果不出现负数的情况，否则负数取余之后的结果也就为负数了，索引并没有负数</span></span><br><span class="line"><span class="comment">     * hash &amp; 0x7FFFFFFF % tab.leng 是为了取在[0, tab.length -1]区间内的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键获取值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; <span class="comment">//hash与equasl都相等才算是相等</span></span><br><span class="line">            <span class="keyword">return</span> (V)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容并重新散列所有节点</span></span><br><span class="line"><span class="comment"> * 新容量 = 旧容量 * 2 + 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = table.length;</span><br><span class="line">    Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">            <span class="comment">// Keep running with MAX_ARRAY_SIZE buckets</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;?,?&gt;[] newMap = <span class="keyword">new</span> Entry&lt;?,?&gt;[newCapacity];</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">    table = newMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123; <span class="comment">//将哈希表中的所有节点，包括链表都进行重新散列</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != <span class="keyword">null</span> ; ) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = old;</span><br><span class="line">            old = old.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> index = (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;<span class="comment">//重新计算在新表中的索引</span></span><br><span class="line">            e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">            newMap[index] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增节点</span></span><br><span class="line"><span class="comment"> * 采用头插法，每新增一个节点就放到链表的头部</span></span><br><span class="line"><span class="comment"> * 节点个数超过阈值时会进行扩容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">        <span class="comment">// Rehash the table if the threshold is exceeded</span></span><br><span class="line">        rehash();</span><br><span class="line"></span><br><span class="line">        tab = table;</span><br><span class="line">        hash = key.hashCode();</span><br><span class="line">        index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creates the new entry.</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">    tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增节点</span></span><br><span class="line"><span class="comment"> * 若发生重复则进行值替换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make sure the value is not null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123; <span class="comment">//遍历链表看看是否有重复的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            V old = entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键移除节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K,V&gt; prev = <span class="keyword">null</span> ; e != <span class="keyword">null</span> ; prev = e, e = e.next) &#123; <span class="comment">//遍历链表 prev：前一个节点  e：当前节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                prev.next = e.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[index] = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量添加节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : t.entrySet())</span><br><span class="line">        put(e.getKey(), e.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = tab.length; --index &gt;= <span class="number">0</span>; )</span><br><span class="line">        tab[index] = <span class="keyword">null</span>;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 浅拷贝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 克隆后的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Hashtable&lt;?,?&gt; t = (Hashtable&lt;?,?&gt;)<span class="keyword">super</span>.clone();</span><br><span class="line">        t.table = <span class="keyword">new</span> Entry&lt;?,?&gt;[table.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = table.length ; i-- &gt; <span class="number">0</span> ; ) &#123;</span><br><span class="line">            t.table[i] = (table[i] != <span class="keyword">null</span>)</span><br><span class="line">                ? (Entry&lt;?,?&gt;) table[i].clone() : <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t.keySet = <span class="keyword">null</span>;</span><br><span class="line">        t.entrySet = <span class="keyword">null</span>;</span><br><span class="line">        t.values = <span class="keyword">null</span>;</span><br><span class="line">        t.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据类型获取枚举</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type 类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 枚举</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Enumeration&lt;T&gt; <span class="title">getEnumeration</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyEnumeration();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Enumerator&lt;&gt;(type, <span class="keyword">false</span>);<span class="comment">//false不允许删除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据类型获取迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type 类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Iterator&lt;T&gt; <span class="title">getIterator</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyIterator();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Enumerator&lt;&gt;(type, <span class="keyword">true</span>);<span class="comment">//true允许删除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有键的迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有键的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (keySet == <span class="keyword">null</span>)</span><br><span class="line">        keySet = Collections.synchronizedSet(<span class="keyword">new</span> KeySet(), <span class="keyword">this</span>);<span class="comment">//线程安全</span></span><br><span class="line">    <span class="keyword">return</span> keySet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有键值对的迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有键值对的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    <span class="keyword">if</span> (entrySet==<span class="keyword">null</span>)</span><br><span class="line">        entrySet = Collections.synchronizedSet(<span class="keyword">new</span> EntrySet(), <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> entrySet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有值的迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有值的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (values==<span class="keyword">null</span>)</span><br><span class="line">        values = Collections.synchronizedCollection(<span class="keyword">new</span> ValueCollection(), <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前节点的哈希值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前节点的键</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前节点的值</span></span><br><span class="line">    V value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前节点的下一个节点</span></span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有些方法并没有展示，请参考HashMap</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>Hashtable的键值对不允许为空，因为它是直接拿这个键去获取哈希值，这不就造成空指针了（感觉有点白痴），它还对值做了空指针判断</p></li><li><p>Hashtable默认初始容量11、默认加载因子0.75</p></li><li><p>Hashtable扩容时以<code>2倍 + 1</code>进行增长，旧表中的所有节点重新散列到新表中，效率较为低下</p></li><li><p>Hashtable计算索引时采用的是取余，而HashMap采用的与运算</p></li><li><p>Hashtable新增节点时采用的头插法</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>键值对不允许null</code> <code>计算索引采用取余</code> <code>头插法</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;探索&lt;code&gt;Hashtable&lt;/code&gt;底层实现是基于&lt;code&gt;JDK1.8&lt;/code&gt;，它的数据结构是&lt;code&gt;数组 + 链表&lt;/code&gt;。在不考虑线程是否安全的前提下，它的很多细节处理都不如HashMap，何况如今的HashMap又加了&lt;code&gt;红黑树&lt;/code&gt;，查询修改肯定比不上，因为红黑树的时间复杂度是O（logN），而链表的时间复杂度是O（N），新增与删除无法比较，毕竟两者的策略不一致；而倘若比较讨论并发的话，&lt;code&gt;ConcurrentHashMap&lt;/code&gt;比它更适合，Hashtable的作者也说了，看来是已经废弃的节奏了。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索TreeMap底层实现</title>
    <link href="http://zlia.tech/2019/10/31/explain-treemap-sourcecode/"/>
    <id>http://zlia.tech/2019/10/31/explain-treemap-sourcecode/</id>
    <published>2019-10-31T03:31:42.000Z</published>
    <updated>2019-11-06T03:13:15.560Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>探索<code>TreeMap</code>底层实现是基于<code>JDK1.8</code>，通过该类的注释可以了解它的数据结构是<code>红黑树</code>，默认是按照<code>自然顺序</code>进行排序（所有的键都必须去实现<code>Comparable</code>），当然也可以通过<code>指定比较器</code>进行排序（所有的键都必须实现<code>Comparator</code>）。至于什么是红黑树，读者最好有一定的了解，那看懂它的源码也就是分分钟的事了。</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//可序列化、克隆</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 比较器</span></span><br><span class="line"><span class="comment">     * 通过该比较器来维持顺序，若为null则按照自然顺序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 红黑树的根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 红黑树中节点的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结构修改的次数，用来检测快速失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 红色标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED   = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 黑色标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存entrySet方法的返回值，用于迭代器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> EntrySet entrySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储按照降序排列的键值对</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;K,V&gt; descendingMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储按照降序排列的键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> KeySet&lt;K&gt; navigableKeySet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始化</span></span><br><span class="line"><span class="comment"> * 按照自然顺序排列，所有的键都必须实现Comparable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    comparator = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定比较器来初始化</span></span><br><span class="line"><span class="comment"> * 按照比较器中定义的规则进行排列，所有的键都必须实现Comparator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> comparator 比较器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定集合到红黑树中</span></span><br><span class="line"><span class="comment"> * 按照自然顺序排列，所有的键都必须实现Comparable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    comparator = <span class="keyword">null</span>;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 添加指定有序集合到红黑树中，并采用该有序集合的比较器作为红黑树的比较器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 有序集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    comparator = m.comparator();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        buildFromSorted(m.size(), m.entrySet().iterator(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取红黑树中节点的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 节点的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树中是否包含指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getEntry(key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键获取红黑树节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 红黑树节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Offload comparator-based version for sake of performance</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) <span class="comment">//比较结果小于0说明在左子树上</span></span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) <span class="comment">//比较结果大于0说明在右子树上</span></span><br><span class="line">            p = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在红黑树中通过指定键与指定比较器获取节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntryUsingComparator</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        K k = (K) key;</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; p = root; <span class="comment">//获取红黑树的根节点</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = cpr.compare(k, p.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) <span class="comment">//比较结果小于0说明在左子树上</span></span><br><span class="line">                p = p.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)<span class="comment">//比较结果大于0说明在右子树上</span></span><br><span class="line">                p = p.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取等于或大于指定键的最小节点，若不存在，即红黑树中最大的键小于指定键则返回null</span></span><br><span class="line"><span class="comment"> * 大于指定键的最小节点：表示大于指定键且与指定键最为接近</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或指定键的最小节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getCeilingEntry</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = compare(key, p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) <span class="comment">//比较结果小于0可以明确的是已经找到大于指定键的节点了，但可能不是最小节点，故而往左子树继续查找</span></span><br><span class="line">                p = p.left;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) &#123; <span class="comment">//比较结果大于0说明还没有找到大于指定键的节点，故而继续往右子树上找</span></span><br><span class="line">                p = p.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 走到这里是已经没有右子树可以查找了，说明已经没有大于指定键的节点了，那么我们需要尝试往上查询之前找到的大于指定键的最近节点或压根就没有大于指定键的节点</span></span><br><span class="line"><span class="comment">                 * 针对查找大于指定键的节点，那么指定键的节点一定在该节点的左子树上（总体来看），所以最终只要不断去查找某个节点是否在其父节点的左子树即可，若是则它的父节点就是大于指定键的最近节点，若最终</span></span><br><span class="line"><span class="comment">                 * parent == null说明整个树始终都没有大于指定键的节点，也就返回null</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                Entry&lt;K,V&gt; parent = p.parent;</span><br><span class="line">                Entry&lt;K,V&gt; ch = p;</span><br><span class="line">                <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; ch == parent.right) &#123;</span><br><span class="line">                    ch = parent;</span><br><span class="line">                    parent = parent.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取等于或小于指定键的最大节点，若不存在，即红黑树中最小的键大于指定键则返回null</span></span><br><span class="line"><span class="comment"> * 小于指定键的最大节点：表示小于指定键且与指定键最为接近</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或指定键的最大节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getFloorEntry</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = compare(key, p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) <span class="comment">//比较结果大于0可以明确的是已经找到小于指定键的节点了，但可能不是最大节点，故而往右子树继续查找</span></span><br><span class="line">                p = p.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) &#123; <span class="comment">//比较结果小于0说明还没有找到小于指定键的节点，故而继续往左子树上找</span></span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 走到这里是已经没有左子树可以查找了，说明已经没有小于指定键的节点了，那么我们需要尝试往上查询之前找到的小于指定键的最近节点或压根就没有小于指定键的节点</span></span><br><span class="line"><span class="comment">                 * 针对查找小于指定键的节点，那么指定键的节点一定在该节点的右子树上（总体来看），所以最终只要不断去查找某个节点是否在其父节点的右子树即可，若是则它的父节点就是小于指定键的最近节点，若最终</span></span><br><span class="line"><span class="comment">                 * parent == null说明整个树始终都没有小于指定键的节点，也就返回null</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                Entry&lt;K,V&gt; parent = p.parent;</span><br><span class="line">                Entry&lt;K,V&gt; ch = p;</span><br><span class="line">                <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; ch == parent.left) &#123;</span><br><span class="line">                    ch = parent;</span><br><span class="line">                    parent = parent.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取大于指定键的最小节点，若不存在则返回null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或指定键的最小节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getHigherEntry</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = compare(key, p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.left != <span class="keyword">null</span>)</span><br><span class="line">                p = p.left;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                p = p.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; parent = p.parent;</span><br><span class="line">                Entry&lt;K,V&gt; ch = p;</span><br><span class="line">                <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; ch == parent.right) &#123;</span><br><span class="line">                    ch = parent;</span><br><span class="line">                    parent = parent.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取小于指定键的最大节点，若不存在则返回null</span></span><br><span class="line"><span class="comment"> * lower &lt; key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或指定键的最大节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getLowerEntry</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = compare(key, p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.right != <span class="keyword">null</span>)</span><br><span class="line">                p = p.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; parent = p.parent;</span><br><span class="line">                Entry&lt;K,V&gt; ch = p;</span><br><span class="line">                <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; ch == parent.left) &#123;</span><br><span class="line">                    ch = parent;</span><br><span class="line">                    parent = parent.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增节点后维持红黑树的平衡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 新增节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    x.color = RED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123; <span class="comment">//x的父节点是红色</span></span><br><span class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123; <span class="comment">//x的父节点在x的爷爷节点的左子树上</span></span><br><span class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); <span class="comment">//x的叔叔节点</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123; <span class="comment">//x的叔叔节点是红色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//x的叔叔节点是黑色</span></span><br><span class="line">                <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123; <span class="comment">//x在x的父节点的右子树上</span></span><br><span class="line">                    x = parentOf(x);<span class="comment">//x变成了x的父节点</span></span><br><span class="line">                    rotateLeft(x);<span class="comment">//将x的父节点进行左旋</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//x在x的父节点的左子树上</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                rotateRight(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//x的父节点在x的爷爷节点的右子树上</span></span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); <span class="comment">//x的叔叔节点</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123; <span class="comment">//x在x的父节点的左子树上</span></span><br><span class="line">                    x = parentOf(x);<span class="comment">//x变成了x的父节点</span></span><br><span class="line">                    rotateRight(x);<span class="comment">//将x的父节点进行右旋</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//x在x的父节点的右子树上</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除节点并调整红黑树使之平衡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 移除节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123; <span class="comment">//移除节点有两个子节点</span></span><br><span class="line">        Entry&lt;K,V&gt; s = successor(p); <span class="comment">//查找大于指定节点的最小节点</span></span><br><span class="line">        p.key = s.key;</span><br><span class="line">        p.value = s.value; <span class="comment">//替换值</span></span><br><span class="line">        p = s;</span><br><span class="line">    &#125; <span class="comment">// p has 2 children</span></span><br><span class="line"></span><br><span class="line">    Entry&lt;K,V&gt; replacement = (p.left != <span class="keyword">null</span> ? p.left : p.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123; <span class="comment">//移除节点至少有一个子节点，先更改移除节点的子节点与其父节点的关系</span></span><br><span class="line">        replacement.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">            p.parent.left  = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = replacement;</span><br><span class="line"></span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK) <span class="comment">//移除节点为黑色的情况才会导致红黑是失去平衡</span></span><br><span class="line">            fixAfterDeletion(replacement);  <span class="comment">//最后调整红黑树使之平衡</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) &#123; <span class="comment">//只有一个节点的情况下</span></span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//移除节点无子节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">                p.parent.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right)</span><br><span class="line">                p.parent.right = <span class="keyword">null</span>;</span><br><span class="line">            p.parent = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取大于指定节点的最小节点</span></span><br><span class="line"><span class="comment"> * 提供一篇文章：https://blog.csdn.net/iwts_24/article/details/87165743  讲的内容不错</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t 指定节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或大于指定节点的最小节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">successor</span><span class="params">(Entry&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; p = t.right;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 在有右子树的情况下查找大于指定键的最小节点，所以应该查找它的右子树的最左边的节点，因为越左边说明越靠近指定键</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *              5</span></span><br><span class="line"><span class="comment">         *            /   \</span></span><br><span class="line"><span class="comment">         *           3     6</span></span><br><span class="line"><span class="comment">         *         /  \</span></span><br><span class="line"><span class="comment">         *        1    4</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         *       1   3 4 5 6</span></span><br><span class="line"><span class="comment">         * t = 3，则 p = 4</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 下面这段代码和上面的getCeilingEntry方法是一样的</span></span><br><span class="line"><span class="comment">         * 在没有右子树的情况下往上查找大于指定键的最小节点，即当某个节点为其父节点的左子树时就是了</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *              5</span></span><br><span class="line"><span class="comment">         *            /   \</span></span><br><span class="line"><span class="comment">         *           3     6</span></span><br><span class="line"><span class="comment">         *         /  \</span></span><br><span class="line"><span class="comment">         *        1    4</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         *       1   3 4 5 6</span></span><br><span class="line"><span class="comment">         * t = 4，则 p = 5</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Entry&lt;K,V&gt; p = t.parent;</span><br><span class="line">        Entry&lt;K,V&gt; ch = t;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; ch == p.right) &#123;</span><br><span class="line">            ch = p;</span><br><span class="line">            p = p.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除节点后调整红黑树的平衡</span></span><br><span class="line"><span class="comment"> * 因为这里涉及到红黑树的算法，较为复杂，目前我也还没有完全理解，虽然之前尝试写过一篇关于红黑树的文章，但发现还是有些问题，所以打算后面探索算法的时候在更改</span></span><br><span class="line"><span class="comment"> * 由于咱们只是探索TreeMap的源码，所以这部分的内容个人觉得并不用花太多的时间去关注</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 移除节点或替代节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != root &amp;&amp; colorOf(x) == BLACK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; sib = rightOf(parentOf(x));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);</span><br><span class="line">                setColor(parentOf(x), RED);</span><br><span class="line">                rotateLeft(parentOf(x));</span><br><span class="line">                sib = rightOf(parentOf(x));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(leftOf(sib))  == BLACK &amp;&amp;</span><br><span class="line">                colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED);</span><br><span class="line">                x = parentOf(x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(leftOf(sib), BLACK);</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    rotateRight(sib);</span><br><span class="line">                    sib = rightOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(rightOf(sib), BLACK);</span><br><span class="line">                rotateLeft(parentOf(x));</span><br><span class="line">                x = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// symmetric</span></span><br><span class="line">            Entry&lt;K,V&gt; sib = leftOf(parentOf(x));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);</span><br><span class="line">                setColor(parentOf(x), RED);</span><br><span class="line">                rotateRight(parentOf(x));</span><br><span class="line">                sib = leftOf(parentOf(x));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK &amp;&amp;</span><br><span class="line">                colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED);</span><br><span class="line">                x = parentOf(x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(rightOf(sib), BLACK);</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    rotateLeft(sib);</span><br><span class="line">                    sib = leftOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(leftOf(sib), BLACK);</span><br><span class="line">                rotateRight(parentOf(x));</span><br><span class="line">                x = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setColor(x, BLACK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    root = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 浅拷贝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 克隆后的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TreeMap&lt;?,?&gt; clone;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        clone = (TreeMap&lt;?,?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将成员属性恢复到初始值，预防后续两个对象产生影响</span></span><br><span class="line">    clone.root = <span class="keyword">null</span>;</span><br><span class="line">    clone.size = <span class="number">0</span>;</span><br><span class="line">    clone.modCount = <span class="number">0</span>;</span><br><span class="line">    clone.entrySet = <span class="keyword">null</span>;</span><br><span class="line">    clone.navigableKeySet = <span class="keyword">null</span>;</span><br><span class="line">    clone.descendingMap = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建红黑树</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        clone.buildFromSorted(size, entrySet().iterator(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键值对来构建一颗红黑树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> size 红黑树的节点个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> it 包含键值对的迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str 包含键值对的输出流，it与str应该其中有一个不为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> defaultVal 若不为空，则使用该默认值作为键的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildFromSorted</span><span class="params">(<span class="keyword">int</span> size, Iterator&lt;?&gt; it, java.io.ObjectInputStream str, V defaultVal)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span>  java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line">    root = buildFromSorted(<span class="number">0</span>, <span class="number">0</span>, size-<span class="number">1</span>, computeRedLevel(size), it, str, defaultVal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算节点的高度达到某个值时应该变成红色，为了能够更好的分配红黑树的颜色</span></span><br><span class="line"><span class="comment"> * 至于它是怎么计算的，只能说这些写算法的人是真的牛逼</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sz 红黑树的节点个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 高度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">computeRedLevel</span><span class="params">(<span class="keyword">int</span> sz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = sz - <span class="number">1</span>; m &gt;= <span class="number">0</span>; m = m / <span class="number">2</span> - <span class="number">1</span>)</span><br><span class="line">        level++;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键值对来构建一颗红黑树</span></span><br><span class="line"><span class="comment"> * 注释上说明了构建后的红黑树的颜色分配很鲜明，实际上最终是通过redLevel来确定哪一部分是黑色，哪一部分是红色，但是顺序依然还是原来的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> level 当前节点的高度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lo 当前节点的子树的第一个节点的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hi 子树的最后一个节点的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> redLevel 当前节点达到此高度时应该是红色</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> it 包含键值对的迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str 包含键值对的输出流，it与str应该其中有一个不为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> defaultVal 若不为空，则使用该默认值作为键的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 根节点，红黑树的结构可能会发生变化，但是它的顺序不会变</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">buildFromSorted</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> redLevel, Iterator&lt;?&gt; it, java.io.ObjectInputStream str, V defaultVal)</span> <span class="keyword">throws</span>  java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hi &lt; lo) <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//hi &gt;= lo 说明子树已经构造完成</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">//取中间位置，无符号右移相当于除以2</span></span><br><span class="line"></span><br><span class="line">    Entry&lt;K,V&gt; left  = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (lo &lt; mid) </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 通过递归的方式构建当前节点的左子树</span></span><br><span class="line"><span class="comment">         * 若你了解红黑树的中序遍历，那应该就很容易理解了</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         *                   4</span></span><br><span class="line"><span class="comment">         *                 3    5</span></span><br><span class="line"><span class="comment">         *               2        6</span></span><br><span class="line"><span class="comment">         *             1            7</span></span><br><span class="line"><span class="comment">         *                           8</span></span><br><span class="line"><span class="comment">         * 中序遍历：  1 2 3 4 5 6 7 8 9    索引是从0开始的，类似数组</span></span><br><span class="line"><span class="comment">         * lo：0  hi：8 mid：4 redLevel：3  故当前节点是5，那么要构建左子树的话，可以认为5的左边的那些数字都是它的左子树中的节点，lo应该从0开始，hi应该是3</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        left = buildFromSorted(level+<span class="number">1</span>, lo, mid - <span class="number">1</span>, redLevel, it, str, defaultVal);</span><br><span class="line"></span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="keyword">if</span> (it != <span class="keyword">null</span>) &#123; <span class="comment">//通过迭代器获取键值对</span></span><br><span class="line">        <span class="keyword">if</span> (defaultVal==<span class="keyword">null</span>) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;)it.next();</span><br><span class="line">            key = (K)entry.getKey();</span><br><span class="line">            value = (V)entry.getValue();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            key = (K)it.next();</span><br><span class="line">            value = defaultVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 通过流的方式获取键值对</span></span><br><span class="line">        key = (K) str.readObject();</span><br><span class="line">        value = (defaultVal != <span class="keyword">null</span> ? defaultVal : (V) str.readObject());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry&lt;K,V&gt; middle =  <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (level == redLevel) <span class="comment">//上面说了某个节点达到此高度时就要变成红色</span></span><br><span class="line">        middle.color = RED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123; <span class="comment">//左子树构建完了就要关联关系</span></span><br><span class="line">        middle.left = left;</span><br><span class="line">        left.parent = middle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mid &lt; hi) &#123; <span class="comment">//通过递归的方式构建当前节点的右子树</span></span><br><span class="line">        Entry&lt;K,V&gt; right = buildFromSorted(level+<span class="number">1</span>, mid+<span class="number">1</span>, hi, redLevel,</span><br><span class="line">                                           it, str, defaultVal);</span><br><span class="line">        middle.right = right;</span><br><span class="line">        right.parent = middle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> middle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 封装键值对，以便控制某些方法不允许暴露给开发者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定键值对</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 封装后的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; Map.<span class="function">Entry&lt;K,V&gt; <span class="title">exportEntry</span><span class="params">(TreeMap.Entry&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (e == <span class="keyword">null</span>) ? <span class="keyword">null</span> : <span class="keyword">new</span> AbstractMap.SimpleImmutableEntry&lt;&gt;(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有键的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有键的Set集合 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> navigableKeySet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有键的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有键的Set集合 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableSet&lt;K&gt; <span class="title">navigableKeySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    KeySet&lt;K&gt; nks = navigableKeySet;</span><br><span class="line">    <span class="keyword">return</span> (nks != <span class="keyword">null</span>) ? nks : (navigableKeySet = <span class="keyword">new</span> KeySet&lt;&gt;(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含按照降序排列的键的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含降序排列的键的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableSet&lt;K&gt; <span class="title">descendingKeySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> descendingMap().navigableKeySet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取按照降序排列的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 降序排列的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableMap&lt;K, V&gt; <span class="title">descendingMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NavigableMap&lt;K, V&gt; km = descendingMap;</span><br><span class="line">    <span class="keyword">return</span> (km != <span class="keyword">null</span>) ? km : (descendingMap = <span class="keyword">new</span> DescendingSubMap&lt;&gt;(<span class="keyword">this</span>, <span class="keyword">true</span>, <span class="keyword">null</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">null</span>, <span class="keyword">true</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有值的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有值的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Collection&lt;V&gt; vs = values;</span><br><span class="line">    <span class="keyword">if</span> (vs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        vs = <span class="keyword">new</span> Values();</span><br><span class="line">        values = vs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有键值对的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有键值对的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    EntrySet es = entrySet;</span><br><span class="line">    <span class="keyword">return</span> (es != <span class="keyword">null</span>) ? es : (entrySet = <span class="keyword">new</span> EntrySet());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定起始键与结束键及是否包含起始、结束键来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * 当前对象是已经排好序了</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * TreeMap&lt;Integer, String&gt; treeMap = new TreeMap&lt;&gt;();</span></span><br><span class="line"><span class="comment"> * treeMap.put(5, "2");</span></span><br><span class="line"><span class="comment"> * treeMap.put(4, "2");</span></span><br><span class="line"><span class="comment"> * treeMap.put(10, "2");</span></span><br><span class="line"><span class="comment"> * treeMap.put(1, "2");</span></span><br><span class="line"><span class="comment"> * treeMap.put(20, "2");</span></span><br><span class="line"><span class="comment"> * treeMap.put(7, "2");</span></span><br><span class="line"><span class="comment"> * treeMap.put(8, "2");</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * System.out.println(treeMap.keySet()); -&gt; [1, 4, 5, 7, 8, 10, 20]</span></span><br><span class="line"><span class="comment"> * System.out.println(treeMap.subMap(2,true, 6, true).keySet());  -&gt; [4, 5]  实际上是在treeMap取2-6区间中的所有键 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromKey 起始键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromInclusive 子集中是否包含起始键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toKey 结束键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toInclusive 子集中是否包含结束键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableMap&lt;K,V&gt; <span class="title">subMap</span><span class="params">(K fromKey, <span class="keyword">boolean</span> fromInclusive, K toKey,   <span class="keyword">boolean</span> toInclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AscendingSubMap&lt;&gt;(<span class="keyword">this</span>, <span class="keyword">false</span>, fromKey, fromInclusive, <span class="keyword">false</span>, toKey, toInclusive);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定结束键及是否包含结束键来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * 当前对象是已经排好序了</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参照上面的代码</span></span><br><span class="line"><span class="comment"> * System.out.println(treeMap.headMap(4, true).keySet()); -&gt; [1, 4]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toKey 结束键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inclusive 子集中是否包含结束键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableMap&lt;K,V&gt; <span class="title">headMap</span><span class="params">(K toKey, <span class="keyword">boolean</span> inclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AscendingSubMap&lt;&gt;(<span class="keyword">this</span>, <span class="keyword">true</span>,  <span class="keyword">null</span>,  <span class="keyword">true</span>, <span class="keyword">false</span>, toKey, inclusive);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定起始键及是否包含起始键来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromKey 起始键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inclusive 子集中是否包含起始键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableMap&lt;K,V&gt; <span class="title">tailMap</span><span class="params">(K fromKey, <span class="keyword">boolean</span> inclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AscendingSubMap&lt;&gt;(<span class="keyword">this</span>, <span class="keyword">false</span>, fromKey, inclusive, <span class="keyword">true</span>,  <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定起始键与结束键来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * 包含起始键、不包含结束键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromKey 起始键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toKey 结束键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SortedMap&lt;K,V&gt; <span class="title">subMap</span><span class="params">(K fromKey, K toKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> subMap(fromKey, <span class="keyword">true</span>, toKey, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定结束键来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * 不包含结束键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toKey 结束键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SortedMap&lt;K,V&gt; <span class="title">headMap</span><span class="params">(K toKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> headMap(toKey, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定起始键来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * 包含起始键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromKey 起始键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SortedMap&lt;K,V&gt; <span class="title">tailMap</span><span class="params">(K fromKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tailMap(fromKey, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 替换指定键的节点的值，过程中要比较节点的值与指定值是否相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> oldValue 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newValue 新值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否替换成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">if</span> (p!=<span class="keyword">null</span> &amp;&amp; Objects.equals(oldValue, p.value)) &#123;</span><br><span class="line">        p.value = newValue;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 替换指定键的节点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 新值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">if</span> (p!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        V oldValue = p.value;</span><br><span class="line">        p.value = value;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按排列后的顺序遍历所有节点并执行指定动作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action 执行指定动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K, V&gt; e = getFirstEntry(); e != <span class="keyword">null</span>; e = successor(e)) &#123; <span class="comment">//successor是获取大于当前节点的最小节点，按照红黑树的中序排列后，实际上就是获取的下一个元素</span></span><br><span class="line">        action.accept(e.key, e.value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (expectedModCount != modCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按排列后的顺序遍历所有节点并执行指定动作后获取新值，利用新值替换所有节点的旧值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> function 指定动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; function)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(function);</span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K, V&gt; e = getFirstEntry(); e != <span class="keyword">null</span>; e = successor(e)) &#123;</span><br><span class="line">        e.value = function.apply(e.key, e.value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (expectedModCount != modCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 比较两个键</span></span><br><span class="line"><span class="comment"> * 若未指定比较器，则必须实现Comparable，通过覆写该类来进行比较</span></span><br><span class="line"><span class="comment"> * 若是指定了比较器，则必须实现Comparator，通过覆写该类来进行比较</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k1 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k2 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 比较结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object k1, Object k2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> comparator==<span class="keyword">null</span> ? ((Comparable&lt;? <span class="keyword">super</span> K&gt;)k1).compareTo((K)k2) : comparator.compare((K)k1, (K)k2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 比较两个值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o1 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o2 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 比较结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">valEquals</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (o1==<span class="keyword">null</span> ? o2==<span class="keyword">null</span> : o1.equals(o2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上面提到的关于获取子集的内容就列出重要的方法，其余的方法都是类似的，就不做重复性的工作了</span></span><br><span class="line"><span class="comment"> * 获取子集时是已经按顺序排列好了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NavigableSubMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前对象，也就是从该对象中获取子集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> TreeMap&lt;K,V&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 起始键与结束键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> K lo, hi;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * fromStart为true的话表示当前对象的第一个键作为起始，相当于是已经明确了起始键，若为false就说明起始键需要调用者指定</span></span><br><span class="line"><span class="comment">     * toEnd为true的话表示当前对象的最后一个键作为结尾，相当于是已经明确了结束键，若为false就说明结束键需要调用者指定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> fromStart, toEnd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子集是否需要包含起始键、结束键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> loInclusive, hiInclusive;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定键是否小于起始键</span></span><br><span class="line"><span class="comment">     * 若等于则看loInclusive变量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否小于起始键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tooLow</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!fromStart) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = m.compare(key, lo);</span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (c == <span class="number">0</span> &amp;&amp; !loInclusive))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定键是否大于结束键</span></span><br><span class="line"><span class="comment">     * 若等于则看hiInclusive变量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否大于起始键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tooHigh</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!toEnd) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = m.compare(key, hi);</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">0</span> || (c == <span class="number">0</span> &amp;&amp; !hiInclusive))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定键是否在起始键与结束键之间，该区间可能是[lo,hi]、(lo,hi) 、[lo,hi)、(lo,hi] 这取决于loInclusive、hiInclusive</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否在起始键与结束键之间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">inRange</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !tooLow(key) &amp;&amp; !tooHigh(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定键是否在起始键与结束键之间，区间是[lo,hi]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否在起始键与结束键之间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">inClosedRange</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (fromStart || m.compare(key, lo) &gt;= <span class="number">0</span>)</span><br><span class="line">            &amp;&amp; (toEnd || m.compare(hi, key) &gt;= <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定键是否在起始键与结束键之间</span></span><br><span class="line"><span class="comment">     * inclusive为true时，key在起始键与结束键之间不会报错，不过若key刚好是等于起始键或结束键，那么对应的区间必须是闭区间，假设key等于起始键，那么它的区间应该是[lo,hi)或[lo,ih]，若是等于结束键，那么区间应该是(lo,hi]或[lo,hi]</span></span><br><span class="line"><span class="comment">     * inclusive为false时，key在起始键与结束键之间不会报错，不过若key刚好是等于起始键或结束键，不管区间如何，都不会报错</span></span><br><span class="line"><span class="comment">     * 当然了，不管inclusive的值如何，如果指定键大于结束键或小于起始键，那肯定会报错</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inclusive 子集中是否包含指定键 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">inRange</span><span class="params">(Object key, <span class="keyword">boolean</span> inclusive)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inclusive ? inRange(key) : inClosedRange(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前对象中大于或等于起始键的节点</span></span><br><span class="line"><span class="comment">     * 因为指定了区间lo-hi，所以还要判断该节点是否超过了结束键hi</span></span><br><span class="line"><span class="comment">     * 如果fromStart为true，说明已经指定了起始键，直接获取第一个节点即可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> null或大于或等于起始键的节点，为null说明要么节点不存在，要么该节点超过了结束键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">absLowest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeMap.Entry&lt;K,V&gt; e = (fromStart ?  m.getFirstEntry() : (loInclusive ? m.getCeilingEntry(lo) : m.getHigherEntry(lo)));</span><br><span class="line">        <span class="keyword">return</span> (e == <span class="keyword">null</span> || tooHigh(e.key)) ? <span class="keyword">null</span> : e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前对象中小于或等于结束键的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> null或小于或等于结束键的节点，为null说明要么节点不存在，要么该节点小于起始键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">absHighest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeMap.Entry&lt;K,V&gt; e = (toEnd ?  m.getLastEntry() : (hiInclusive ?  m.getFloorEntry(hi) : m.getLowerEntry(hi)));</span><br><span class="line">        <span class="keyword">return</span> (e == <span class="keyword">null</span> || tooLow(e.key)) ? <span class="keyword">null</span> : e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取大于或等于指定键的节点</span></span><br><span class="line"><span class="comment">     * 若指定键小于起始键，那么只需要获取起始键即可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> null或大于或等于指定键的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">absCeiling</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tooLow(key))</span><br><span class="line">            <span class="keyword">return</span> absLowest();</span><br><span class="line">        TreeMap.Entry&lt;K,V&gt; e = m.getCeilingEntry(key);</span><br><span class="line">        <span class="keyword">return</span> (e == <span class="keyword">null</span> || tooHigh(e.key)) ? <span class="keyword">null</span> : e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取大于指定键的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> null或大于指定键的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">absHigher</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tooLow(key))</span><br><span class="line">            <span class="keyword">return</span> absLowest();</span><br><span class="line">        TreeMap.Entry&lt;K,V&gt; e = m.getHigherEntry(key);</span><br><span class="line">        <span class="keyword">return</span> (e == <span class="keyword">null</span> || tooHigh(e.key)) ? <span class="keyword">null</span> : e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取小于或等于指定键的节点</span></span><br><span class="line"><span class="comment">     * 若指定键大于结束键，则直接获取结束键即可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> null或小于或等于指定键的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">absFloor</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tooHigh(key))</span><br><span class="line">            <span class="keyword">return</span> absHighest();</span><br><span class="line">        TreeMap.Entry&lt;K,V&gt; e = m.getFloorEntry(key);</span><br><span class="line">        <span class="keyword">return</span> (e == <span class="keyword">null</span> || tooLow(e.key)) ? <span class="keyword">null</span> : e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取小于指定键的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> null或小于指定键的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">absLower</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tooHigh(key))</span><br><span class="line">            <span class="keyword">return</span> absHighest();</span><br><span class="line">        TreeMap.Entry&lt;K,V&gt; e = m.getLowerEntry(key);</span><br><span class="line">        <span class="keyword">return</span> (e == <span class="keyword">null</span> || tooLow(e.key)) ? <span class="keyword">null</span> : e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取子集的尾节点（结果不包含尾节点）</span></span><br><span class="line"><span class="comment">     * 当hiInclusive为true时，说明结果要包含指定的结束键，所以它就取了比指定结束键还要大的节点作为尾节点</span></span><br><span class="line"><span class="comment">     * 当hiInclusive为false时，说明结果不包含指定的结束键，所以它就取了等于结束键的节点作为尾节点</span></span><br><span class="line"><span class="comment">     * 不管是哪一种，反正它是不包含尾节点，可以在迭代器的hasNext中看到：next != null &amp;&amp; next.key != fenceKey;  说明不包含尾节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 尾节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">absHighFence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (toEnd ? <span class="keyword">null</span> : (hiInclusive ? m.getHigherEntry(hi) : m.getCeilingEntry(hi)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取子集的头节点（不包含头节点）</span></span><br><span class="line"><span class="comment">     * 分析同上</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 头节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">absLowFence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (fromStart ? <span class="keyword">null</span> : (loInclusive ? m.getLowerEntry(lo) : m.getFloorEntry(lo)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//剩下的方法就不一一分析了，大多数都是类似的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        compare(key, key); <span class="comment">//校验指定键至是否实现Comparable或Comparator</span></span><br><span class="line"></span><br><span class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>); <span class="comment">//设置红黑树的根节点</span></span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="comment">// split comparator and comparable paths</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123; <span class="comment">//采用Comparator的方式进行比较，查找新增节点应该放在哪个位置上</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value); <span class="comment">//新增节点已经存在则进行替换值</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">//采用Comparable的方式进行比较，查找新增节点应该放在哪个位置上</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = k.compareTo(t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent); <span class="comment">//构建节点并关联关系</span></span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="移除节点"><a href="#移除节点" class="headerlink" title="移除节点"></a>移除节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除指定键对应的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 移除节点的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    V oldValue = p.value;</span><br><span class="line">    deleteEntry(p); <span class="comment">//移除节点并调整红黑树的平衡</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取排序后的第一个节点并移除</span></span><br><span class="line"><span class="comment"> * 获取最左边的节点并移除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最左边的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">pollFirstEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getFirstEntry();</span><br><span class="line">    Map.Entry&lt;K,V&gt; result = exportEntry(p);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>)</span><br><span class="line">        deleteEntry(p);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取排序后的最后一个节点并移除</span></span><br><span class="line"><span class="comment"> * 获取最右边的节点并移除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最右边的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">pollLastEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getLastEntry();</span><br><span class="line">    Map.Entry&lt;K,V&gt; result = exportEntry(p);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>)</span><br><span class="line">        deleteEntry(p);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取排序后的第一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 排序后的第一个节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">firstEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exportEntry(getFirstEntry());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取最左边的节点，实际上就是在获取排序后的第一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最左边的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getFirstEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取排序后的最后一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 排序后的最后一个节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">lastEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exportEntry(getLastEntry());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取最右边的节点，实际上就是在获取排序后的最后一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最右边的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getLastEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">while</span> (p.right != <span class="keyword">null</span>)</span><br><span class="line">            p = p.right;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取小于指定键的最大节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 小于指定键的最大节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">lowerEntry</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exportEntry(getLowerEntry(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取小于指定键的最大节点的键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 小于指定键的最大节点的键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> K <span class="title">lowerKey</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> keyOrNull(getLowerEntry(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取等于或小于指定键的最大节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 等于或小于指定键的最大节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">floorEntry</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exportEntry(getFloorEntry(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取小于指定键的最大节点的键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 小于指定键的最大节点的键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> K <span class="title">floorKey</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> keyOrNull(getFloorEntry(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取等于或大于指定键的最小节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 等于或大于指定键的最小节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">ceilingEntry</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exportEntry(getCeilingEntry(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取等于或大于指定键的最小节点的键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 等于或大于指定键的最小节点的键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> K <span class="title">ceilingKey</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> keyOrNull(getCeilingEntry(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取大于指定键的最小节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 大于指定键的最小节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">higherEntry</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exportEntry(getHigherEntry(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取大于指定键的最小节点的键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 大于指定键的最小节点的键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> K <span class="title">higherKey</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> keyOrNull(getHigherEntry(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>若要按自然顺序排列则键必须实现Comparable，此时TreeMap中键不可以为null；若要自定义排列顺序则键必须实现Comparator，此时TreeMap中键可以为null</p></li><li><p>TreeMap中的很多算法跟红黑树中的中序有很大的关联，所以最好提前了解</p></li><li><p>TreeMap有序不可重复，非线程安全</p></li><li><p>TreeMap的数据结构是<code>红黑树</code></p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>红黑树</code> <code>Comparable与Comparator</code> <code>有序不可重复</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;探索&lt;code&gt;TreeMap&lt;/code&gt;底层实现是基于&lt;code&gt;JDK1.8&lt;/code&gt;，通过该类的注释可以了解它的数据结构是&lt;code&gt;红黑树&lt;/code&gt;，默认是按照&lt;code&gt;自然顺序&lt;/code&gt;进行排序（所有的键都必须去实现&lt;code&gt;Comparable&lt;/code&gt;），当然也可以通过&lt;code&gt;指定比较器&lt;/code&gt;进行排序（所有的键都必须实现&lt;code&gt;Comparator&lt;/code&gt;）。至于什么是红黑树，读者最好有一定的了解，那看懂它的源码也就是分分钟的事了。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索LinkedHashMap底层实现</title>
    <link href="http://zlia.tech/2019/10/25/explain-linkedhashmap-sourcecode/"/>
    <id>http://zlia.tech/2019/10/25/explain-linkedhashmap-sourcecode/</id>
    <published>2019-10-25T06:59:27.000Z</published>
    <updated>2019-10-31T03:29:19.477Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>印象中对LinkedHashMap的使用次数好像也不多，参考了几篇文章发现它依赖于<code>HashMap</code>而存在，也就是说它在HashMap的基础上又增加了某些特性，比如说<code>有序</code>。既然是基于HashMap，那么它内部的数据结构也应该有数组 + 链表 + 红黑树，而刚才说它又加上了自己的有序特性，那么应该还有<code>一条链表来维护该顺序</code>，如下图所示：</p><p class="customize-img"><img src="/assets/blogImg/java/linkedhashmap/data-structure.png" alt="LinkedHashMap数据结构"></p><p>该图侧重于它是如何保持有序的，就像上面说的是一条链表，画的有点丑，不过应该不难理解。另外一方面，由于它是基于HashMap，所以在看这篇文章之前最好能对HashMap有个了解，加上接下来并不会过多的解释它的数据结构，更多的关注还是在有序及其他特性上，毕竟它的数据结构是偷来的，探索LinkedHashMap底层实现是基于<code>JDK1.8</code>。</p><a id="more"></a><h3 id="阅读注释"><a href="#阅读注释" class="headerlink" title="阅读注释"></a><div><span>阅读注释</span></div></h3><p class="customize-img"><img src="/assets/blogImg/java/linkedhashmap/linkedhashmap-comment-1.png" alt="LinkedHashMap注释-1"></p><p>提供了一条链表来维护有序性，默认顺序是节点的插入顺序。</p><p class="customize-img"><img src="/assets/blogImg/java/linkedhashmap/linkedhashmap-comment-2.png" alt="LinkedHashMap注释-2"></p><p>还提供了按照访问顺序进行排序，该排序方式适合左LRU缓存。</p><p class="customize-img"><img src="/assets/blogImg/java/linkedhashmap/linkedhashmap-comment-3.png" alt="LinkedHashMap注释-3"></p><p>LinkedHashMap的迭代性能比HashMap高，因为HashMap会迭代所有容量，包括某些索引上并没有节点，而LinkedHashMap按照链表来迭代，并不会理会空节点。</p><p class="customize-img"><img src="/assets/blogImg/java/linkedhashmap/linkedhashmap-comment-4.png" alt="LinkedHashMap注释-4"></p><p>非线程安全，与HashMap相比，结构修改的概念不太一样。</p><p class="customize-img"><img src="/assets/blogImg/java/linkedhashmap/linkedhashmap-comment-5.png" alt="LinkedHashMap注释-5"></p><p>迭代器会发生快速失败倒是每个集合的共有特点。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//继承了HashMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//唯一序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3801124242820219131L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//双向链表的头节点，也代表着最少访问</span></span><br><span class="line">    <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//双向链表的尾节点，也代表着最多访问</span></span><br><span class="line">    <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置排序方式，也是迭代时的顺序</span></span><br><span class="line"><span class="comment">     * true：按照访问顺序，最多访问的节点会更新到尾节点</span></span><br><span class="line"><span class="comment">     * false：按照插入顺序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量与加载因子来初始化，按照插入顺序排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor 指定加载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量来初始，按照插入顺序排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 采用默认的初始容量与加载因子来初始化，按照插入顺序排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定结集合添加到表中，按照插入顺序排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定容量与加载因子、排序方式来初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor 指定加载因子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> accessOrder 指定排序方式-按照插入顺序、访问顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h4><p>以下的方法将不会详细介绍HashMap中的相关方法，只可能会略微提到，读者最好能够对HashMap有一定的了解。</p><h5 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定节点添加到尾部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 指定节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">//添加到尾部后要进行关联关系，以便通过上下节点维护顺序</span></span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 复制节点的关联关系以保持有序</span></span><br><span class="line"><span class="comment"> * HashMap中可能出现链表转换成红黑树、也有可能出现红黑树转换为链表，所以相应的在转换过程中对象的结构也应该发生变化，为了保持有序性，必须复制原有结构的关联关系到新结构上</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src 原结构的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dst 现结构的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transferLinks</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; src, LinkedHashMap.Entry&lt;K,V&gt; dst)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; b = dst.before = src.before;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; a = dst.after = src.after;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = dst;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = dst;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = dst;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = dst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 恢复到初始状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reinitialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.reinitialize();</span><br><span class="line">    head = tail = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建普通结构的节点</span></span><br><span class="line"><span class="comment"> * 相当于在HashMap原有节点的基础上又维护了一层有序</span></span><br><span class="line"><span class="comment"> * 添加节点时会调用HashMap#putVal，紧着会调用该方法用来创建新节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 下一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p = <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将红黑树结构的节点的变成普通结构的节点，实际上只是对象变了，其成员属性拷贝原有节点上对应的值</span></span><br><span class="line"><span class="comment"> * HashMap#untreeify时会调用该方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 红黑树结构的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> next 下一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 普通结构的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; q = (LinkedHashMap.Entry&lt;K,V&gt;)p;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; t =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(q.hash, q.key, q.value, next);</span><br><span class="line">    transferLinks(q, t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建红黑树结构的节点</span></span><br><span class="line"><span class="comment"> * HashMap#putTreeVal时会调用该方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> next 下一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">newTreeNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(hash, key, value, next);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将普通结构的节点变成红黑树结构的节点，实际上只是对象变了，其成员属性拷贝原有节点上对应的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 普通结构的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> next 下一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 红黑树结构的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; q = (LinkedHashMap.Entry&lt;K,V&gt;)p;</span><br><span class="line">    TreeNode&lt;K,V&gt; t = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(q.hash, q.key, q.value, next);</span><br><span class="line">    transferLinks(q, t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除节点后的动作</span></span><br><span class="line"><span class="comment"> * HashMap#removeNode时会调用该方法</span></span><br><span class="line"><span class="comment"> * 将指定节点移除后应该维护其剩余节点的关联关系</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增节点后的动作</span></span><br><span class="line"><span class="comment"> * 默认情况下不会移除最少访问的节点</span></span><br><span class="line"><span class="comment"> * HashMap#putVal时会调用该方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict 模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123; <span class="comment">//可根据覆写removeEldestEntry方法来实现不同策略的缓存机制，默认是不会移除</span></span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>); <span class="comment">//移除最少访问的节点，即头部节点，默认情况下不会调用该方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问节点后的动作</span></span><br><span class="line"><span class="comment"> * 上面我们提到accessOrder = true时会按照访问顺序排序，最多访问的节点会被移动到尾部，即将当前节点移动到尾部，若是accessOrder = false则按照插入顺序排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 当前节点，即访问的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123; <span class="comment">//说明当前节点不是尾部节点，那就说明要移动到尾部</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; <span class="comment">//当前节点的上下节点</span></span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>) <span class="comment">//说明当前节点是头部节点</span></span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//当前节点是中间节点</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//a = null 说明当前节点是尾部，可是我们在一开始就判断了当前节点不是尾部节点，所以这里的else就不会走到</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>) <span class="comment">//last = tail也不可能为空，因为只有当前节点存在的情况才会调用该方法</span></span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p; <span class="comment">//将当前节点当作尾部节点</span></span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将键值对分别写入到流中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 输出流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">internalWriteEntries</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after) &#123;</span><br><span class="line">        s.writeObject(e.key);</span><br><span class="line">        s.writeObject(e.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否包含指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after) &#123;</span><br><span class="line">        V v = e.value;</span><br><span class="line">        <span class="keyword">if</span> (v == value || (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键获取值</span></span><br><span class="line"><span class="comment"> * 若accessOrder = true 调用该方法时认为是访问节点，同时也认为是结构修改，所以会去调用afterNodeAccess</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键获取值，若不存在指定节点则返回默认值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> defaultValue 默认值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 值或默认值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">   Node&lt;K,V&gt; e;</span><br><span class="line">   <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">       <span class="keyword">return</span> defaultValue;</span><br><span class="line">   <span class="keyword">if</span> (accessOrder)</span><br><span class="line">       afterNodeAccess(e);</span><br><span class="line">   <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.clear();</span><br><span class="line">    head = tail = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否移除最少访问的节点</span></span><br><span class="line"><span class="comment"> * 可通过覆写该方法来实现不同的策略，比如当缓存达到指定瓶颈时，每添加新节点时就删除掉最少访问的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> eldest 最少访问的节点，即头节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有键的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有键的Set集合 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Set&lt;K&gt; ks = keySet;</span><br><span class="line">    <span class="keyword">if</span> (ks == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ks = <span class="keyword">new</span> LinkedKeySet();</span><br><span class="line">        keySet = ks;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含所有键的集合</span></span><br><span class="line"><span class="comment"> * 跟HashMap中的代码类似，就不做解释了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedKeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; LinkedHashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedKeyIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsKey(o); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;K&gt; <span class="title">spliterator</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, Spliterator.SIZED |</span><br><span class="line">                                        Spliterator.ORDERED |</span><br><span class="line">                                        Spliterator.DISTINCT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> mc = modCount;</span><br><span class="line">        <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after)</span><br><span class="line">            action.accept(e.key);</span><br><span class="line">        <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有值的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有值的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Collection&lt;V&gt; vs = values;</span><br><span class="line">    <span class="keyword">if</span> (vs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        vs = <span class="keyword">new</span> LinkedValues();</span><br><span class="line">        values = vs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含所有值的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedValues</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; LinkedHashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedValueIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsValue(o); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;V&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, Spliterator.SIZED |</span><br><span class="line">                                        Spliterator.ORDERED);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> mc = modCount;</span><br><span class="line">        <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after)</span><br><span class="line">            action.accept(e.value);</span><br><span class="line">        <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有键值对的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有键值对的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> LinkedEntrySet()) : es;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含所有键值对的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedEntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; LinkedHashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedEntryIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">        Object key = e.getKey();</span><br><span class="line">        Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class="line">        <span class="keyword">return</span> candidate != <span class="keyword">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">            Object key = e.getKey();</span><br><span class="line">            Object value = e.getValue();</span><br><span class="line">            <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, Spliterator.SIZED |</span><br><span class="line">                                        Spliterator.ORDERED |</span><br><span class="line">                                        Spliterator.DISTINCT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> mc = modCount;</span><br><span class="line">        <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after)</span><br><span class="line">            action.accept(e);</span><br><span class="line">        <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历表并执行指定动作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action 指定动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> mc = modCount;</span><br><span class="line">    <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after)</span><br><span class="line">        action.accept(e.key, e.value);</span><br><span class="line">    <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历表并执行指定动作后获取新值，利用新值替换所有节点的旧值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> function 指定动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; function)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (function == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> mc = modCount;</span><br><span class="line">    <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after)</span><br><span class="line">        e.value = function.apply(e.key, e.value);</span><br><span class="line">    <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代器基类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashIterator</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; next;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; current;</span><br><span class="line">    <span class="keyword">int</span> expectedModCount;</span><br><span class="line"></span><br><span class="line">    LinkedHashIterator() &#123;</span><br><span class="line">        next = head;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        current = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> LinkedHashMap.<span class="function">Entry&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        current = e;</span><br><span class="line">        next = e.after;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; p = current;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        current = <span class="keyword">null</span>;</span><br><span class="line">        K key = p.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含所有键的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedKeyIterator</span> <span class="keyword">extends</span> <span class="title">LinkedHashIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().getKey(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含所有值的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedValueIterator</span> <span class="keyword">extends</span> <span class="title">LinkedHashIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含所有键值对的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedEntryIterator</span> <span class="keyword">extends</span> <span class="title">LinkedHashIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>有序、不可重复、非线程安全：内部通过维护一条双向链表来保证有序性</p></li><li><p>排序方式有两种：按插入顺序；按访问顺序，最近访问的节点会被移动到尾部，相当于头节点是最少访问的节点</p></li><li><p>removeEldestEntry：是否移除最少访问的节点，可覆写该方法来实现不同策略的缓存机制</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>双向链表保证有序性</code> <code>可按插入顺序或按访问顺序</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;印象中对LinkedHashMap的使用次数好像也不多，参考了几篇文章发现它依赖于&lt;code&gt;HashMap&lt;/code&gt;而存在，也就是说它在HashMap的基础上又增加了某些特性，比如说&lt;code&gt;有序&lt;/code&gt;。既然是基于HashMap，那么它内部的数据结构也应该有数组 + 链表 + 红黑树，而刚才说它又加上了自己的有序特性，那么应该还有&lt;code&gt;一条链表来维护该顺序&lt;/code&gt;，如下图所示：&lt;/p&gt;
&lt;p class=&quot;customize-img&quot;&gt;&lt;img src=&quot;/assets/blogImg/java/linkedhashmap/data-structure.png&quot; alt=&quot;LinkedHashMap数据结构&quot;&gt;&lt;/p&gt;
&lt;p&gt;该图侧重于它是如何保持有序的，就像上面说的是一条链表，画的有点丑，不过应该不难理解。另外一方面，由于它是基于HashMap，所以在看这篇文章之前最好能对HashMap有个了解，加上接下来并不会过多的解释它的数据结构，更多的关注还是在有序及其他特性上，毕竟它的数据结构是偷来的，探索LinkedHashMap底层实现是基于&lt;code&gt;JDK1.8&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索IdentityHashMap底层实现</title>
    <link href="http://zlia.tech/2019/10/23/explain-identityhashmap-sourcecode/"/>
    <id>http://zlia.tech/2019/10/23/explain-identityhashmap-sourcecode/</id>
    <published>2019-10-23T09:11:08.000Z</published>
    <updated>2019-11-04T08:05:22.859Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a><div><span>前沿</span></div></h3><p>我也是第一次认识IdentityHashMap，在工作中从未使用过它，所以对它的使用场景可能并不是很了解，本文也仅仅针对基于<code>JDK1.8</code>的源码进行探索。<code>IdentityHashMap</code>的数据结构应该是如图所示：</p><p class="customize-img"><img src="/assets/blogImg/java/identityhashmap/data-structure.png" alt="IdentityHashMap数据结构"></p><p>这个数据结构是我在看源码之前看了几篇别人写的文章所了解到的，个人喜欢在看源码对目标有所了解的习惯，紧接着才去深入它。</p><a id="more"></a><h3 id="阅读注释"><a href="#阅读注释" class="headerlink" title="阅读注释"></a><div><span>阅读注释</span></div></h3><p class="customize-img"><img src="/assets/blogImg/java/identityhashmap/identityhashmap-comment-1.png" alt="IdentityHashMap注释-1"></p><p>在IdentityHashMap中，对于两个键只有在k1 == k2成立时才认为是相等的，而在HashMap中确实k1.equals(k2)成立是才被认为相等，<code>前者是引用相等，而后者是对象相等</code>。</p><p class="customize-img"><img src="/assets/blogImg/java/identityhashmap/identityhashmap-comment-2.png" alt="IdentityHashMap注释-2"></p><p class="customize-img"><img src="/assets/blogImg/java/identityhashmap/identityhashmap-comment-3.png" alt="IdentityHashMap注释-3"></p><p>Identity可用于序列化或深拷贝或对象代理。</p><p class="customize-img"><img src="/assets/blogImg/java/identityhashmap/identityhashmap-comment-4.png" alt="IdentityHashMap注释-4"></p><p>键值对允许存放null，同样也是无序的。</p><p class="customize-img"><img src="/assets/blogImg/java/identityhashmap/identityhashmap-comment-5.png" alt="IdentityHashMap注释-5"></p><p>IdentityHashMap属于非线程安全，和集合中的其他类一样迭代器都可能发生快速失败。</p><p class="customize-img"><img src="/assets/blogImg/java/identityhashmap/identityhashmap-comment-6.png" alt="IdentityHashMap注释-6"></p><p>线性探针哈希表，这是对其数据结构的称呼。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//可序列化、克隆</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdentityHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认键值对个数</span></span><br><span class="line"><span class="comment">     * 虽然注释上写着是默认初始容量，但当你发现有这样子的一段代码时：table = new Object[2 * initCapacity]，你就会明白默认初始容量应该是64</span></span><br><span class="line"><span class="comment">     * 容量大小必须是2的幂次方，在添加节点时会先判断当前节点的个数是否超过了容量的1/3，所以我认为1/3是加载因子</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 为什么必须是2的幂次方?</span></span><br><span class="line"><span class="comment">     * 在计算索引时用&amp;代码了%，提升了效率，不过这导致了一个前提，就是必须是2的幂次方，为了是能够取到容量区间中的每个索引，有人将这种做法称为均匀分布</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最小键值对个数</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 为什么最小是4?</span></span><br><span class="line"><span class="comment">     * 假设手动指定容量大小是1，则初始容量应该是2，在添加第一个节点时会先判断当前节点的个数是否超过了容量的1/3，很显然，2 * 1/3的结果都不足1，所以它会先扩容，扩容后再添加节点，由于扩容是需要消耗一定的成本，为何不在初始化时就设定较 * 高的值来避免此次扩容；那么如果指定容量大小是2呢? 4 * 1/3 不足2，因为它的数据结构是同时存储key与value，所以在存储value时也必定会扩容，故也不行；那3就更不行了，毕竟要是2的幂次方，所以4属于最小指定容量值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MINIMUM_CAPACITY = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大键值对个数</span></span><br><span class="line"><span class="comment">     * 虽然注释上写着是最大容量，但实际上并不是，此数值用于当构造函数中指定的容量过高时会直接该数值，而当你发现有这样子一句代码时：table = new Object[2 * initCapacity]; 你就会发现实际上最大的容量应该是 1&lt;&lt;30才对</span></span><br><span class="line"><span class="comment">     * 实际上，线性探针表中能存储的节点个数不能超过 1&lt;&lt;&lt;30 - 1 个，因为它至少有一个位置是存储了null，用来避免死循环</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">29</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线性探针表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线性探针表中存储的节点个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 结构被修改的次数</span></span><br><span class="line"><span class="comment">     * 该成员属性是用于检测迭代器的快速失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代表键为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object NULL_KEY = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存entrySet方法的返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 采用默认键值对个数初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdentityHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init(DEFAULT_CAPACITY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键值对个数来初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expectedMaxSize 指定键值对个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdentityHashMap</span><span class="params">(<span class="keyword">int</span> expectedMaxSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (expectedMaxSize &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"expectedMaxSize is negative: "</span></span><br><span class="line">                                           + expectedMaxSize);</span><br><span class="line">    init(capacity(expectedMaxSize));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键值对个数进行初始化，并将指定集合添加到线性探针表中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdentityHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Allow for a bit of growth</span></span><br><span class="line">    <span class="keyword">this</span>((<span class="keyword">int</span>) ((<span class="number">1</span> + m.size()) * <span class="number">1.1</span>));</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 倘若键为null则采用NULL_KEY作为键</span></span><br><span class="line"><span class="comment">  * 正如方法名一样，隐藏Null</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> NULL_KEY或指定键</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">maskNull</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span> ? NULL_KEY : key);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 倘若键为NULL_KEY则返回null</span></span><br><span class="line"><span class="comment">  * 正如方法名一样，揭露Null</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key 线性探针表中的键</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> null或指定键</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title">unmaskNull</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (key == NULL_KEY ? <span class="keyword">null</span> : key);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 调整指定键值对个数</span></span><br><span class="line"><span class="comment">  * Integer.highestOneBit 返回只含有二进制中最高位（从左到右第一个数字为1）的十进制，如15对应的二进制是1111，结果是1000，也就是数字8</span></span><br><span class="line"><span class="comment">  * 这里有一点我觉得代码写的不够完美，假设expectedMaxSize = 3，意思我可能要存储3个键值对，而它最终的容量是16，那么在我添加最后一对键值对时，它仍然会进行扩容，个人觉得设计的不够完美</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> expectedMaxSize 指定键值对个数</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 调整后的键值对个数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">(<span class="keyword">int</span> expectedMaxSize)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line">         (expectedMaxSize &gt; MAXIMUM_CAPACITY / <span class="number">3</span>) ? MAXIMUM_CAPACITY :</span><br><span class="line">         (expectedMaxSize &lt;= <span class="number">2</span> * MINIMUM_CAPACITY / <span class="number">3</span>) ? MINIMUM_CAPACITY :</span><br><span class="line">         Integer.highestOneBit(expectedMaxSize + (expectedMaxSize &lt;&lt; <span class="number">1</span>));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 指定键值对个数来初始化哈希探针表</span></span><br><span class="line"><span class="comment">  * 由于参数代表着键值对个数，相当于是2倍的节点个数，故在初始化时 * 2</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> initCapacity 指定键值对个数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> initCapacity)</span> </span>&#123;</span><br><span class="line">     table = <span class="keyword">new</span> Object[<span class="number">2</span> * initCapacity];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取哈希探针表中节点的个数</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 节点的个数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> size;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 判断哈希探针表是否为空</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 哈希探针表是否为空</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 在指定区间内获取偶数索引位置</span></span><br><span class="line"><span class="comment">  * 为什么是偶数位置?</span></span><br><span class="line"><span class="comment">  * 因为它的数据结构是按照 | key | value | key1 | value1 | 的形式进行存储，导致了键是存储在偶数位置上，而值是存储在奇数位置上</span></span><br><span class="line"><span class="comment">  * 它采用的System.identityHashCode，该方法的结果与Object#hashCode的结果是一样的，只不过这样子就调不到开发人员自己覆写的hashCode方法</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> x 指定键</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> length 指定容量大小</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 偶数索引位置</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object x, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> h = System.identityHashCode(x);</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * (h &lt;&lt; 1) - (h &lt;&lt;8) </span></span><br><span class="line"><span class="comment">      * h * Math.pow(2,1) - h * Math.pow(2,8) -&gt; -h * (Math.pow(2,8) - Math.pow(2,1)) -&gt; -h * 2 * (Math.pow(2,7) - 1) -&gt; -h * 2 * 127 -&gt; -h * 127 * 2</span></span><br><span class="line"><span class="comment">      * 简化后的结果正好跟注释对应上，不过它始终没解释为啥是乘以-127，目前只知道 * 2是一定会得到偶数，因为它相当于进行了左移，去掉了最右边的一位，即1</span></span><br><span class="line"><span class="comment">      * 然后偶数 &amp; (length - 1) 最终是确定索引只可能是该区间内上的某一个偶数位置</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">return</span> ((h &lt;&lt; <span class="number">1</span>) - (h &lt;&lt; <span class="number">8</span>)) &amp; (length - <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取下一个偶数索引位置</span></span><br><span class="line"><span class="comment">  * 若下一个偶数索引位置超过了哈希探针表的容量大小，则从头开始，相当于在循环遍历哈希探针表</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> i 当前索引位置</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> len 表的容量大小</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 下一个偶数索引位置</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextKeyIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (i + <span class="number">2</span> &lt; len ? i + <span class="number">2</span> : <span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 对哈希探针表进行扩容</span></span><br><span class="line"><span class="comment">  * 新表是旧表的2倍，原来在旧表中节点重新散列到新表上</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> newCapacity 指定容量大小</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 是否扩容成功</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> newLength = newCapacity * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">     Object[] oldTable = table;</span><br><span class="line">     <span class="keyword">int</span> oldLength = oldTable.length;</span><br><span class="line">     <span class="keyword">if</span> (oldLength == <span class="number">2</span> * MAXIMUM_CAPACITY) &#123;</span><br><span class="line">         <span class="keyword">if</span> (size == MAXIMUM_CAPACITY - <span class="number">1</span>) <span class="comment">//最大节点的个数不能超过 MAXIMUM_CAPACITY - 1，因为有一个位置要存储Null，避免死循环</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Capacity exhausted."</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (oldLength &gt;= newLength)</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">     Object[] newTable = <span class="keyword">new</span> Object[newLength];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLength; j += <span class="number">2</span>) &#123; <span class="comment">//查找偶数位置上的键</span></span><br><span class="line">         <span class="comment">//扩容后将键值对重新散列到新表上</span></span><br><span class="line">         Object key = oldTable[j];</span><br><span class="line">         <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">             Object value = oldTable[j+<span class="number">1</span>];</span><br><span class="line">             oldTable[j] = <span class="keyword">null</span>;</span><br><span class="line">             oldTable[j+<span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">             <span class="keyword">int</span> i = hash(key, newLength);</span><br><span class="line">             <span class="keyword">while</span> (newTable[i] != <span class="keyword">null</span>)</span><br><span class="line">                 i = nextKeyIndex(i, newLength);</span><br><span class="line">             newTable[i] = key;</span><br><span class="line">             newTable[i + <span class="number">1</span>] = value;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     table = newTable;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 哈希探针表中是否包含指定键</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 是否包含指定键</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     Object k = maskNull(key);</span><br><span class="line">     Object[] tab = table;</span><br><span class="line">     <span class="keyword">int</span> len = tab.length;</span><br><span class="line">     <span class="keyword">int</span> i = hash(k, len);</span><br><span class="line">     <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">         Object item = tab[i];</span><br><span class="line">         <span class="keyword">if</span> (item == k)</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         <span class="keyword">if</span> (item == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         i = nextKeyIndex(i, len);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 哈希探针表中是否包含指定值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 是否包含指定值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">     Object[] tab = table;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tab.length; i += <span class="number">2</span>)</span><br><span class="line">         <span class="keyword">if</span> (tab[i] == value &amp;&amp; tab[i - <span class="number">1</span>] != <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 哈希探针表中是否包含指定键值对</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 是否包含指定键值对</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">containsMapping</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">     Object k = maskNull(key);</span><br><span class="line">     Object[] tab = table;</span><br><span class="line">     <span class="keyword">int</span> len = tab.length;</span><br><span class="line">     <span class="keyword">int</span> i = hash(k, len);</span><br><span class="line">     <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">         Object item = tab[i];</span><br><span class="line">         <span class="keyword">if</span> (item == k)</span><br><span class="line">             <span class="keyword">return</span> tab[i + <span class="number">1</span>] == value;</span><br><span class="line">         <span class="keyword">if</span> (item == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         i = nextKeyIndex(i, len);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 删除节点后重新散列所有可能冲突的节点</span></span><br><span class="line"><span class="comment">  * | key | value | key1 | value1 | key2 | value2 | -&gt; | key1 | value1 | key2 | value2 | null | null |</span></span><br><span class="line"><span class="comment">  * 该方法的实现较为混乱</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> d 指定索引位置</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeDeletion</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// Adapted from Knuth Section 6.4 Algorithm R</span></span><br><span class="line">     Object[] tab = table;</span><br><span class="line">     <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Look for items to swap into newly vacated slot</span></span><br><span class="line">     <span class="comment">// starting at index immediately following deletion,</span></span><br><span class="line">     <span class="comment">// and continuing until a null slot is seen, indicating</span></span><br><span class="line">     <span class="comment">// the end of a run of possibly-colliding keys.</span></span><br><span class="line">     Object item;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = nextKeyIndex(d, len); (item = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">          i = nextKeyIndex(i, len) ) &#123;</span><br><span class="line">         <span class="keyword">int</span> r = hash(item, len);</span><br><span class="line">         <span class="keyword">if</span> ((i &lt; r &amp;&amp; (r &lt;= d || d &lt;= i)) || (r &lt;= d &amp;&amp; d &lt;= i)) &#123;</span><br><span class="line">             tab[d] = item;</span><br><span class="line">             tab[d + <span class="number">1</span>] = tab[i + <span class="number">1</span>];</span><br><span class="line">             tab[i] = <span class="keyword">null</span>;</span><br><span class="line">             tab[i + <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">             d = i;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 清空</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     modCount++;</span><br><span class="line">     Object[] tab = table;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; i++)</span><br><span class="line">         tab[i] = <span class="keyword">null</span>;</span><br><span class="line">     size = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 比较当前对象与指定对象是否相等</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> o 指定对象</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 是否相等</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (o == <span class="keyword">this</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> IdentityHashMap) &#123;</span><br><span class="line">         IdentityHashMap&lt;?,?&gt; m = (IdentityHashMap&lt;?,?&gt;) o;</span><br><span class="line">         <span class="keyword">if</span> (m.size() != size)</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">         Object[] tab = m.table;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; i+=<span class="number">2</span>) &#123;</span><br><span class="line">             Object k = tab[i];</span><br><span class="line">             <span class="keyword">if</span> (k != <span class="keyword">null</span> &amp;&amp; !containsMapping(k, tab[i + <span class="number">1</span>]))</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">         Map&lt;?,?&gt; m = (Map&lt;?,?&gt;)o;</span><br><span class="line">         <span class="keyword">return</span> entrySet().equals(m.entrySet());</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">// o is not a Map</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取哈希值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 哈希值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">     Object[] tab = table;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; i +=<span class="number">2</span>) &#123;</span><br><span class="line">         Object key = tab[i];</span><br><span class="line">         <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">             Object k = unmaskNull(key);</span><br><span class="line">             result += System.identityHashCode(k) ^</span><br><span class="line">                       System.identityHashCode(tab[i + <span class="number">1</span>]);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 浅拷贝</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 克隆后的对象</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         IdentityHashMap&lt;?,?&gt; m = (IdentityHashMap&lt;?,?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">         m.entrySet = <span class="keyword">null</span>;</span><br><span class="line">         m.table = table.clone();</span><br><span class="line">         <span class="keyword">return</span> m;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 迭代器</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IdentityHashMapIterator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">     <span class="comment">//当前索引位置</span></span><br><span class="line">     <span class="keyword">int</span> index = (size != <span class="number">0</span> ? <span class="number">0</span> : table.length);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//结构修改次数</span></span><br><span class="line">     <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//移除节点前需要先获取当前索引位置，即先调用nextIndex后才能移除，下一次移除仍然需要先调用该方法</span></span><br><span class="line">     <span class="keyword">int</span> lastReturnedIndex = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//是否是有效索引</span></span><br><span class="line">     <span class="keyword">boolean</span> indexValid; <span class="comment">// To avoid unnecessary next computation</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//哈希探针表</span></span><br><span class="line">     Object[] traversalTable = table; <span class="comment">// reference to main table or copy</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 从当前索引位置开始后续是否有下一个键</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span> 是否有下一个键</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         Object[] tab = traversalTable;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; tab.length; i+=<span class="number">2</span>) &#123;</span><br><span class="line">             Object key = tab[i];</span><br><span class="line">             <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 index = i;</span><br><span class="line">                 <span class="keyword">return</span> indexValid = <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         index = tab.length;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 获取下一个索引</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span> 下一个索引</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">         <span class="keyword">if</span> (!indexValid &amp;&amp; !hasNext())</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">         indexValid = <span class="keyword">false</span>;</span><br><span class="line">         lastReturnedIndex = index;</span><br><span class="line">         index += <span class="number">2</span>;</span><br><span class="line">         <span class="keyword">return</span> lastReturnedIndex;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 移除当前节点</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (lastReturnedIndex == -<span class="number">1</span>)</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">         <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line"></span><br><span class="line">         expectedModCount = ++modCount;</span><br><span class="line">         <span class="keyword">int</span> deletedSlot = lastReturnedIndex;</span><br><span class="line">         lastReturnedIndex = -<span class="number">1</span>;</span><br><span class="line">         <span class="comment">// back up index to revisit new contents after deletion</span></span><br><span class="line">         index = deletedSlot;</span><br><span class="line">         indexValid = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">         Object[] tab = traversalTable;</span><br><span class="line">         <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">int</span> d = deletedSlot;</span><br><span class="line">         Object key = tab[d];</span><br><span class="line">         tab[d] = <span class="keyword">null</span>;        <span class="comment">// vacate the slot</span></span><br><span class="line">         tab[d + <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// If traversing a copy, remove in real table.</span></span><br><span class="line">         <span class="comment">// We can skip gap-closure on copy.</span></span><br><span class="line">         <span class="keyword">if</span> (tab != IdentityHashMap.<span class="keyword">this</span>.table) &#123;</span><br><span class="line">             IdentityHashMap.<span class="keyword">this</span>.remove(key);</span><br><span class="line">             expectedModCount = modCount;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         size--;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//在删除节点后所有可能冲突的节点会被重新散列，但是遍历的索引确实不变的，这也就是导致了移动后的某些节点可能会遍历不到，所以它在变化前做了数组的拷贝以便能够正常访问</span></span><br><span class="line">         Object item;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = nextKeyIndex(d, len); (item = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">              i = nextKeyIndex(i, len)) &#123;</span><br><span class="line">             <span class="keyword">int</span> r = hash(item, len);</span><br><span class="line">             <span class="comment">// See closeDeletion for explanation of this conditional</span></span><br><span class="line">             <span class="keyword">if</span> ((i &lt; r &amp;&amp; (r &lt;= d || d &lt;= i)) ||</span><br><span class="line">                 (r &lt;= d &amp;&amp; d &lt;= i)) &#123;</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">if</span> (i &lt; deletedSlot &amp;&amp; d &gt;= deletedSlot &amp;&amp;</span><br><span class="line">                     traversalTable == IdentityHashMap.<span class="keyword">this</span>.table) &#123;</span><br><span class="line">                     <span class="keyword">int</span> remaining = len - deletedSlot;</span><br><span class="line">                     Object[] newTable = <span class="keyword">new</span> Object[remaining];</span><br><span class="line">                     System.arraycopy(tab, deletedSlot,</span><br><span class="line">                                      newTable, <span class="number">0</span>, remaining);</span><br><span class="line">                     traversalTable = newTable;</span><br><span class="line">                     index = <span class="number">0</span>;</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 tab[d] = item;</span><br><span class="line">                 tab[d + <span class="number">1</span>] = tab[i + <span class="number">1</span>];</span><br><span class="line">                 tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                 tab[i + <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">                 d = i;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 包含所有键的迭代器</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">IdentityHashMapIterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">     <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">     <span class="function"><span class="keyword">public</span> K <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> (K) unmaskNull(traversalTable[nextIndex()]);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 包含所有值的迭代器</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">IdentityHashMapIterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">     <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">     <span class="function"><span class="keyword">public</span> V <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> (V) traversalTable[nextIndex() + <span class="number">1</span>];</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 包含所有键值对的迭代器，都是类似的代码就不做解释了</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">IdentityHashMapIterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> Entry lastReturnedEntry;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         lastReturnedEntry = <span class="keyword">new</span> Entry(nextIndex());</span><br><span class="line">         <span class="keyword">return</span> lastReturnedEntry;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         lastReturnedIndex =</span><br><span class="line">             ((<span class="keyword">null</span> == lastReturnedEntry) ? -<span class="number">1</span> : lastReturnedEntry.index);</span><br><span class="line">         <span class="keyword">super</span>.remove();</span><br><span class="line">         lastReturnedEntry.index = lastReturnedIndex;</span><br><span class="line">         lastReturnedEntry = <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">         <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">private</span> <span class="title">Entry</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">this</span>.index = index;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">         <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             checkIndexForEntryUse();</span><br><span class="line">             <span class="keyword">return</span> (K) unmaskNull(traversalTable[index]);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">         <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             checkIndexForEntryUse();</span><br><span class="line">             <span class="keyword">return</span> (V) traversalTable[index+<span class="number">1</span>];</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">         <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">             checkIndexForEntryUse();</span><br><span class="line">             V oldValue = (V) traversalTable[index+<span class="number">1</span>];</span><br><span class="line">             traversalTable[index+<span class="number">1</span>] = value;</span><br><span class="line">             <span class="comment">// if shadowing, force into main table</span></span><br><span class="line">             <span class="keyword">if</span> (traversalTable != IdentityHashMap.<span class="keyword">this</span>.table)</span><br><span class="line">                 put((K) traversalTable[index], value);</span><br><span class="line">             <span class="keyword">return</span> oldValue;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">super</span>.equals(o);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">             <span class="keyword">return</span> (e.getKey() == unmaskNull(traversalTable[index]) &amp;&amp;</span><br><span class="line">                    e.getValue() == traversalTable[index+<span class="number">1</span>]);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">if</span> (lastReturnedIndex &lt; <span class="number">0</span>)</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">super</span>.hashCode();</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span> (System.identityHashCode(unmaskNull(traversalTable[index])) ^</span><br><span class="line">                    System.identityHashCode(traversalTable[index+<span class="number">1</span>]));</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span> (unmaskNull(traversalTable[index]) + <span class="string">"="</span></span><br><span class="line">                     + traversalTable[index+<span class="number">1</span>]);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkIndexForEntryUse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Entry was removed"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取包含所有键的集合</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 包含所有键的Set集合 </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Set&lt;K&gt; ks = keySet;</span><br><span class="line">     <span class="keyword">if</span> (ks == <span class="keyword">null</span>) &#123;</span><br><span class="line">         ks = <span class="keyword">new</span> KeySet();</span><br><span class="line">         keySet = ks;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ks;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 包含哈希探针表中所有键的集合</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> size;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> containsKey(o);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> oldSize = size;</span><br><span class="line">         IdentityHashMap.<span class="keyword">this</span>.remove(o);</span><br><span class="line">         <span class="keyword">return</span> size != oldSize;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">         Objects.requireNonNull(c);</span><br><span class="line">         <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">for</span> (Iterator&lt;K&gt; i = iterator(); i.hasNext(); ) &#123;</span><br><span class="line">             <span class="keyword">if</span> (c.contains(i.next())) &#123;</span><br><span class="line">                 i.remove();</span><br><span class="line">                 modified = <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> modified;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         IdentityHashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (K key : <span class="keyword">this</span>)</span><br><span class="line">             result += System.identityHashCode(key);</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">         <span class="keyword">return</span> toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">     <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">         <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">         <span class="keyword">int</span> size = size();</span><br><span class="line">         <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">             a = (T[]) Array.newInstance(a.getClass().getComponentType(), size);</span><br><span class="line">         Object[] tab = table;</span><br><span class="line">         <span class="keyword">int</span> ti = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> si = <span class="number">0</span>; si &lt; tab.length; si += <span class="number">2</span>) &#123;</span><br><span class="line">             Object key;</span><br><span class="line">             <span class="keyword">if</span> ((key = tab[si]) != <span class="keyword">null</span>) &#123; <span class="comment">// key present ?</span></span><br><span class="line">                 <span class="comment">// more elements than expected -&gt; concurrent modification from other thread</span></span><br><span class="line">                 <span class="keyword">if</span> (ti &gt;= size) &#123;</span><br><span class="line">                     <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                 &#125;</span><br><span class="line">                 a[ti++] = (T) unmaskNull(key); <span class="comment">// unmask key</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// fewer elements than expected or concurrent modification from other thread detected</span></span><br><span class="line">         <span class="keyword">if</span> (ti &lt; size || expectedModCount != modCount) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// final null marker as per spec</span></span><br><span class="line">         <span class="keyword">if</span> (ti &lt; a.length) &#123;</span><br><span class="line">             a[ti] = <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> a;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Spliterator&lt;K&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> KeySpliterator&lt;&gt;(IdentityHashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取包含所有值的对象</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 包含所有值的对象</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Collection&lt;V&gt; vs = values;</span><br><span class="line">     <span class="keyword">if</span> (vs == <span class="keyword">null</span>) &#123;</span><br><span class="line">         vs = <span class="keyword">new</span> Values();</span><br><span class="line">         values = vs;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> vs;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 包含所有值的对象</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Values</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> ValueIterator();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> size;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> containsValue(o);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">for</span> (Iterator&lt;V&gt; i = iterator(); i.hasNext(); ) &#123;</span><br><span class="line">             <span class="keyword">if</span> (i.next() == o) &#123;</span><br><span class="line">                 i.remove();</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         IdentityHashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">         <span class="keyword">return</span> toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">     <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">         <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">         <span class="keyword">int</span> size = size();</span><br><span class="line">         <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">             a = (T[]) Array.newInstance(a.getClass().getComponentType(), size);</span><br><span class="line">         Object[] tab = table;</span><br><span class="line">         <span class="keyword">int</span> ti = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> si = <span class="number">0</span>; si &lt; tab.length; si += <span class="number">2</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (tab[si] != <span class="keyword">null</span>) &#123; <span class="comment">// key present ?</span></span><br><span class="line">                 <span class="comment">// more elements than expected -&gt; concurrent modification from other thread</span></span><br><span class="line">                 <span class="keyword">if</span> (ti &gt;= size) &#123;</span><br><span class="line">                     <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                 &#125;</span><br><span class="line">                 a[ti++] = (T) tab[si+<span class="number">1</span>]; <span class="comment">// copy value</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// fewer elements than expected or concurrent modification from other thread detected</span></span><br><span class="line">         <span class="keyword">if</span> (ti &lt; size || expectedModCount != modCount) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// final null marker as per spec</span></span><br><span class="line">         <span class="keyword">if</span> (ti &lt; a.length) &#123;</span><br><span class="line">             a[ti] = <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> a;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Spliterator&lt;V&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> ValueSpliterator&lt;&gt;(IdentityHashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取包含所有键值对的集合</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 包含所有键值对的集合</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">     Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet;</span><br><span class="line">     <span class="keyword">if</span> (es != <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">return</span> es;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">return</span> entrySet = <span class="keyword">new</span> EntrySet();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 包含所有键值对的集合</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">         <span class="keyword">return</span> containsMapping(entry.getKey(), entry.getValue());</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">         <span class="keyword">return</span> removeMapping(entry.getKey(), entry.getValue());</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> size;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         IdentityHashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">         Objects.requireNonNull(c);</span><br><span class="line">         <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = iterator(); i.hasNext(); ) &#123;</span><br><span class="line">             <span class="keyword">if</span> (c.contains(i.next())) &#123;</span><br><span class="line">                 i.remove();</span><br><span class="line">                 modified = <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> modified;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">         <span class="keyword">return</span> toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">     <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">         <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">         <span class="keyword">int</span> size = size();</span><br><span class="line">         <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">             a = (T[]) Array.newInstance(a.getClass().getComponentType(), size);</span><br><span class="line">         Object[] tab = table;</span><br><span class="line">         <span class="keyword">int</span> ti = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> si = <span class="number">0</span>; si &lt; tab.length; si += <span class="number">2</span>) &#123;</span><br><span class="line">             Object key;</span><br><span class="line">             <span class="keyword">if</span> ((key = tab[si]) != <span class="keyword">null</span>) &#123; <span class="comment">// key present ?</span></span><br><span class="line">                 <span class="comment">// more elements than expected -&gt; concurrent modification from other thread</span></span><br><span class="line">                 <span class="keyword">if</span> (ti &gt;= size) &#123;</span><br><span class="line">                     <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                 &#125;</span><br><span class="line">                 a[ti++] = (T) <span class="keyword">new</span> AbstractMap.SimpleEntry&lt;&gt;(unmaskNull(key), tab[si + <span class="number">1</span>]);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// fewer elements than expected or concurrent modification from other thread detected</span></span><br><span class="line">         <span class="keyword">if</span> (ti &lt; size || expectedModCount != modCount) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// final null marker as per spec</span></span><br><span class="line">         <span class="keyword">if</span> (ti &lt; a.length) &#123;</span><br><span class="line">             a[ti] = <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> a;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> EntrySpliterator&lt;&gt;(IdentityHashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 自定义序列化</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> s 输出流</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> java.io.IOException  </span>&#123;</span><br><span class="line">     <span class="comment">// Write out and any hidden stuff</span></span><br><span class="line">     s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Write out size (number of Mappings)</span></span><br><span class="line">     s.writeInt(size);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Write out keys and values (alternating)</span></span><br><span class="line">     Object[] tab = table;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">         Object key = tab[i];</span><br><span class="line">         <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">             s.writeObject(unmaskNull(key));</span><br><span class="line">             s.writeObject(tab[i + <span class="number">1</span>]);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 自定义反序列化</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> s 输入流</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException  </span>&#123;</span><br><span class="line">     <span class="comment">// Read in any hidden stuff</span></span><br><span class="line">     s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Read in size (number of Mappings)</span></span><br><span class="line">     <span class="keyword">int</span> size = s.readInt();</span><br><span class="line">     <span class="keyword">if</span> (size &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> java.io.StreamCorruptedException</span><br><span class="line">             (<span class="string">"Illegal mappings count: "</span> + size);</span><br><span class="line">     <span class="keyword">int</span> cap = capacity(size);</span><br><span class="line">     SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, cap);</span><br><span class="line">     init(cap);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Read the keys and values, and put the mappings in the table</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">         <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">             K key = (K) s.readObject();</span><br><span class="line">         <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">             V value = (V) s.readObject();</span><br><span class="line">         putForCreate(key, value);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 反序列化时将键值对存储到哈希探针表上</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putForCreate</span><span class="params">(K key, V value)</span> <span class="keyword">throws</span> java.io.StreamCorruptedException </span>&#123;</span><br><span class="line">     Object k = maskNull(key);</span><br><span class="line">     Object[] tab = table;</span><br><span class="line">     <span class="keyword">int</span> len = tab.length;</span><br><span class="line">     <span class="keyword">int</span> i = hash(k, len);</span><br><span class="line"></span><br><span class="line">     Object item;</span><br><span class="line">     <span class="keyword">while</span> ( (item = tab[i]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (item == k)</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> java.io.StreamCorruptedException();</span><br><span class="line">         i = nextKeyIndex(i, len);</span><br><span class="line">     &#125;</span><br><span class="line">     tab[i] = k;</span><br><span class="line">     tab[i + <span class="number">1</span>] = value;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 遍历哈希探针表并执行指定动作</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> action 指定动作</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">     Objects.requireNonNull(action);</span><br><span class="line">     <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">     Object[] t = table;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; t.length; index += <span class="number">2</span>) &#123;</span><br><span class="line">         Object k = t[index];</span><br><span class="line">         <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">             action.accept((K) unmaskNull(k), (V) t[index + <span class="number">1</span>]);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 遍历哈希探针表并执行指定动作后获取新值，利用新值替换所有节点的旧值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> function 指定动作</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; function)</span> </span>&#123;</span><br><span class="line">     Objects.requireNonNull(function);</span><br><span class="line">     <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">     Object[] t = table;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; t.length; index += <span class="number">2</span>) &#123;</span><br><span class="line">         Object k = t[index];</span><br><span class="line">         <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">             t[index + <span class="number">1</span>] = function.apply((K) unmaskNull(k), (V) t[index + <span class="number">1</span>]);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加节点</span></span><br><span class="line"><span class="comment"> * 先获取偶数索引位置，若该位置上已经存在节点且两者的节点相等，则进行替换，若两者的节点不相等则继续往下查找偶数索引位置，直到偶数位置上不存在节点时才跳出循环</span></span><br><span class="line"><span class="comment"> * 在上面我们提到，在最大键值对中必须有一个地方存在null，否则会陷入死循环，而这里正好也是说明了这一点，要是在最大键值对中所有的偶数位置上都已经填充了节点，那么它会一直查找，陷入了一个环形的查找中，反正就是死循环了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object k = maskNull(key);</span><br><span class="line"></span><br><span class="line">    retryAfterResize: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">final</span> Object[] tab = table;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> len = tab.length;</span><br><span class="line">        <span class="keyword">int</span> i = hash(k, len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object item; (item = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">             i = nextKeyIndex(i, len)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item == k) &#123; <span class="comment">//若新增的节点与当前偶数索引位置上的节点相等，将新值替换旧值</span></span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    V oldValue = (V) tab[i + <span class="number">1</span>];</span><br><span class="line">                tab[i + <span class="number">1</span>] = value;</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> s = size + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * s + (s &lt;&lt; 1) -&gt; 3 * s</span></span><br><span class="line"><span class="comment">         * 添加节点后是否超过容量的1/3，若超过则进行扩容，扩容成功后要在新表中重新查找偶数索引位置，若扩容失败或不需要扩容则直接存储节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (s + (s &lt;&lt; <span class="number">1</span>) &gt; len &amp;&amp; resize(len))</span><br><span class="line">            <span class="keyword">continue</span> retryAfterResize; <span class="comment">//代码又回到for循环上</span></span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        tab[i] = k;</span><br><span class="line">        tab[i + <span class="number">1</span>] = value;</span><br><span class="line">        size = s;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定集合到线性探针表中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = m.size();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; size)</span><br><span class="line">        resize(capacity(n)); <span class="comment">//保守扩容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</span><br><span class="line">        put(e.getKey(), e.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过指定键获取值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    Object[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = hash(k, len);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        Object item = tab[i];</span><br><span class="line">        <span class="keyword">if</span> (item == k)</span><br><span class="line">            <span class="keyword">return</span> (V) tab[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        i = nextKeyIndex(i, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="移除节点"><a href="#移除节点" class="headerlink" title="移除节点"></a>移除节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过指定键移除节点</span></span><br><span class="line"><span class="comment"> * 移除节点后会重新散列所有可能冲突的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    Object[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = hash(k, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        Object item = tab[i];</span><br><span class="line">        <span class="keyword">if</span> (item == k) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                V oldValue = (V) tab[i + <span class="number">1</span>];</span><br><span class="line">            tab[i + <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            closeDeletion(i); <span class="comment">//删除节点后重新散列所有可能冲突的节点</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        i = nextKeyIndex(i, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过键值对移除节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">removeMapping</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    Object[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = hash(k, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        Object item = tab[i];</span><br><span class="line">        <span class="keyword">if</span> (item == k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tab[i + <span class="number">1</span>] != value)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            modCount++;</span><br><span class="line">            size--;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            tab[i + <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">            closeDeletion(i);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        i = nextKeyIndex(i, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>IdentityHashMap的数据结构是<code>线性探针表</code></p></li><li><p>IdentityHashMap采用的是<code>引用相等</code>，而HashMap采用的是<code>对象相等</code></p></li><li><p>IdentityHashMap默认容量大小是64，个人认为加载因子是1/3</p></li><li><p>IdentityHashMap的容量大小必须是2的幂次方</p></li><li><p>IdentityHashMap用于序列化或深拷贝、代理场景中，不过即使这么说，我还是没能感受到它的用处</p></li><li><p>IdentityHashMap无序、不可重复、非线程安全</p></li><li><p>IdentityHashMap的键值对允许存放null</p></li><li><p><code>添加节点流程</code>：首先获取索引位置，接着若发现当前位置上不存在节点则直接添加皆可，若发现当前位置上已经存在节点了则比较两者是否相等（采用 k1 == k2的方式），若相等则说明重复进行替换值即可，若不相等说明发生冲突，它会往后查抄偶数索引位置，直到发现偶数索引位置上不存在节点时才进行存储</p></li><li><p><code>扩容机制</code>：在添加元素时判断当前节点个数是否超过了容量的1/3，若超过则以<code>2倍大小</code>进行扩容，扩容时对哈希探针表中的所有节点进行重新散列，扩容结束后从重新走上面的添加节点流程，因为节点的索引位置已经发生变化；最大键值对是 1 &lt;&lt; 29，最小键值对是 4，虽说最大键值对是1 &lt;&lt; 29，但实际上能存储的最大键值对是 1 &lt;&lt; 29 -1，因为它要保留一个null来防止死循环，在程序中它采用的是不断遍历哈希探针表来获取偶数位置上不存在节点的索引，若所有位置上都填充了节点，就会陷入死循环中，所以至少要有这样子的一个null</p></li><li><p><code>删除节点流程</code>：在删除节点后，它会重新散列所有可能冲突的节点。按照上面的添加节点流程中我们知道，两个节点即使发生冲突了也只是找其他的位置进行存储，这和不冲突的情况下进行存储并没有什么区别，所以在删除节点后，它会重新散列所有节点</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>resize</code> <code>put</code> <code>remove</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前沿&quot;&gt;&lt;a href=&quot;#前沿&quot; class=&quot;headerlink&quot; title=&quot;前沿&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前沿&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;我也是第一次认识IdentityHashMap，在工作中从未使用过它，所以对它的使用场景可能并不是很了解，本文也仅仅针对基于&lt;code&gt;JDK1.8&lt;/code&gt;的源码进行探索。&lt;code&gt;IdentityHashMap&lt;/code&gt;的数据结构应该是如图所示：&lt;/p&gt;
&lt;p class=&quot;customize-img&quot;&gt;&lt;img src=&quot;/assets/blogImg/java/identityhashmap/data-structure.png&quot; alt=&quot;IdentityHashMap数据结构&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个数据结构是我在看源码之前看了几篇别人写的文章所了解到的，个人喜欢在看源码对目标有所了解的习惯，紧接着才去深入它。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索HashMap底层实现</title>
    <link href="http://zlia.tech/2019/10/21/explain-hashmap-sourcecode/"/>
    <id>http://zlia.tech/2019/10/21/explain-hashmap-sourcecode/</id>
    <published>2019-10-21T02:32:13.000Z</published>
    <updated>2019-10-31T03:29:26.045Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>探索<code>HashMap</code>底层实现是基于<code>JDK1.8</code>，看代码之前翻了一下别人写的博客我才知道<code>JDK1.7</code>版本的HashMap是由<code>数组 + 链表</code>的数据结构组成，而对于JDK1.8是由<code>数组 + 链表 + 红黑树</code>的数据结构组成，所以我又去了解了什么是二叉树、平衡二叉树、红黑树，为的就是能做个铺垫。既然是由数组、链表、红黑树组成，加上平时我们了解过的一些细节，可以猜到它的数据结构应该是这样子的，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/java/hashmap/hashmap-data-structure.png" alt="HashMap数据结构"></p><p>长的虽然有点丑。下面我们就开始探索它吧，还是先从注释开始看！</p><a id="more"></a><h3 id="阅读注释"><a href="#阅读注释" class="headerlink" title="阅读注释"></a><div><span>阅读注释</span></div></h3><p class="customize-img"><img src="/assets/blogImg/java/hashmap/hashmap-comment-1.png" alt="HashMap注释-1"></p><p>HashMap的每个节点都由一个键值对组成，也就是一个Key对应着一个Value，相当于绑定关系了，这两者都可以为Null。Hashtable的代码我还没有看过，不过这个结论不用质疑。HashMap是<code>无序</code>的，这跟它的实现机制有关。</p><p class="customize-img"><img src="/assets/blogImg/java/hashmap/hashmap-comment-2.png" alt="HashMap注释-2"></p><p>简单来说，迭代所需的时间与遍历数组、链表、红黑树的大小成比例，因为数据有可能存放在链表、红黑树中，它要把所有的数据都遍历出来。</p><p class="customize-img"><img src="/assets/blogImg/java/hashmap/hashmap-comment-3.png" alt="HashMap注释-3"></p><p>当哈希表中元素的填充数量超过加载因子与当前容量的乘积时，就会发生扩容！</p><p class="customize-img"><img src="/assets/blogImg/java/hashmap/hashmap-comment-4.png" alt="HashMap注释-4"></p><p>为什么较高的加载因子会减少空间开销，增加了查找的成本呢？加载因子表示元素填满的程度，在容量不变的情况下，随着加载因子越大，填满的元素就越多，空间利用率变大了。假设容量固定值为16，有以下情况：</p><ul><li><p>A. 加载因子0.75，该数组在不扩容的情况下最多可填充0.75 * 16 = 12。</p></li><li><p>B. 加载因子1，该数组在不扩容的情况下最多可填充1* 16 = 16。</p></li></ul><p>所以我们说空间利用率变大了，同样的，元素多了，查找的成本也就自然增加了。</p><p class="customize-img"><img src="/assets/blogImg/java/hashmap/hashmap-comment-5.png" alt="HashMap注释-5"></p><p>若是知道键值对的数量，可创建具有指定容量大小的HashMap。</p><p class="customize-img"><img src="/assets/blogImg/java/hashmap/hashmap-comment-6.png" alt="HashMap注释-6"></p><p>HashMap属于非线程安全，需要在外部进行控制。</p><p class="customize-img"><img src="/assets/blogImg/java/hashmap/hashmap-comment-7.png" alt="HashMap注释-7"></p><p>Java提供了方法来保证HashMap的线程安全。</p><p class="customize-img"><img src="/assets/blogImg/java/hashmap/hashmap-comment-8.png" alt="HashMap注释-8"></p><p>该说法很ArrayList很像。</p><p class="customize-img"><img src="/assets/blogImg/java/hashmap/hashmap-comment-9.png" alt="HashMap注释-9"></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唯一序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的初始容量，必须是2的幂次方！！！</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 1 &lt;&lt; 4 = 16，为什么不直接写16呢?</span></span><br><span class="line"><span class="comment">     * 我们都知道计算机底层都是用二进制操作的，而如果直接写16的话最终还是要转换成二进制，对于位运算来说，就是直接用二进制进行计算的，所以效率会更高一些</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 为什么是2的幂次方?</span></span><br><span class="line"><span class="comment">     * HashMap的底层是由数组 + 链表 + 红黑树组成的，那么先从数组开始存起，先不管规则如何，想要往数组中存入元素，必须要先知道指定索引</span></span><br><span class="line"><span class="comment">     * 虽然和ArrayList一样都是数组，但对于HashMap添加一个元素来说，并不是按照顺序存入，那将和ArrayList没什么区别了</span></span><br><span class="line"><span class="comment">     * 既然不是按顺序存入，那就是按照一定的规则去计算索引了，当然了，这个规则不能是死的，所以只能拿着传入的值进行一定的规则运算</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 因为HashMap可以存入任意类型的元素，不管是Key还是Value，所以对于任意类型来说都应该可以使用这个规则，也就是说它必须存在于任意类型中，不管是方法还是成员变量，那我们能想到的</span></span><br><span class="line"><span class="comment">     * 也只有Object了，它是所有类型的父类，加上索引的值应该是int类型的，所以它最终采用了hashCode方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 不过你会发现hashCode方法返回的数值是不可预测的，而对于HashMap中的数组来说，索引的取值必须要在0~15之间，所以这个规则还没有结束，必须把hashCode的结果控制在0-15之间</span></span><br><span class="line"><span class="comment">     * 第一个反应想到的对容量大小采用取余运算，没错，是可以的，但是有更好的方法，就像上面一样，为了提高效率采用了位运算，这里我们采用的位运算是&amp;</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 那为什么不用 | 呢？只能说在A | B计算中（A相当于是hashCode，B相当于是容量大小），B没办法对结果产生范围性的控制，比如下面：</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * A:    1000</span></span><br><span class="line"><span class="comment">     *    | </span></span><br><span class="line"><span class="comment">     * B：   0111</span></span><br><span class="line"><span class="comment">     * ----------</span></span><br><span class="line"><span class="comment">     *       1111</span></span><br><span class="line"><span class="comment">     * B的最大值只能取到7，而结果确实15，肯定不行，所以最终采用了&amp;。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 因为索引的最大值只能取到15，所以是 &amp; 15，如果是16，那么就能取到16造成索引越界了，不过它有一些要求（重点来了），细心的同学会发现在构造HashMap时是可以指定其他值，比如13、17，这* 些都不是2的幂次方，我们假设采用13</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   1000         0010</span></span><br><span class="line"><span class="comment">     * &amp;            &amp;</span></span><br><span class="line"><span class="comment">     *   1101         1101</span></span><br><span class="line"><span class="comment">     * -------      -------</span></span><br><span class="line"><span class="comment">     *   0000         0000</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 你可以都计算几个，我们发现，有些索引它没办法取到，就上面的索引为2它取不到，关键就是因为1101（13）中的第三位是0，不管上面的取值（hashCode）如何，它的结果都是0，所以它的值必须要* 是1才可以，才能取到所有的值，所以应该是1111这样子的一种格式，就是最后几位都是1，不能是0和1发生间隔，而我们刚才说了最多只能取到1111（15），这个值是由容量大小 -1 决定的，所以应* 该是capacity -1的结果要是1111的这种格式才可以，我们发现：</span></span><br><span class="line"><span class="comment">     * capacity = 111 + 1 = 1000 = 8</span></span><br><span class="line"><span class="comment">     * capacity = 1111 + 1 = 10000 = 16</span></span><br><span class="line"><span class="comment">     * capacity = 11111 + 1 = 100000 = 32</span></span><br><span class="line"><span class="comment">     * capacity = 111111 + 1 = 1000000 = 64</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 多的就不计算了，这些结果都是2的幂次方，不知道我讲明白了没有...</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * ===========================================================分割线=========================================================================================</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 既然已经解释那么多，还差一个，反正后面还是要解释的，就一起得了...</span></span><br><span class="line"><span class="comment">     * 到目前为止我们得到的结论是：hashCode &amp; (capacity - 1) ，还没有结束...</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 为了更好的说明接下来的问题，我们随便取值一个hashCode来做运算</span></span><br><span class="line"><span class="comment">     * 情况A：</span></span><br><span class="line"><span class="comment">     *      0000 0010 0100 0110 0000 0110 0000 0011</span></span><br><span class="line"><span class="comment">     *   &amp;</span></span><br><span class="line"><span class="comment">     *      0000 0000 0000 0000 0000 0000 0000 1111</span></span><br><span class="line"><span class="comment">     *  ---------------------------------------------</span></span><br><span class="line"><span class="comment">     *      0000 0000 0000 0000 0000 0000 0000 0011</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 看情况A我们可以看出对于hashCode来说，它的后面好几位（从右向左看）基本上没啥用，反正不管是1还是0，结果都是0，排面都是靠低位撑着呢...也就是说索引的结果基本上由低位说了算的，所以* 这样子造成了一个现象，有可能出现高位不同低位相同的两个数计算出的索引结果是一致的！看情况B：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 情况B：</span></span><br><span class="line"><span class="comment">     *      1111 0000 0000 0000 0000 0000 0000 0011</span></span><br><span class="line"><span class="comment">     *   &amp;</span></span><br><span class="line"><span class="comment">     *      0000 0000 0000 0000 0000 0000 0000 1111</span></span><br><span class="line"><span class="comment">     * ----------------------------------------------</span></span><br><span class="line"><span class="comment">     *      0000 0000 0000 0000 0000 0000 0000 0011</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 情况A与情况B的结果是一致的，可是它们的hashCode是不一样的啊，说明了这是两个不同的数，有点问题啊！所以我们必须对这个hashCode在做一次计算，因为要使得高位不同得出的结果应该也要不* 同，故而要拿这个高位来做文章才能做区分，最简单的方式是拿hashCode的高位与hashCode自身在做一次计算，在HashMap中16位我们称之位高位（从左向右开始数），所以是拿这个16位在做一次运* 算，同样是采用位运算，有可能是&amp;、|、^（异或）</span></span><br><span class="line"><span class="comment">     * 上面我们说，有可能出现高位不同低位相同的两个数，针对不同的位运算我们采用假设：</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 若是采用位运算&amp;，AB两个数的低位都为0，A的高位为1，B的高位为0，即使在做一次运算，得到的结果还是一样的</span></span><br><span class="line"><span class="comment">     * 若是采用位运算|，AB两个数的低位都为1，A的高位为0，B的高位为1，即使在做一次运算，得到的结果也是一样的</span></span><br><span class="line"><span class="comment">     * 若是采用位运算^，AB两个数的低位都为1，A的高位为0，B的高位为1，结果就不一样了，A的结果为0，B的结果为1，是不是巧合呢</span></span><br><span class="line"><span class="comment">     * 若是采用位运算^，AB两个数的低位都为1，A的高位为1，B的高位为0，结果也是不一样的</span></span><br><span class="line"><span class="comment">     * 若是采用位运算^，AB两个数的低位都为0，A的高位为0，B的高位为1，结果也是不一样的</span></span><br><span class="line"><span class="comment">     * 若是采用位运算^，AB两个数的低位都为0，A的高位为1，B的高位为0，结果也是不一样的</span></span><br><span class="line"><span class="comment">     * 已经很明显了，最终采用的位运算是^，所以会经过如下计算：hashCode ^ (hashCode &gt;&gt;&gt; 16)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ==============================================================分割线====================================================================================  </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 上面说的有点多来总结下吧：</span></span><br><span class="line"><span class="comment">     * 1. 为什么HashMap的容量大小必须是2的幂次方：因为在HashMap中采用了位运算&amp;代替了取余运算%，这样做是为了提升效率，不过在替换运算符号的同时也有一个要求，为了能取到区间中的每个数，</span></span><br><span class="line"><span class="comment">     * 比如0-15中的每个数都能取到，也就是说最后几位要是连续的1（01111，从左向右看），不能是0与1发生间隔，而把这个数去 + 1就等于容量大小，你会发现它正是2的幂次方，所以按照我个人的理解来说，就是在将&amp;替换了%后，为了能取到区间中的每* 个索引，必须是2的幂次方，有人将这种做法叫做均匀分布</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. 为什么采用hashCode方法：HashMap能存放任意类型的数据，要想按照HashMap的规则进行运算，在任意类型的数据当中一定存在着这些规则，那就只有Object#hashCode</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. result = hasCode ^ (hashCode &gt;&gt;&gt; 16)目的是什么：为了降低不同的数导致同样的结果（索引），简单来说就是为了降低碰撞，但还是有可能发生碰撞</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 4. result &amp; (capacity - 1)：计算索引的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大容量值，必须是2的幂次方</span></span><br><span class="line"><span class="comment">     * 当通过构造函数传入更高的值时会使用最大容量指来代替</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的加载因子</span></span><br><span class="line"><span class="comment">     * 设置成0.75是对空间与时间的一个权衡（折中），加载因子过大会减少空间开销，增加查找成本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当添加节点后链表的长度超过该数值时会将链表转换为红黑树，提升查询速度，但同时内存使用会增大，因为树节点的大小约是常规节点的两倍</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 为什么是8?</span></span><br><span class="line"><span class="comment">     * 在节点良好分布的情况下，基本不会用到红黑树。而在理想情况下的随机哈希，节点分布遵循泊松分布，链表下的长度达到8已经是非常小的概率，超过8的概率我们认为是几乎不可能发生的事情</span></span><br><span class="line"><span class="comment">     * 不过HashMap还是做了预防措施，当链表的长度达到8时会被转换成红黑树，至于为什么不是7，个人认为8更合适，应该尽可能的提升性能.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当红黑树的节点个数小于该数值时，红黑树将转换回链表</span></span><br><span class="line"><span class="comment">     * 这里有个点很重要，当初我以为红黑树在删除节点后长度就会变小，那应该会按照这个指标来将其变成单向链表结构，可惜不是，红黑树在删除节点前会判断是否次树过小，若过小则转换为链表，若不是则删除节点并进行自我平衡，所以只有在重新散列时* 才会判断该数值！！！！</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 为什么不是7?</span></span><br><span class="line"><span class="comment">     * 若是频繁地添加删除添加删除元素，那么HashMap将在转换中消耗很大的性能，而7的空隙让它有一个很好的缓冲</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当链表的长度大于8时：</span></span><br><span class="line"><span class="comment">     * 若哈希表的容量大于64，则将链表转换成红黑树</span></span><br><span class="line"><span class="comment">     * 若哈希表的容量小于64，数据结构保持不变，对哈希表进行扩容，扩容时原来的节点可能在旧的索引上，有可能在新的索引上（原来的索引 + 旧的容量大小）</span></span><br><span class="line"><span class="comment">     * 至少应该是4 * TREEIFY_THRESHOLD，防止重新散列和树化阈值(TREEIFY_THRESHOLD)产生冲突</span></span><br><span class="line"><span class="comment">     * 在哈希表容量很小的情况下，随着不断的添加节点，链表的长度会越来越大，也会有越来越多的链表，当长度超过一定的阈值之后便需要转换成红黑树，而在扩容时又需要拆解成链表，这些都是需要一定的成本，所以在容量较小的情况下直接选择* 扩容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义加载因子</span></span><br><span class="line"><span class="comment">     * 容量大小不变的情况下，加载因子过大减少空间开销，增加查询成本</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 注意：该属性是可以指定大于1，但是会造成一定的成本，具体可看threshold属性说明，最终是建议不应该超过1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希表</span></span><br><span class="line"><span class="comment">     * 数组结构中包括链表、红黑树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存entrySet方法的返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 键值对的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashMap中结构修改的次数</span></span><br><span class="line"><span class="comment">     * 在上面的翻译中我们已经解释了什么是结构修改</span></span><br><span class="line"><span class="comment">     * 该成员属性是用于检测迭代器的快速失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩容前需要判断的阈值</span></span><br><span class="line"><span class="comment">     * 若超过该值则扩容，若没超过则不需要</span></span><br><span class="line"><span class="comment">     * 该值的计算方式：capacity * load factor</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 注意：该属性是可以超过指定容量大小（capacity），准备来说，应该是加载因子（load factor）可以指定大于1，下面假设是2</span></span><br><span class="line"><span class="comment">     * 相当于指定了容量大小是10，但是会到大于20时才会扩充容量</span></span><br><span class="line"><span class="comment">     * 当填充的元素个数超过10个而小于20个后，那么后续的元素必定会造成碰撞从而形成链表或红黑树，这就为后续的增加/查找造成了一定的成本</span></span><br><span class="line"><span class="comment">     * 所以建议加载因子（load factor）不应该超过1</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 我为什么会想到这个注意点呢，是因为putMapEntries方法中有一段代码：float ft = ((float)s / loadFactor) + 1.0F，这段代码很有意思，可以看具体方法中的说明</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储Key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;K&gt; keySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储Value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Collection&lt;V&gt; values;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap的大部分知识点，包括一些细节方面，其实都在上面的注释中提到了，应该尽可能的去理解它！</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量与加载因子构造哈希表</span></span><br><span class="line"><span class="comment"> * 在上面中我们提到了容量必须是2的幂次方，所以调用tableSizeFor方法来进行调整</span></span><br><span class="line"><span class="comment"> * Float.isNaN：检测是否是数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor 指定加载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量与默认加载因子（0.75）构造哈希表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始容量（16）与默认加载因子（0.75）构造哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定集合添加到哈希表中，采用默认加载因子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h4><h5 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br><span class="line">1319</span><br><span class="line">1320</span><br><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br><span class="line">1345</span><br><span class="line">1346</span><br><span class="line">1347</span><br><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br><span class="line">1366</span><br><span class="line">1367</span><br><span class="line">1368</span><br><span class="line">1369</span><br><span class="line">1370</span><br><span class="line">1371</span><br><span class="line">1372</span><br><span class="line">1373</span><br><span class="line">1374</span><br><span class="line">1375</span><br><span class="line">1376</span><br><span class="line">1377</span><br><span class="line">1378</span><br><span class="line">1379</span><br><span class="line">1380</span><br><span class="line">1381</span><br><span class="line">1382</span><br><span class="line">1383</span><br><span class="line">1384</span><br><span class="line">1385</span><br><span class="line">1386</span><br><span class="line">1387</span><br><span class="line">1388</span><br><span class="line">1389</span><br><span class="line">1390</span><br><span class="line">1391</span><br><span class="line">1392</span><br><span class="line">1393</span><br><span class="line">1394</span><br><span class="line">1395</span><br><span class="line">1396</span><br><span class="line">1397</span><br><span class="line">1398</span><br><span class="line">1399</span><br><span class="line">1400</span><br><span class="line">1401</span><br><span class="line">1402</span><br><span class="line">1403</span><br><span class="line">1404</span><br><span class="line">1405</span><br><span class="line">1406</span><br><span class="line">1407</span><br><span class="line">1408</span><br><span class="line">1409</span><br><span class="line">1410</span><br><span class="line">1411</span><br><span class="line">1412</span><br><span class="line">1413</span><br><span class="line">1414</span><br><span class="line">1415</span><br><span class="line">1416</span><br><span class="line">1417</span><br><span class="line">1418</span><br><span class="line">1419</span><br><span class="line">1420</span><br><span class="line">1421</span><br><span class="line">1422</span><br><span class="line">1423</span><br><span class="line">1424</span><br><span class="line">1425</span><br><span class="line">1426</span><br><span class="line">1427</span><br><span class="line">1428</span><br><span class="line">1429</span><br><span class="line">1430</span><br><span class="line">1431</span><br><span class="line">1432</span><br><span class="line">1433</span><br><span class="line">1434</span><br><span class="line">1435</span><br><span class="line">1436</span><br><span class="line">1437</span><br><span class="line">1438</span><br><span class="line">1439</span><br><span class="line">1440</span><br><span class="line">1441</span><br><span class="line">1442</span><br><span class="line">1443</span><br><span class="line">1444</span><br><span class="line">1445</span><br><span class="line">1446</span><br><span class="line">1447</span><br><span class="line">1448</span><br><span class="line">1449</span><br><span class="line">1450</span><br><span class="line">1451</span><br><span class="line">1452</span><br><span class="line">1453</span><br><span class="line">1454</span><br><span class="line">1455</span><br><span class="line">1456</span><br><span class="line">1457</span><br><span class="line">1458</span><br><span class="line">1459</span><br><span class="line">1460</span><br><span class="line">1461</span><br><span class="line">1462</span><br><span class="line">1463</span><br><span class="line">1464</span><br><span class="line">1465</span><br><span class="line">1466</span><br><span class="line">1467</span><br><span class="line">1468</span><br><span class="line">1469</span><br><span class="line">1470</span><br><span class="line">1471</span><br><span class="line">1472</span><br><span class="line">1473</span><br><span class="line">1474</span><br><span class="line">1475</span><br><span class="line">1476</span><br><span class="line">1477</span><br><span class="line">1478</span><br><span class="line">1479</span><br><span class="line">1480</span><br><span class="line">1481</span><br><span class="line">1482</span><br><span class="line">1483</span><br><span class="line">1484</span><br><span class="line">1485</span><br><span class="line">1486</span><br><span class="line">1487</span><br><span class="line">1488</span><br><span class="line">1489</span><br><span class="line">1490</span><br><span class="line">1491</span><br><span class="line">1492</span><br><span class="line">1493</span><br><span class="line">1494</span><br><span class="line">1495</span><br><span class="line">1496</span><br><span class="line">1497</span><br><span class="line">1498</span><br><span class="line">1499</span><br><span class="line">1500</span><br><span class="line">1501</span><br><span class="line">1502</span><br><span class="line">1503</span><br><span class="line">1504</span><br><span class="line">1505</span><br><span class="line">1506</span><br><span class="line">1507</span><br><span class="line">1508</span><br><span class="line">1509</span><br><span class="line">1510</span><br><span class="line">1511</span><br><span class="line">1512</span><br><span class="line">1513</span><br><span class="line">1514</span><br><span class="line">1515</span><br><span class="line">1516</span><br><span class="line">1517</span><br><span class="line">1518</span><br><span class="line">1519</span><br><span class="line">1520</span><br><span class="line">1521</span><br><span class="line">1522</span><br><span class="line">1523</span><br><span class="line">1524</span><br><span class="line">1525</span><br><span class="line">1526</span><br><span class="line">1527</span><br><span class="line">1528</span><br><span class="line">1529</span><br><span class="line">1530</span><br><span class="line">1531</span><br><span class="line">1532</span><br><span class="line">1533</span><br><span class="line">1534</span><br><span class="line">1535</span><br><span class="line">1536</span><br><span class="line">1537</span><br><span class="line">1538</span><br><span class="line">1539</span><br><span class="line">1540</span><br><span class="line">1541</span><br><span class="line">1542</span><br><span class="line">1543</span><br><span class="line">1544</span><br><span class="line">1545</span><br><span class="line">1546</span><br><span class="line">1547</span><br><span class="line">1548</span><br><span class="line">1549</span><br><span class="line">1550</span><br><span class="line">1551</span><br><span class="line">1552</span><br><span class="line">1553</span><br><span class="line">1554</span><br><span class="line">1555</span><br><span class="line">1556</span><br><span class="line">1557</span><br><span class="line">1558</span><br><span class="line">1559</span><br><span class="line">1560</span><br><span class="line">1561</span><br><span class="line">1562</span><br><span class="line">1563</span><br><span class="line">1564</span><br><span class="line">1565</span><br><span class="line">1566</span><br><span class="line">1567</span><br><span class="line">1568</span><br><span class="line">1569</span><br><span class="line">1570</span><br><span class="line">1571</span><br><span class="line">1572</span><br><span class="line">1573</span><br><span class="line">1574</span><br><span class="line">1575</span><br><span class="line">1576</span><br><span class="line">1577</span><br><span class="line">1578</span><br><span class="line">1579</span><br><span class="line">1580</span><br><span class="line">1581</span><br><span class="line">1582</span><br><span class="line">1583</span><br><span class="line">1584</span><br><span class="line">1585</span><br><span class="line">1586</span><br><span class="line">1587</span><br><span class="line">1588</span><br><span class="line">1589</span><br><span class="line">1590</span><br><span class="line">1591</span><br><span class="line">1592</span><br><span class="line">1593</span><br><span class="line">1594</span><br><span class="line">1595</span><br><span class="line">1596</span><br><span class="line">1597</span><br><span class="line">1598</span><br><span class="line">1599</span><br><span class="line">1600</span><br><span class="line">1601</span><br><span class="line">1602</span><br><span class="line">1603</span><br><span class="line">1604</span><br><span class="line">1605</span><br><span class="line">1606</span><br><span class="line">1607</span><br><span class="line">1608</span><br><span class="line">1609</span><br><span class="line">1610</span><br><span class="line">1611</span><br><span class="line">1612</span><br><span class="line">1613</span><br><span class="line">1614</span><br><span class="line">1615</span><br><span class="line">1616</span><br><span class="line">1617</span><br><span class="line">1618</span><br><span class="line">1619</span><br><span class="line">1620</span><br><span class="line">1621</span><br><span class="line">1622</span><br><span class="line">1623</span><br><span class="line">1624</span><br><span class="line">1625</span><br><span class="line">1626</span><br><span class="line">1627</span><br><span class="line">1628</span><br><span class="line">1629</span><br><span class="line">1630</span><br><span class="line">1631</span><br><span class="line">1632</span><br><span class="line">1633</span><br><span class="line">1634</span><br><span class="line">1635</span><br><span class="line">1636</span><br><span class="line">1637</span><br><span class="line">1638</span><br><span class="line">1639</span><br><span class="line">1640</span><br><span class="line">1641</span><br><span class="line">1642</span><br><span class="line">1643</span><br><span class="line">1644</span><br><span class="line">1645</span><br><span class="line">1646</span><br><span class="line">1647</span><br><span class="line">1648</span><br><span class="line">1649</span><br><span class="line">1650</span><br><span class="line">1651</span><br><span class="line">1652</span><br><span class="line">1653</span><br><span class="line">1654</span><br><span class="line">1655</span><br><span class="line">1656</span><br><span class="line">1657</span><br><span class="line">1658</span><br><span class="line">1659</span><br><span class="line">1660</span><br><span class="line">1661</span><br><span class="line">1662</span><br><span class="line">1663</span><br><span class="line">1664</span><br><span class="line">1665</span><br><span class="line">1666</span><br><span class="line">1667</span><br><span class="line">1668</span><br><span class="line">1669</span><br><span class="line">1670</span><br><span class="line">1671</span><br><span class="line">1672</span><br><span class="line">1673</span><br><span class="line">1674</span><br><span class="line">1675</span><br><span class="line">1676</span><br><span class="line">1677</span><br><span class="line">1678</span><br><span class="line">1679</span><br><span class="line">1680</span><br><span class="line">1681</span><br><span class="line">1682</span><br><span class="line">1683</span><br><span class="line">1684</span><br><span class="line">1685</span><br><span class="line">1686</span><br><span class="line">1687</span><br><span class="line">1688</span><br><span class="line">1689</span><br><span class="line">1690</span><br><span class="line">1691</span><br><span class="line">1692</span><br><span class="line">1693</span><br><span class="line">1694</span><br><span class="line">1695</span><br><span class="line">1696</span><br><span class="line">1697</span><br><span class="line">1698</span><br><span class="line">1699</span><br><span class="line">1700</span><br><span class="line">1701</span><br><span class="line">1702</span><br><span class="line">1703</span><br><span class="line">1704</span><br><span class="line">1705</span><br><span class="line">1706</span><br><span class="line">1707</span><br><span class="line">1708</span><br><span class="line">1709</span><br><span class="line">1710</span><br><span class="line">1711</span><br><span class="line">1712</span><br><span class="line">1713</span><br><span class="line">1714</span><br><span class="line">1715</span><br><span class="line">1716</span><br><span class="line">1717</span><br><span class="line">1718</span><br><span class="line">1719</span><br><span class="line">1720</span><br><span class="line">1721</span><br><span class="line">1722</span><br><span class="line">1723</span><br><span class="line">1724</span><br><span class="line">1725</span><br><span class="line">1726</span><br><span class="line">1727</span><br><span class="line">1728</span><br><span class="line">1729</span><br><span class="line">1730</span><br><span class="line">1731</span><br><span class="line">1732</span><br><span class="line">1733</span><br><span class="line">1734</span><br><span class="line">1735</span><br><span class="line">1736</span><br><span class="line">1737</span><br><span class="line">1738</span><br><span class="line">1739</span><br><span class="line">1740</span><br><span class="line">1741</span><br><span class="line">1742</span><br><span class="line">1743</span><br><span class="line">1744</span><br><span class="line">1745</span><br><span class="line">1746</span><br><span class="line">1747</span><br><span class="line">1748</span><br><span class="line">1749</span><br><span class="line">1750</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定容量大小调整到2的幂次方</span></span><br><span class="line"><span class="comment"> * 具体是调整到比该容量还大的最近2的幂次方</span></span><br><span class="line"><span class="comment"> * cap = 21 最终调整到 32</span></span><br><span class="line"><span class="comment"> * cap = 15 最终调整到 16</span></span><br><span class="line"><span class="comment"> * 若是2的幂次方则结果是原来的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cap 指定容量大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 2的幂次方</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定集合中的元素添加到哈希表中</span></span><br><span class="line"><span class="comment"> * 若哈希表为空，表达式s/loadFactor有可能出现带有小数的情况，比如1.6、1.4这样子的一种格式</span></span><br><span class="line"><span class="comment"> * 而后续的 + 1.0F 和 (int)ft 相当于是对小数点做一个向上取整，以尽可能的保证更大容量</span></span><br><span class="line"><span class="comment"> * 若哈希表不为空，则预先进行扩容一次，若没有预先进行扩容，而是等到后续添加元素达到阈值后才开始扩容，那个时候随着元素的增加扩容所消耗的时间也会增加，简单来说，减少了一定的时间成本</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 总结：</span></span><br><span class="line"><span class="comment"> * 若哈希表已初始化，则采用它自身的容量进行扩容</span></span><br><span class="line"><span class="comment"> * 若哈希表未初始化，则采用集合的容量作为哈希表的容量大小，前提是大于哈希表的容量大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取哈希表中的元素个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希表中的元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断哈希表是否为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希表是否为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定键查找节点</span></span><br><span class="line"><span class="comment"> * HashMap在插入节点时先通过hashCode进行比较，若两者相同在通过equals进行比较，若也相同则认为是重复，会进行相应的覆盖，若不相等则用链表或红黑树进行存储</span></span><br><span class="line"><span class="comment"> * 按照如此的思路，要查找某个节点，则hashCode与equals必须都相等，若有其中一个不相等则继续查找下一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 键的哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定键对应的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定键计算哈希值</span></span><br><span class="line"><span class="comment"> * 至于为什么是这么计算的可参考一开始提到的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断指定类是否实现了Comparable，同时Comparable的泛型是它自身</span></span><br><span class="line"><span class="comment"> * 简单来说就是判断指定类C是否满足`class C implements Comparable&lt;C&gt;`这样子的一种格式，若满足则返回该类的class，否则返回null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 指定类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> x.getClass or null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">        Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;</span><br><span class="line">        <span class="keyword">if</span> ((c = x.getClass()) == String.class) <span class="comment">// bypass checks</span></span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        <span class="keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ts.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((t = ts[i]) <span class="keyword">instanceof</span> ParameterizedType) &amp;&amp;</span><br><span class="line">                    ((p = (ParameterizedType)t).getRawType() ==</span><br><span class="line">                     Comparable.class) &amp;&amp;</span><br><span class="line">                    (as = p.getActualTypeArguments()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    as.length == <span class="number">1</span> &amp;&amp; as[<span class="number">0</span>] == c) <span class="comment">// type arg is c</span></span><br><span class="line">                    <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 若x与kc的类型相同则比较x与k的大小，实际上k与kc的类类型是同一个，简单来说就是在比较k与x的大小，既然是比较，类类型是一样的才有意义</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> kc k的类类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 比较值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 另一个比较值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 比较结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareComparables</span><span class="params">(Class&lt;?&gt; kc, Object k, Object x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x == <span class="keyword">null</span> || x.getClass() != kc ? <span class="number">0</span> :</span><br><span class="line">            ((Comparable)k).compareTo(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否包含指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化哈希表或以两倍的大小进行扩容，扩容后进行重新散列-rehash</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * rehash机制：</span></span><br><span class="line"><span class="comment"> * 若指定索引上存在元素且没有链表或红黑树结构，则在新数组上重新计算索引并填充即可</span></span><br><span class="line"><span class="comment"> * 若指定索引上存在元素且结构是链表，将链表分成高低位两条链表并往新数组中填充，高位链表会存储在新索引上（原索引 + 旧容量大小），低位链表存储在原索引上</span></span><br><span class="line"><span class="comment"> * 若指定索引上存在元素且结构是红黑树，将红黑树分成高低位两棵树，低位这棵树中的长度若超过8，在判断高位那棵树是否存在，若不存在说明低位已经树形化过，若存在说明结构已经修改，低位需要重新树形化，若低位这棵树的长度不超过8则将这棵树转换* 成单向链表的结构，同理对于处理高位这棵树也是如此判断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length; <span class="comment">//旧容量</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold; <span class="comment">//旧阈值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>; <span class="comment">//新容量与新阈值</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123; <span class="comment">//旧容量超过最大容量时</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY) <span class="comment">//新容量是旧容量的两倍大小</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">//新阈值是旧阈值的两倍大小</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">//threshold大于0说明采用了自定义的初始容量大小，而一开始threshold存放了初始容量的大小</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">//threshold小于0说明采用默认初始容量大小与加载因子</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123; <span class="comment">//只有在采用自定义初始容量大小的情况下才会进入到该语句中</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap]; <span class="comment">//使用新容量创建新数组以便进行扩容</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>) <span class="comment">//哈希表指定索引上只有一个元素，也就是说该位置上不存在链表或者红黑树之类的数据结构</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e; <span class="comment">//将该位置上的元素按照新容量重新散列，也就是在新数组中重新计算索引并填充，至于为什么是这么计算的，最上面应该提到了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) <span class="comment">//哈希表指定索引上是红黑树，红黑树将自身拆解成高低位两棵树，具体可参见split方法</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; </span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 哈希表指定索引上是一条链表，根据哈希值将一条链表上的节点分成高位、低位两部分组成的两条链表（分组），将高低位两条链条填充到新数组中，高位填充到新索引（原索引 + 旧容量大小）处，而低位的索引保持不变</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * 首先应该明白oldCap是2的幂次方，它的二进制应该是0000 0000 0000 0000 0000 0000 0000 1000 这样子的一种格式</span></span><br><span class="line"><span class="comment">                         * e.hash &amp; oldCap：将结果大于0的节点构成一组链表，既然是链表就有头部节点与尾部节点，所以这就对应了上面的hiHead、hiTail，我们称作高位；同样的将结果小于0</span></span><br><span class="line"><span class="comment">                         * 的节点构成另外一组链表，对应着loHead、loTail，我们称作低位</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 为什么在新的哈希表中索引只可能出现在旧索引处或旧索引 + 旧容量大小处</span></span><br><span class="line"><span class="comment">                     * 首先索引的计算方式是：e.hash &amp; (capacity-1)，方便理解我们直接举例</span></span><br><span class="line"><span class="comment">                     * oldCapacity：16  newCapacity：32   node1：0000 0000 0000 0000 0000 1111 0000 1010  node2：0000 0000 0000 0000 0000 1111 0001 1010</span></span><br><span class="line"><span class="comment">                     *         node1 &amp; (oldCapacity -1)                                           node2 &amp; (oldCapacity -1)</span></span><br><span class="line"><span class="comment">                     * </span></span><br><span class="line"><span class="comment">                     *    0000 0000 0000 0000 0000 1111 0000 1010                        0000 0000 0000 0000 0000 1111 0001 1010     </span></span><br><span class="line"><span class="comment">                     * &amp;  0000 0000 0000 0000 0000 0000 0000 1111                   &amp;    0000 0000 0000 0000 0000 0000 0000 1111</span></span><br><span class="line"><span class="comment">                     * --------------------------------------------                    ------------------------------------------</span></span><br><span class="line"><span class="comment">                     *    0000 0000 0000 0000 0000 0000 0000 1010                        0000 0000 0000 0000 0000 0000 0000 1010</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     *         node1 &amp; (newCapacity -1)                                           node2 &amp; (newCapacity -1)</span></span><br><span class="line"><span class="comment">                     * </span></span><br><span class="line"><span class="comment">                     *    0000 0000 0000 0000 0000 1111 0000 1010                        0000 0000 0000 0000 0000 1111 0001 1010     </span></span><br><span class="line"><span class="comment">                     * &amp;  0000 0000 0000 0000 0000 0000 0001 1111                   &amp;    0000 0000 0000 0000 0000 0000 0001 1111</span></span><br><span class="line"><span class="comment">                     * --------------------------------------------                    ------------------------------------------</span></span><br><span class="line"><span class="comment">                     *    0000 0000 0000 0000 0000 0000 0000 1010                        0000 0000 0000 0000 0000 0000 0001 1010</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * 在旧容量当中索引取决于最后的4位，而在新容量当中索引取决于最后的5位，旧容量与新容量相比最大的差别在于倒数第5位上，而能造成它们索引不同的情况就要看hash值的倒数第5位上是否是1</span></span><br><span class="line"><span class="comment">                     * 若不是1，&amp;完之后结果自然为0，此时的新容量下的索引与旧容量下的索引是一致的；若是1，&amp;完之后结果自然是1，而正好该位置上是旧容量的大小（倒数第5位），如果转换成十进制的话，此时新容量下的索引是旧容量下的索引 +  * 旧容量大小，所以我们可以得出在新容量下的索引只可能出现在这两种情况下。而在计算当中采用 e.hash &amp; oldCap就是在判断倒数第5位是否是1，若是1则索引是旧容量下的索引 + 旧容量大小，若不是1，则还是原来的索引</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定索引上的单向链表结构转成红黑树 + 双向链表</span></span><br><span class="line"><span class="comment"> * 链表长度不仅要超过8，同时哈希表的长度要超过64，否则直接进行扩容</span></span><br><span class="line"><span class="comment"> * 为什么还要采用双向链表呢?</span></span><br><span class="line"><span class="comment"> * 因为在转成红黑树后需要将根节点移动到链表的头部，这就需要更改链表节点之间的关系，而单向链表中是不知道上一个节点是谁，若想知道的话就还需要从头遍历，所以采用双向链表</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tab 新数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 哈希值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123; <span class="comment">//将链表转成双向链表</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>); <span class="comment">//将节点信息变成红黑树节点</span></span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab); <span class="comment">//将双向链表转成红黑树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将节点信息转换成红黑树节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> next 下一个节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 红黑树节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 转换成普通的节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> next 下一个节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 普通节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表树形化</span></span><br><span class="line"><span class="comment"> * 单向链表 -&gt; 双向链表 + 红黑树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tab 哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="comment">//若根节点不存在则进行设置</span></span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            root = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123; <span class="comment">//存在根节点则要进行左右子树的比较来选择最终的存储点</span></span><br><span class="line">                <span class="keyword">int</span> dir, ph;</span><br><span class="line">                K pk = p.key;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h) <span class="comment">//通过比较hash值，此时说明x节点小于根节点，故应该在左子树</span></span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h) <span class="comment">//右子树上</span></span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp; <span class="comment">//若当前节点与另外一个节点的hash相等的话，就比较键值，若键值也相同的话就比较类名</span></span><br><span class="line">                            (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                            (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p; <span class="comment">//xp是p节点的父节点</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123; <span class="comment">//查找到叶子节点后说明后续已经没有节点了，可以进行插入了</span></span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    root = balanceInsertion(root, x); <span class="comment">//插入后仍然需要维持红黑树的平衡，通过左右旋转的方式来维持平衡</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    moveRootToFront(tab, root); <span class="comment">//将根节点移动到链表头部</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先比较两个对象的类名是否相等，若相等则比较两个对象的哈希值大小并返回结果，若不相等则返回结果</span></span><br><span class="line"><span class="comment"> * 若对象为空，则哈希值等于0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> b 另一个对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 比较结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tieBreakOrder</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span> ||</span><br><span class="line">        (d = a.getClass().getName().</span><br><span class="line">            compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">        d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span><br><span class="line">                -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树中插入节点后维持平衡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 插入节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * xp = x.parent    x的父节点</span></span><br><span class="line"><span class="comment">        * xpp = x.parent.parent x的爷爷节点</span></span><br><span class="line"><span class="comment">        * xppl = x.parent.parent.left  x的爷爷节点的左子树</span></span><br><span class="line"><span class="comment">        * xppr = x.parent.parent.right  x的爷爷节点的右子树</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    x.red = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123; <span class="comment">//1 x.parent == null 说明是根节点，将其变成黑色即可</span></span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>) <span class="comment">//2 xp = x.parent 说明x的父节点是黑色，不需要任何的操作</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123; <span class="comment">//3 x的父节点在x的爷爷节点的左子树上</span></span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123; <span class="comment">//4 x的父节点是红色，叔叔节点也是红色</span></span><br><span class="line">                xppr.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == xp.right) &#123; <span class="comment">//5 X的父节点在X的爷爷节点的左子树上，X在X的父节点的右子树上</span></span><br><span class="line">                    root = rotateLeft(root, x = xp);<span class="comment">//注意此时的x变成了原来x的父节点</span></span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123; <span class="comment">//6 X的父节点在X的爷爷节点的左子树上，X在X的父节点的左子树上</span></span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateRight(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//7 X的父节点在X的爷爷节点的右子树上</span></span><br><span class="line">            <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123; <span class="comment">//8 x的父节点是红色，叔叔节点也是红色</span></span><br><span class="line">                xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123; <span class="comment">//9 x的父节点在X的爷爷节点的右子树上，X在X的父节点的左子树上</span></span><br><span class="line">                    root = rotateRight(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123; <span class="comment">//10 x的父节点在X的爷爷节点的右子树上，X在X的父节点的右子树上</span></span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树中指定节点进行左旋</span></span><br><span class="line"><span class="comment"> * 过多的算法就不讨论了，可以参考红黑树、AVL树的文章</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 指定节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * r = p.right 当前节点的右子树</span></span><br><span class="line"><span class="comment">     * rl = r.left 当前节点的右子树的左子树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>)</span><br><span class="line">            rl.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">            (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">            pp.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = r;</span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树中指定节点进行右旋</span></span><br><span class="line"><span class="comment"> * 过多的算法就不讨论了，可以参考红黑树、AVL树的文章</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 指定节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (l = p.left) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="keyword">null</span>)</span><br><span class="line">            lr.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">            (root = l).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)</span><br><span class="line">            pp.right = l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.left = l;</span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将根节点移动到链表的头部</span></span><br><span class="line"><span class="comment"> * 看到这里我发现，它不仅保留了双向链表同时增加了红黑树，所以在查找的时候应该是使用的红黑树结构</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tab 哈希表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; tab != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; root.hash;</span><br><span class="line">        TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">        <span class="keyword">if</span> (root != first) &#123;</span><br><span class="line">            Node&lt;K,V&gt; rn;</span><br><span class="line">            tab[index] = root;</span><br><span class="line">            TreeNode&lt;K,V&gt; rp = root.prev;</span><br><span class="line">            <span class="keyword">if</span> ((rn = root.next) != <span class="keyword">null</span>)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)rn).prev = rp;</span><br><span class="line">            <span class="keyword">if</span> (rp != <span class="keyword">null</span>)</span><br><span class="line">                rp.next = rn;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                first.prev = root;</span><br><span class="line">            root.next = first;</span><br><span class="line">            root.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前节点作为查找的起始节点，查找其所有子节点中是否有匹配到指定节点，匹配必须是hash相同、equals相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h 哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 指定节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> kc 比较器的泛型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">        TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h) <span class="comment">//当前节点的hash大于指定节点的hash，后续应该从左子树进行下一轮比较</span></span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h) <span class="comment">//当前节点的hash小于指定节点的hash，后续应该从右子树进行下一轮比较</span></span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk))) <span class="comment">//当前节点的hash与指定节点的hash相同，同时equals也相等</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//执行到这里说明当前节点的hash与指定节点的hash相同，但是equals不相等，因为接下来不知道该从左子树还是右子树开始查找，所以要先判断是否存在左右子树</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>) <span class="comment">//若左子树为空，那只能从右子树开始进行下一轮比较</span></span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>) <span class="comment">// 若右子树为空，那只能从左子树开始进行下一轮比较</span></span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                    (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                    (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>) </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                * 若左右子树都不为空，那就必须定义一种规则了，通过comparable方法来比较key的大小</span></span><br><span class="line"><span class="comment">                * 首先得先检测是否实现了comparable才可以进行比较-comparableClassFor</span></span><br><span class="line"><span class="comment">                * 接着还得检测是否类型相同，否则也不具备可比性</span></span><br><span class="line"><span class="comment">                * 若满足以上两点则返回比较结果</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>) <span class="comment">//执行到这里说明无法通过comparable进行比较或者key在比较之后还是相等，只能先尝试从右子树开始查找</span></span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">//若右子树递归后还是未找到，那么就从左子树开始查找</span></span><br><span class="line">            p = pl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//最后未匹配的话就返回null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 将红黑树拆解成高低的两棵树，并根据判断来选择是转换成单向链表还是重新树形化</span></span><br><span class="line"><span class="comment"> * 若低位这棵树的长度不超过6，则将其转换成单向链表，同理高位这棵树也是这么判断的</span></span><br><span class="line"><span class="comment"> * 若低位这棵树的长度超过6，且另外一棵树高位不存在，说明红黑树并未将其拆解成两棵树，低位这棵树的结构仍是不变，故而不需要进行重新树形化，而若高位这棵树存在，则需要重新树形化，因为结构已经发生变化</span></span><br><span class="line"><span class="comment"> * 同理，高位也是如此判断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tab 新的哈希表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bit 旧的哈希表长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123; <span class="comment">//尝试将红黑树拆解成高低位的两棵树，至少何为高低位可参考上面的解释</span></span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">        e.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)  <span class="comment">//低位这棵树的长度小于链表的阈值则转换成链表结构</span></span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">//若hiHead为空，说明红黑树并未拆解成高低位两棵树，低位已经被树形化过了不需要重新树形化，若hiHead不为空，说明红黑树已经拆解成高低位两棵树，结构已经发生变化，低位需要重新树形化</span></span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树转换单向链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 链表的头部节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">        Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">            hd = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tl.next = p;</span><br><span class="line">        tl = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在哈希表中通过指定键移除节点</span></span><br><span class="line"><span class="comment"> * 返回值是null表示不存在移除的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定value，通过hash与equals找到节点后还要根据matchValue来判断是否需要判断value值相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> matchValue 标识是否需要判断value是否相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> movable 标识移除节点后是否需要移动其他节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 移除的节点或null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value, <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">//当前节点刚好是要移除的节点，链表的头部或红黑树的根节点</span></span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123; <span class="comment">//走到这里说明头部节点/根节点为匹配上，获取它的下一个节点，若有说明它的结构可能是红黑树或链表，若没有说明不存在移除的节点</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">//判断当前节点是否是红黑树结构</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);  <span class="comment">//从红黑树中查找节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123; <span class="comment">//从链表中查找节点</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e; <span class="comment">// 把当前节点p指向e，这一步是让p存储的永远下一次循环里e的父节点，如果下一次e匹配上了，那么p就是node的父节点</span></span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value || <span class="comment">//matchValue标识在找到节点后是否需要判断value值是否相等</span></span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode) <span class="comment">//从红黑树中移除节点</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p) <span class="comment">//说明头部节点刚好是要移除的节点，直接将它的下一个节点填充到哈希表中</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 说明链表中找到移除的节点，p是node的父节点，由于要删除node，所有只需要把p的下一个节点指向到node的下一个节点即可把node从链表中删除了</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在红黑树中通过指定键查找节点</span></span><br><span class="line"><span class="comment"> * 从根节点开始查找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h 哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树中移除当前节点</span></span><br><span class="line"><span class="comment"> * 调用该方法前当前节点必须存在</span></span><br><span class="line"><span class="comment"> * 作者说该方法的代码比典型的红黑删除代码更为混乱，因为红黑树在删除中会通过交换值的方式来删除，而在红黑树中还维护了一个双向链表，若是直接通过交换值会对双向链表中节点之间的关系造成错误，因此它采用了另外一种方式-交换树链接</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 交换树链接：当前节点与当前节点的右子树的最左节点进行交换，包括parent、left、right节点的关系都发生交换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tab 新的哈希表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> movable 标识移除节点后是否需要移动其他节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始处理链表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">    TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl; <span class="comment">//first、root：根节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev; <span class="comment">//succ：当前节点的下一个节点   pred：当前节点的上一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>) <span class="comment">//说明当前节点是根节点，直接将它的下一个节点作为根节点</span></span><br><span class="line">        tab[index] = first = succ;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//说明当前节点是某一个节点，移除当前节点时更改当前节点的上下节点的关系</span></span><br><span class="line">        pred.next = succ;</span><br><span class="line">    <span class="keyword">if</span> (succ != <span class="keyword">null</span>)</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span>) <span class="comment">//走到这里说明当前节点的下一个节点为空，即表明已经没有节点了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.parent != <span class="keyword">null</span>) </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * moveRootToFront是用来维持红黑树的根节点即为链表的头部，但是在该方法在调用moveRootToFront时会进行判断，也就是它可能不会被调用到，那么会造成红黑的根节点与链表的头部节点不一致</span></span><br><span class="line"><span class="comment">     * 这里获取的root指向的是链表的头部节点，并不是红黑树的根节点，故而还要往上查找根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        root = root.root();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.right == <span class="keyword">null</span> ||</span><br><span class="line">        (rl = root.left) == <span class="keyword">null</span> || rl.left == <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 通过root节点来判断此红黑树是否太小, 如果是则调用untreeify方法转为链表节点并返回，转链表后就无需再进行下面的红黑树处理，这比维持红黑树的平衡来说简单多了</span></span><br><span class="line"><span class="comment">         * 因为在删除节点后红黑树需要维持平衡，有可能根节点会发生变化，也有可能被置空（根节点与删除节点之间是父子节点的关系导致），而又由于没有调用moveRootToFront来更新根节点，导致下次在获取根节点时可能获取到的为空</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结束处理链表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开始处理红黑树</span></span><br><span class="line"></span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>, pl = left, pr = right, replacement; <span class="comment">//p：当前节点  pl：当前节点的左子树    pr：当前节点的右子树</span></span><br><span class="line">    <span class="comment">//1. 当前节点有两个子节点的情况下</span></span><br><span class="line">    <span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">        <span class="keyword">while</span> ((sl = s.left) != <span class="keyword">null</span>) <span class="comment">//找到当前节点的右子树的最左节点，即为s</span></span><br><span class="line">            s = sl;</span><br><span class="line">        <span class="keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="comment">//交换s与p的颜色，也就是交换当前节点与最左节点的颜色</span></span><br><span class="line">        TreeNode&lt;K,V&gt; sr = s.right;  <span class="comment">//最左节点的右子树，即为sr</span></span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;  <span class="comment">//当前节点的父节点，即为pp</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一次调整和第二次调整：将当前节点和最左节点进行了位置调换</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一次调整</span></span><br><span class="line">        <span class="keyword">if</span> (s == pr) &#123;  <span class="comment">//如果当前节点的右节点即为最左节点，则将当前节点的父节点赋值为最左节点，将最左节点的右节点赋值为当前节点</span></span><br><span class="line">            p.parent = s;</span><br><span class="line">            s.right = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; sp = s.parent; <span class="comment">//最左节点的父节点，即为sp</span></span><br><span class="line">            <span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123; <span class="comment">//将当前节点的父节点变成最左节点的父节点</span></span><br><span class="line">                <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                    sp.left = p; <span class="comment">//最左节点应该是在左子树上，这边的代码应该是会走进去，而不会走到else中；将最左节点的父节点的左子树变成当前节点</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sp.right = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>) <span class="comment">//最左节点的左子树必定为null，但有可能还有右子树，故而将它的右子树变成当前节点的右子树</span></span><br><span class="line">                pr.parent = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二次调整</span></span><br><span class="line">        p.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>)</span><br><span class="line">            sr.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>)</span><br><span class="line">            pl.parent = s;</span><br><span class="line">        <span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>)</span><br><span class="line">            root = s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = s;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = s;</span><br><span class="line">        <span class="keyword">if</span> (sr != <span class="keyword">null</span>) <span class="comment">//若最左节点的右子树不为空，则赋值replacement为最左节点的右子树</span></span><br><span class="line">            replacement = sr;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            replacement = p; <span class="comment">//若最左节点的右子树为空，则赋值replacement为当前节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 当前节点只有一个子节点且是左子树，replacement赋值当前节点的左子树</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)</span><br><span class="line">        replacement = pl;</span><br><span class="line">    <span class="comment">//3. 当前节点只有一个子节点且是右子树，replacement赋值为当前节点的右子树</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)</span><br><span class="line">        replacement = pr;</span><br><span class="line">    <span class="comment">//4. 当前节点无子节点，即本身是个叶子节点，replacement赋值为当前节点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        replacement = p;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第三次调整：使用replacement节点替换掉p节点的位置，将p节点移除</span></span><br><span class="line">    <span class="keyword">if</span> (replacement != p) &#123; <span class="comment">//这里说明当前节点不是叶子节点，直接用replacement代替当前节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent; <span class="comment">//获取当前节点的父节点</span></span><br><span class="line">        <span class="keyword">if</span> (pp == <span class="keyword">null</span>) <span class="comment">//说明当前节点是根节点</span></span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left) <span class="comment">//说明当前节点在父节点的左子树上</span></span><br><span class="line">            pp.left = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = replacement; <span class="comment">//说明当前节点在父节点的右子树上</span></span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>; <span class="comment">//当前节点已经被完整的替换为replacement, 将当前节点清空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若当前节点的颜色是红色，可以直接删除，因为删除一个红色并不会影响红黑树的平衡，否则需要进行红黑树的平衡调整，因为删除黑色会导致黑色数目不一致</span></span><br><span class="line">    TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">//说明当前节点是叶子节点，也就是说replacement是需要删除的节点，直接将replacement的关系清空即可</span></span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        p.parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                pp.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                pp.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (movable) <span class="comment">//判断是否将红黑树的根节点移动到链表的头部</span></span><br><span class="line">        moveRootToFront(tab, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调整红黑树的平衡</span></span><br><span class="line"><span class="comment"> * 该方法可以说是HashMap中最复杂的部分了，不过我认为它是跟算法有些关系，对于源码中的算法个人认为只要你清楚它在做什么即可，毕竟你的算法基本并不怎样，所以这里就不做深入研究了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 当前节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceDeletion</span><span class="params">(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * x：当前节点</span></span><br><span class="line"><span class="comment">     * xp：当前节点的父节点</span></span><br><span class="line"><span class="comment">     * xpl：当前节点的父节点的左子树</span></span><br><span class="line"><span class="comment">     * xpr：当前节点的父节点的右子树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpl, xpr;;)  &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span> || x == root)  <span class="comment">//当前节点是根节点的情况</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123; <span class="comment">//当前节点是根节点，染成黑色，直接返回，因为调整过后，root并不一定指向删除操作过后的根节点，如果之前删除的是root节点，则x将成为新的根节点）</span></span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x.red) &#123; <span class="comment">//如果x为红色，则无需调整</span></span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((xpl = xp.left) == x) &#123; <span class="comment">//当前节点为其父节点的左孩子</span></span><br><span class="line">            <span class="keyword">if</span> ((xpr = xp.right) != <span class="keyword">null</span> &amp;&amp; xpr.red) &#123; <span class="comment">//如果它有红色的兄弟节点xpr，那么它的父亲节点xp一定是黑色节点</span></span><br><span class="line">                xpr.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">true</span>;</span><br><span class="line">                root = rotateLeft(root, xp);</span><br><span class="line">                xpr = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果xpr为空，则向上继续调整，将x的父节点xp作为新的x继续循环</span></span><br><span class="line">            <span class="keyword">if</span> (xpr == <span class="keyword">null</span>)</span><br><span class="line">                x = xp;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</span><br><span class="line">                <span class="keyword">if</span> ((sr == <span class="keyword">null</span> || !sr.red) &amp;&amp;</span><br><span class="line">                    (sl == <span class="keyword">null</span> || !sl.red)) &#123; <span class="comment">//若sl和sr都为黑色或者不存在，即xpr没有红色孩子，则将xpr染红</span></span><br><span class="line">                    xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                    x = xp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sr == <span class="keyword">null</span> || !sr.red) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (sl != <span class="keyword">null</span>)</span><br><span class="line">                            sl.red = <span class="keyword">false</span>;</span><br><span class="line">                        xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateRight(root, xpr);</span><br><span class="line">                        xpr = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                            <span class="keyword">null</span> : xp.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpr.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                        <span class="keyword">if</span> ((sr = xpr.right) != <span class="keyword">null</span>)</span><br><span class="line">                            sr.red = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xp.red = <span class="keyword">false</span>;</span><br><span class="line">                        root = rotateLeft(root, xp);</span><br><span class="line">                    &#125;</span><br><span class="line">                    x = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// symmetric</span></span><br><span class="line">            <span class="keyword">if</span> (xpl != <span class="keyword">null</span> &amp;&amp; xpl.red) &#123;</span><br><span class="line">                xpl.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">true</span>;</span><br><span class="line">                root = rotateRight(root, xp);</span><br><span class="line">                xpl = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (xpl == <span class="keyword">null</span>)</span><br><span class="line">                x = xp;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;</span><br><span class="line">                <span class="keyword">if</span> ((sl == <span class="keyword">null</span> || !sl.red) &amp;&amp;</span><br><span class="line">                    (sr == <span class="keyword">null</span> || !sr.red)) &#123;</span><br><span class="line">                    xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                    x = xp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sl == <span class="keyword">null</span> || !sl.red) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                            sr.red = <span class="keyword">false</span>;</span><br><span class="line">                        xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpl);</span><br><span class="line">                        xpl = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                            <span class="keyword">null</span> : xp.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xpl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpl.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                        <span class="keyword">if</span> ((sl = xpl.left) != <span class="keyword">null</span>)</span><br><span class="line">                            sl.red = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xp.red = <span class="keyword">false</span>;</span><br><span class="line">                        root = rotateRight(root, xp);</span><br><span class="line">                    &#125;</span><br><span class="line">                    x = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表中是否包含指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                    (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有键的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有键的Set集合 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Set&lt;K&gt; ks = keySet;</span><br><span class="line">    <span class="keyword">if</span> (ks == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ks = <span class="keyword">new</span> KeySet();</span><br><span class="line">        keySet = ks;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含哈希表中所有键的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取哈希表的大小，共存储了多少节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 哈希表的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空哈希表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取包含所有键的迭代器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 包含所有键的迭代器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希表中是否包含指定键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 指定键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否包含指定键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsKey(o); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据指定键移除节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取分割迭代器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;K&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KeySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历所有键并执行指定动作</span></span><br><span class="line"><span class="comment">     * 遍历过程中不允许HashMap调用任何会修改结构的方法，否则最后会抛出异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> action 指定动作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有值的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有值的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Collection&lt;V&gt; vs = values;</span><br><span class="line">    <span class="keyword">if</span> (vs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        vs = <span class="keyword">new</span> Values();</span><br><span class="line">        values = vs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含所有值的对象</span></span><br><span class="line"><span class="comment"> * 和上面的集合类似，就不做介绍了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Values</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ValueIterator(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsValue(o); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;V&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ValueSpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e.value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有键值对的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有键值对的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> EntrySet()) : es;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含所有键值对的集合</span></span><br><span class="line"><span class="comment"> * 和上面的代码大同小异，不讲解了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">        Object key = e.getKey();</span><br><span class="line">        Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class="line">        <span class="keyword">return</span> candidate != <span class="keyword">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">            Object key = e.getKey();</span><br><span class="line">            Object value = e.getValue();</span><br><span class="line">            <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>; <span class="comment">//注意这里，倒数第二个参数matchValue为true，说明删除的时候还要比较value值是否相同</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EntrySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过指定键获取节点并替换值</span></span><br><span class="line"><span class="comment"> * 该方法会比较旧值是否与获取到的节点的值相同，只有相同的情况下才会替换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> oldValue 旧值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newValue 新值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否替换成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e; V v;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        ((v = e.value) == oldValue || (v != <span class="keyword">null</span> &amp;&amp; v.equals(oldValue)))) &#123;</span><br><span class="line">        e.value = newValue;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过指定键获取节点并替换值</span></span><br><span class="line"><span class="comment"> * 该方法不会比较值是否相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 新值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧值或null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        V oldValue = e.value;</span><br><span class="line">        e.value = value;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过指定键获取节点并执行指定动作</span></span><br><span class="line"><span class="comment"> * 获取到的节点若不为空同时值不为空，则不会执行指定动作</span></span><br><span class="line"><span class="comment"> * 否则执行指定动作获取新值，若新值为空直接返回，若新值不为空则继续</span></span><br><span class="line"><span class="comment"> * 若是节点不为空，说明是值为空，则用新值代替</span></span><br><span class="line"><span class="comment"> * 若是节点为空，则判断当前位置是否是红黑树结构，若是则采用红黑树的方式新增节点，若不是则采用头插法（将新增的节点插入到链表的头部），同时还要判断链表的长度是否超过8，超过则转换成红黑树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键值、</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mappingFunction 指定动作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧值或执行指定动作后的新值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">computeIfAbsent</span><span class="params">(K key, Function&lt;? <span class="keyword">super</span> K, ? extends V&gt; mappingFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mappingFunction == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; t = <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;K,V&gt; old = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="keyword">null</span> ||</span><br><span class="line">        (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length; <span class="comment">//初始化容量大小或扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                    old = e;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++binCount;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        V oldValue;</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span> &amp;&amp; (oldValue = old.value) != <span class="keyword">null</span>) &#123; <span class="comment">//通过键获取到的节点若不为空同时值不为空，则不会执行指定动作</span></span><br><span class="line">            afterNodeAccess(old);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    V v = mappingFunction.apply(key);</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123; <span class="comment">//走到这里说明节点的值为空，替换成新值</span></span><br><span class="line">        old.value = v;</span><br><span class="line">        afterNodeAccess(old);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t != <span class="keyword">null</span>) <span class="comment">//当前位置的结构是红黑树</span></span><br><span class="line">        t.putTreeVal(<span class="keyword">this</span>, tab, hash, key, v);</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">//采用头插法</span></span><br><span class="line">        tab[i] = newNode(hash, key, v, first);</span><br><span class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    ++size;</span><br><span class="line">    afterNodeInsertion(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过指定键获取节点并执行指定动作</span></span><br><span class="line"><span class="comment"> * 若是节点为空或节点的值为空，则直接返回</span></span><br><span class="line"><span class="comment"> * 若是节点不为空同时值不为空，执行指定动作获取新值，若新值为空则删除当前节点，否则替换当前节点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mappingFunction 指定动作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或执行指定动作后的新值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">computeIfPresent</span><span class="params">(K key, BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (remappingFunction == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Node&lt;K,V&gt; e; V oldValue;</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash, key)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (oldValue = e.value) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        V v = remappingFunction.apply(key, oldValue);</span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = v;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            removeNode(hash, key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过指定键获取节点并执行指定动作</span></span><br><span class="line"><span class="comment"> * 不管节点是否为空，都会执行指定动作获取新址</span></span><br><span class="line"><span class="comment"> * 若节点不为空且新值不为空，则进行替换</span></span><br><span class="line"><span class="comment"> * 若节点不为空且新值为空，则移除当前节点</span></span><br><span class="line"><span class="comment"> * 若节点为空且新值不为空，则新增节点，当前位置是红黑树结构则采用红黑树的新增方式，否则采用头插法来新增节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> remappingFunction 指定动作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 执行指定动作后的新值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(K key, BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (remappingFunction == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; t = <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;K,V&gt; old = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="keyword">null</span> ||</span><br><span class="line">        (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode) <span class="comment">//在红黑树中查找</span></span><br><span class="line">            old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                    old = e;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++binCount;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    V oldValue = (old == <span class="keyword">null</span>) ? <span class="keyword">null</span> : old.value;</span><br><span class="line">    V v = remappingFunction.apply(key, oldValue);</span><br><span class="line">    <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">            old.value = v;</span><br><span class="line">            afterNodeAccess(old);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            removeNode(hash, key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) <span class="comment">//当前位置是红黑树结构</span></span><br><span class="line">            t.putTreeVal(<span class="keyword">this</span>, tab, hash, key, v);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//采用头插法</span></span><br><span class="line">            tab[i] = newNode(hash, key, v, first);</span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        ++size;</span><br><span class="line">        afterNodeInsertion(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过指定键获取节点并执行指定动作</span></span><br><span class="line"><span class="comment"> * 若节点不为空且值不为空，则执行指定动作获取新值</span></span><br><span class="line"><span class="comment"> * 若节点不为空且值为空，则采用默认值（value）作为新值</span></span><br><span class="line"><span class="comment"> * 若新值为空则移除节点，若移除不为空则替换</span></span><br><span class="line"><span class="comment"> * 若节点为空且新值不为空，则新增节点，当前位置是红黑树结构则采用红黑树的新增方式，否则采用头插法来新增节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 默认值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> remappingFunction 指定动作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 执行指定动作后的新值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">merge</span><span class="params">(K key, V value, BiFunction&lt;? <span class="keyword">super</span> V, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (remappingFunction == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; t = <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;K,V&gt; old = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="keyword">null</span> ||</span><br><span class="line">        (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                    old = e;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++binCount;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">        V v;</span><br><span class="line">        <span class="keyword">if</span> (old.value != <span class="keyword">null</span>)</span><br><span class="line">            v = remappingFunction.apply(old.value, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            v = value;</span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">            old.value = v;</span><br><span class="line">            afterNodeAccess(old);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            removeNode(hash, key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">            t.putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[i] = newNode(hash, key, value, first);</span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        ++size;</span><br><span class="line">        afterNodeInsertion(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历哈希表并执行指定动作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action 指定动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> mc = modCount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                action.accept(e.key, e.value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历哈希表并执行指定动作后获取新值，利用新值替换所有节点的旧值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> function 指定动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; function)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">if</span> (function == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> mc = modCount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                e.value = function.apply(e.key, e.value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 浅拷贝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 克隆后的新对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HashMap&lt;K,V&gt; result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = (HashMap&lt;K,V&gt;)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">    result.reinitialize(); <span class="comment">//恢复到初始化</span></span><br><span class="line">    <span class="comment">//恢复到初始化后需要重新设置节点，明明一开始已经设置节点了为什么还要恢复初始化后再设置呢?个人认为是因为某些成员属性需要被恢复到初始化，克隆后的对象有可能会被使用到，不能在与克隆前的对象有所关联，初始化便需要重新设置</span></span><br><span class="line">    result.putMapEntries(<span class="keyword">this</span>, <span class="keyword">false</span>); </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取加载因子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 加载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">float</span> <span class="title">loadFactor</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> loadFactor; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取容量大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (table != <span class="keyword">null</span>) ? table.length :</span><br><span class="line">        (threshold &gt; <span class="number">0</span>) ? threshold :</span><br><span class="line">        DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义序列化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 输出流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> buckets = capacity();</span><br><span class="line">    <span class="comment">// Write out the threshold, loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    s.writeInt(buckets);</span><br><span class="line">    s.writeInt(size);</span><br><span class="line">    internalWriteEntries(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将键值对存储到流中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 输出流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">internalWriteEntries</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                s.writeObject(e.key);</span><br><span class="line">                s.writeObject(e.value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义反序列化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 输入流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    reinitialize();</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                         loadFactor);</span><br><span class="line">    s.readInt();                <span class="comment">// 读取buckets</span></span><br><span class="line">    <span class="keyword">int</span> mappings = s.readInt(); <span class="comment">// 读取size</span></span><br><span class="line">    <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Illegal mappings count: "</span> +</span><br><span class="line">                                         mappings);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123; <span class="comment">// (if zero, use defaults)</span></span><br><span class="line">        <span class="comment">// Size the table using given load factor only if within</span></span><br><span class="line">        <span class="comment">// range of 0.25...4.0</span></span><br><span class="line">        <span class="keyword">float</span> lf = Math.min(Math.max(<span class="number">0.25f</span>, loadFactor), <span class="number">4.0f</span>);</span><br><span class="line">        <span class="keyword">float</span> fc = (<span class="keyword">float</span>)mappings / lf + <span class="number">1.0f</span>; <span class="comment">//向上取整获取初始容量，尽可能的获取到更大的容量以便减少resize的调用</span></span><br><span class="line">        <span class="keyword">int</span> cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                   DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                   (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor((<span class="keyword">int</span>)fc));</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)cap * lf;</span><br><span class="line">        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check Map.Entry[].class since it's the nearest public type to</span></span><br><span class="line">        <span class="comment">// what we're actually creating.</span></span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap);</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[cap];</span><br><span class="line">        table = tab;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                K key = (K) s.readObject();</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                V value = (V) s.readObject();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代器基类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">    <span class="comment">//下一个节点</span></span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">    <span class="comment">//当前节点        </span></span><br><span class="line">    Node&lt;K,V&gt; current;</span><br><span class="line">    <span class="comment">//记录修改次数</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount;</span><br><span class="line">    <span class="comment">//当前位置</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     * 提前准备好第一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HashIterator() &#123;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        Node&lt;K,V&gt;[] t = table;</span><br><span class="line">        current = next = <span class="keyword">null</span>;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否存在下一个节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否存在下一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] t;</span><br><span class="line">        Node&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除当前节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; p = current;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        current = <span class="keyword">null</span>;</span><br><span class="line">        K key = p.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含所有键的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().key; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含所有值的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含所有键值对的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建普通节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将红黑树节点转换成普通节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建红黑树节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">newTreeNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将普通节点节点转换成红黑树节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 恢复到初始状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reinitialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    table = <span class="keyword">null</span>;</span><br><span class="line">    entrySet = <span class="keyword">null</span>;</span><br><span class="line">    keySet = <span class="keyword">null</span>;</span><br><span class="line">    values = <span class="keyword">null</span>;</span><br><span class="line">    modCount = <span class="number">0</span>;</span><br><span class="line">    threshold = <span class="number">0</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问节点后的动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入节点后的动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除节点后的动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        r = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 校验红黑树的基本特性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否是红黑树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">checkInvariants</span><span class="params">(TreeNode&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right,</span><br><span class="line">        tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next;</span><br><span class="line">    <span class="keyword">if</span> (tb != <span class="keyword">null</span> &amp;&amp; tb.next != t)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tn != <span class="keyword">null</span> &amp;&amp; tn.prev != t)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tp != <span class="keyword">null</span> &amp;&amp; t != tp.left &amp;&amp; t != tp.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tl != <span class="keyword">null</span> &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tr != <span class="keyword">null</span> &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (t.red &amp;&amp; tl != <span class="keyword">null</span> &amp;&amp; tl.red &amp;&amp; tr != <span class="keyword">null</span> &amp;&amp; tr.red)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tl != <span class="keyword">null</span> &amp;&amp; !checkInvariants(tl))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tr != <span class="keyword">null</span> &amp;&amp; !checkInvariants(tr))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过键获取对应的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 键对应的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过键获取对应的值</span></span><br><span class="line"><span class="comment"> * 因为哈希表允许存放null,若获取的值为null则采用默认值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> defaultValue 默认值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 键对应的值或默认值 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? defaultValue : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定键值对</span></span><br><span class="line"><span class="comment"> * 与putIfAbsent相比该方法的修改一定会生效，不管值是否为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧值或null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定节点到哈希表中</span></span><br><span class="line"><span class="comment"> * 有可能会发生重复添加节点，若发生重复的话会更新指定节点的最新值，若不重复则添加即可，以下的添加方式大同小异，区别在于红黑树可能要做一些调整来维持红黑树的特性</span></span><br><span class="line"><span class="comment"> * 若索引上不存在任何节点直接添加即可</span></span><br><span class="line"><span class="comment"> * 若索引上已经存在节点且结构是链表，若链表长度不超过8则往链表上添加即可，若超过8则执行树形化操作</span></span><br><span class="line"><span class="comment"> * 若索引上已经存在节点且结构是红黑树，调用红黑树的添加节点方法</span></span><br><span class="line"><span class="comment"> * 返回值是null表示没有重复添加，返回具体值表示发生重复添加</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 旧值或null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent 在键值对存在的情况下发生重复添加是否不允许修改值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict 模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧值或null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length; <span class="comment">//初始化容量大小</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">//指定索引上未存放元素，直接存放即可</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p; <span class="comment">//通过hash与equals来判断是否是重复的节点，若是则先记录下当前节点以便后续替换值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value); <span class="comment">//以红黑树的方式进行添加节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//不重复的节点但在同一个索引处下有两种可能：hash不同、hash相同但equals不相同</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// 当链表长度超过8</span></span><br><span class="line">                        treeifyBin(tab, hash); <span class="comment">//树形化操作</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// 新增节点时存在重复的节点，将该节点更新成最新的值</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold) <span class="comment">//超过阈值时就需要进行扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树中插入节点</span></span><br><span class="line"><span class="comment"> * 插入过程中会判断是否重复插入，从根节点开始查找</span></span><br><span class="line"><span class="comment"> * 若是返回null表示新增了一个节点，若是返回重复的节点则后续会将这个节点的值修改成最新的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map map对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tab 哈希表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h 指定节点的哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 指定节点的键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> v 指定节点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或重复的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h) <span class="comment">//当前节点的hash值大于指定节点的hash，后续应该从左子树开始查找</span></span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h) <span class="comment">//当前节点的hash值小于指定节点的hash，后续应该从右子树开始查找</span></span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk))) <span class="comment">//当前节点的hash值与指定节点的hash值相同、equals也相等，此时的节点就是重复的节点，直接返回即可</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//走到这里说明当前节点的hash值与指定节点的hash值相同，但是equals不相等，而后续不知道该从左子树还是右子树开始查找，故而要指定具体规则，通过comparable来比较当前节点的键与指定节点的键</span></span><br><span class="line">        <span class="comment">//但前提是要先检测是否实现了comparable才能比较</span></span><br><span class="line">        <span class="comment">//继而还要检测两个键值的类型是否相同，否则也不具备可比性</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                    (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                * 走到这里的话说明不具备比较器或者比较之后还是相等或者两个键值的类型不同，那么还是无法决定是要从左子树还是右子树开始查找，所以没办法只能先尝试查抄左子树在查找右子树，个个去尝试下</span></span><br><span class="line"><span class="comment">                * searched：标识已经遍历过当前节点的所有子节点，包括子孙节点，为false说明还没有过，那么就递归遍历对比，看是否能够查找到equals相等的节点，如果查找到了，也就是查找到了重复节点，直接返回即可</span></span><br><span class="line"><span class="comment">                * 如果查找不到，说明应该新增一个节点</span></span><br><span class="line"><span class="comment">                * 在查找过后就修改此值，标识已经遍历过了后续就不用再遍历了</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 不知道查找左子树还是右子树的情况下，只能一个一个去尝试了</span></span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//走到这里说明遍历了整个红黑树都没有找到键值相等的节点，说明该新增一个节点了，那就要思考要新增到左子树上还是右子树上呢?</span></span><br><span class="line">            <span class="comment">//而该方法就是决定胜负的那个方法，必须要抉择出是左子树还是右子树</span></span><br><span class="line">            <span class="comment">//先比较键的类名是否相等，若相等则比较哈希值并返回结果，若不相等则返回结果，这样子就能决定是新增到左子树还是右子树上</span></span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//走到这里说明要新增一个节点，而新增一个节点应该先找到叶子节点才能实现最后的插入，找到叶子节点并插入后就是调整节点之间的关系，比较容易理解</span></span><br><span class="line">        <span class="comment">//若dir小于或等于0且当前节点的左子树是否为空，若不为空则继续查找，若为空则说明新增的节点可以作为当前节点的左子树</span></span><br><span class="line">        <span class="comment">//若dir大于0且当前节点的右子树是否为空，若不为空则继续查找，若为空则说明新增的节点可以作为当前节点的右子树</span></span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">            TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);<span class="comment">//创建一个新的红黑树节点</span></span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x;</span><br><span class="line">            xp.next = x;</span><br><span class="line">            x.parent = x.prev = xp;</span><br><span class="line">            <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">            moveRootToFront(tab, balanceInsertion(root, x));<span class="comment">//新增节点后有可能会导致红黑树失去平衡、根节点的变化，故要做调整以及更新根节点到链表的头部</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量添加节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    putMapEntries(m, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定键值对</span></span><br><span class="line"><span class="comment"> * 与put相比该方法的修改只有在值为空的情况下才会生效</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧值或null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="移除节点"><a href="#移除节点" class="headerlink" title="移除节点"></a>移除节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过指定键移除节点</span></span><br><span class="line"><span class="comment"> * matchVaue = false，故移除过程中不会比较值是否相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 移除节点的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过指定键移除节点</span></span><br><span class="line"><span class="comment"> * matchVaue = true，故移除过程中还会比较值是否相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>e.hash &amp; oldCap：其结果不为0个人称之为高位，等于0个人称之为低位。实际上它是在判断新容量下节点的索引位置应该是保持不变还是变成原先的索引（旧容量下的索引位置） + 旧容量大小，至于为什么是这两种可以看上面具体方法的解释。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p><code>当前位置不存在节点时新增节点</code>：直接添加</p></li><li><p><code>当前位置存在节点且是红黑树结构下新增节点</code>：直接添加，添加后可能需要旋转并移动根节点</p></li><li><p><code>当前位置存在节点且是链表结构下新增节点</code>：直接添加，添加后检测是否超过红黑树的阈值（8）和当前哈希表的长度是否超过一定容量大小（64），若这两者都满足则先将其单向链表转换成双向链表，遍历双向链表后变成红黑树，此时红黑树中的节点具有prev、next、lef、right、parent信息</p></li><li><p><code>当前位置只有一个节点且不存在链表或红黑树结构下进行扩容</code>：在新的哈希表中重新计算位置并填充即可</p></li><li><p><code>当前位置有多个节点且是红黑树结构下进行扩容</code>：将红黑树尝试分成高低位两棵树（何为高低位可参考上面的解释），低位这棵树先检测长度是否超过链表的阈值（6），若超过说明要进行树形化，接着检测是否已经树形化过，实际上就是判断高位的那棵树是否为空即可知道低位是否已经树形化过，若是高位那棵树为空，说明红黑树并未分成高低位两棵树，所以最终是将红黑树填充到新的哈希表中；同样的，若是高位那棵树存在，说明红黑树确实分成了两棵树，结构已经发生了变化，低位需要重新树形化；若低位这棵树的长度不超过链表的阈值（6）则要将其转换成单向链表结构并填充到新的哈希表中。高位那棵树的做法和低位是类似的，只不过最终填充到新的哈希表中时索引不一致，低位的索引是原先的索引（保持不变），高位的索引是原来的索引 + 旧的哈希表的容量大小。</p></li><li><p><code>当前位置有多个节点且是链表结构下进行扩容</code>：将链表尝试分成高低位两条链表并填充到新的哈希表中，低位的索引是原先的索引（保持不变），高位的索引是原来的索引 + 旧的哈希表的容量大小</p></li><li><p><code>当前位置存在节点且是红黑树结构下删除节点</code>：查找到指定节点后先调整双向链表，若此时红黑树的长度过小则直接将其转换成单向链表，若不是则利用交换树链接的方式来移除并调整平衡。该内容涉及到比较多的算法，建议对于算法只要懂的它做什么即可，后续想研究算法的话可以在回过头来！</p></li><li><p>HashMap的键与值都允许存放Null</p></li><li><p>HashMap是无序不可重复、非线程安全</p></li><li><p>HashMap的容量大小必须是2的幂次方</p></li><li><p>HashMap默认初始容量16、默认加载因子0.75</p></li><li><p>HashMap中索引的计算方式：hash &amp; (capacity - 1)</p></li><li><p>HashMap扩容时会以<code>2倍大小</code>进行增长，旧数组中的节点重新散列到新数组中，而在新数组中索引可能出现在原索引位置或原索引位置 + 旧数组容量大小</p></li><li><p>红黑树的根节点不一定是链表的头节点</p></li><li><p>JDK1.7在扩容时会出现死循环，而JDK1.8不会</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>单向链表转成红黑树</code>  <code>红黑树转成单向链表</code> <code>rehash</code> <code>默认初始容量与加载因子</code> <code>hash值与索引的计算方式</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;探索&lt;code&gt;HashMap&lt;/code&gt;底层实现是基于&lt;code&gt;JDK1.8&lt;/code&gt;，看代码之前翻了一下别人写的博客我才知道&lt;code&gt;JDK1.7&lt;/code&gt;版本的HashMap是由&lt;code&gt;数组 + 链表&lt;/code&gt;的数据结构组成，而对于JDK1.8是由&lt;code&gt;数组 + 链表 + 红黑树&lt;/code&gt;的数据结构组成，所以我又去了解了什么是二叉树、平衡二叉树、红黑树，为的就是能做个铺垫。既然是由数组、链表、红黑树组成，加上平时我们了解过的一些细节，可以猜到它的数据结构应该是这样子的，如图所示：&lt;/p&gt;
&lt;p class=&quot;customize-img&quot;&gt;&lt;img src=&quot;/assets/blogImg/java/hashmap/hashmap-data-structure.png&quot; alt=&quot;HashMap数据结构&quot;&gt;&lt;/p&gt;
&lt;p&gt;长的虽然有点丑。下面我们就开始探索它吧，还是先从注释开始看！&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>初识红黑树</title>
    <link href="http://zlia.tech/2019/09/18/explain-binarytree-redblack/"/>
    <id>http://zlia.tech/2019/09/18/explain-binarytree-redblack/</id>
    <published>2019-09-18T14:19:58.000Z</published>
    <updated>2019-09-20T10:09:55.186Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>在认识红黑树之前，最好你已经认识并掌握了二叉树与平衡二叉树（AVL）。AVL树是高度平衡的二叉树，它的时间复杂度大约是O(log<sub>2</sub>n)，即使在最坏的情况下也是。其实AVL树最复杂的地方在于删除节点重新平衡时的处理，有可能需要多次旋转节点。而红黑树相对于AVL树<code>降低了平衡要求</code>，它使用<code>红黑两种颜色来标记节点</code>，并对颜色进行要求（限制），在插入删除操作后对不符合的情况进行调整以满足要求，从而实现自我平衡。这些所谓的要求即是红黑树的特性：</p><ul><li><p>每个节点要么是红色要么是黑色。</p></li><li><p>根节点是黑色。</p></li><li><p>叶节点（值为Nil或Null的节点）是黑色。</p></li><li><p>如果一个节点是红色，那么它的子节点是黑色，相当于父子节点之间不能出现连续的红色节点。</p></li><li><p>从任意节点出发到任意叶节点的所有路径上均包含相同数目的黑色节点。</p></li></ul><a id="more"></a><p>通过上面的要求保证了<code>任意节点到叶节点的所有路径中，没有一条路径会大于其他路径的两倍长（最大是两倍</code>）。可以想象某条路径上有3个连续的黑色节点，而另外一条路径上它能达到的最长也就是红黑相间，所以最长是6个节点，3个黑色3个红色。由于红黑树降低了平衡的要求，也就是说它在插入删除时可能不需要任何的操作，也可能只需要改变下颜色即可，最糟糕的情况下才是旋转，相比AVL树只能通过旋转去达到平衡，所以说<code>红黑树的插入删除效率比AVL树要高</code>，而AVL树对于平衡要求较高导致了<code>它的查询效率比红黑树高</code>，但实际上差别并不是很大！最终看一下红黑树的效果图：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-1.png" alt="红黑树结构"></p><h3 id="了解旋转"><a href="#了解旋转" class="headerlink" title="了解旋转"></a><div><span>了解旋转</span></div></h3><p>在继续讲解红黑树之前，<code>旋转</code>是必须要掌握的。在上一篇<a href="http://zlia.tech/2019/09/15/explain-binarytree-avl">AVL平衡二叉树</a>中我们详细说明了什么是旋转、旋转的几种情况，希望不懂的同学可以先去了解下，毕竟这是前提，这里只是简单帮助同学回忆下。</p><h4 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h4><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-2.png" alt="左旋"></p><p>节点8左旋之后，由一开始节点8的右子树为节点10变成了节点10的左子树为节点8，同时根节点变成了节点10。</p><h4 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h4><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-3.png" alt="右旋"></p><p>节点8右旋之后，由一开始节点8的左子树为节点6变成了节点6的右子树为节点8，同时根节点变成了节点6。</p><h3 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a><div><span>红黑树的插入</span></div></h3><p>上面说了节点要么是红色要么是黑色，对于新插入的节点来说也是如此。假设新插入的节点是黑色，那么某条路径上便会多出来一个黑色节点，除了将其改成红色之外其余的方式，包括左旋、右旋，都无法改变会多出来一个黑色节点，所以它完全满足不了红黑树的第五特性，那么留下来的只有红色了，故而<code>新插入的节点颜色是红色的</code>！在想想，若新插入的节点是红色的话，会造成哪里不平衡，也就是说会违背哪些特性：</p><ul><li><p>每个节点要么是红色要么是黑色。</p></li><li><p>根节点是黑色。</p></li><li><p>叶节点是黑色。</p></li><li><p>如果一个节点是红色，那么它的子节点是黑色，相当于父子节点之间不能出现连续的红色节点。</p></li><li><p>从任意节点出发到任意叶节点的所有路径上均包含相同数目的黑色节点。</p></li></ul><p>第一条显然没有违背；对于空树来说，新插入的红色节点违背了该条，不过调整起来很简单，并不是关键点；新插入的节点并未来影响到叶节点；新插入的红色节点有可能它的父节点也是红色，故违背了该条，接下来的内容是针对此情况进行重点分析；新插入的节点为红色正是为了不违背该条。</p><h4 id="插入情况分析"><a href="#插入情况分析" class="headerlink" title="插入情况分析"></a>插入情况分析</h4><p>现在来分析新插入的红色节点可能出现的情况，以及它们的处理措施，这里我们<code>假设新插入的红色节点为X</code>：</p><ul><li><p>若X是根节点，将其变成黑色皆可。</p></li><li><p>若X的父节点是黑色，则不需要任何黑色。</p></li><li><p>若X的父节点是红色，叔叔节点（隶属于同一个父节点）也是红色，解决方案如下：</p><ul><li><p>将X的父节点与叔叔节点变成黑色。</p></li><li><p>将X的爷爷节点变成红色。</p></li><li><p>X的爷爷节点变成红色后，有可能会出现连续红色节点的冲突，若有的话则将X的爷爷节点当作是新插入的节点，继续重复31、32操作，直到当前节点是根节点，最后将根节点变成黑色。</p></li></ul></li></ul><p>如图所示红黑树：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-insert-1.png" alt="红黑树插入-1"></p><p><code>新插入的红色节点X为125</code>，如图所示红黑树：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-insert-2.png" alt="红黑树插入-2"></p><p><code>节点125和其父节点130都是红色节点，违背了第四点要求</code>，所以将节点125的父节点130与叔叔节点150变成黑色，同时将节点125的爷爷节点140变成红色，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-insert-3.png" alt="红黑树插入-3"></p><p><code>节点140和其父节点120都是红色节点，也违背了第四点要求</code>，我们可以将节点140看成是新插入的节点。所以将节点140的父节点120与叔叔节点60变成黑色，同时将节点140的爷爷节点90变成红色，由于节点90是根节点，又将其节点90变成了黑色，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-insert-4.png" alt="红黑树插入-4"></p><p>到这里，新插入的红色节点125一开始不满足红黑树的特性到所作的一系列调整，最终变成了标准的红黑树！</p><ul><li><p>若X的父节点是红色，叔叔节点是黑色（空），解决方案如下：</p><ul><li><p>X和X的父节点在X的爷爷节点的左子树上（左左情况）。</p></li><li><p>X和X的父节点在X的爷爷节点的右子树上（右右情况）。</p></li><li><p>以上的两种情况（4142）都是同一个处理措施，只不过旋转的方向不一致。</p><ul><li><p>将X的父节点与X的爷爷节点进行颜色互换。</p></li><li><p>将X的爷爷节点进行左/右旋，左左情况是右旋，右右情况是左旋。</p></li></ul></li></ul></li></ul><p>如图所示红黑树（左左情况）：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-insert-5.png" alt="红黑树插入-5"></p><p><code>新插入的红色节点X为25</code>，如图所示红黑树：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-insert-6.png" alt="红黑树插入-6"></p><p>节点25的父节点30为红色，叔叔节点为黑色，且节点25与父节点30都是节点50的左子树，所以将节点30与节点50进行颜色互换，同时将节点50进行右旋，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-insert-7.png" alt="红黑树插入-7"></p><p>以上是左左情况下该如何处理，右右情况的话只需要左旋即可，很简单！这边提下为啥要进行旋转，单是颜色互换其实你会发现90-&gt;60-&gt;50-&gt;null这条路径上少了一个黑色节点数目，它并不满足第五点要求，所以旋转是必须的。</p><ul><li><p>若X的父节点是红色，叔叔节点是黑色（空），该情况与上面的第四点有些类似，解决方案如下：</p><ul><li><p>X的父节点在X的爷爷节点的左子树上，X在X的父节点的右子树上（左右情况）。</p></li><li><p>X的父节点在X的爷爷节点的右子树上，X在X的父节点的左子树上（右左情况）。</p></li><li><p>以上的两种情况（5152）都是同一个处理措施，只不过旋转的方式不一样。</p><ul><li><p>将X的父节点进行左/右旋，左右情况是左旋，右左情况是右旋。</p></li><li><p>注意旋转后，X将会变化，将X的父节点与X的爷爷节点进行颜色互换。</p></li><li><p>将X的爷爷节点进行左/右旋，左右情况是右，右左情况是左旋，因为前面已经旋转过一次了，故后面是另外一个旋转，就比如左右，先左旋在右旋。</p></li></ul></li></ul></li></ul><p>如图所示红黑树（左右情况）：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-insert-8.png" alt="红黑树插入-8"></p><p><code>新插入的红色节点X为126</code>，如图所示红黑树：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-insert-9.png" alt="红黑树插入-9"></p><p>节点126的父节点125为红色，叔叔节点为黑色，且节点125在节点130的左子树上，节点126在节点125的右子树上，所以将节点125进行左旋，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-insert-10.png" alt="红黑树插入-10"></p><p>不知道发现没有，旋转后的红黑树跟第四点提到的情景是一样的，故处理方式也是一直。此时的X应该是节点125，故将节点126与节点130进行颜色互换，同时将节点130进行右旋，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-insert-11.png" alt="红黑树插入-11"></p><p>最终也是一颗标准的红黑树！以上是左右情况下该如何处理，右左情况的话也是差不多，不过多介绍了！</p><h4 id="插入情况总结"><a href="#插入情况总结" class="headerlink" title="插入情况总结"></a>插入情况总结</h4><p>整理下插入节点的情况及措施，假设新插入的节点为X：</p><ul><li><p>X是根节点：将其变成黑色即可。</p></li><li><p>X的父节点为黑色：不需要任何操作。</p></li><li><p>X的父节点为红色：</p><ul><li><p>叔叔节点为红色：将X的父节点与叔叔节点变成黑色；将X的爷爷节点变成红色；X的爷爷节点变成红色后，有可能会出现连续红色节点的冲突，若有的话则将X的爷爷节点当作是新插入的节点，继续重复上面的操作，直到当前节点是根节点，最后将根节点变成黑色。</p></li><li><p>叔叔节点为黑色：</p><ul><li><p>X在左子树上，父节点也在左子树上（左左情况） || X在右子树上，父节点也在右子树上（右右情况）：将X的父节点与X的爷爷节点进行颜色互换，将X的爷爷节点进行左/右旋，左左情况是右旋，右右情况是左旋。</p></li><li><p>父节点在左子树上，X在右子树上（左右情况） || 父节点在右子树上，X在左子树上（右左情况）：将X的父节点进行左/右旋，左右情况是左旋，右左情况是右旋，旋转后会发现与321的情况一样，然后按照321的情况继续处理，因为已经旋转过一次了，所以左右情况是右旋，右左情况是左旋。</p></li></ul></li></ul></li></ul><p>了解完以上的所有情况后，不知道你们会不会觉得有点难。实际上每一种情况对应着一种处理方式，你只需对应上即可，不过关键还是要去理解它！</p><h3 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a><div><span>红黑树的删除</span></div></h3><p>删除节点很容易，复杂的是删除节点后如何调整平衡，请同学们一定要耐心的看，仔细看，加上自己的理解！参考了其他人的文章，将删除节点的子节点个数分为以下情况，这里我们<code>假设删除节点为X</code>：</p><ul><li><p>X没有子节点的情况：</p><ul><li><p>X为红色。</p></li><li><p>X为黑色，X的兄弟节点没有子节点。</p></li><li><p>X为黑色，X的兄弟节点只有一个子节点。</p><ul><li><p>X的兄弟节点与X的兄弟节点的子节点在左子树上（左左情况）。</p></li><li><p>X的兄弟节点与X的兄弟节点的子节点在右子树上（右右情况）。</p></li><li><p>X的兄弟节点在左子树上，X的兄弟节点的子节点在右子树上（左右情况）。</p></li><li><p>X的兄弟节点在右子树上，X的兄弟节点的子节点在左子树上（右左情况）。</p></li></ul></li><li><p>X为黑色，X的兄弟节点有两个子节点。</p></li></ul></li><li><p>X只有一个子节点的情况（左右无所谓）：</p><ul><li><p>X为红色，其子节点只能为黑色。</p></li><li><p>X为黑色，其子节点为红色。</p></li><li><p>X为黑色，其子节点为黑色。</p></li></ul></li><li><p>X有两个子节点的情况是将其简化成以上的两种情况后再处理，有以下两种简化方式（根据业务需求自行选择其中一种）：</p><ul><li><p>找到X的右子树中最左的节点，将两个节点的值进行交换，就变成了删除最左的节点，不过删除的值依然还是原来的值，相当于X换了个位置。由于是最左的节点，那么它肯定没有左子树，所以它要么是没有子节点要么是只有一个子节点。</p></li><li><p>找到X的左子树中最右的节点，将两个节点的值进行交换。由于是最右的节点，那么它肯定没有右子树，所以它要么是没有子节点要么是只有一个子节点。</p></li></ul></li></ul><p>情况有点多，接下来一一分析！</p><h4 id="删除节点没有子节点"><a href="#删除节点没有子节点" class="headerlink" title="删除节点没有子节点"></a>删除节点没有子节点</h4><ul><li>X为红色。</li></ul><p>如图所示红黑树：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-1.png" alt="红黑树删除-1"></p><p><code>删除节点X为126</code>，如图所示红黑树：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-2.png" alt="红黑树删除-2"></p><p>直接删除即可，因为删除的是红色节点，并不会影响黑色节点的数目。</p><ul><li>X为黑色，X的兄弟节点没有子节点，此时X的兄弟节点必定为黑色。</li></ul><p>如图所示红黑树：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-3.png" alt="红黑树删除-3"></p><p><code>删除节点X为110</code>，它为黑色，且兄弟节点140没有子节点。由于X为黑色，那么它的兄弟节点必定为黑色（否则就违背了黑色数目不一致），如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-4.png" alt="红黑树删除-4"></p><p>图中删除后的节点用虚线白字表示，方便讲解。在删除节点110后，90-&gt;120-&gt;110的路径上明显少了一个黑色数目，采取的措施是将删除节点X的兄弟节点变成红色，X的父节点变成黑色，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-5.png" alt="红黑树删除-5"></p><p>最终每条路径上的黑色数目一样。</p><ul><li><p>X为黑色，X的兄弟节点只有一个子节点</p><ul><li><p>X的兄弟节点与X的兄弟节点的子节点在左子树上（左左情况）</p></li><li><p>X的兄弟节点与X的兄弟节点的子节点在右子树上（右右情况）</p></li><li><p>以上的两种情况都是同一个处理措施，只不过旋转的方式不一样。</p></li></ul></li></ul><p>如图所示红黑树（左左情况）：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-6.png" alt="红黑树删除-6"></p><p><code>删除节点X为140</code>，它为黑色，且兄弟节点110（左子树上）只有一个子节点100（左子树上），如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-7.png" alt="红黑树删除-7"></p><p>在删除节点140后，90-&gt;120-&gt;140的路径上少了一个黑色数目，采取的措施是将X的父节点与X的兄弟节点进行颜色互换，将X的父节点变成黑色，将X的兄弟节点的子节点变成黑色，最后将X的父节点进行左/右旋，左左情况是右旋，右右情况是左旋，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-8.png" alt="红黑树删除-8"></p><p>最终每条路径上的黑色数目一样。</p><ul><li><p>X为黑色，X的兄弟节点只有一个子节点</p><ul><li><p>X的兄弟节点在左子树上，X的兄弟节点的子节点在右子树上（左右情况）</p></li><li><p>X的兄弟节点在右子树上，X的兄弟节点的子节点在左子树上（右左情况）</p></li><li><p>以上的两种情况都是同一个处理措施，只不过旋转的方式不一样。</p></li></ul></li></ul><p>如图所示红黑树（左右情况）：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-9.png" alt="红黑树删除-9"></p><p><code>删除节点X为140</code>，它为黑色，且兄弟节点110（左子树上）只有一个子节点115（右子树上），如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-10.png" alt="红黑树删除-10"></p><p>在删除节点140后，90-&gt;120-&gt;110-&gt;115的路径上少了一个黑色数目，采取的措施是将X的兄弟节点与X的兄弟节点的子节点进行颜色互换，将X的兄弟节点进行左/右旋，左右情况是左旋，右左情况是右旋，将X的父节点进行左/右旋，左右情况是右，右左情况是左旋，因为前面已经旋转过一次了，后面是另外一个旋转，就比如左右，先左旋在右旋，将X的父节点与X的兄弟节点变成黑色，将X的父节点的父节点变成红色，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-11.png" alt="红黑树删除-11"></p><p>最终每条路径上的黑色数目一样。</p><ul><li><p>X为黑色，X的兄弟节点有两个子节点（若是叶节点则和上面的第2点没啥区别，所以这里不是叶节点）</p><ul><li>X的兄弟节点为黑色，那么它的两个子节点必定是红色（因为X没有子节点，这种情况不用考虑兄弟节点的子节点，因为即使旋转了红色的节点并不会影响黑色数目），这样子才能保证黑色数目一致</li></ul></li></ul><p>如图所示红黑树：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-12.png" alt="红黑树删除-12"></p><p><code>删除节点X为140</code>，它为黑色，且兄弟节点110也为黑色，有两个子节点，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-13.png" alt="红黑树删除-13"></p><p>在删除节点140后，90-&gt;120-&gt;140的路径上少了一个黑色数目，采取的措施是将X的父节点进行左/右旋，X在左子树是左旋，X在右子树是右旋，将X的父节点与X的兄弟节点的左/右子节点变成黑色，X在左子树上就将右子节点变成黑色，X在右子树上就将左子节点变成黑色，将X的兄弟节点变成红色（若X的兄弟节点是根节点则不需要变化），如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-14.png" alt="红黑树删除-14"></p><p>最终每条路径上的黑色数目一样。</p><ul><li><p>X为黑色，X的兄弟节点有两个子节点</p><ul><li><p>X的兄弟节点为红色，那么它的两个子节点只能为黑色，这样子才能保证黑色数目一样</p><ul><li>X的兄弟节点的子节点都无子节点</li></ul></li></ul></li></ul><p>如图所示红黑树：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-15.png" alt="红黑树删除-15"></p><p><code>删除节点X为30</code>，它为黑色，兄弟节点85为红色，有两个子节点（在无子节点），如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-16.png" alt="红黑树删除-16"></p><p>在删除节点30后，60-&gt;30的路径上少了一个黑色数目，由于该情况比较复杂，我们以X的父节点为目标（即使在移动后我们仍称为X的父节点）采取的措施是：</p><ul><li><p>删除X</p></li><li><p>X的父节点与X的兄弟节点颜色互换</p></li><li><p>X的父节点左/右旋，X在左子树是左旋，X在右子树是右旋</p></li><li><p>X的父节点与X的父节点的子节点（旋转过后的子节点）颜色互换</p></li></ul><p>如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-17.png" alt="红黑树删除-17"></p><p>最终每条路径上的黑色数目一样。</p><ul><li><p>X为黑色，X的兄弟节点有两个子节点</p><ul><li><p>X的兄弟节点为红色，那么它的两个子节点只能为黑色（只考虑X的兄弟节点的子节点与X同边，就比如X在左子树，那么只考虑X的兄弟节点的左子树，因为只有左子树才会在旋转之后移动到了X的那一侧，影响到了黑色数目，而右子树始终没有变动）</p><ul><li>X的兄弟节点的子节点的子节点只有一个，那么X的兄弟节点的子节点为黑色，那么X的兄弟节点的子节点的子节点必为红色（因为X无子节点）</li></ul></li></ul></li></ul><p>如图所示红黑树：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-18.png" alt="红黑树删除-18"></p><p><code>删除节点X为30</code>，它为黑色，兄弟节点85为红色，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-19.png" alt="红黑树删除-19"></p><p>在删除节点30后，60-&gt;30的路径上少了一个黑色数目，由于该情况比较复杂，我们以X的父节点为目标（即使在移动后我们仍称为X的父节点）采取的措施是：</p><ul><li><p>删除X</p></li><li><p>X的父节点左/右旋，X在左子树是左旋，X在右子树右旋</p></li><li><p>X的父节点与X的兄弟节点颜色互换</p></li><li><p>若X的父节点的左/右子树（旋转过后）的左/右子树与X同边，简单来说，若X在左/右子树，那么只考虑X的父节点的右/左子树的左/右子树，从14225开始执行，若是没对应上则从14227开始执行，同理X在右子树上</p></li><li><p>X在左/右子树，X的父节点的右/左子树进行右/左旋（14225）</p></li><li><p>X在左/右子树，X的父节点的右/左子树与X的父节点的右/左子树的右/左子树进行颜色互换（14226）</p></li><li><p>X的父节点左/右旋，x在左子树是左旋，x在右子树右旋（14227）</p></li><li><p>X的父节点与X的父节点的兄弟节点变成黑色，X的父节点的父节点变成红色（旋转过后）</p></li></ul><p>最终每条路径上的黑色数目一样。该情况很是复杂，希望同学们能耐心的理解并尝试动手，否则很难从中发现规律！</p><ul><li><p>X为黑色，X的兄弟节点有两个子节点</p><ul><li><p>X的兄弟节点为红色，那么它的两个子节点只能为黑色（和上面一样，只需考虑一侧）</p><ul><li>X的兄弟节点的子节点的子节点有两个，那么X的兄弟节点的子节点为黑色，那么X的兄弟节点的子节点的两个子节点都为红色</li></ul></li></ul></li></ul><p>如图所示红黑树：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-20.png" alt="红黑树删除-20"></p><p><code>删除节点X为30</code>，它为黑色，兄弟节点85为红色，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-21.png" alt="红黑树删除-21"></p><p>在删除节点30后，60-&gt;30的路径上少了一个黑色数目，由于该情况比较复杂，我们以X的父节点为目标（即使在移动后我们仍称为X的父节点）采取的措施是：</p><ul><li><p>删除X</p></li><li><p>X的父节点左/右旋，X在左子树是左旋，X在右子树右旋</p></li><li><p>X的父节点与X的兄弟节点颜色互换</p></li><li><p>X的父节点左/右旋，X在左子树是左旋，X在右子树右旋</p></li><li><p>X的父节点与X的父节点的兄弟节点变成黑色，X的父节点的父节点变成红色（旋转过后）</p></li></ul><p>删除节点中最复杂的部分差不多都在这里了。说实话，我整理起来都耗费了很多精力与时间，同学们看不懂或者不理解的地方尝试多看几遍，多动手几次，说不定，当然了，也不排除我写错了，所以还是要自己动手比较好，加油吧！</p><h4 id="删除节点只有一个子节点"><a href="#删除节点只有一个子节点" class="headerlink" title="删除节点只有一个子节点"></a>删除节点只有一个子节点</h4><ul><li><p>X为红色，其子节点为黑色，不存在这样子的情况，要不然黑色数目就不一样了</p></li><li><p>X为黑色，其子节点为黑色，同样的道理，黑色数目还是不一样（X-&gt;Null路径上少了一个）</p></li><li><p>X为黑色，其子节点为红色（左右无所谓），这里就不上图片了，直接说处理措施：</p><ul><li><p>删除X</p></li><li><p>将X的子节点变成黑色，并作为X的父节点的子节点</p></li></ul></li></ul><h4 id="删除节点有两个子节点"><a href="#删除节点有两个子节点" class="headerlink" title="删除节点有两个子节点"></a>删除节点有两个子节点</h4><ul><li><p>找到X的右子树中最左的节点，将两个节点的值进行交换，就变成了删除最左的节点，不过删除的值依然还是原来的值，所以最左的节点要么没有子节点，要么只有一个子节点，是不是又回到上面的情况了，那处理情况自然也就是上面的内容了</p></li><li><p>找到X的左子树中最右的节点，将两个节点的值进行交换，所以最右的节点要么没有子节点，要么只有一个子节点，同理！</p></li></ul><h4 id="删除情况总结"><a href="#删除情况总结" class="headerlink" title="删除情况总结"></a>删除情况总结</h4><ul><li><p>X没有子节点的情况</p><ul><li><p>X为红色，不需要任何处理，直接删除即可</p></li><li><p>X为黑色，X的兄弟节点没有子节点</p><ul><li><p>那么X的兄弟节点肯定也为黑色</p></li><li><p>删除X</p></li><li><p>将X的兄弟节点变成红色，X的父节点变成黑色</p></li></ul></li><li><p>X为黑色，X的兄弟节点只有一个子节点</p><ul><li><p>X的兄弟节点与X的兄弟节点的子节点在左子树上（左左情况） || X的兄弟节点与X的兄弟节点的子节点在右子树上（右右情况）</p><ul><li><p>删除X</p></li><li><p>将X的父节点与X的兄弟节点进行颜色互换</p></li><li><p>将X的父节点变成黑色</p></li><li><p>将X的兄弟节点的子节点变成黑色</p></li><li><p>将X的父节点进行左/右旋，左左情况是右旋，右右情况是左旋</p></li></ul></li><li><p>X的兄弟节点在左子树上，X的兄弟节点的子节点在右子树上（左右情况） || X的兄弟节点在右子树上，X的兄弟节点的子节点在左子树上（右左情况）</p><ul><li><p>删除X</p></li><li><p>将X的兄弟节点与X的兄弟节点的子节点进行颜色互换</p></li><li><p>将X的兄弟节点进行左/右旋，左右情况是左旋，右左情况是右旋</p></li><li><p>将X的父节点进行左/右旋，左右情况是右，右左情况是左旋，因为前面已经旋转过一次了，后面是另外一个旋转，就比如左右，先左旋在右旋</p></li><li><p>将X的父节点与X的兄弟节点变成黑色</p></li><li><p>将X的父节点的父节点变成红色</p></li></ul></li></ul></li><li><p>X为黑色，X的兄弟节点有两个子节点（若是叶子节点则和上面的12没什么区别，所以这里不是叶子节点）</p><ul><li><p>X的兄弟节点为黑色，那么它的两个子节点必定都是红色（因为X没有子节点，这种情况不用考虑子节点，因为即使旋转了红色的节点并不会影响黑色数目）</p><ul><li><p>删除X</p></li><li><p>X的父节点进行左/右旋，X在左子树是左旋，X在右子树是右旋</p></li><li><p>将X的父节点与X的兄弟节点的左/右子节点变成黑色，X在左子树上就将右子节点变成黑色，X在右子树上就将左子节点变成黑色</p></li><li><p>若X的兄弟节点是根节点则不需要变化，将X的兄弟节点变成红色</p></li></ul></li><li><p>X的兄弟节点为红色，那么它的两个子节点必定是黑色（只考虑X的兄弟节点的子节点与X同边，就比如X在左子树，那么只考虑X的兄弟节点的左子树，因为只有左子树才会在旋转之后移动到了X的那一侧，影响到了黑色数目，而右子树始终没有变动）</p><ul><li><p>X的兄弟节点的子节点都无子节点</p><ul><li><p>删除X</p></li><li><p>X的父节点与X的兄弟节点颜色互换</p></li><li><p>X的父节点左/右旋，X在左子树是左旋，X在右子树是右旋</p></li><li><p>X的父节点与X的父节点的子节点（旋转过后的子节点）颜色互换</p></li></ul></li><li><p>X的兄弟节点的子节点只有一个子节点，X的兄弟节点的子节点为黑色，那么X的兄弟节点的子节点的子节点必为红色</p><ul><li><p>删除X</p></li><li><p>x的父节点左/右旋，x在左子树是左旋，x在右子树右旋</p></li><li><p>x的父节点与X的兄弟节点颜色互换</p></li><li><p>若X的父节点的左/右子树（旋转过后）的左/右子树与X同边，简单来说，若X在左/右子树，那么只考虑X的父节点的右/左子树的左/右子树，先从14225开始执行，若是没对应上则先从14227开始执行，同理X在右子树上</p></li><li><p>X在左/右子树，X的父节点的右/左子树进行右/左旋</p></li><li><p>X在左/右子树，X的父节点的右/左子树与X的父节点的右/左子树的右/左子树进行颜色互换</p></li><li><p>X的父节点左/右旋，x在左子树是左旋，x在右子树右旋</p></li><li><p>X的父节点与X的父节点的兄弟节点变成黑色，X的父节点的父节点变成红色（旋转过后）</p></li></ul></li><li><p>X的兄弟节点的子节点有两个子节点，X的兄弟节点的子节点为黑色，那么X的兄弟节点的子节点的两个子节点都为红色</p><ul><li><p>删除X</p></li><li><p>x的父节点左/右旋，x在左子树是左旋，x在右子树右旋</p></li><li><p>x的父节点与X的兄弟节点颜色互换</p></li><li><p>x的父节点左/右旋，x在左子树是左旋，x在右子树右旋</p></li><li><p>X的父节点与X的父节点的兄弟节点变成黑色，X的父节点的父节点变成红色（旋转过后）</p></li></ul></li></ul></li></ul></li></ul></li><li><p>X只有一个子节点的情况</p><ul><li><p>X为黑色，其子节点只能为红色（左右都无所谓）</p><ul><li><p>删除X</p></li><li><p>将X的子节点变成黑色，并作为X的父节点的子节点</p></li></ul></li><li><p>X为红色，其子节点为黑色 || X为黑色，其子节点为黑色</p><ul><li>不存在这两种情况，黑叔数目不一样</li></ul></li></ul></li><li><p>X有两个子节点的情况</p><ul><li><p>找到X的右子树中最左的节点，将两个节点的值进行交换，就变成了删除最左的节点，不过删除的值依然还是原来的值，相当于X换了个位置。由于是最左的节点，那么它肯定没有左子树，所以它要么是没有子节点要么是只有一个子节点（右子树），最终变成了上面的处理情况。</p></li><li><p>找到X的左子树中最右的节点，将两个节点的值进行交换。由于是最右的节点，那么它肯定没有右子树，所以它要么是没有子节点要么是只有一个子节点（左子树），最终变成了上面的情况。</p></li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><div><span>总结</span></div></h3><p>红黑树的插入与删除较为复杂，过一段时间后容易忘记，特意整理了一份流程说明，有兴趣的同学可以去观摩-<a href="https://github.com/JulianHang/translate-article/blob/master/RedBlackTreeProcess.md" target="_blank" rel="noopener">红黑树插入与删除流程说明</a>，至于代码的设计实现上可能没有那么快给出，我也是个菜鸟啊，到时候要是不小心写出来了我就在新写一篇文章告知天下！这篇算是纯理论的红黑树，想学东西就要多去实践。最后推荐个<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">数据结构可视化网站</a>，可调试二叉树、AVL树、红黑树，估计还有其他我不知道的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;在认识红黑树之前，最好你已经认识并掌握了二叉树与平衡二叉树（AVL）。AVL树是高度平衡的二叉树，它的时间复杂度大约是O(log&lt;sub&gt;2&lt;/sub&gt;n)，即使在最坏的情况下也是。其实AVL树最复杂的地方在于删除节点重新平衡时的处理，有可能需要多次旋转节点。而红黑树相对于AVL树&lt;code&gt;降低了平衡要求&lt;/code&gt;，它使用&lt;code&gt;红黑两种颜色来标记节点&lt;/code&gt;，并对颜色进行要求（限制），在插入删除操作后对不符合的情况进行调整以满足要求，从而实现自我平衡。这些所谓的要求即是红黑树的特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;每个节点要么是红色要么是黑色。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;根节点是黑色。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;叶节点（值为Nil或Null的节点）是黑色。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果一个节点是红色，那么它的子节点是黑色，相当于父子节点之间不能出现连续的红色节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从任意节点出发到任意叶节点的所有路径上均包含相同数目的黑色节点。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="algorithm" scheme="http://zlia.tech/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>初识平衡二叉树-AVL</title>
    <link href="http://zlia.tech/2019/09/15/explain-binarytree-avl/"/>
    <id>http://zlia.tech/2019/09/15/explain-binarytree-avl/</id>
    <published>2019-09-15T11:23:55.000Z</published>
    <updated>2019-09-16T02:35:27.539Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>上一篇文章只是简单地认识下<code>二叉树</code>，并未提到它的<code>缺陷</code>。数据结构的好坏取决于<code>时间复杂度</code>，由于每次操作（插入、删除、查找）需要与节点比较来选择进入到左子树还是右子树，也就是说每次比较都会排除一些可能（选择左右其中一侧），当然了这是对于随机均匀分布的二叉树来说，它的时间复杂度是O（log<sub>2</sub>n），但是对于只有单向的左子树或右子树来说，它的时间复杂度就变成了O(n)，每次操作都会从头到尾所有节点比较一遍。总的来说，二叉树的时间复杂度区间是在O(log<sub>2</sub>n) ~ O(n)之间，这完全取决于二叉树的结构！如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/avl/single-binarytree.png" alt="单向二叉树结构"></p><p>随着单向二叉树越来越长，所消耗的时间也会越来越多，这已经跟单链表没有什么区别了。因此，为了解决单链表的情况，将时间复杂度降低至O（log<sub>2</sub>n），衍生出了<code>平衡二叉树</code>。</p><a id="more"></a><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><div><span>平衡二叉树</span></div></h3><p>通过上面的分析看出，只要将节点均匀分布在两侧即可完成目的，而这也正是平衡二叉树所要做的事，因此它要求<code>任何节点的左右子树的高度相差不超过1</code>，实际上就是计算同一层中<code>最大的高度值与最小的高度值相差不超过1</code>，解释下高度的含义：从叶子节点开始自底向上到指定节点的最长距离，叶子节点的高度为0，<code>空树的高度为-1</code>。对于AVL树来说，它只是平衡二叉树的其中一种，节点的左右子树高度差被称为<code>平衡因子</code>，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/avl/balance-binarytree-1.png" alt="平衡二叉树结构"></p><p>图中左侧为平衡二叉树，每一层的高度差值都不会超过1，图中右侧中出现高度差值超过1，故非平衡二叉树。仔细观察下，图中左右两个的二叉树无非就差了一个节点6，可以将这个多余的节点看成是新插入的节点，是该操作导致了二叉树失去平衡，更严格来说，只要是修改了树的结构，都有可能导致平衡失调，而能修改树结构的操作只有删除与插入。那么该如何才能让它继续保持平衡呢？很容易想到，只要稍微移动下树的结构就能使之平衡，这样子的操作被称为<code>旋转</code>，分为<code>单旋转</code>和<code>双旋转</code>。在想一想，图中右侧中左子树相对偏高，若是旋转的话应该将左子树的高度降低，相应的右子树也会增高，这样子就达到平衡了。</p><h3 id="AVL树旋转"><a href="#AVL树旋转" class="headerlink" title="AVL树旋转"></a><div><span>AVL树旋转</span></div></h3><p>上面提到只有删除与插入会导致二叉树不平衡，这里就举插入来介绍平衡二叉树的几种<code>旋转方式</code>。插入的话无非就以下几种方式：</p><h4 id="左左型"><a href="#左左型" class="headerlink" title="左左型"></a>左左型</h4><ul><li>插入到根节点的左子树的左子树上，称作<code>左左型LL（右旋转）</code>。该方式导致的不平衡是因为左子树上的节点增加了，所以旋转的话就应当将左子树的高度降低，而旋转的节点是插入的节点到根节点的路径上的节点都有可能旋转（这个很在编写代码中很关键），也就是说有可能旋转多次才能达到平衡，如图所示操作：</li></ul><p class="customize-img"><img src="/assets/blogImg/algorithm/avl/avl-binarytree-1.png" alt="avl平衡二叉树结构-1"></p><p>图中可见是节点7，我们知道向右旋转会导致左子树的高度降低，没错，旋转正确的话是使二叉树达到平衡。我们将节点7移动到根节点位置上，节点5、6紧随其后，而节点8变成了节点的右子树，节点9还是节点8的右子树，简单来说，随着某个节点的移动，其他节点也会相应的移动，这样子才能达到平衡。不知道你们发现没有，旋转过后，不仅符合二叉树的规则，同时也达到平衡，只不过根节点变化了，不过这丝毫不影响！这是比较简单的<code>左左型LL</code>，在来看另外一种情况：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/avl/avl-binarytree-2.png" alt="avl平衡二叉树结构-2"></p><p>此种情况比上面多了一个节点，不过这不是关键。我们发现节点X应该是比节点7大，而比节点8小，也就是说它可以当作节点7的右子树，也可以当作节点8的左子树，而随着节点7移动到根节点上，它已经有了节点5与节点8两个子节点，容不下第三个节点了，也就是说它已经做不了节点7的右子树了，那么这个时候节点X只能考虑去走另外一套方案了，让我称为节点8的左子树，所以最终旋转的结果如上图所示。理解了右旋转，左旋转也是一样的道理。</p><h4 id="右右型"><a href="#右右型" class="headerlink" title="右右型"></a>右右型</h4><ul><li>插入到根节点的右子树的右子树上，称作<code>右右型RR（左旋转）</code>。该方式导致的不平衡是因为右子树上的节点增加了，所以旋转的话就应当将右子树的高度降低，如图所示：</li></ul><p class="customize-img"><img src="/assets/blogImg/algorithm/avl/avl-binarytree-3.png" alt="avl平衡二叉树结构-3"></p><p>图中可见是节点9导致了二叉树的不平衡，那么应该左旋转来降低右子树的高度。将节点9移动到根节点位置上，节点10、11紧随其后，而节点8变成了节点9的左子树，重点在于节点X，发现节点X比节点8大，而比节点9小，随着节点9的移动，它已经做不了节点9的左子树了，所以结果它成了节点8的右子树。跟上面的右旋转有点类似！</p><h4 id="左右型"><a href="#左右型" class="headerlink" title="左右型"></a>左右型</h4><ul><li>插入到根节点的左子树的右子树上，称作<code>左右型LR（左右旋转）</code>。该方式的结构与上面的左左型稍微有点区别，因为最终插入的节点是落在了右子树上，所以首先应该先降低右子树的高度，应该左旋转，不过你会发现，随着右子树的移动，左子树的高度最终增加了，二叉树还是不平衡，不过不用担心，事情是往好的方向发展，你发现没有，左旋转后的结构与上面的左左型是一样的！也就是说只需要在向右旋转一次就能达到平衡，总共旋转了两次，所以称为左右旋转！如图所示：</li></ul><p class="customize-img"><img src="/assets/blogImg/algorithm/avl/avl-binarytree-4.png" alt="avl平衡二叉树结构-4"></p><p>我们知道若是直接移动节点7，最终还是不平衡，而咱们说从节点插入的地方到根节点的路径上都有可能需要旋转，那只有节点X了，那么应该通过左旋转来降低高度，不过随着节点X的移动，最终发现二叉树还是不平衡，不过你也应该发现了，这结构和左左型很像，所以最终还需要右旋转来达到平衡！</p><h4 id="右左型"><a href="#右左型" class="headerlink" title="右左型"></a>右左型</h4><ul><li>插入到根节点的右子树的左子树上，称作<code>右左型RL（右左旋转）</code>。该方式的结构与上面的右右型有些区别，最终插入的节点是落在了左子树上，所以首先应该先降低左子树的高度，那么应该右旋转，同理，随着旋转一次后发现还是不平衡，不过结构倒是很像右右型，接下来的操作就跟右右型一样了，就不做多阐述了！如图所示：</li></ul><p class="customize-img"><img src="/assets/blogImg/algorithm/avl/avl-binarytree-5.png" alt="avl平衡二叉树结构-5"></p><p>这几种类型不难理解，只要记住哪边高度多大就旋转哪边，需要注意的事可能要旋转多次，这也很简单，发现旋转后还是不平衡在继续旋转即可。</p><h3 id="平衡二叉树的设计与实现"><a href="#平衡二叉树的设计与实现" class="headerlink" title="平衡二叉树的设计与实现"></a><div><span>平衡二叉树的设计与实现</span></div></h3><p>掌握概念后，最重要的就是实战，我已经把代码写了一遍，不过中途是参考了别人的文章，这边也只是放出了代码图片，有兴趣的同学可以去github上观摩-<a href="https://github.com/JulianHang/little-java-project/blob/master/src/tech/zlia/interest/algorithm/tree/avl/AvlBalanceTree.java" target="_blank" rel="noopener">avl平衡二叉树代码设计与实现</a></p><p class="customize-img"><img src="/assets/blogImg/algorithm/avl/avl-binarytree-code.png" alt="avl平衡二叉树结构代码设计"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><div><span>总结</span></div></h3><p>平衡二叉树中的旋转较为复杂，最好能够结合场景去分析推敲，加油吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;上一篇文章只是简单地认识下&lt;code&gt;二叉树&lt;/code&gt;，并未提到它的&lt;code&gt;缺陷&lt;/code&gt;。数据结构的好坏取决于&lt;code&gt;时间复杂度&lt;/code&gt;，由于每次操作（插入、删除、查找）需要与节点比较来选择进入到左子树还是右子树，也就是说每次比较都会排除一些可能（选择左右其中一侧），当然了这是对于随机均匀分布的二叉树来说，它的时间复杂度是O（log&lt;sub&gt;2&lt;/sub&gt;n），但是对于只有单向的左子树或右子树来说，它的时间复杂度就变成了O(n)，每次操作都会从头到尾所有节点比较一遍。总的来说，二叉树的时间复杂度区间是在O(log&lt;sub&gt;2&lt;/sub&gt;n) ~ O(n)之间，这完全取决于二叉树的结构！如图所示：&lt;/p&gt;
&lt;p class=&quot;customize-img&quot;&gt;&lt;img src=&quot;/assets/blogImg/algorithm/avl/single-binarytree.png&quot; alt=&quot;单向二叉树结构&quot;&gt;&lt;/p&gt;
&lt;p&gt;随着单向二叉树越来越长，所消耗的时间也会越来越多，这已经跟单链表没有什么区别了。因此，为了解决单链表的情况，将时间复杂度降低至O（log&lt;sub&gt;2&lt;/sub&gt;n），衍生出了&lt;code&gt;平衡二叉树&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="algorithm" scheme="http://zlia.tech/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>初识二叉树</title>
    <link href="http://zlia.tech/2019/09/11/explain-binarytree/"/>
    <id>http://zlia.tech/2019/09/11/explain-binarytree/</id>
    <published>2019-09-11T08:27:44.000Z</published>
    <updated>2019-09-17T08:27:46.801Z</updated>
    
    <content type="html"><![CDATA[<h3 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a><div><span>树的概念</span></div></h3><p>探索二叉树前，先来认识下什么是树？用官方一点的话来说，<code>树是数据元素之间具有层次关系的非线性结构，是由n（n&gt;=0）个节点组成的有限集合</code>，n=0时称为空树。在任意一颗非空树中，它具有了以下特性：</p><ul><li><p>每棵树至多只有一个根节点。</p></li><li><p>由根节点构造出多个孩子节点，每个孩子节点只有一个父节点，而孩子节点又构造出多个节点。</p></li></ul><p>先看张图，方便了解下树的一些专业术语。</p><p class="customize-img"><img src="/assets/blogImg/algorithm/binarytree/tree-structure-1.png" alt="树结构"></p><ul><li><p><code>根节点</code>：根节点是没有父节点，图中的A节点。</p></li><li><p><code>孩子节点/子节点</code>：某个节点的孩子称为孩子节点，孩子节点/子节点是相对的，图中A的孩子节点有B、C、D，而B的孩子节点有E、F。</p></li><li><p><code>叶子节点</code>：某个节点没有孩子，图中的E、F、G、D。</p></li><li><p><code>节点的度</code>：某个节点的孩子节点个数，图中A有BCD（3）个孩子节点，B有EF（2）个孩子节点。</p></li><li><p><code>树的层次</code>：某个节点处于树中的层次，图中的A处于第1层。</p></li><li><p><code>树的高/深度</code>：树的最大层次，图中的高/深度为3。</p></li></ul><p>接下来聊正题吧！</p><a id="more"></a><h3 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a><div><span>二叉树的概念</span></div></h3><p><code>二叉树是由n（n&gt;=0）个节点组成的有限集合</code>，n=0时称为空树。在任意一颗非空树中，由一个根节点和两颗互不相交、分别称为根节点的左子树、右子树组成。简单来说，二叉树是一种特殊的树，每个节点最多只能有<code>两个</code>子节点，也就是左子树、右子树。比某个节点小的值放在该节点的左侧，称为左子树，该节点左侧的所有节点，包括子孙节点，都小于该节点，同理，比某个节点大的值放在该节点的右侧，称为右子树，右侧的所有节点都大于该节点的值，这是二叉树的特点！除了上面提到的特性，二叉树还有另外一些性质，提供一张图，方便理解与解释：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/binarytree/binarytree-structure-1.png" alt="二叉树结构"></p><ul><li><p>在二叉树的第K层上，<code>最多</code>有2<sup>k-1</sup>个节点，假设k=3，即在第三层，最多有4个节点。</p></li><li><p>高/深为m的二叉树中，<code>最多</code>有2<sup>m</sup>-1个节点，图中高/深度为3，那么最多7个节点，只差C节点的左子树。</p></li><li><p>在任意一颗二叉树中，度为0的节点总是比度为2的节点多1个，图中度为0的节点有DEF（3），而度为2的节点有AB（2）个。</p></li><li><p>具有n个节点的二叉树，其高/深度<code>至少</code>为log<sub>2</sub>n + 1，图中共有6个节点，log<sub>2</sub>6不会算的话，可以想想6是不是介于2<sup>2</sup>与2<sup>3</sup>之间，它应该无限接近于2次方，最后在加上1，所以高/深至少为3层。</p></li></ul><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p><code>在一颗二叉树中，每一层的节点数都达到最大个数</code>，以下是它的特性：</p><ul><li><p>在满二叉树的第K层上，有2<sup>k-1</sup>个节点。</p></li><li><p>高/深为m的二叉树中，有2<sup>m</sup>-1个节点。</p></li></ul><p>如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/binarytree/binarytree-full-structure-1.png" alt="满二叉树结构"></p><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p><code>在一颗二叉树中，除了最后一层外，其他各层的节点数都达到最大个数，且最后一层从左向右的节点连续存在，只缺右侧若干节点</code>。该含义和满二叉树很相似，所以说满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树，以下是它的特性：</p><ul><li>具有n个节点的二叉树，其高/深为log<sub>2</sub>n + 1</li></ul><p>如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/binarytree/binarytree-complete-structure-1.png" alt="完全二叉树结构"></p><p class="customize-img"><img src="/assets/blogImg/algorithm/binarytree/binarytree-complete-structure-2.png" alt="普通二叉树结构"></p><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a><div><span>二叉树的存储结构</span></div></h3><h4 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h4><p>二叉树的顺序结构是使用一维数组存储二叉树中的节点，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/binarytree/binarytree-order-1.png" alt="二叉树顺序存储结构"></p><p>上图中所采用的顺序存储结构如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/binarytree/binarytree-order-2.png" alt="二叉树顺序存储结构"></p><p>仔细观察这是一颗完全二叉树，数组能够刚好填充数组，但对于不是完全二叉树又该是如何存储的？接着看图：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/binarytree/binarytree-order-3.png" alt="二叉树顺序存储结构"></p><p>上图中所采用的顺序存储结构如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/binarytree/binarytree-order-4.png" alt="二叉树顺序存储结构"></p><p>存储位置没有发生变化，只是在索引为4的位置上存储了空元素（^代表为空），表示此位置上是没有节点的？为什么要这么做呢？简单来说就是为了节点能够很容易地找到父节点或孩子节点，若没有按照一定的规则存储，压根不知道每个节点之间的关系，也就失去了二叉树的意义了。具体的规则如下：一棵树有n个节点，假设i（0 &lt;= i &lt; n）为某个节点的索引，那么该节点的左子树对应的数组索引是2i + 1，右子树对应的数组索引是2i + 2，而该节点的父节点对应的数组索引是(i - 1) / 2。通过以上的规则在数组中维护了每个节点之间的关系，但同时也会造成一定空间的浪费，就好比当它是空元素时，也只有在完全二叉树的情况下才不会造成空间的浪费，严格上来说，该存储方式一般适用于完全二叉树。</p><h4 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h4><p>二叉树还有另外一种存储结构，<code>链式存储结构</code>，该结构可分为：二叉链表、三叉链表，下面将会分别说明。<code>二叉链表结构</code>主要由一个<code>数据域</code>和两个分别指向<code>左右子树的节点</code>组成，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/binarytree/binarytree-link-1.png" alt="二叉树链表存储结构"></p><p>这很像单向链表，每个节点只存储了孩子节点的关系，若要找到其父节点需要重新遍历链表，那效率将被大大的降低了！因此为了提高效率，在原有的基础上新增了父节点的地址，称为<code>三叉链表结构</code>，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/binarytree/binarytree-link-2.png" alt="二叉树链表存储结构"></p><p>两者的区别仅在于多了一个父节点的地址。</p><h3 id="二叉树的设计与实现"><a href="#二叉树的设计与实现" class="headerlink" title="二叉树的设计与实现"></a><div><span>二叉树的设计与实现</span></div></h3><p>尝试手写下二叉树，将采用二叉链表结构实现。由于作者对算法技术并不是很了解，该设计也是参考了别个文章的代码，不得不说，别人写的算法文章还是很专业，对于算法内容讲的很明白、清晰，但是对于代码上的设计并不是很友好，所以最终作者是自己设计了实现代码，只是放出了代码相关的图片，有兴趣的同学可以去github上观摩-<a href="https://github.com/JulianHang/little-java-project/blob/master/src/tech/zlia/interest/algorithm/tree/binary/BinarySearchTree.java" target="_blank" rel="noopener">二叉树设计</a>，也顺便提一下别人的文章<a href="https://blog.csdn.net/javazejian/article/details/53727333" target="_blank" rel="noopener">二叉树算法</a>。</p><p class="customize-img"><img src="/assets/blogImg/algorithm/binarytree/binarytree-code.png" alt="二叉树设计"></p><p><code>若只是想了解算法的话，可以看提供的别人的文章，想看设计代码的话，可以看我的设计代码，良心推荐！</code></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><div><span>总结</span></div></h3><p>二叉树的知识点还是挺复杂、多样的。作者也是入门级别水平，要学的内容还是挺多的，尽可能的将自己理解的内容通过博客的方式写出来，帮助自己也拉别人一把。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;树的概念&quot;&gt;&lt;a href=&quot;#树的概念&quot; class=&quot;headerlink&quot; title=&quot;树的概念&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;树的概念&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;探索二叉树前，先来认识下什么是树？用官方一点的话来说，&lt;code&gt;树是数据元素之间具有层次关系的非线性结构，是由n（n&amp;gt;=0）个节点组成的有限集合&lt;/code&gt;，n=0时称为空树。在任意一颗非空树中，它具有了以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;每棵树至多只有一个根节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;由根节点构造出多个孩子节点，每个孩子节点只有一个父节点，而孩子节点又构造出多个节点。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先看张图，方便了解下树的一些专业术语。&lt;/p&gt;
&lt;p class=&quot;customize-img&quot;&gt;&lt;img src=&quot;/assets/blogImg/algorithm/binarytree/tree-structure-1.png&quot; alt=&quot;树结构&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;根节点&lt;/code&gt;：根节点是没有父节点，图中的A节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;孩子节点/子节点&lt;/code&gt;：某个节点的孩子称为孩子节点，孩子节点/子节点是相对的，图中A的孩子节点有B、C、D，而B的孩子节点有E、F。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;叶子节点&lt;/code&gt;：某个节点没有孩子，图中的E、F、G、D。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;节点的度&lt;/code&gt;：某个节点的孩子节点个数，图中A有BCD（3）个孩子节点，B有EF（2）个孩子节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;树的层次&lt;/code&gt;：某个节点处于树中的层次，图中的A处于第1层。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;树的高/深度&lt;/code&gt;：树的最大层次，图中的高/深度为3。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来聊正题吧！&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="algorithm" scheme="http://zlia.tech/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>探索Stack底层实现</title>
    <link href="http://zlia.tech/2019/09/06/explain-stack-sourcecode/"/>
    <id>http://zlia.tech/2019/09/06/explain-stack-sourcecode/</id>
    <published>2019-09-06T06:10:06.000Z</published>
    <updated>2019-09-16T06:56:43.294Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a><div><span>简单介绍</span></div></h3><p><code>Stack</code>类就一百多行代码，简单说明下。它的特性是<code>后进先出（LIFO）</code>，继承了Vector类，大部分的操作都是使用Vector中的方法。在注释中，作者提醒我们若要使用后进先出的栈操作，应该优先使用<code>Deque</code>，这么说来，该类已经被放弃了，早在JDK1.0的时候它就出现了，是有点老了！我们说过Vector属于相对线程安全，所以Stack也是相对线程安全！探索<code>Stack</code>源代码是基于<code>JDK1.8</code>的。</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a><div><span>源码</span></div></h3><p>该类的代码不多，就不做分类了，不过为了方便理解，提供了它的数据结构图。</p><p class="customize-img"><img src="/assets/blogImg/java/stack/stack-data-structure.png" alt="Stack数据结构图"></p><p>说是后进先出，实际上它还是能通过调用Vector中的方法来破除该原则！该图只是告诉大家什么是<code>后进先出</code>。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 添加指定元素到栈的顶层</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 指定元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 指定元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">push</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">        addElement(item);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除栈的顶层元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 被移除的顶层元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        E obj;</span><br><span class="line">        <span class="keyword">int</span> len = size();</span><br><span class="line"></span><br><span class="line">        obj = peek();</span><br><span class="line">        removeElementAt(len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取栈的顶层元素</span></span><br><span class="line"><span class="comment">     * 若为空数组，则抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        <span class="keyword">return</span> elementAt(len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断数组是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 数组是否为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反向遍历获取指定元素的索引，返回指定元素的索引与顶层元素的索引之间的差值</span></span><br><span class="line"><span class="comment">     * 若未找到指定元素则返回-1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 差值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = lastIndexOf(o);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> size() - i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a><div><span>重点</span></div></h3><p><code>使用Deque代替Stack</code> <code>严格上说并不满足后进先出原则</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简单介绍&quot;&gt;&lt;a href=&quot;#简单介绍&quot; class=&quot;headerlink&quot; title=&quot;简单介绍&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;简单介绍&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Stack&lt;/code&gt;类就一百多行代码，简单说明下。它的特性是&lt;code&gt;后进先出（LIFO）&lt;/code&gt;，继承了Vector类，大部分的操作都是使用Vector中的方法。在注释中，作者提醒我们若要使用后进先出的栈操作，应该优先使用&lt;code&gt;Deque&lt;/code&gt;，这么说来，该类已经被放弃了，早在JDK1.0的时候它就出现了，是有点老了！我们说过Vector属于相对线程安全，所以Stack也是相对线程安全！探索&lt;code&gt;Stack&lt;/code&gt;源代码是基于&lt;code&gt;JDK1.8&lt;/code&gt;的。&lt;/p&gt;
&lt;h3 id=&quot;源码&quot;&gt;&lt;a href=&quot;#源码&quot; class=&quot;headerlink&quot; title=&quot;源码&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;源码&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;该类的代码不多，就不做分类了，不过为了方便理解，提供了它的数据结构图。&lt;/p&gt;
&lt;p class=&quot;customize-img&quot;&gt;&lt;img src=&quot;/assets/blogImg/java/stack/stack-data-structure.png&quot; alt=&quot;Stack数据结构图&quot;&gt;&lt;/p&gt;
&lt;p&gt;说是后进先出，实际上它还是能通过调用Vector中的方法来破除该原则！该图只是告诉大家什么是&lt;code&gt;后进先出&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索CopyOnWriteArrayList底层实现</title>
    <link href="http://zlia.tech/2019/09/05/explain-copyonwritearraylist-sourcecode/"/>
    <id>http://zlia.tech/2019/09/05/explain-copyonwritearraylist-sourcecode/</id>
    <published>2019-09-05T10:21:39.000Z</published>
    <updated>2019-11-06T10:02:09.960Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a><div><span>简单介绍</span></div></h3><p>由于<code>CopyOnWriteArrayList</code>的<code>注释</code>并不是很多，所以在这里简单的说明下，它属于线程安全，底层是通过<code>生成数组的新副本</code>来实现的，也就是在修改列表元素/结构的情况会生成新副本。简单地说，它是ArrayList的一个变体！探索<code>CopyOnWriteArrayList</code>源代码是基于<code>JDK1.8</code>版本的。</p><h3 id="开干"><a href="#开干" class="headerlink" title="开干"></a><div><span>开干</span></div></h3><p>开始进入到看源码的时间吧！</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//支持随机访问，可克隆，可序列化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8673264195747942595L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//目前先知道是锁就行了，后续会有新文章来进行详细说明</span></span><br><span class="line">    <span class="comment">//保证同一个时间内只有一个线程能访问，</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保证变量的可见性，但无法保证原子性</span></span><br><span class="line">    <span class="comment">//至于什么是可见性、原子性，较为难理解，况且也不是本章的重点，加上作者对其的理解还不够，所以后续才会出文章去做详细说明</span></span><br><span class="line">    <span class="comment">//该数组用于存放元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相比于ArrayList，为什么没有了size、modCount成员属性呢？</span></span><br><span class="line">    <span class="comment">//因为每次添加/删除元素时，都会生成数组的新副本，也就是说新副本代替了size的作用</span></span><br><span class="line">    <span class="comment">//modCount在ArrayList中主要用于在迭代器的结构修改判断中，而CopyOnWriteArrayList的迭代器中不支持结构修改，为什么不支持呢？</span></span><br><span class="line">    <span class="comment">//源码中并未提到为什么不支持，以下主要是自我的理解</span></span><br><span class="line">    <span class="comment">//结构修改中必然涉及到加锁，若对迭代器加锁了，要是对它进行遍历上千条数据，那其他线程就不用执行了，所以迭代器万不可加锁！</span></span><br><span class="line">    <span class="comment">//不能加锁，那对于结构的修改势必会造成并发访问的问题，所以目前是没有提供支持，纯属个人理解！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//JDK1.8并未有该类的相关注释，偏向底层，目前作者只知道它是跟锁有关联的，若想知道可自行百度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> lockOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = CopyOnWriteArrayList.class;</span><br><span class="line">            lockOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"lock"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建空数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建一个包含指定collection集合的对象，CopyOnWriteArrayList容量大小和该集合大小一致，指定集合中的元素按照迭代器的顺序排列</span></span><br><span class="line"><span class="comment"> * collection集合类型有Map、set、List等子类，所以入参可以是多种类型</span></span><br><span class="line"><span class="comment"> * CopyOnWriteArrayList保证数组中元素类型是Object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] elements;</span><br><span class="line">    <span class="keyword">if</span> (c.getClass() == CopyOnWriteArrayList.class)</span><br><span class="line">        elements = ((CopyOnWriteArrayList&lt;?&gt;)c).getArray();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        elements = c.toArray();</span><br><span class="line">        <span class="comment">//c.toArray 可能不会返回正确的Object[]类型，这边可能会利用多态的性质，如 A a = new B()</span></span><br><span class="line">        <span class="keyword">if</span> (elements.getClass() != Object[].class)</span><br><span class="line">            elements = Arrays.copyOf(elements, elements.length, Object[].class);</span><br><span class="line">    &#125;</span><br><span class="line">    setArray(elements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建一个包含指定数组的对象</span></span><br><span class="line"><span class="comment"> * 生成数组的新副本，并让该对象中的数组指向它</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toCopyIn 指定数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(E[] toCopyIn)</span> </span>&#123;</span><br><span class="line">    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h4><p>接下来按照类的声明顺序介绍<code>方法</code>，有必要的情况下结合例子进行说明。</p><h5 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组</span></span><br><span class="line"><span class="comment"> * 之所以没有加上private访问修饰符，是因为在CopyOnWriteArraySet类中使用了该方法</span></span><br><span class="line"><span class="comment"> * 加上final防止继承类去覆写该方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 新数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组元素的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组元素的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getArray().length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断数组是否为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组是否为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断两个对象是否相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o1 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o2 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 两个对象是否相等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">eq</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (o1 == <span class="keyword">null</span>) ? o2 == <span class="keyword">null</span> : o1.equals(o2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正向遍历，获取从指定起始索引到指定结束索引之间搜索指定元素的索引</span></span><br><span class="line"><span class="comment"> * 若指定区间不存在指定元素的话则返回-1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> elements 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fence 指定结束索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o, Object[] elements,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> index, <span class="keyword">int</span> fence)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; fence; i++)</span><br><span class="line">            <span class="keyword">if</span> (elements[i] == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; fence; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elements[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反向遍历，获取从指定起始索引到索引为0之间搜索指定元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> elements 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o, Object[] elements, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elements[i] == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elements[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断数组中是否包含指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组是否包含指定元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">return</span> indexOf(o, elements, <span class="number">0</span>, elements.length) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正向遍历，获取指定元素的索引</span></span><br><span class="line"><span class="comment"> * 若未发现指定元素则返回-1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">return</span> indexOf(o, elements, <span class="number">0</span>, elements.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正向遍历，获取从指定起始索引处开始搜索指定元素的索引</span></span><br><span class="line"><span class="comment"> * 若未发现指定元素则返回-1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(E e, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">return</span> indexOf(e, elements, index, elements.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反向遍历，获取指定元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">return</span> lastIndexOf(o, elements, elements.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反向遍历，获取从指定起始索引处开始搜索指定元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(E e, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">return</span> lastIndexOf(e, elements, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拷贝新的CopyOnWriteArrayList对象，没有拷贝对象中的数组，属于浅拷贝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        CopyOnWriteArrayList&lt;E&gt; clone =</span><br><span class="line">            (CopyOnWriteArrayList&lt;E&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        clone.resetLock();</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个包含所有列表元素的有序（按照添加顺序）数组</span></span><br><span class="line"><span class="comment"> * 此方法是创建一个新数组，方便使用者能够随便操作新数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elements, elements.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将列表的所有元素放入到指定数组中并返回</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：T类型要么是数组中数据的相同类型，要么是数组中数据的父类型，运用多态性质</span></span><br><span class="line"><span class="comment"> * 若传入的新数组容量 &lt; 列表容量，则取它的类类型来创建一个包含列表元素的新数组，并返回</span></span><br><span class="line"><span class="comment"> * 若传入的新数组容量 &gt; 列表容量，则将列表中的元素按照顺序拷贝到新数组中，同时将新数组中索引为size的值设置成null</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 一开始我也好奇为啥要在索引为size上设置个null呢？</span></span><br><span class="line"><span class="comment"> * 看了注释加上自我的理解，若传入的新数组是个空数组的话，那么除了拷贝列表元素后剩余的所有空间的值都为null，此时在给索引为size的值设置成null似乎没有多大</span></span><br><span class="line"><span class="comment"> * 意思；另外一种情况是若传入的新数组不是个空数组，那这个设置就有意义了，传入的新数组的某些元素会被列表元素覆盖，同时有个null，剩下的才是自己本身的数据，呈现这样子一种效果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment"> * list.add(11);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Integer[] str = new Integer[]&#123;1,2,3,4,5,6,7,8,9,10&#125;;</span></span><br><span class="line"><span class="comment"> * Integer[] s1 = list.toArray(str);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * for (Integer s : s1) &#123;</span></span><br><span class="line"><span class="comment"> *     System.out.println(s + ",");</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输出结果：11,null,3,4,5,6,7,8,9,10,</span></span><br><span class="line"><span class="comment"> * 那么设置这个null的意义就在于能够确定列表中元素个数（长度），但有个前提就是调用者知道链表中的所有节点信息不存在null才有意义，目前我只有想到这一种情况下有用！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 指定数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 填充完列表元素的指定数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T a[]) &#123;</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">int</span> len = elements.length;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; len)</span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elements, len, a.getClass());</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        System.arraycopy(elements, <span class="number">0</span>, a, <span class="number">0</span>, len);</span><br><span class="line">        <span class="keyword">if</span> (a.length &gt; len)</span><br><span class="line">            a[len] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断数组中是否包含指定集合中的所有元素</span></span><br><span class="line"><span class="comment"> * 集合中的元素但凡在数组中未包含则返回false</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组中是否包含指定集合中的所有元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">int</span> len = elements.length;</span><br><span class="line">    <span class="keyword">for</span> (Object e : c) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indexOf(e, elements, <span class="number">0</span>, len) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集合与数组取交集</span></span><br><span class="line"><span class="comment"> * 最终数组中只包含与集合共有的元素，相当于在修改数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组元素是否被修改成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="keyword">if</span> (len != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// temp array holds those elements we know we want to keep</span></span><br><span class="line">            <span class="keyword">int</span> newlen = <span class="number">0</span>;</span><br><span class="line">            Object[] temp = <span class="keyword">new</span> Object[len];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                Object element = elements[i];</span><br><span class="line">                <span class="keyword">if</span> (c.contains(element))</span><br><span class="line">                    temp[newlen++] = element;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newlen != len) &#123;</span><br><span class="line">                setArray(Arrays.copyOf(temp, newlen));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空数组中的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        setArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历数组，并对数组中的元素进行指定处理</span></span><br><span class="line"><span class="comment"> * 读取时不会发生冲突，因为添加、删除、替换等操作都是使用新副本，只不过会出现实时数据不一致，但最终是一致的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action 函数式接口，对数组中的元素指定处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">int</span> len = elements.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) elements[i];</span><br><span class="line">        action.accept(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定条件移除元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filter 使用指定条件来过滤元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> E&gt; filter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (filter == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="keyword">if</span> (len != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> newlen = <span class="number">0</span>;</span><br><span class="line">            Object[] temp = <span class="keyword">new</span> Object[len];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) elements[i];</span><br><span class="line">                <span class="keyword">if</span> (!filter.test(e))</span><br><span class="line">                    temp[newlen++] = e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newlen != len) &#123;</span><br><span class="line">                setArray(Arrays.copyOf(temp, newlen));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定规则替换所有旧元素</span></span><br><span class="line"><span class="comment"> * operator.apply方法：旧元素作为入参传入，根据规则返回新元素，然后进行替换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> operator 指定规则，函数式接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (operator == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) elements[i];</span><br><span class="line">            newElements[i] = operator.apply(e);</span><br><span class="line">        &#125;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定规则对数组中的元素进行排序</span></span><br><span class="line"><span class="comment"> * 若没有指定规则则使用默认的升序进行排序</span></span><br><span class="line"><span class="comment"> * 指定规则后会调用自定义比较器中的compare方法进行比较排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 自定义比较器，覆写compare方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, elements.length);</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E[] es = (E[])newElements;</span><br><span class="line">        Arrays.sort(es, c);</span><br><span class="line">        setArray(newElements);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义序列化</span></span><br><span class="line"><span class="comment"> * 写入数组的长度及数组的元素方便构建</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 输出流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="comment">// Write out array length</span></span><br><span class="line">    s.writeInt(elements.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (Object element : elements)</span><br><span class="line">        s.writeObject(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义反序列化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 输入流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成新的锁对象</span></span><br><span class="line">    resetLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = s.readInt();</span><br><span class="line">    SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, len);</span><br><span class="line">    Object[] elements = <span class="keyword">new</span> Object[len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        elements[i] = s.readObject();</span><br><span class="line">    setArray(elements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组元素的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组元素的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.toString(getArray());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先判断当前对象与指定对象是否指向同一个对象，就是在判断地址</span></span><br><span class="line"><span class="comment"> * 紧接着判断指定对象属于List的子类</span></span><br><span class="line"><span class="comment"> * 紧接着获取该对象的迭代器</span></span><br><span class="line"><span class="comment"> * 若两个迭代器的元素个数不相等，则返回false</span></span><br><span class="line"><span class="comment"> * 若两个迭代器的元素个数相等，则将两个迭代器的元素进行对应的比较，但凡出现对应的元素不相等则返回false</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 当前对象与指定对象是否相等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> List))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;?&gt; list = (List&lt;?&gt;)(o);</span><br><span class="line">    Iterator&lt;?&gt; it = list.iterator();</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">int</span> len = elements.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!it.hasNext() || !eq(elements[i], it.next()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (it.hasNext())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hashCode = <span class="number">1</span>;</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">int</span> len = elements.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        Object obj = elements[i];</span><br><span class="line">        hashCode = <span class="number">31</span>*hashCode + (obj==<span class="keyword">null</span> ? <span class="number">0</span> : obj.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取分割迭代器</span></span><br><span class="line"><span class="comment"> * 由于该方法涉及到另外一个接口，会另外新起一篇文章来讲解该内容，这里就不做阐述</span></span><br><span class="line"><span class="comment"> * 附上文章地址：http://zlia.tech/2019/08/28/explain-arraylist-spliterator-sourcecode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Spliterators.spliterator</span><br><span class="line">        (getArray(), Spliterator.IMMUTABLE | Spliterator.ORDERED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取指定起始索引到指定结束索引之间的元素，简称获取指定子集</span></span><br><span class="line"><span class="comment"> * 指定区间中的元素包括起始索引，不包括结束索引</span></span><br><span class="line"><span class="comment"> * 若起始索引与结束索引相等，则返回空元素</span></span><br><span class="line"><span class="comment"> * 对子集的操作，即调用set、add、remove等方法将会影响到整个数组</span></span><br><span class="line"><span class="comment"> * 但在先获取子集后，又对整个数组的结构进行修改，这时在遍历子集则会导致报错，而对于整体的非结构性修改则不会报错，不过依然会影响到子集</span></span><br><span class="line"><span class="comment"> * 所以在获取子集后最好不要修改数组的结构</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 代码片段与ArrayList是类似的，可参考ArrayList文章：http://zlia.tech/2019/08/16/explain-arraylist-sourcecode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromIndex 起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toIndex 结束索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定区间中的所有元素，称为子集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span> || toIndex &gt; len || fromIndex &gt; toIndex)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> COWSubList&lt;E&gt;(<span class="keyword">this</span>, fromIndex, toIndex);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重置锁，生成新的锁对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resetLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UNSAFE.putObjectVolatile(<span class="keyword">this</span>, lockOffset, <span class="keyword">new</span> ReentrantLock());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取指定索引的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定索引的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取指定索引的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定索引的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定索引处的元素修改成指定元素</span></span><br><span class="line"><span class="comment"> * 在执行操作之前，先加上锁，接着生成数组的新副本，在新副本中替换元素，最后将数组指向新副本并释放锁</span></span><br><span class="line"><span class="comment"> * 在未释放锁之前，其他线程无法进入，这样子就保证了线程安全</span></span><br><span class="line"><span class="comment"> * 每次调用该方法都会造成新副本数组的生成，导致内存飙升</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 新元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oldValue != element) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setArray(elements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定元素到列表尾部</span></span><br><span class="line"><span class="comment"> * 在执行操作之前，先加上锁，接着生成数组的新副本，并扩充其容量，最后将数组指向新副本并释放锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定元素到指定索引处</span></span><br><span class="line"><span class="comment"> * 由于每次都会生成新副本，原先数组的前index元素列表会拷贝到新副本中，再者原先数据的后index元素列表会拷贝到新副本中</span></span><br><span class="line"><span class="comment"> * 原先数组中的所有元素都拷贝到了新副本中，最终在新副本中的index位置为null，最后在设置指定元素即可</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 指定元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; len || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index+</span><br><span class="line">                                                <span class="string">", Size: "</span>+len);</span><br><span class="line">        Object[] newElements;</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            newElements = <span class="keyword">new</span> Object[len + <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            System.arraycopy(elements, index, newElements, index + <span class="number">1</span>,</span><br><span class="line">                             numMoved);</span><br><span class="line">        &#125;</span><br><span class="line">        newElements[index] = element;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 若数组中未包含指定元素则进行添加到尾部</span></span><br><span class="line"><span class="comment"> * 若数组中已经存在指定元素则返回false</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addIfAbsent</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    Object[] snapshot = getArray();</span><br><span class="line">    <span class="keyword">return</span> indexOf(e, snapshot, <span class="number">0</span>, snapshot.length) &gt;= <span class="number">0</span> ? <span class="keyword">false</span> :</span><br><span class="line">        addIfAbsent(e, snapshot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 若新副本中未包含指定元素则进行添加到尾部</span></span><br><span class="line"><span class="comment"> * 若是新副本中已经存在指定元素则返回false</span></span><br><span class="line"><span class="comment"> * 至始至终snapshot都是用来做与新副本进行比较的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> snapshot 数组，有可能成为旧数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addIfAbsent</span><span class="params">(E e, Object[] snapshot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] current = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = current.length;</span><br><span class="line">        <span class="keyword">if</span> (snapshot != current) &#123;</span><br><span class="line">            <span class="comment">//生成了新的数组副本</span></span><br><span class="line">            <span class="keyword">int</span> common = Math.min(snapshot.length, len);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; common; i++)</span><br><span class="line">                <span class="keyword">if</span> (current[i] != snapshot[i] &amp;&amp; eq(e, current[i]))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (indexOf(e, current, common, len) &gt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(current, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加集合中未被数组包含的元素到数组尾部，相当于批量添加不存在的元素到尾部</span></span><br><span class="line"><span class="comment"> * 集合中重复的元素只会被添加一次</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 添加到数组中的元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addAllAbsent</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] cs = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> (cs.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="keyword">int</span> added = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// uniquify and compact elements in cs</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cs.length; ++i) &#123;</span><br><span class="line">            Object e = cs[i];</span><br><span class="line">            <span class="keyword">if</span> (indexOf(e, elements, <span class="number">0</span>, len) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                indexOf(e, cs, <span class="number">0</span>, added) &lt; <span class="number">0</span>)</span><br><span class="line">                cs[added++] = e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (added &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + added);</span><br><span class="line">            System.arraycopy(cs, <span class="number">0</span>, newElements, len, added);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> added;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定集合添加到数组尾部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] cs = (c.getClass() == CopyOnWriteArrayList.class) ?</span><br><span class="line">        ((CopyOnWriteArrayList&lt;?&gt;)c).getArray() : c.toArray();</span><br><span class="line">    <span class="keyword">if</span> (cs.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span> &amp;&amp; cs.getClass() == Object[].class)</span><br><span class="line">            setArray(cs);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + cs.length);</span><br><span class="line">            System.arraycopy(cs, <span class="number">0</span>, newElements, len, cs.length);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定集合添加到数组的指定索引处</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] cs = c.toArray();</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; len || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index+</span><br><span class="line">                                                <span class="string">", Size: "</span>+len);</span><br><span class="line">        <span class="keyword">if</span> (cs.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index;</span><br><span class="line">        Object[] newElements;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            newElements = Arrays.copyOf(elements, len + cs.length);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            newElements = <span class="keyword">new</span> Object[len + cs.length];</span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            System.arraycopy(elements, index,</span><br><span class="line">                             newElements, index + cs.length,</span><br><span class="line">                             numMoved);</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(cs, <span class="number">0</span>, newElements, index, cs.length);</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除数组中指定索引处的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除数组中的指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    Object[] snapshot = getArray();</span><br><span class="line">    <span class="keyword">int</span> index = indexOf(o, snapshot, <span class="number">0</span>, snapshot.length);</span><br><span class="line">    <span class="keyword">return</span> (index &lt; <span class="number">0</span>) ? <span class="keyword">false</span> : remove(o, snapshot, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除数组中的指定索引处的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> snapshot 数组，有可能是旧数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o, Object[] snapshot, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] current = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = current.length;</span><br><span class="line">        <span class="keyword">if</span> (snapshot != current) findIndex: &#123;</span><br><span class="line">            <span class="comment">//这部分代码是获取新副本中指定元素的索引，也就是获取最新的索引，看看新副本中有没有存在等于指定元素的更小索引</span></span><br><span class="line">            <span class="keyword">int</span> prefix = Math.min(index, len);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (current[i] != snapshot[i] &amp;&amp; eq(o, current[i])) &#123;</span><br><span class="line">                    index = i;</span><br><span class="line">                    <span class="keyword">break</span> findIndex; <span class="comment">//表示跳出指定代码块</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若在新副本中未找到指定元素的索引则index不会被改变，此时的情况应该是：旧数组的长度大于新副本数组的长度，那么最终会返回false</span></span><br><span class="line">            <span class="keyword">if</span> (index &gt;= len)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//判断新副本的指定索引处的元素是否与指定元素相等，若相等则说明该位置的元素并未发生改变</span></span><br><span class="line">            <span class="keyword">if</span> (current[index] == o)</span><br><span class="line">                <span class="keyword">break</span> findIndex;</span><br><span class="line">            <span class="comment">//此时的情况是：新副本数组的长度大于旧数组的长度，获取新副本中指定元素的索引</span></span><br><span class="line">            index = indexOf(o, current, index, len);</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">        System.arraycopy(current, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">        System.arraycopy(current, index + <span class="number">1</span>,</span><br><span class="line">                         newElements, index,</span><br><span class="line">                         len - index - <span class="number">1</span>);</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除指定起始索引到结束索引之间的所有元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromIndex 指定起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toIndex 指定结束索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span> || toIndex &gt; len || toIndex &lt; fromIndex)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        <span class="keyword">int</span> newlen = len - (toIndex - fromIndex);</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - toIndex;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            setArray(Arrays.copyOf(elements, newlen));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> Object[newlen];</span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, fromIndex);</span><br><span class="line">            System.arraycopy(elements, toIndex, newElements,</span><br><span class="line">                             fromIndex, numMoved);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组中移除指定集合的所有元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="keyword">if</span> (len != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// temp array holds those elements we know we want to keep</span></span><br><span class="line">            <span class="keyword">int</span> newlen = <span class="number">0</span>;</span><br><span class="line">            Object[] temp = <span class="keyword">new</span> Object[len];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                Object element = elements[i];</span><br><span class="line">                <span class="keyword">if</span> (!c.contains(element))</span><br><span class="line">                    temp[newlen++] = element;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newlen != len) &#123;</span><br><span class="line">                setArray(Arrays.copyOf(temp, newlen));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 迭代器 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> COWIterator&lt;E&gt;(getArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> COWIterator&lt;E&gt;(getArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取从指定起始索引开始的列表迭代器</span></span><br><span class="line"><span class="comment"> * 列表迭代器中的元素是从指定索引开始到结束索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 列表迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">int</span> len = elements.length;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; len)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> COWIterator&lt;E&gt;(elements, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 列表迭代器，正向迭代</span></span><br><span class="line"><span class="comment"> * 可获取上一个元素、下一个元素及索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">COWIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当迭代器被创建后，只拿到当前数组的引用，也就是说只拥有当前数组的元素</span></span><br><span class="line">    <span class="comment">//而随着后面列表的add、remove、repalce都是在操作新副本，这些变动并不会反映到当前的引用，相当于是两个引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下一个元素的索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> elements 当前数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCursor 下一个元素的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">COWIterator</span><span class="params">(Object[] elements, <span class="keyword">int</span> initialCursor)</span> </span>&#123;</span><br><span class="line">        cursor = initialCursor;</span><br><span class="line">        snapshot = elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 判断是否有下一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否有下一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &lt; snapshot.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否有前一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否有前一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个元素的值</span></span><br><span class="line"><span class="comment">     * 若不存在则抛出异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个元素的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasNext())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取上一个元素</span></span><br><span class="line"><span class="comment">     * 若不存在则抛出异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 上一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasPrevious())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> (E) snapshot[--cursor];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个元素的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个元素的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取上一个元素的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 上一个元素的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不支持，为什么不支持在数据结构那一栏中有提到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不支持，为什么不支持在数据结构那一栏中有提到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不支持，为什么不支持在数据结构那一栏中有提到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历元素，只能遍历一次</span></span><br><span class="line"><span class="comment">     * 与forEach的区别在于：可以遍历多次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> consumer 函数式接口，声明如何处理元素的函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        Object[] elements = snapshot;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = elements.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cursor; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) elements[i];</span><br><span class="line">            action.accept(e);</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>CopyOnWriteArrayList允许存放Null。</p></li><li><p>底层通过生成数组的新副本实现，故内存占用是个明显的问题。</p></li><li><p>多线程情况下，可能读取旧数据，只能保证数据的最终一致性。</p></li><li><p>CopyOnWriteArrayList适用于读多写少的场景。</p></li><li><p>CopyOnWriteArrayList在性能上没有ArrayList、LinkedList好，毕竟加了锁！</p></li><li><p>CopyOnWriteArrayList没有扩容机制，每次添加节点前就拷贝源数组到新数组中，而新数组与源数组的长度差为1</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>线程安全</code> <code>底层是通过生成数组的新副本实现</code> <code>由于每次都生成新副本，故内存占用会相对更大</code> <code>多线程情况下，可能读取到旧数据（读取在添加之前执行）</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简单介绍&quot;&gt;&lt;a href=&quot;#简单介绍&quot; class=&quot;headerlink&quot; title=&quot;简单介绍&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;简单介绍&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;由于&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;的&lt;code&gt;注释&lt;/code&gt;并不是很多，所以在这里简单的说明下，它属于线程安全，底层是通过&lt;code&gt;生成数组的新副本&lt;/code&gt;来实现的，也就是在修改列表元素/结构的情况会生成新副本。简单地说，它是ArrayList的一个变体！探索&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;源代码是基于&lt;code&gt;JDK1.8&lt;/code&gt;版本的。&lt;/p&gt;
&lt;h3 id=&quot;开干&quot;&gt;&lt;a href=&quot;#开干&quot; class=&quot;headerlink&quot; title=&quot;开干&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;开干&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;开始进入到看源码的时间吧！&lt;/p&gt;
&lt;h4 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//支持随机访问，可克隆，可序列化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CopyOnWriteArrayList&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;List&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt;, &lt;span class=&quot;title&quot;&gt;RandomAccess&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Cloneable&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;java&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;io&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Serializable&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//序列号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; serialVersionUID = &lt;span class=&quot;number&quot;&gt;8673264195747942595L&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//目前先知道是锁就行了，后续会有新文章来进行详细说明&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//保证同一个时间内只有一个线程能访问，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;transient&lt;/span&gt; ReentrantLock lock = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ReentrantLock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//保证变量的可见性，但无法保证原子性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//至于什么是可见性、原子性，较为难理解，况且也不是本章的重点，加上作者对其的理解还不够，所以后续才会出文章去做详细说明&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//该数组用于存放元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;transient&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;volatile&lt;/span&gt; Object[] array;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//相比于ArrayList，为什么没有了size、modCount成员属性呢？&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//因为每次添加/删除元素时，都会生成数组的新副本，也就是说新副本代替了size的作用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//modCount在ArrayList中主要用于在迭代器的结构修改判断中，而CopyOnWriteArrayList的迭代器中不支持结构修改，为什么不支持呢？&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//源码中并未提到为什么不支持，以下主要是自我的理解&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//结构修改中必然涉及到加锁，若对迭代器加锁了，要是对它进行遍历上千条数据，那其他线程就不用执行了，所以迭代器万不可加锁！&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//不能加锁，那对于结构的修改势必会造成并发访问的问题，所以目前是没有提供支持，纯属个人理解！&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//JDK1.8并未有该类的相关注释，偏向底层，目前作者只知道它是跟锁有关联的，若想知道可自行百度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; sun.misc.Unsafe UNSAFE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; lockOffset;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            UNSAFE = sun.misc.Unsafe.getUnsafe();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Class&amp;lt;?&amp;gt; k = CopyOnWriteArrayList.class;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            lockOffset = UNSAFE.objectFieldOffset&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                (k.getDeclaredField(&lt;span class=&quot;string&quot;&gt;&quot;lock&quot;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Error(e);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList与LinkedList的性能比较</title>
    <link href="http://zlia.tech/2019/09/02/arraylist-linkedlist-perfermance-compare/"/>
    <id>http://zlia.tech/2019/09/02/arraylist-linkedlist-perfermance-compare/</id>
    <published>2019-09-02T15:44:31.000Z</published>
    <updated>2019-09-02T15:51:13.322Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>我们都知道<code>ArrayList适合查询/替换</code>、<code>LinkedList适合添加/删除</code>，造成这样子的原因也在于它们底层的实现。光说这些理论似乎大家都会，所以准备用更加具体的例子来证明它，也能更好地比较这两者之间的性能关系。在测试具体场景前，简单说明下环境配置，window环境下：内存8个G；JDK8；i7处理器。</p><h3 id="测试场景"><a href="#测试场景" class="headerlink" title="测试场景"></a><div><span>测试场景</span></div></h3><p>分别准备1w、5w、10w、50w、100w条数据，也就是说数据类别有上面这几种，将它们分别按照下列场景测试。</p><ul><li><p>在首部、尾部添加元素/节点的效率。</p></li><li><p>随机位置/索引插入元素/节点的效率。</p></li><li><p>在首部、尾部删除元素/节点的效率。</p></li><li><p>随机位置/索引删除元素/节点的效率。</p></li><li><p>随机位置/索引获取元素/节点的效率。</p></li><li><p>随机位置/索引修改元素/节点的效率。</p></li></ul><a id="more"></a><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a><div><span>测试结果</span></div></h3><p>测试结果将以表格的方式展示。</p><ul><li>在首部、尾部添加元素/节点。</li></ul><p>A首：ArrayList首部添加元素，L首：LinkedList首部添加元素，A尾：ArrayList尾部添加元素，L尾：LinkedList尾部添加元素。</p><p class="customize-img"><img src="/assets/blogImg/java/arraylist-compare-linkedlist/arraylist-compare-linkedlist-1.png" alt="ArrayList注释-1"></p><ul><li>随机位置/索引插入元素/节点。</li></ul><p>A随：ArrayList随机位置添加元素，L随：LinkedList随机位置添加元素。</p><p class="customize-img"><img src="/assets/blogImg/java/arraylist-compare-linkedlist/arraylist-compare-linkedlist-2.png" alt="ArrayList注释-2"></p><p>由于50w、100w执行时间过长故并未给出具体时间，不过已经足以说明结果了。</p><ul><li>在首部、尾部删除元素/节点。</li></ul><p>A首：ArrayList首部删除元素，L首：LinkedList首部删除元素，A尾：ArrayList尾部删除元素，L尾：LinkedList尾部删除元素。</p><p class="customize-img"><img src="/assets/blogImg/java/arraylist-compare-linkedlist/arraylist-compare-linkedlist-3.png" alt="ArrayList注释-3"></p><ul><li>随机位置/索引删除元素/节点。</li></ul><p class="customize-img"><img src="/assets/blogImg/java/arraylist-compare-linkedlist/arraylist-compare-linkedlist-4.png" alt="ArrayList注释-4"></p><p>同上。</p><ul><li>随机位置/索引获取元素/节点。</li></ul><p class="customize-img"><img src="/assets/blogImg/java/arraylist-compare-linkedlist/arraylist-compare-linkedlist-5.png" alt="ArrayList注释-5"></p><p>同上。</p><ul><li>随机位置/索引替换元素/节点。</li></ul><p class="customize-img"><img src="/assets/blogImg/java/arraylist-compare-linkedlist/arraylist-compare-linkedlist-6.png" alt="ArrayList注释-6"></p><p>同上。</p><h3 id="测试结果分析"><a href="#测试结果分析" class="headerlink" title="测试结果分析"></a><div><span>测试结果分析</span></div></h3><p>以上的测试方式较为简单，没有考虑其他太多的因素，所以不要纠结于具体的时间，而是要了解它们的性能趋势。从测试结果来看，可以得到更为具体的结论：</p><ul><li><p><code>在首部添加/删除元素/节点过程中</code>，随着数据量的不断增大，<code>LinkedList明显要比ArrayList优秀很多</code>，<code>而对于尾部添加/删除</code>，<code>两者则差别不大</code>。</p></li><li><p>在随机插入/删除/获取/替换元素/节点过程中，随着数据量的不断增大，ArrayList明显要比LinkedList优秀很多！</p></li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a><div><span>结论</span></div></h3><ul><li><p><code>ArrayList比LinkedList更能适应大多数情况</code>。</p></li><li><p>频繁在首部添加/删除元素/节点，不需要过多的访问，可能更适合LinkedList。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;我们都知道&lt;code&gt;ArrayList适合查询/替换&lt;/code&gt;、&lt;code&gt;LinkedList适合添加/删除&lt;/code&gt;，造成这样子的原因也在于它们底层的实现。光说这些理论似乎大家都会，所以准备用更加具体的例子来证明它，也能更好地比较这两者之间的性能关系。在测试具体场景前，简单说明下环境配置，window环境下：内存8个G；JDK8；i7处理器。&lt;/p&gt;
&lt;h3 id=&quot;测试场景&quot;&gt;&lt;a href=&quot;#测试场景&quot; class=&quot;headerlink&quot; title=&quot;测试场景&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;测试场景&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;分别准备1w、5w、10w、50w、100w条数据，也就是说数据类别有上面这几种，将它们分别按照下列场景测试。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在首部、尾部添加元素/节点的效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;随机位置/索引插入元素/节点的效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在首部、尾部删除元素/节点的效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;随机位置/索引删除元素/节点的效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;随机位置/索引获取元素/节点的效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;随机位置/索引修改元素/节点的效率。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索LinkedList底层实现</title>
    <link href="http://zlia.tech/2019/09/02/explain-linkedlist-sourcecode/"/>
    <id>http://zlia.tech/2019/09/02/explain-linkedlist-sourcecode/</id>
    <published>2019-09-02T06:59:49.000Z</published>
    <updated>2019-10-31T03:30:08.354Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>老样子，还是先看注释！本来以为能收获点什么干货，结果注释与<code>ArrayList</code>的注释基本相同，有点尴尬…LinkedList的源码是基于<code>JDK1.8</code>。</p><h3 id="开干"><a href="#开干" class="headerlink" title="开干"></a><div><span>开干</span></div></h3><p>先上LinkedList类的注释，在深入到类中详细说明属性与方法。</p><a id="more"></a><h4 id="阅读注释"><a href="#阅读注释" class="headerlink" title="阅读注释"></a>阅读注释</h4><p class="customize-img"><img src="/assets/blogImg/java/linkedlist/linkedlist-comment-1.png" alt="LinkedList注释-1"></p><p class="customize-img"><img src="/assets/blogImg/java/linkedlist/linkedlist-comment-2.png" alt="LinkedList注释-2"></p><p>它的意思是：通过索引来操作LinkedList的话，每次都需要从头或从尾开始一个一个遍历，直到遇到指定的索引。</p><p class="customize-img"><img src="/assets/blogImg/java/linkedlist/linkedlist-comment-3.png" alt="LinkedList注释-3"></p><p>也是非线程安全，所以在多线程环境下要在外部控制同步防止数据紊乱。</p><p class="customize-img"><img src="/assets/blogImg/java/linkedlist/linkedlist-comment-4.png" alt="LinkedList注释-4"></p><p>不多说了。</p><p class="customize-img"><img src="/assets/blogImg/java/linkedlist/linkedlist-comment-5.png" alt="LinkedList注释-5"></p><p>有一个点要注意下，获取迭代器后，不能在直接通过对象调用方法去修改结构，只能通过迭代器去调用，否则将会抛出异常。</p><p class="customize-img"><img src="/assets/blogImg/java/linkedlist/linkedlist-comment-6.png" alt="LinkedList注释-6"></p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>接下来将详细说明LinkedList类的属性与方法，在这之前，先通过一张图简单了解下它的数据结构。</p><p class="customize-img"><img src="/assets/blogImg/java/linkedlist/linkedlist-data-structure.png" alt="LinkedList注释-6"></p><p>很简单的一张图，每一个节点都保存了当前节点的信息，同时又关联了下一个节点与上一个节点。若要获取指定节点信息，那么只能通过这种关联关系来找到具体节点，这也奠定了它<code>查找</code>的速度相对于<code>ArrayList</code>来说要慢很多，但也是由于有这层关系，<code>添加/删除</code>的速度相对于<code>ArrayList</code>来说要更快，<code>毕竟它只需要更改当前节点关联的上下节点关系即可，而ArrayList需要移动一波元素</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//支持克隆、序列化、双端队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//链表的容量大小，意指包含多少个节点</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//链表的第一个节点，也就是首部节点</span></span><br><span class="line">    <span class="comment">//链表中的每一个节点都保存着当前节点的信息、上一个节点的地址、下一个节点的地址</span></span><br><span class="line">    <span class="comment">//首部节点的上一个节点指向null</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//链表的最后一个节点，也就是尾部节点</span></span><br><span class="line">    <span class="comment">//尾部节点的下一个节点指向null</span></span><br><span class="line">    <span class="comment">//有了首部节点为什么还要有个尾部节点呢，个人理解是为了方便遍历计算</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinkedList的底层是通过链表实现的，并不需要提供成员属性来预先开辟内存空间以便后续的存储节点，所以<code>它充分利用了内存空间，实现灵活的内存管理</code>，不存在什么扩容机制。也正因为此，它并未提供有入参initCapacity的构造函数，在实现上看起来比ArrayList更简单。</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空参数构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个包含指定集合的链表</span></span><br><span class="line"><span class="comment"> * 指定集合中的节点按照迭代器的顺序依次添加到链表的尾部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉上确实比ArrayList简单多了，不用考虑那么多，直接new一个对象即可。</p><h4 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h4><p>接下来按照类的声明顺序介绍<code>方法</code>，有必要的情况下结合例子进行说明。</p><h5 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定节点到首部</span></span><br><span class="line"><span class="comment"> * 指定节点作为首部节点，它的上一个节点指向null</span></span><br><span class="line"><span class="comment"> * 若是空链表，当添加指定节点时首部节点与尾部节点指向同一个节点，即指定节点</span></span><br><span class="line"><span class="comment"> * 若不是空链表，则将原先的首部节点的上一个节点指向指定节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定节点到尾部</span></span><br><span class="line"><span class="comment"> * 指定节点作为尾部节点，它的下一个节点指向null</span></span><br><span class="line"><span class="comment"> * 若是空链表，当添加指定节点时首部节点与尾部节点指向同一个节点，即指定节点</span></span><br><span class="line"><span class="comment"> * 若不是空链表，则将原先的尾部节点的下一个节点指向指定节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定节点到指定节点succ前</span></span><br><span class="line"><span class="comment"> * 在添加节点时，更换对应上下节点的指向地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 添加的指定节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> succ 指定节点处</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除首部节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> f 首部节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除尾部节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> l 尾部节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> E element = l.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除指定节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 指定节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定节点的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否包含指定信息</span></span><br><span class="line"><span class="comment"> * 一个节点一个节点的判断是否与指定信息相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正向遍历的方式获取指定信息的位置</span></span><br><span class="line"><span class="comment"> * 由于是链表的数据结构，每个节点只知道自己的信息与上下两个节点，所以每次查找时都只能从头/尾开始遍历</span></span><br><span class="line"><span class="comment"> * 相当于是一个人一个人的问，直到问到自己想要的人</span></span><br><span class="line"><span class="comment"> * 若未找到指定节点则返回-1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> 0 指定信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定信息的位置或-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取节点个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空所有节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">        Node&lt;E&gt; next = x.next;</span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">    first = last = <span class="keyword">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断指定位置是否越界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否越界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断指定位置是否合法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否合法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取指定位置越界或不合法的信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">outOfBoundsMsg</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Index: "</span>+index+<span class="string">", Size: "</span>+size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 校验指定位置是否越界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isElementIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 校验指定位置是否合法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取指定位置的节点</span></span><br><span class="line"><span class="comment"> * 先判断指定位置处于0-mid-size的哪个区间，避免从头遍历消耗不必要的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反向遍历的方式获取指定信息的位置</span></span><br><span class="line"><span class="comment"> * 由于是链表的数据结构，每个节点只知道自己的信息与上下两个节点，所以每次查找时都只能从头/尾开始遍历</span></span><br><span class="line"><span class="comment"> * 相当于是一个人一个人的问，直到问到自己想要的人</span></span><br><span class="line"><span class="comment"> * 若未找到指定节点则返回-1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> 0 指定信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定信息的位置或-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = size;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储每个节点的信息及指向上下节点的地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当前节点的信息</span></span><br><span class="line">    E item;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前节点的下一个节点</span></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前节点的上一个节点</span></span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prev 当前节点的上一个节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element 当前节点的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> next 当前节点的下一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用该clone之前，该类要实现Cloneable，不然会抛出异常</span></span><br><span class="line"><span class="comment"> * 浅拷贝与深拷贝，举个例子吧</span></span><br><span class="line"><span class="comment"> * 比如A类中包含基本类型与B类，当调用A类clone方法后，两个A对象肯定是不一致，不然就不叫做拷贝了，不过这不是关键</span></span><br><span class="line"><span class="comment"> * 若A1对象中的B对象与A2对象中的B对象指向同一个对象，则认为它是浅拷贝，认为B没有被拷贝新的一份</span></span><br><span class="line"><span class="comment"> * 若两者指向不相等的话，则认为深拷贝，认为B重新拷贝了一份，不过这通常需要我们自定义代码，就像下面的方法一样</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 克隆后的新对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> LinkedList&lt;E&gt; <span class="title">superClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (LinkedList&lt;E&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;E&gt; clone = superClone();</span><br><span class="line"></span><br><span class="line">    clone.first = clone.last = <span class="keyword">null</span>;</span><br><span class="line">    clone.size = <span class="number">0</span>;</span><br><span class="line">    clone.modCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        clone.add(x.item);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造新数组，存放链表中的所有节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有节点信息的新数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    Object[] result = <span class="keyword">new</span> Object[size];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        result[i++] = x.item;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将链表中的所有节点信息放入到指定数组中并返回</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 一开始我也好奇为啥要在索引为size上设置个null呢？</span></span><br><span class="line"><span class="comment"> * 看了注释加上自我的理解，若传入的新数组是个空数组的话，那么除了拷贝列表元素后剩余的所有空间的值都为null，此时在给索引为size的值设置成null似乎没有多大</span></span><br><span class="line"><span class="comment"> * 意思；另外一种情况是若传入的新数组不是个空数组，那这个设置就有意义了，传入的新数组的某些元素会被列表元素覆盖，同时有个null，剩下的才是自己本身的数据，呈现这样子一种效果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment"> * list.add(11);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Integer[] str = new Integer[]&#123;1,2,3,4,5,6,7,8,9,10&#125;;</span></span><br><span class="line"><span class="comment"> * Integer[] s1 = list.toArray(str);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * for (Integer s : s1) &#123;</span></span><br><span class="line"><span class="comment"> *     System.out.println(s + ",");</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输出结果：11,null,3,4,5,6,7,8,9,10,</span></span><br><span class="line"><span class="comment"> * 那么设置这个null的意义就在于能够确定列表中元素个数（长度），但有个前提就是调用者知道链表中的所有节点信息不存在null才有意义，目前我只有想到这一种情况下有用！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 指定数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 填充完链表所有节点信息的指定数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        a = (T[])java.lang.reflect.Array.newInstance(</span><br><span class="line">                            a.getClass().getComponentType(), size);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    Object[] result = a;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        result[i++] = x.item;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义序列化</span></span><br><span class="line"><span class="comment"> * 每个节点当中保存的上下节点的关联关系对于序列化来说可有可无，只要你按次序保存好每个节点的信息，反序列化后依然可以构造出这些关联关系</span></span><br><span class="line"><span class="comment"> * 默认的序列化机制会将非静态与非瞬时（非transient修饰）写入流中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 输出流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        s.writeObject(x.item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义反序列化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 输入流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = s.readInt();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        linkLast((E)s.readObject());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取分割迭代器</span></span><br><span class="line"><span class="comment"> * 分割迭代器的方法作用都是类似的，不同的地方在于算法的实现上，所以不在做重复的分析，可参考另外一篇文章的详细介绍</span></span><br><span class="line"><span class="comment"> * 附上文章地址：http://zlia.tech/2019/08/28/explain-arraylist-spliterator-sourcecode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LLSpliterator&lt;E&gt;(<span class="keyword">this</span>, -<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很多方法都没有过多的说明，是因为可能涉及到算法或者只要简单画一画就能理解了！</p><h5 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取首部节点信息</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 首部节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取尾部节点信息</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 尾部节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取指定位置的信息</span></span><br><span class="line"><span class="comment"> * 校验位置是否越界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定位置的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取首部节点信息</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会返回null</span></span><br><span class="line"><span class="comment"> * 该方法比getFirst更友好</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 首部节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取首部节点信息</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 首部节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取首部节点信息</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会返回null</span></span><br><span class="line"><span class="comment"> * 该方法比getFirst更友好</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 首部节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取尾部节点信息</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会返回null</span></span><br><span class="line"><span class="comment"> * 该方法比getLast更友好</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 首部节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="移除节点"><a href="#移除节点" class="headerlink" title="移除节点"></a>移除节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除首部节点</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 首部节点的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除尾部节点</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 尾部节点的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除指定信息</span></span><br><span class="line"><span class="comment"> * 由于是链表的数据结构，每个节点只知道自己的信息与上下两个节点，所以每次查找时都只能从头开始遍历</span></span><br><span class="line"><span class="comment"> * 相当于是一个人一个人的问，直到问到自己想要的人</span></span><br><span class="line"><span class="comment"> * 若未找到指定节点则返回false</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除指定位置的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除首部节点，相当于队列取出元素</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会返回null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除首部节点</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 首部节点的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除首部节点，相当于队列取出元素</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会返回null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除尾部节点，相当于队列取出元素</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会返回null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正向遍历，删除指定节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否删除指定节点信息成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeFirstOccurrence</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remove(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反向遍历，删除指定节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否删除指定节点信息成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeLastOccurrence</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定信息到首部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定信息到尾部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定信息到尾部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定集合信息到尾部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在指定位置添加指定集合信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        succ = <span class="keyword">null</span>;</span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size += numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定节点信息到指定位置上</span></span><br><span class="line"><span class="comment"> * 在添加过程中只需要修改旧节点的上下节点关联关系即可，可以说效率提升了很多</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 指定节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定节点信息到尾部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定节点信息到首部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定节点信息到尾部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="修改节点"><a href="#修改节点" class="headerlink" title="修改节点"></a>修改节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改指定位置的节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 指定节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含指定位置开始到结尾之间的节点的正向迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含指定位置到结尾之间的节点的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 列表迭代器，正向迭代</span></span><br><span class="line"><span class="comment"> * 可获取上一个元素、下一个元素及位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指向当前节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; lastReturned;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指向上/下一个节点，随着调用方法的不同指向便不同</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上/下一个节点的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nextIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每次调用迭代器中的方法时，都会判断是否调用了LinkedList的外部方法去修改结构列表，如此的操作通常会造成快速失败</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化参数，设置下一个节点及下一个节点的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 当前位置，调用迭代器中的方法时该位置对应的节点信息是第一个获取到的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="comment">// assert isPositionIndex(index);</span></span><br><span class="line">        next = (index == size) ? <span class="keyword">null</span> : node(index);</span><br><span class="line">        nextIndex = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否有下一个节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否有下一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex &lt; size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个节点的信息</span></span><br><span class="line"><span class="comment">     * 初始化时的入参index对应的节点作为开始</span></span><br><span class="line"><span class="comment">     * 在获取下一个节点信息前，会判断是否造成了快速失败</span></span><br><span class="line"><span class="comment">     * 在获取完下一个节点后，将其指向赋值給lastReturned，同时修改next指向下一个节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个节点的信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">if</span> (!hasNext())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">        lastReturned = next;</span><br><span class="line">        next = next.next;</span><br><span class="line">        nextIndex++;</span><br><span class="line">        <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否有上一个节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否有上一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取上一个节点的信息</span></span><br><span class="line"><span class="comment">     * 初始化时的入参index对应的节点的上一个节点作为开始</span></span><br><span class="line"><span class="comment">     * 在获取下一个节点信息前，会判断是否造成了快速失败</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 上一个节点的信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">if</span> (!hasPrevious())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">        lastReturned = next = (next == <span class="keyword">null</span>) ? last : next.prev;</span><br><span class="line">        nextIndex--;</span><br><span class="line">        <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个节点的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个节点的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取上一个节点的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 上一个节点的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除当前节点，也就是lastReturned指向的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line"></span><br><span class="line">        Node&lt;E&gt; lastNext = lastReturned.next;</span><br><span class="line">        unlink(lastReturned);</span><br><span class="line">        <span class="keyword">if</span> (next == lastReturned)</span><br><span class="line">            next = lastNext;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nextIndex--;</span><br><span class="line">        lastReturned = <span class="keyword">null</span>;</span><br><span class="line">        expectedModCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将当前节点的信息修改成指定信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 指定信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line">        lastReturned.item = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在下一个节点前添加指定节点</span></span><br><span class="line"><span class="comment">     * 若下一个节点指向null，也就是说当前节点已经是尾部节点了，在将指定节点添加到尾部</span></span><br><span class="line"><span class="comment">     * 若下一个节点指向不为null，则在下一个节点前添加指定节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 指定节点信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        lastReturned = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">            linkLast(e);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            linkBefore(e, next);</span><br><span class="line">        nextIndex++;</span><br><span class="line">        expectedModCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正向遍历链表的剩余节点，对每一个节点执行指定的动作</span></span><br><span class="line"><span class="comment">     * 对于每个迭代器，除非剩余节点未遍历完毕，否则该方法只能执行一次，因为随着遍历nextIndex的次数在增加</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> action 对每一个节点执行指定的动作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">while</span> (modCount == expectedModCount &amp;&amp; nextIndex &lt; size) &#123;</span><br><span class="line">            action.accept(next.item);</span><br><span class="line">            lastReturned = next;</span><br><span class="line">            next = next.next;</span><br><span class="line">            nextIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        checkForComodification();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化时 modCount 与 expectedModCount 是相等的</span></span><br><span class="line"><span class="comment">     * 但如果在遍历的过程修改数组结构的话，此时 modCount 会有所变化，导致两者不相等，故而抛出异常，也就是我们上面提到的fast-failed异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取反向迭代器，尾部节点作为开始</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 以尾部节点作为开始的反向迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DescendingIterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 列表迭代器，反向迭代</span></span><br><span class="line"><span class="comment"> * 实际上都是采用ListItr类中的方法，只不过包装了一层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DescendingIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ListItr itr = <span class="keyword">new</span> ListItr(size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从反向的角度来看，判断是否有下一个节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否有下一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> itr.hasPrevious();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从反向的角度来看，获取下一个节点信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个节点信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> itr.previous();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从反向的角度来看，移除当前节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        itr.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>队列中的方法简单说明下：</li></ul><p>peek、peekFirst、elements方法都是<code>获取首部节点</code>，但若是空链表的话，前两者不会抛出异常（返回null），最后一个会。</p><p>peekLast方法是<code>获取尾部节点</code>。</p><p>poll、pollFirst、remove、pop方法都是<code>删除并首部节点</code>，但若是空链表的话，前两者不会抛出异常（返回null），后两者会。</p><p>pollLast方法是<code>删除并获取尾部节点</code>。</p><p>offer与offerLast方法都是<code>添加指定节点到尾部</code>，没啥区别。</p><p>offerFirst、push方法是<code>添加指定节点到首部</code>，两者的区别在于有无返回值。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>LinkedList允许存放Null。</p></li><li><p>LinkedList内部通过链表实现，属于非线程安全。</p></li><li><p>LinkedList充分利用了内存空间，不存在扩容机制。</p></li><li><p>ArrayList具有<code>iterator</code>与<code>listIterator</code>，虽然LinkedList也有这两个方法，但实际上这两个方法的内部实现都是调用的<code>listIterator</code>。</p></li><li><p>在遍历过程中不允许修改结构，否则会抛出错误。</p></li><li><p>LinkedList实现了队列。</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>底层是通过链表实现，有序可重复</code> <code>充分利用内存空间</code> </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;老样子，还是先看注释！本来以为能收获点什么干货，结果注释与&lt;code&gt;ArrayList&lt;/code&gt;的注释基本相同，有点尴尬…LinkedList的源码是基于&lt;code&gt;JDK1.8&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;开干&quot;&gt;&lt;a href=&quot;#开干&quot; class=&quot;headerlink&quot; title=&quot;开干&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;开干&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;先上LinkedList类的注释，在深入到类中详细说明属性与方法。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
</feed>
