<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>奇思妙想</title>
  
  <subtitle>越努力越幸运！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zlia.tech/"/>
  <updated>2018-11-11T07:09:02.830Z</updated>
  <id>http://zlia.tech/</id>
  
  <author>
    <name>zlia</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>简单喵下ActiveMQ生产者源码</title>
    <link href="http://zlia.tech/2018/09/02/explain-activemq-soucecode/"/>
    <id>http://zlia.tech/2018/09/02/explain-activemq-soucecode/</id>
    <published>2018-09-02T01:00:21.000Z</published>
    <updated>2018-11-11T07:09:02.830Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a><div><span>前提</span></div></h3><p>前提前提大前提！准备一份源码呗，activemq生产者的源码。何为生产者？就是发消息的源头，谁来发送消息谁就是生产者。有了生产者自然就会有消费者，今天着重看看生产者的故事，后面的几篇文章咱们都会一一进行讲解，包括服务端、消费者以及<code>ACK</code>模式，<code>消息的传送机制</code>，至于其他的内容还有待发掘，因为目前我也只是了解了部分！生产者的源码大伙可以从网上百度下，只要能跑起来就可以了，如果可以的话最好知道对方写了什么，对代码有个简单的理解，否则下面讲解的内容可能跟你的需求会有很大的出入，也帮助不了你哈，另一方面也是浪费了作者的苦心啦！自我迷恋中，切勿当真，哈哈。最好最好或者你有兴趣的话，可以clone下我的代码，里面都添加了对应的注释，<a href="https://github.com/JulianHang/activemq-client.git" target="_blank" rel="noopener">源码下载</a>。最后一个前提，作者使用的代码工具是<code>IDEA</code>，采用DEBUG模式来查看源码，所以读者对工具的操作最好有个简单的了解。好了，不啰嗦了！<a id="more"></a></p><h3 id="一步一个脚印，先看客户端如何连接到服务端"><a href="#一步一个脚印，先看客户端如何连接到服务端" class="headerlink" title="一步一个脚印，先看客户端如何连接到服务端"></a><div><span>一步一个脚印，先看客户端如何连接到服务端</span></div></h3><p>作者采用的代码工具是IDEA，所以不熟悉的读者最好先简单熟悉下！作者采取对象开始实例化时作为入口。</p><p class="customize-img"><img src="/assets/blogImg/activemq-producer/connectionFac-part-1.png" alt="实例化连接工厂"></p><p>由于代码跳转过于频繁，固采用择重点部分来讲解，同时用红色方块标记！这样子方便读者理解讲的是什么，毕竟看源码很容易迷失在代码的海洋中，甚至还会头晕，罪过罪过！要知道代码做了什么之前，先理解某个类是做什么用的，加深印象，鉴于理解，而读者只要翻译头部的英文即可大致明白，其他的类也是一个道理。该类是用来创建连接对象，对象有分队列、主题！说到这个，又得提一个点，咱们讲的内容都是基于主题来讲解的。</p><p>进入到内部代码中。</p><p class="customize-img"><img src="/assets/blogImg/activemq-producer/connectionFac-part-2.png" alt="连接工厂对象"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置账号、密码，为啥需要账号密码呢？连接服务端时可能需要提供账号密码来进行授权验证，默认是不需要的，可以在服务端的配置文件中增加授权验证功能</span></span><br><span class="line">setUserName(userName);</span><br><span class="line">setPassword(password);</span><br><span class="line"><span class="comment">//设置URL</span></span><br><span class="line">setBrokerURL(brokerURL);</span><br></pre></td></tr></table></figure><p class="customize-img"><img src="/assets/blogImg/activemq-producer/connectionFac-part-3.png" alt="连接对象"></p><p class="customize-img"><img src="/assets/blogImg/activemq-producer/connectionFac-part-4.png" alt="连接对象内部操作-1"></p><p class="customize-img"><img src="/assets/blogImg/activemq-producer/connectionFac-part-5.png" alt="连接对象内部操作-2"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将URL中QueryString的参数添加到Map中，如tcp://127.0.0.1:61614?wireFormat.cacheEnabled=false&amp;wireFormat.tightEncodingEnabled=false</span></span><br><span class="line"><span class="comment">//QueryString即为wireFormat.cacheEnabled=false&amp;wireFormat.tightEncodingEnabled=false，存入时以wireFormat.cacheEnabled为key，以false为value</span></span><br><span class="line">Map&lt;String, String&gt; options = <span class="keyword">new</span> HashMap&lt;String, String&gt;(URISupport.parseParameters(location));</span><br><span class="line"><span class="comment">//传输协议的配置信息对象，官方解释：专为在线路上的性能和大小而设计，具有更高的性能和更低的网络带宽</span></span><br><span class="line">WireFormat wf = createWireFormat(options);</span><br><span class="line"><span class="comment">//创建传输协议对象,如Tcp,同时将配置信息对象应用到该对象当中</span></span><br><span class="line">Transport transport = createTransport(location, wf);</span><br><span class="line"><span class="comment">//将QueryString中的参数配置应用到传输协议的配置信息对象当中，同时为每个过滤器设置相关联的传输协议对象来形成链条，以便后续对消息进行逐一处理</span></span><br><span class="line"><span class="comment">//链条的顺序：MutexTransport-&gt;WireFormatNegotiator-&gt;InactivityMonitor-&gt;TcpTransport</span></span><br><span class="line">Transport rc = configure(transport, wf, options);</span><br></pre></td></tr></table></figure><p class="customize-img"><img src="/assets/blogImg/activemq-producer/connectionFac-part-6.png" alt="连接对象内部操作-3"></p><p class="customize-img"><img src="/assets/blogImg/activemq-producer/connectionFac-part-7.png" alt="连接对象内部操作-4"></p><p>只是选择了部分代码进行讲解，因为有些代码官方并没有给出详细的说明！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...<span class="comment">//省略代码</span></span><br><span class="line"><span class="comment">//创建连接对象来存储连接信息，包括是否是异步发送，超时时间</span></span><br><span class="line"><span class="keyword">this</span>.info = <span class="keyword">new</span> ConnectionInfo(<span class="keyword">new</span> ConnectionId(uniqueId));</span><br><span class="line"><span class="comment">//创建连接会话对象，填充随机生成的连接ID，在同一个连接下的所有生产者消费者均采用同一个会话，多个生产者通过随机生成ID来区分</span></span><br><span class="line"><span class="keyword">this</span>.connectionSessionId = <span class="keyword">new</span> SessionId(info.getConnectionId(), -<span class="number">1</span>);</span><br><span class="line"><span class="comment">//设置监听，与服务端通信，包括发送连接信息、收发消息都会经过上面提到的链条逐一处理</span></span><br><span class="line"><span class="keyword">this</span>.transport.setTransportListener(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><h3 id="终于看到底层代码了，顺便交代下下一步"><a href="#终于看到底层代码了，顺便交代下下一步" class="headerlink" title="终于看到底层代码了，顺便交代下下一步"></a><div><span>终于看到底层代码了，顺便交代下下一步</span></div></h3><p class="customize-img"><img src="/assets/blogImg/activemq-producer/connectionFac-part-8.png" alt="连接对象内部操作-5"></p><p>我想大多数人都知道，实现连接底层的代码无非就是用的<code>socket</code>！好了，客户端到服务端的连接实现咱们已经阐述的差不多了，当然了，其中还有很多细节，包括涉及到模式，其实我到现在还不是很明白设计那些链条的意义都是什么？很疑惑，是出于什么情况下的考虑吗？就仿佛生产线一样，一个产品都需要经过每一个流程加工后才能到下一步，否则就是个废品！今天写的内容大多数以图片为主，主要讲几个重要的点通过代码加注释的方式点出来，一方面是希望读者能去详细查看内部代码做更进一步的了解，另一方面是其他的内容对于今天的主题来说可有可无，感兴趣的可以去了解下！下一步讲客户端如何开启事务及几种<code>ACK</code>模式。</p><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>链条</code></p><p><a href="https://github.com/JulianHang/activemq-client.git" target="_blank" rel="noopener">源码下载</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前提&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;前提前提大前提！准备一份源码呗，activemq生产者的源码。何为生产者？就是发消息的源头，谁来发送消息谁就是生产者。有了生产者自然就会有消费者，今天着重看看生产者的故事，后面的几篇文章咱们都会一一进行讲解，包括服务端、消费者以及&lt;code&gt;ACK&lt;/code&gt;模式，&lt;code&gt;消息的传送机制&lt;/code&gt;，至于其他的内容还有待发掘，因为目前我也只是了解了部分！生产者的源码大伙可以从网上百度下，只要能跑起来就可以了，如果可以的话最好知道对方写了什么，对代码有个简单的理解，否则下面讲解的内容可能跟你的需求会有很大的出入，也帮助不了你哈，另一方面也是浪费了作者的苦心啦！自我迷恋中，切勿当真，哈哈。最好最好或者你有兴趣的话，可以clone下我的代码，里面都添加了对应的注释，&lt;a href=&quot;https://github.com/JulianHang/activemq-client.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源码下载&lt;/a&gt;。最后一个前提，作者使用的代码工具是&lt;code&gt;IDEA&lt;/code&gt;，采用DEBUG模式来查看源码，所以读者对工具的操作最好有个简单的了解。好了，不啰嗦了！
    
    </summary>
    
      <category term="mq" scheme="http://zlia.tech/categories/mq/"/>
    
    
      <category term="activemq" scheme="http://zlia.tech/tags/activemq/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ的简单使用</title>
    <link href="http://zlia.tech/2018/08/18/activemq-understand/"/>
    <id>http://zlia.tech/2018/08/18/activemq-understand/</id>
    <published>2018-08-18T10:51:45.000Z</published>
    <updated>2018-09-02T01:07:12.801Z</updated>
    
    <content type="html"><![CDATA[<h3 id="接触消息队列"><a href="#接触消息队列" class="headerlink" title="接触消息队列"></a><div><span>接触消息队列</span></div></h3><p>原本一开始是打算直接从activemq的客户端讲起的，但是忽然发现，既然对activemq有了些许了解之后，至少应该知道消息队列是什么？或者是它的由来和一些应用场景，可是我并不知道。我觉得更多的人更倾向于该技术怎么使用，而并不关心它为什么会出现，也很难静得下心来看它的理念以及应用场景，包括我。因为我觉得那些概念看着看着就可能让我失去了兴趣，也就果断地放弃学些了，哈哈。当然了，现在还是个小小的程序员，等升了职位后就该去考虑了，偷懒了偷懒了！不过这里我也简单地看了一下几篇<code>消息队列</code>的文章，着实不错，有各种高级的架构啊，所以分享给各位<a href="https://blog.csdn.net/dj2008/article/details/78872889" target="_blank" rel="noopener">消息队列的使用场景</a>。有打破砂锅问到底心态的朋友可以去观望观望，定不会让你失望。<a id="more"></a></p><h3 id="ActiveMQ服务端跑起来吧"><a href="#ActiveMQ服务端跑起来吧" class="headerlink" title="ActiveMQ服务端跑起来吧"></a><div><span>ActiveMQ服务端跑起来吧</span></div></h3><p>既然有客户端，那就一定要先有服务端，那我们就先让服务端跑起来吧！acitvemq官网下载地址：<a href="http://activemq.apache.org/activemq-5155-release.html" target="_blank" rel="noopener">http://activemq.apache.org/activemq-5155-release.html</a> 。官网提供了Linux和window的版本，由于没有Linux环境故下载了window版本。</p><p class="customize-img"><img src="/assets/blogImg/activemq/download-activemq.png" alt="下载AcitveMQ服务器window版本"></p><p>下载好了就直接解压即可。在跑起来之前先来认识下每个目录的用处以便后续的开发：</p><p class="customize-img"><img src="/assets/blogImg/activemq/activemq-catalog.png" alt="下载AcitveMQ服务器window版本"></p><ul><li>bin：存放用来启动<code>服务器的脚本文件</code>，可以用普通用户或管理员的权限来启动。</li><li>conf：存放<code>服务器的相关配置文件</code>、管理端的配置文件以及安全权限控制。多说几句，<code>activmemq.xml</code>是用来配置服务器相关协议的端口、地址和相关属性，还有消息存储方式以及集群方式等等。</li><li>data：存放<code>消息存储的文件</code>以及日志文件。</li><li>docs：ActiveMQ的相关文档。</li><li>examples：服务器相关协议的客户端例子。</li><li>lib：存放ActiveMQ相关jar包。</li><li>webapps/webapps-demo：存放ActiveMQ管理端的相关文件。</li></ul><p>来吧！开始跑起来~进入到bin目录中并双击activemq.bat文件，若出现如下图所示则说明启动成功了！</p><p class="customize-img"><img src="/assets/blogImg/activemq/start-activemq.png" alt="启动AcitveMQ服务器"></p><p>这里就不带大家去看管理端长啥样了，要是有兴趣的话可以私底下去观摩观摩，管理端的默认账号密码都是<code>admin</code>。</p><h3 id="开始造人了，生产者与消费者"><a href="#开始造人了，生产者与消费者" class="headerlink" title="开始造人了，生产者与消费者"></a><div><span>开始造人了，生产者与消费者</span></div></h3><p>既然服务器都搭建完成了，那么就开始着手造生产者与消费者了。先创建一个简单的Java项目，这里之所以创建的是Java项目，是因为笔者是直接通过引入ActiveMQ Jar包的方式来进行开发的。当然了，也可以用Maven来进行操作，不过鉴于有些用户不会用maven，所以干脆来个最简单的使用方式。</p><p class="customize-img"><img src="/assets/blogImg/activemq/create-activemq.png" alt="创建ActiveMQ项目"></p><p>啥都没有，空空如也。有用户可能会觉得还要去下载个Jar来引入，好麻烦啊，我才不想去下载，但是如果够细心的话，其实刚才在讲解ActiveMQ目录结构的时候最底下就有一个<code>activemq-all-5.9.0.jar</code>文件，一看名字就知道是ActiveMQ的所有Jar包，哈哈！将其该Jar包引入到项目中去。</p><p class="customize-img"><img src="/assets/blogImg/activemq/import-activemq.png" alt="引入ActiveMQ包"></p><p>Jar包引入了，那就速速开始开发吧！具体的代码内容就不做展示了，若有需要请在最下面点击<code>源码下载</code>即可到Github上获取所需。开发的差不多了，就来看看效果吧，首先启动消费者，在启动生产者，结果如图所示。</p><p class="customize-img"><img src="/assets/blogImg/activemq/producer-result.png" alt="生产者结果"><br><img src="/assets/blogImg/activemq/consumer-result.png" alt="消费者结果"></p><p>是否感觉很简单很容易，但是越往后你就会发现越来越多坑，哈哈，就很敲代码一样！不过，这都是必经之路，否则难成大神。好了，今天的分享就到这里了~</p><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>activemq.xml 生产者与消费者 ActiveMQ管理端</code></p><p><a href="https://github.com/JulianHang/activemq-client.git" target="_blank" rel="noopener">源码下载</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;接触消息队列&quot;&gt;&lt;a href=&quot;#接触消息队列&quot; class=&quot;headerlink&quot; title=&quot;接触消息队列&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;接触消息队列&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;原本一开始是打算直接从activemq的客户端讲起的，但是忽然发现，既然对activemq有了些许了解之后，至少应该知道消息队列是什么？或者是它的由来和一些应用场景，可是我并不知道。我觉得更多的人更倾向于该技术怎么使用，而并不关心它为什么会出现，也很难静得下心来看它的理念以及应用场景，包括我。因为我觉得那些概念看着看着就可能让我失去了兴趣，也就果断地放弃学些了，哈哈。当然了，现在还是个小小的程序员，等升了职位后就该去考虑了，偷懒了偷懒了！不过这里我也简单地看了一下几篇&lt;code&gt;消息队列&lt;/code&gt;的文章，着实不错，有各种高级的架构啊，所以分享给各位&lt;a href=&quot;https://blog.csdn.net/dj2008/article/details/78872889&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;消息队列的使用场景&lt;/a&gt;。有打破砂锅问到底心态的朋友可以去观望观望，定不会让你失望。
    
    </summary>
    
      <category term="mq" scheme="http://zlia.tech/categories/mq/"/>
    
    
      <category term="activemq" scheme="http://zlia.tech/tags/activemq/"/>
    
  </entry>
  
  <entry>
    <title>读懂Javascript中的作用域链</title>
    <link href="http://zlia.tech/2018/06/03/js-scope/"/>
    <id>http://zlia.tech/2018/06/03/js-scope/</id>
    <published>2018-06-03T13:08:06.000Z</published>
    <updated>2018-08-18T07:32:37.303Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安静安静的看会书都不行"><a href="#安静安静的看会书都不行" class="headerlink" title="安静安静的看会书都不行"></a><div><span>安静安静的看会书都不行</span></div></h3><p>咦，咱们的文章标题是不是写错了。。其实是有原因的，以前没看到犀牛书以为应该是本通俗易懂的好书，不管是走到哪里都会看到有人推荐这本书。拿到这本书的时候我是很兴奋的，加上右下角又写着<code>淘宝前端译</code>，顿时觉得不愧是本好书！可惜啊，在看了不到两天后觉得这里头的语句何止是不通顺，甚至是读不懂，一开始以为我是不是很久没读书了，理解能力都下降了。好，继续读，天啊！大牛们这是直接翻译英文还是加上理解后在翻译呢，压力大的很，正好我也刚看到了作用域，身心觉得不能在放过了，要不就废了。于是，我借鉴了网上的相关知识并加上自己的理解来进行升级。<a id="more"></a></p><h3 id="犀牛书上关于作用域链的原话"><a href="#犀牛书上关于作用域链的原话" class="headerlink" title="犀牛书上关于作用域链的原话"></a><div><span>犀牛书上关于作用域链的原话</span></div></h3><p>在JavaScript的最顶层代码中，作用域链由一个全局对象组成。在不包含嵌套的函数体内，作用域链上有两个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象。在一个嵌套的函数体内，作用域链上至少有三个对象。当定义一个函数时，它实际上保存一个作用域链。当调用这个函数时，它创建一个新的对象来存储它的局部变量，并将这个对象添加至保存的那个作用域链上，同时创建一个新的更长的表示函数调用作用域的“链”。就这么几句话就想概括了这块的知识点，我服！不管它了，在理解这块知识点前先来介绍几个专业术语。</p><ul><li><code>执行环境</code>：定义了变量或函数，决定了它们各自的行为。每个执行环境中都有一个与之关联的执行上下文对象，该环境中的所有变量和函数都由这个对象来创建。而当执行环境中的代码被执行完毕后就会进入到销毁阶段，该环境中的变量和函数也会跟随着消失。<code>全局执行环境</code>是最外围的一个执行环境，在浏览器中，它的执行上下文对象是window，因此所有的变量以及函数都由window对象来创建成属性或方法。<code>每个函数都有执行环境</code>：当一个函数被调用时，该函数就会被推入到堆栈中，由于window是最先被推入的，所以该堆栈中最底部的环境永远是window。</li></ul><p class="customize-img"><img src="/assets/blogImg/js/execution-context.png" alt="执行环境"></p><p>执行环境的建立分两个阶段：<code>建立执行上下文对象</code>和<code>代码执行阶段</code>。</p><ul><li><code>执行上下文对象</code>：该对象是在函数被调用时，但还未执行代码时被创建的。在该对象中主要创建了作用域链、变量、函数、参数、this的指向对象，来看个具体的例子。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'hello'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//something</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>那么在调用foo(22)时，具体的建立阶段如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fooEexecutionContext = &#123;</span><br><span class="line">variableObject: &#123;</span><br><span class="line"><span class="built_in">arguments</span>: &#123;</span><br><span class="line"><span class="number">0</span>: <span class="number">22</span>,</span><br><span class="line">length: <span class="number">1</span></span><br><span class="line">&#125;,</span><br><span class="line">i: <span class="number">22</span>,</span><br><span class="line">b: pointer to <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)，//函数引用</span></span><br><span class="line"><span class="function"><span class="title">a</span>: <span class="title">undefined</span></span></span><br><span class="line"><span class="function">&#125;,</span></span><br><span class="line"><span class="function"><span class="title">scopeChain</span>: </span>&#123;&#125;,</span><br><span class="line"><span class="keyword">this</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由此可见，在创建执行上下文对象时，除了arguments、函数、参数被赋予了具体的值之外，其他的变量默认都是undefined。建立阶段结果后就进入到了具体的代码执行阶段，在代码执行完成后，执行上下文对象经过了如下的变化。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fooEexecutionContext = &#123;</span><br><span class="line">variableObject: &#123;</span><br><span class="line"><span class="built_in">arguments</span>: &#123;</span><br><span class="line"><span class="number">0</span>: <span class="number">22</span>,</span><br><span class="line">length: <span class="number">1</span></span><br><span class="line">&#125;,</span><br><span class="line">i: <span class="number">22</span>,</span><br><span class="line">b: pointer to <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)，//函数引用</span></span><br><span class="line"><span class="function"><span class="title">a</span>: '<span class="title">hello</span>'</span></span><br><span class="line"><span class="function">&#125;,</span></span><br><span class="line"><span class="function"><span class="title">scopeChain</span>: </span>&#123;&#125;,</span><br><span class="line"><span class="keyword">this</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到这里你会知道，函数中的变量只有在具体代码的执行阶段才会被真正的赋值，这也正好解释了js当中的声明提前机制，即使变量声明在变量使用的后面依然可以打印出变量值，只不过该值是undefined。</p><ul><li><code>活动对象</code>：当函数被调用的时候，一个对象将会被创建，即活动对象。该活动对象之后便会作为执行上下文对象来使用。</li></ul><h3 id="作用域链详解"><a href="#作用域链详解" class="headerlink" title="作用域链详解"></a><div><span>作用域链详解</span></div></h3><p>上面已经解释到，当函数被调用时，创建相应的执行环境、执行上下文对象并将其添加到作用链中，其实也就是执行环境被推入到堆栈中，该作用域的底部永远都是全局的执行上下文对象，因为它是最先被加载的。以下通过图片的形式来更为形象的说明。</p><p class="customize-img"><img src="/assets/blogImg/js/function-detail.png" alt="函数执行过程"></p><p>声明father函数时，会创建一个预先包含全局执行上下文对象的作用域链，这个作用域链会被保存在内部的属性中。当调用father函数时，会为函数创建一个执行环境，同时构建起执行环境的带有全局执行上下文对象的作用域链。紧接着，创建该函数的执行上下文对象并将其添加到该作用域中，也就是作用域当中最终有两个执行上下文对象，若是函数当中嵌套着函数，则对象的作用域应当有三个执行上下文对象，当最顶端的执行上下文对象被执行完成后，下一个即为包含该函数的执行上下文对象，就是外部函数，就这样一直延续到全局执行上下文对象。作用域链本质上是一个指向执行上下文对象的指针列表，每调用一个不同的函数都会创建一个作用域链，其用途是保证执行环境中的变量及函数被有序访问。</p><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>执行环境 执行上下文环境 函数执行过程图</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;安静安静的看会书都不行&quot;&gt;&lt;a href=&quot;#安静安静的看会书都不行&quot; class=&quot;headerlink&quot; title=&quot;安静安静的看会书都不行&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;安静安静的看会书都不行&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;咦，咱们的文章标题是不是写错了。。其实是有原因的，以前没看到犀牛书以为应该是本通俗易懂的好书，不管是走到哪里都会看到有人推荐这本书。拿到这本书的时候我是很兴奋的，加上右下角又写着&lt;code&gt;淘宝前端译&lt;/code&gt;，顿时觉得不愧是本好书！可惜啊，在看了不到两天后觉得这里头的语句何止是不通顺，甚至是读不懂，一开始以为我是不是很久没读书了，理解能力都下降了。好，继续读，天啊！大牛们这是直接翻译英文还是加上理解后在翻译呢，压力大的很，正好我也刚看到了作用域，身心觉得不能在放过了，要不就废了。于是，我借鉴了网上的相关知识并加上自己的理解来进行升级。
    
    </summary>
    
      <category term="frontend" scheme="http://zlia.tech/categories/frontend/"/>
    
    
      <category term="js" scheme="http://zlia.tech/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>尝尝markdown源码的味道</title>
    <link href="http://zlia.tech/2018/05/23/markdown-understand/"/>
    <id>http://zlia.tech/2018/05/23/markdown-understand/</id>
    <published>2018-05-22T16:16:23.000Z</published>
    <updated>2018-05-31T08:38:40.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一切动力源于好奇"><a href="#一切动力源于好奇" class="headerlink" title="一切动力源于好奇"></a><div><span>一切动力源于好奇</span></div></h3><p>为什么要写md的原理呢？因为md的语法本来就很有局限性，想要整个高大上的页面就显得很鸡肋，所以需要我们自己去定义一些语法来解析生成对应的标签。原本以为github或者google上应该有个现成什么的，至少也要有个大体的方向，可惜我是个菜鸟表示看不懂各位大神所描述的，看不懂看不懂，故打算自己看下源码，要求不高，大部分看懂就可以了，特地写了此篇文章来阐述自己对源码的理解，同时也为需要的人提供一些小小的帮助，嘻嘻！<a id="more"></a></p><h3 id="着手啃代码"><a href="#着手啃代码" class="headerlink" title="着手啃代码"></a><div><span>着手啃代码</span></div></h3><p>首先去github上clone个<a href="https://github.com/markedjs" target="_blank" rel="noopener">markdown源代码</a>，我在看源代码的时候喜欢先看大神写的小Demo，不知道其他大神是怎么欣赏别人文章的，好奇，也想学习学习。在项目中有个doc目录，打开它你就可以看到有个Demo目录，open it。只有100多行的代码，简单容易理解，所以建议大家也可以先看下Demo，先简单地浏览下。如果你是个有经验的前端开发者，我想你应该不会在我的文章里多呆一分钟吧，所以此篇文章的主要对象是初学者和不是从事前端开发的人员，因为我也不是个前端开发者，顶多是个业余的，惭愧惭愧，若接下来有什么理解错误的地方请谅解，若讲的不错请常来就好。你在浏览代码的过程中难免会发现有这么一个对象<code>marked</code>，为什么会是它呢？因为有这样一条语句<code>marked.parser</code>，其实就是解析的意思啦，好庸俗啊。。接着来，解析md语法的主要入口就是它，如果还不信的话可以在当前目录下打开index.html文件，打开后在其控制台（F12）下打印marked，会出现一个function对象，奇怪了，这是个什么鬼，双击后便可以看到另一个文件<code>marked.js</code>，这个文件在上一级目录lib下，它才是最主要的解析md语法的重点。回到刚才的Demo中，我们搜索下marked对象第一次出现的位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lexed = marked.lexer($inputElem.value);</span><br></pre></td></tr></table></figure><p>如果你认识lexer这个单词的话你应该就会明白这句话的意思是什么。<strong>词法分析器</strong>，实际上是根据是否匹配正则表达式从而进一步分析md的语法，最后组装好数据返回，这些数据主要是你用了哪些语法内容，如###之类，以及对应的值。接着来看下一步，parser方法是根据返回的数据解析成html，然后将内容innerHtml到页面上，最终的效果也就是你看到的页面。如果有同学觉得疑惑的话，你可以打开index.html页面进行调试便可以很容易的明白我所阐述的内容。</p><h3 id="深入代码内部击垮敌军"><a href="#深入代码内部击垮敌军" class="headerlink" title="深入代码内部击垮敌军"></a><div><span>深入代码内部击垮敌军</span></div></h3><p>现在我们只是大体的明白了md原理的表面，对于我们想要自定义语法来说，还远远不够，必须要深入到代码内部去，只有这样子才能彻底击垮敌军，来看看marked.js文件中的<code>lexer</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lexer.prototype.lex = <span class="function"><span class="keyword">function</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  src = src</span><br><span class="line">    .replace(<span class="regexp">/\r\n|\r/g</span>, <span class="string">'\n'</span>)</span><br><span class="line">    .replace(<span class="regexp">/\t/g</span>, <span class="string">'    '</span>)</span><br><span class="line">    .replace(<span class="regexp">/\u00a0/g</span>, <span class="string">' '</span>)</span><br><span class="line">    .replace(<span class="regexp">/\u2424/g</span>, <span class="string">'\n'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.token(src, <span class="literal">true</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在lexer方法中将制表符、换行等之类的表达式用对应的空格或者指定换行表达式来代替，以防后面解析时出现错误。在lexer内部中调用了<code>token</code>方法。在这个方法中，主要做的是根据md语法写的内容进行正则表达式匹配，其中的部分代码是匹配标题（#{1,6}）的方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// heading</span></span><br><span class="line">   <span class="keyword">if</span> (cap = <span class="keyword">this</span>.rules.heading.exec(src)) &#123;</span><br><span class="line">     src = src.substring(cap[<span class="number">0</span>].length);</span><br><span class="line">     <span class="keyword">this</span>.tokens.push(&#123;</span><br><span class="line">       type: <span class="string">'heading'</span>,</span><br><span class="line">       depth: cap[<span class="number">1</span>].length,</span><br><span class="line">       text: cap[<span class="number">2</span>]</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>匹配到对应的规则之后进行数据的封装，封装的数据主要是类型、内容、具体匹配了哪一种（Depth指的是匹配了h1、h2、h3中的哪一种）。到这里Demo中的marked.lexer方法就结束了，它返回了匹配成功后的数据封装。下一步来到<code>marked.parse</code>，将之前的数据封装传入，并构建标签分析器，专业术语我不知道，因为这一步会生成一个html，故称之为标签分析器，接着开始执行<code>tok</code>方法，部分代码用来匹配标题的方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'heading'</span>: &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.renderer.heading(</span><br><span class="line">       <span class="keyword">this</span>.inline.output(<span class="keyword">this</span>.token.text),</span><br><span class="line">       <span class="keyword">this</span>.token.depth,</span><br><span class="line">       <span class="built_in">unescape</span>(<span class="keyword">this</span>.inlineText.output(<span class="keyword">this</span>.token.text)));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>走下一步到<code>output</code>，根据内容参数来匹配正则表达式，当然了，这其中发生了很多事，有<code>merger</code>方法，主要用来合并相关匹配标签的正则表达；有<code>edit</code>方法，主要用来将通用的正则整合在一起。其实这两种方法都是在对正则表达式进行操作，可见作者对正则的理解很高深，至少在我看来正则知识较为难学，会让人头都脑壳痛。因为内容有可能会出现标签，如div，在escape方法中将其转换成$lt、$gt等之类的标记，防止出现解析错误造成乱码。大家有注意到格式转换后都会去调用this.render.text或者其他类似的方法，在其对应的方法中返回由标签包围的内容的字符串形式，最后在将其字符串打入到页面中即可呈现你想要的效果。若有同学想要改变标签的表现形式即可根据所需来对<code>this.render</code>中的具体方法来做修改，不妨试一试。</p><h3 id="战后总结"><a href="#战后总结" class="headerlink" title="战后总结"></a><div><span>战后总结</span></div></h3><p>表面上说是看了源码感觉很厉害的样子，但是里面的很多细节表示没有看懂或者理解不到位甚至是理解出错，顿时感觉自己的功力和水平还远远不够，难怪说程序员就是要一直学习下去，不然连个饭碗都端不起了，惭愧惭愧。有人说要想有所成长就必须要去看别人写的源码，看多了总会让人想吐，恶心，这还是一点点的代码，要是那种一片一片的代码，我想早就炸了，希望日后加强自身的知识储备，好好努力，加油！</p><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>lexe token parse output render</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一切动力源于好奇&quot;&gt;&lt;a href=&quot;#一切动力源于好奇&quot; class=&quot;headerlink&quot; title=&quot;一切动力源于好奇&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;一切动力源于好奇&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;为什么要写md的原理呢？因为md的语法本来就很有局限性，想要整个高大上的页面就显得很鸡肋，所以需要我们自己去定义一些语法来解析生成对应的标签。原本以为github或者google上应该有个现成什么的，至少也要有个大体的方向，可惜我是个菜鸟表示看不懂各位大神所描述的，看不懂看不懂，故打算自己看下源码，要求不高，大部分看懂就可以了，特地写了此篇文章来阐述自己对源码的理解，同时也为需要的人提供一些小小的帮助，嘻嘻！
    
    </summary>
    
      <category term="essays" scheme="http://zlia.tech/categories/essays/"/>
    
    
      <category term="markdown" scheme="http://zlia.tech/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>初识异常</title>
    <link href="http://zlia.tech/2018/05/06/exception-knowledge/"/>
    <id>http://zlia.tech/2018/05/06/exception-knowledge/</id>
    <published>2018-05-06T08:28:24.000Z</published>
    <updated>2018-08-18T07:32:30.903Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a><div><span>简介</span></div></h3><p>用户在运行程序的期间，往往有可能会出现各种各样的错误导致程序执行失败，其结果是用户数据丢失。出现这种情况的时候当然不能置之不理，要么就应该告诉用户该错误，要么是用户数据得到保存，否则用户流量将呈现下降的趋势。为了正确的处理错误，Java提供了一种称为：<code>异常处理的错误捕获机制处理</code>。该机制的任务就是将控制权从错误产生的地方转移给能够处理错误的处理器。当然了，想要正确的处理异常情况的前提是必须要研究程序中哪些地方会出现问题和错误。<a id="more"></a></p><blockquote><p>异常的处理机制就好比生活中较为常见的灾难预防措施，如在公共场所安防灭火器、洒水器。</p></blockquote><h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a><div><span>异常分类</span></div></h3><p>在Java程序设计语言中，异常对象都是派生于<code>Throwable</code>类的一个实例，若内置的异常类不能满足需求，则用户还可以创建自己的异常类。</p><p class="customize-img"><img src="/assets/blogImg/exception/throwable-hierarchy.png" alt="异常层次目录"></p><p>所有的异常都是由<code>Throwable</code>继承而来，在下一层又划分为两个分支：<code>Error</code>和<code>Exception</code>。</p><ul><li><code>Error</code>：描述了Java运行时系统的内部错误。在程序当中不应该抛出这种类型的错误，因为该错误除了通知用户之外，我们对它无能为力。</li><li><code>Exception</code>：<ul><li><code>IOException</code>：操作IO时出现的异常情况，如操作的文件不存在、试图在文件尾部后面读取数据。</li><li><code>RuntimeException</code>：由程序的错误编写而导致异常的出现，如错误的类型转换、数组角标越界。</li></ul></li></ul><h3 id="声明受查异常"><a href="#声明受查异常" class="headerlink" title="声明受查异常"></a><div><span>声明受查异常</span></div></h3><p>Java语言规范将派生于<code>Error</code>或<code>RuntimeException</code>的所有异常成为<code>非受查异常</code>，其他的所有异常称为<code>受查异常</code>。<br>为什么要声明异常呢？当你遇到无法处理的情况时是不是要告诉别人这件事我做不了你看着办，有点小尴尬的样子～至于为什么受查异常要声明而非受查异常不用声明呢？（声明了也不要紧，只是没必要）-见如下分析～</p><blockquote><p>处理文件时一般会先检查该文件是否存在，但是它是不是有可能在你检查完是否存在后就被删除了，所以受查异常更取决于环境而不只是代码。运行时异常（RuntimeException）出现的原因是由于代码编写的不规范而产生的，这完全是在我们的控制范围内，Java语言建议我们应该将更多的时间花费在修正程序中的错误上，而不是说明这些错误发生的可能性，所以非受查异常要么是我们无能为力的，要么是我们应该通过修正程序来避免发生。</p></blockquote><p>一个方法有可能要声明多个受查异常类型，那么就必须在方法的首部列出所有的异常类，每个异常类之间用逗号隔开。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.zlia.exception.knowledge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.EOFException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnimation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawImage</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">throws</span> FileNotFoundException , EOFException </span>&#123;</span><br><span class="line"><span class="comment">//do anything</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>Throwable RuntimeException IOException 受查异常 非受查异常</code></p><p><a href="https://github.com/JulianHang/core-java/tree/master/src/tech/zlia/exception" target="_blank" rel="noopener">源码下载</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;简介&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;用户在运行程序的期间，往往有可能会出现各种各样的错误导致程序执行失败，其结果是用户数据丢失。出现这种情况的时候当然不能置之不理，要么就应该告诉用户该错误，要么是用户数据得到保存，否则用户流量将呈现下降的趋势。为了正确的处理错误，Java提供了一种称为：&lt;code&gt;异常处理的错误捕获机制处理&lt;/code&gt;。该机制的任务就是将控制权从错误产生的地方转移给能够处理错误的处理器。当然了，想要正确的处理异常情况的前提是必须要研究程序中哪些地方会出现问题和错误。
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
</feed>
