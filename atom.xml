<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>奇思妙想</title>
  
  <subtitle>越努力越幸运！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zlia.tech/"/>
  <updated>2019-02-24T04:09:16.571Z</updated>
  <id>http://zlia.tech/</id>
  
  <author>
    <name>zlia</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>core-java-knowledge-20190211</title>
    <link href="http://zlia.tech/2019/02/24/core-java-knowledge-20190211/"/>
    <id>http://zlia.tech/2019/02/24/core-java-knowledge-20190211/</id>
    <published>2019-02-24T04:09:16.000Z</published>
    <updated>2019-02-24T04:09:16.571Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java"><a href="#java" class="headerlink" title="java"></a><div><span>java</span></div></h3><ul><li>在同一个catch语句中可以捕获多个<code>不存在子类关系</code>的异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(FileNotFoundException | UnknowHostException e)&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>java中原来有提供<code>断言</code>，学到了学到了.</p></li><li><p>泛型类、泛型方法</p></li><li><p>一个类型变量或通配符可以有多个限定.限定类型用&amp;分隔，而逗号用来分隔类型变量.</p></li><li><p>对于编译器来说，用方法名+参数列表来确定一个方法签名.而对于虚拟机来说，用参数类型+返回类型来确定一个方法，编译器不允许开发者编码出方法名一致，返回值却不同的方法，而它自己却可以自动生成这种操作（产生两个仅返回类型不同的方法字节码）并交给虚拟机来处理.这种操作在泛型中称为<code>桥方法</code>，它主要用来避免类型变量擦除所带来的多态灾难.</p></li></ul><p class="customize-img"><img src="/assets/blogImg/daliy-konwledge-point/20190217/generic-method.png" alt="桥方法"></p><ul><li>运行时类型查询只适用于原始类型.意思是泛型不支持类型检查.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该类型检查会得到一个编译器错误</span></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Test&lt;String&gt;)&#123;</span><br><span class="line">    <span class="comment">//something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li><p>不能使用像new T()、new T[]、T.class这样子表达式中的类型变量.</p></li><li><p>泛型类的静态上下文中类型变量无效.</p></li><li><p>不能抛出或捕获泛型类的实例.</p></li><li><p>带有超类型限定的通配符可以向泛型对象写入，带有子类型限定的通配符可以从泛型对象读取.</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java&quot;&gt;&lt;a href=&quot;#java&quot; class=&quot;headerlink&quot; title=&quot;java&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;java&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在同一个catch语句中可以捕获多个&lt;code&gt;不存在子类关系&lt;/code&gt;的异常&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt;(FileNotFoundException | UnknowHostException e)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;java中原来有提供&lt;code&gt;断言&lt;/code&gt;，学到了学到了.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;泛型类、泛型方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个类型变量或通配符可以有多个限定.限定类型用&amp;amp;分隔，而逗号用来分隔类型变量.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于编译器来说，用方法名+参数列表来确定一个方法签名.而对于虚拟机来说，用参数类型+返回类型来确定一个方法，编译器不允许开发者编码出方法名一致，返回值却不同的方法，而它自己却可以自动生成这种操作（产生两个仅返回类型不同的方法字节码）并交给虚拟机来处理.这种操作在泛型中称为&lt;code&gt;桥方法&lt;/code&gt;，它主要用来避免类型变量擦除所带来的多态灾难.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p class=&quot;customize-img&quot;&gt;&lt;img src=&quot;/assets/blogImg/daliy-konwledge-point/20190217/generic-method.png&quot; alt=&quot;桥方法&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行时类型查询只适用于原始类型.意思是泛型不支持类型检查.&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//该类型检查会得到一个编译器错误&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(a &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; Test&amp;lt;String&amp;gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//something&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="daily-konwledge-point-java" scheme="http://zlia.tech/tags/daily-konwledge-point-java/"/>
    
  </entry>
  
  <entry>
    <title>每日知识点20181216</title>
    <link href="http://zlia.tech/2019/02/24/core-java-knowledge-20181216/"/>
    <id>http://zlia.tech/2019/02/24/core-java-knowledge-20181216/</id>
    <published>2019-02-24T04:08:59.000Z</published>
    <updated>2019-02-24T04:08:59.355Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java"><a href="#java" class="headerlink" title="java"></a><div><span>java</span></div></h3><ul><li><p>Arrays.deepToString(a)：打印二维数组.</p></li><li><p>Java8开始时间使用Date类，日期使用<code>LocalDate</code>类.</p></li><li><p>包内的类不能引用默认包中的类.</p></li><li><p>内部类可以是私有类（private），而常规类只可以具有包可见性（default）或公有可见性（public）.</p></li><li><p>内部类不能有static方法.</p></li><li><p>局部类不能用public或private访问说明符进行声明.</p></li></ul><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> flag)</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">FatherInner</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    System.out.println(flag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该段代码编译后生成Father.class与Father$1FatherInner.class文件.反编译Father$1FatherInner.class后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>$1<span class="title">Inner</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Father$<span class="number">1</span>Inner(Father var1,<span class="keyword">boolean</span> var2)&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span> = var1;</span><br><span class="line">        <span class="keyword">this</span>.val$flag = var2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.val$flag)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.val$flag)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> val$flag;</span><br><span class="line">    <span class="keyword">final</span> Father <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>由于构造器的名字与类名相同，而匿名类没有类名，所以匿名类不能有构造器.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java&quot;&gt;&lt;a href=&quot;#java&quot; class=&quot;headerlink&quot; title=&quot;java&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;java&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Arrays.deepToString(a)：打印二维数组.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Java8开始时间使用Date类，日期使用&lt;code&gt;LocalDate&lt;/code&gt;类.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;包内的类不能引用默认包中的类.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内部类可以是私有类（private），而常规类只可以具有包可见性（default）或公有可见性（public）.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内部类不能有static方法.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;局部类不能用public或private访问说明符进行声明.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="daily-konwledge-point-java" scheme="http://zlia.tech/tags/daily-konwledge-point-java/"/>
    
  </entry>
  
  <entry>
    <title>每日知识点20181213</title>
    <link href="http://zlia.tech/2018/12/14/core-java-knowledge-20181213/"/>
    <id>http://zlia.tech/2018/12/14/core-java-knowledge-20181213/</id>
    <published>2018-12-13T16:18:38.000Z</published>
    <updated>2019-01-16T15:16:43.511Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java"><a href="#java" class="headerlink" title="java"></a><div><span>java</span></div></h3><ul><li><p>s.substring(a,b)的长度：b-a.</p></li><li><p>String.join(“/“,”a”,”b”,”c”)：a/b/c.</p></li><li><p><code>字符串常量</code>是共享的，而+或substring等操作产生的结果并不是共享的，所以会导致拼接后的结果随便相同，但引用的地址却不是同一个.</p></li><li><p>Scanner in = new Scanner(System.in),String name = in.next(); //该方法以空格为分隔符，即空格符的之间的内容需要多次获取.</p></li><li><p>上面的读取控制台输入不适合密码，毕竟事明文，所以可采用Console类.但是Console不能在Eclipse或ide中的控制台使用，会报错.必须使用原始控制台，如在终端中编译运行Java代码即可使用.</p></li><li><p>float用<code>24</code>位来表示精确度，int用<code>32</code>位来表示精确度，故当将int转换成float时可能会丢失精度.</p></li><li><p>如果将一个类声明为final，只有其中的方法自动地成为final，而不包括域.</p></li><li><p>编译器对带有文件分割符和扩展名.java的文件进行操作，而java解释器加载类（带有分隔符）.</p></li></ul><a id="more"></a><ul><li><p>最好不要读取在初始化块后面的域</p></li><li><p>自动装箱：<code>Integer.valueOf(int i)</code>.自动装箱规范要求boolean、byte、char&lt;=127，介于-128~127之间的short和int被包装到固定的对象中.在Integer.valueOf(int i)中[-128,127]区间的Integer对象已经被初始化好了，每次调用只会从缓存中取，如果越过了这个区间则会创建新的对象，所以会导致超过了这个区间的Integer对象不相等.</p></li><li><p>装箱和拆箱是<code>编译器</code>认可的，而不是虚拟机.编译器在生成类的字节码时，插入必要的方法调用.虚拟机只是执行这些字节码.</p></li><li><p>整型数组类型int[]可以被转换成Object，但不能转换成对象数组Object[].</p></li><li><p><code>invoke</code>方法访问对象中的静态方法时，第一个参数可以被忽略，即可以将它设置为null.</p></li><li><p>在Java8中接口可以有默认方法和静态方法.</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java&quot;&gt;&lt;a href=&quot;#java&quot; class=&quot;headerlink&quot; title=&quot;java&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;java&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;s.substring(a,b)的长度：b-a.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;String.join(“/“,”a”,”b”,”c”)：a/b/c.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;字符串常量&lt;/code&gt;是共享的，而+或substring等操作产生的结果并不是共享的，所以会导致拼接后的结果随便相同，但引用的地址却不是同一个.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Scanner in = new Scanner(System.in),String name = in.next(); //该方法以空格为分隔符，即空格符的之间的内容需要多次获取.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;上面的读取控制台输入不适合密码，毕竟事明文，所以可采用Console类.但是Console不能在Eclipse或ide中的控制台使用，会报错.必须使用原始控制台，如在终端中编译运行Java代码即可使用.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;float用&lt;code&gt;24&lt;/code&gt;位来表示精确度，int用&lt;code&gt;32&lt;/code&gt;位来表示精确度，故当将int转换成float时可能会丢失精度.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果将一个类声明为final，只有其中的方法自动地成为final，而不包括域.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;编译器对带有文件分割符和扩展名.java的文件进行操作，而java解释器加载类（带有分隔符）.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="daily-konwledge-point-java" scheme="http://zlia.tech/tags/daily-konwledge-point-java/"/>
    
  </entry>
  
  <entry>
    <title>每日知识点20181212</title>
    <link href="http://zlia.tech/2018/12/12/core-java-knowledge-20181212/"/>
    <id>http://zlia.tech/2018/12/12/core-java-knowledge-20181212/</id>
    <published>2018-12-12T14:40:05.000Z</published>
    <updated>2019-01-16T15:16:27.469Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java"><a href="#java" class="headerlink" title="java"></a><div><span>java</span></div></h3><ul><li><p>jdk-8u191-windows-x64：Java SE 8的第<code>191次更新</code>.</p></li><li><p>OpenJDK：Java SE的一个免费的开源实现，不包含浏览器集成或JavaFX（用于图形化界面）.</p></li><li><p>从Java 7开始，数字字面量加下划线：<code>1_000_000</code>，Java编译器会去除这些下划线.</p></li><li><p>Double.isNaN(x)：判断是否是非数值.</p></li><li><p>整型值和布尔值之间不能进行相互转换.</p></li><li><p>Character.isJavaIdentifierStart：指定的字符是否允许作为Java标识符的<code>首字母</code>.</p></li><li><p>Character.isJavaIdentifierPart：指定的字符是否允许作为Java标识符的<code>一部分</code>.</p></li></ul><a id="more"></a><ul><li><p>15.0/2 = 7.5.</p></li><li><p>int -&gt; float：int包含的位数比float所能够表达的<code>位数多</code>，在转换过程中可能会丢失一定的精度.</p></li><li><p>数值类型之间的转换优先级：double &gt; float &gt; long &gt; int.</p></li><li><p>(byte)300 = 44，300是int类型，有32个bits（0000 0000 0001 0010 1100），而byte字节只有<code>8个bits</code>，所以最终取得后8位，即为44.</p></li><li><p>a += b += c：a +=(b += c).</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java&quot;&gt;&lt;a href=&quot;#java&quot; class=&quot;headerlink&quot; title=&quot;java&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;java&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;jdk-8u191-windows-x64：Java SE 8的第&lt;code&gt;191次更新&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;OpenJDK：Java SE的一个免费的开源实现，不包含浏览器集成或JavaFX（用于图形化界面）.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从Java 7开始，数字字面量加下划线：&lt;code&gt;1_000_000&lt;/code&gt;，Java编译器会去除这些下划线.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Double.isNaN(x)：判断是否是非数值.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;整型值和布尔值之间不能进行相互转换.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Character.isJavaIdentifierStart：指定的字符是否允许作为Java标识符的&lt;code&gt;首字母&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Character.isJavaIdentifierPart：指定的字符是否允许作为Java标识符的&lt;code&gt;一部分&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="daily-konwledge-point-java" scheme="http://zlia.tech/tags/daily-konwledge-point-java/"/>
    
  </entry>
  
  <entry>
    <title>搭建基于leancloud的评论系统</title>
    <link href="http://zlia.tech/2018/11/18/leancloud-build/"/>
    <id>http://zlia.tech/2018/11/18/leancloud-build/</id>
    <published>2018-11-18T07:11:42.000Z</published>
    <updated>2018-11-18T07:16:45.813Z</updated>
    
    <content type="html"><![CDATA[<h3 id="博客都有个评论系统"><a href="#博客都有个评论系统" class="headerlink" title="博客都有个评论系统"></a><div><span>博客都有个评论系统</span></div></h3><p>没啥好说的，但凡是个博客都应该有个评论系统。一开始找了个<code>多说</code>还是啥来着，要填写备案信息，好扯，只好绕路。又换了一个，<code>来必力</code>,搜了好几篇文章，都说不错不错，实际上给我的体验一般般，至少它的管理页面让我觉得不爽，当然了，我还是尝试了一波，因为懒，哈哈，结果居然不行！网上的一篇篇博客都TM是复制粘贴的，很难看出谁才是原创作者，没啥意思，真不知道是为了什么？别人的博客可以参考，复制就过分了，把我给气的，所以我的博客并没有放到百度的搜索库中，只有谷歌才能搜到，我宁愿别人没有看到自己的博客，也不想看着自己的成果被人一个个吞噬。后面又看了几篇文章，发现<code>leanCloud</code>这个评论系统是做的真可以，不是我吹牛，不管是文档还是管理端都很符合我的要求，脑子里一下子决定就是它了！当然了，它也没白白让我失望，花了2个晚上的时间就基本搞定了，体验真的好，它是免费的，啥都不用做，就只需要注册登录进去配置内容即可。<a id="more"></a></p><h3 id="动手开始干吧"><a href="#动手开始干吧" class="headerlink" title="动手开始干吧"></a><div><span>动手开始干吧</span></div></h3><p>因为我搭建该评论系统的时候也是参照着别人写好的博客来操作，关键是你提问作者还会准时回答的你，让我很佩服，更加重了我要搭建此评论系统的决心，真的赞！所以这里就贴出两个我觉得很好的博客文章，从零开始搭建的一个教程吧，它们是基于<code>yilia</code>主题来搭建的，因为我的博客应用的便是该主题。这两篇文章加起来刚好很完整，有代码层面的也有配置层面的，当然了，如果你看不懂也是可以在下方进行评论的，我就是其中的一个留言者！</p><p><a href="https://www.xxwhite.com/2017/Valine.html" target="_blank" rel="noopener">yilia主题配置leancloud</a> &amp; <a href="https://panjunwen.com/valine-admin-document/" target="_blank" rel="noopener">leancloud管理端配置</a></p><p><code>这里我在补充一些关键信息，也是非常重要的内容</code>，当初就是该错误让我找不到方向，上面提到的文章的作者也没能给我很好的回答，要是你仔细看评论的话可能会发现我留下的足迹，哈哈，整了2天都是因为该问题，都想放弃了，不够真心觉得它不错所以又拾起来了。按照上面提供的文章配置完毕后，你应该会在你的管理端中发现有这样子的内容，请看截图！</p><p class="customize-img"><img src="/assets/blogImg/leancloud/leancloud-build-1.png" alt="leancloud管理端"></p><p>当初配置完毕后就是少了<code>Comment Count</code>这两张表导致控制台一直报<code>https://xfc3sns5.api.lncld.net/1.1/classes/Comment?····</code>错误，我就想不通了，咋就这样子呢，有人让我创建一个，但我总得知道这表的数据结构吧，我去哪里找呢，肯定不好找，还是找了有一段时间，不好找，于是于是，报着尝试的心里将<code>原有的应用删除掉重新建了一个</code>，果然果然，这两张表有了，是<code>系统帮我们已经创建好的</code>，也就是说之所以第一次没生成成功是因为<code>leancloud</code>系统内部的原因，当然了你看不到内部有啥原因，只是存粹的猜测而已，反正第二次是成功了，开心开心，将内容重新发布后就可以了，控制台也没有报错了，哇！有兴趣的同学可以看下我的博客哈，菜鸟一枚，只为了提高自己来幸福自己！ <a href="http://zlia.tech/">zlia博客</a></p><p>最后的最后，我简单截下我配置后的效果图，里头也加上了评论邮箱通知功能。</p><p class="customize-img"><img src="/assets/blogImg/leancloud/leancloud-build-2.png" alt="配置leancloud管理端-2"></p><p class="customize-img"><img src="/assets/blogImg/leancloud/leancloud-build-3.png" alt="配置leancloud管理端-3"></p><p class="customize-img"><img src="/assets/blogImg/leancloud/leancloud-build-4.png" alt="配置leancloud管理端-4"></p><p class="customize-img"><img src="/assets/blogImg/leancloud/leancloud-build-5.png" alt="配置leancloud管理端-5"></p><p>截的图是相对比较重要的内容，其他像部署库和应用key参考提供的两篇文章就可以解决了，很简单。</p><h3 id="早点实现你想做的事"><a href="#早点实现你想做的事" class="headerlink" title="早点实现你想做的事"></a><div><span>早点实现你想做的事</span></div></h3><p>为啥会是这个小标题呢？好像跟博客没啥毛关系呢，其实是由于搭建了评论系统而进一步完善了博客，基本的东西都拥有了，倘若若干年后我在来回顾自己所写的博客文章，一定会越看越笑，就仿佛吃了蜜一样开心，一步一个脚印建立起来的，很有成就感！我想每个搭建博客的作者都应该会有这样子的感想吧。所以早点去做自己想做的事你就可以早点看到体验到什么叫做成功的人生，哈哈！无奈，感慨了一把！</p><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><a href="https://www.xxwhite.com/2017/Valine.html" target="_blank" rel="noopener">yilia主题配置leancloud</a> &amp; <a href="https://panjunwen.com/valine-admin-document/" target="_blank" rel="noopener">leancloud管理端配置</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;博客都有个评论系统&quot;&gt;&lt;a href=&quot;#博客都有个评论系统&quot; class=&quot;headerlink&quot; title=&quot;博客都有个评论系统&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;博客都有个评论系统&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;没啥好说的，但凡是个博客都应该有个评论系统。一开始找了个&lt;code&gt;多说&lt;/code&gt;还是啥来着，要填写备案信息，好扯，只好绕路。又换了一个，&lt;code&gt;来必力&lt;/code&gt;,搜了好几篇文章，都说不错不错，实际上给我的体验一般般，至少它的管理页面让我觉得不爽，当然了，我还是尝试了一波，因为懒，哈哈，结果居然不行！网上的一篇篇博客都TM是复制粘贴的，很难看出谁才是原创作者，没啥意思，真不知道是为了什么？别人的博客可以参考，复制就过分了，把我给气的，所以我的博客并没有放到百度的搜索库中，只有谷歌才能搜到，我宁愿别人没有看到自己的博客，也不想看着自己的成果被人一个个吞噬。后面又看了几篇文章，发现&lt;code&gt;leanCloud&lt;/code&gt;这个评论系统是做的真可以，不是我吹牛，不管是文档还是管理端都很符合我的要求，脑子里一下子决定就是它了！当然了，它也没白白让我失望，花了2个晚上的时间就基本搞定了，体验真的好，它是免费的，啥都不用做，就只需要注册登录进去配置内容即可。
    
    </summary>
    
      <category term="essays" scheme="http://zlia.tech/categories/essays/"/>
    
    
      <category term="leancloud" scheme="http://zlia.tech/tags/leancloud/"/>
    
  </entry>
  
  <entry>
    <title>不蒜子更换域名通告</title>
    <link href="http://zlia.tech/2018/11/14/busuanzi-latest-notice/"/>
    <id>http://zlia.tech/2018/11/14/busuanzi-latest-notice/</id>
    <published>2018-11-14T13:52:06.000Z</published>
    <updated>2018-11-14T13:54:27.006Z</updated>
    
    <content type="html"><![CDATA[<h3 id="想要告诉不知道的人"><a href="#想要告诉不知道的人" class="headerlink" title="想要告诉不知道的人"></a><div><span>想要告诉不知道的人</span></div></h3><p>你有博客吗？有的话继续往下看，没有的话就再见吧！有博客的人都是有故事的…废话不多说了，由于博客中会用到文章阅读量与网站访问人数的统计，我这边引用的是<code>不蒜子</code>插件。前几天发现控制台不断报与不蒜子相关的404错误，一看就知道肯定有蹊跷，果然，<code>原来它域名更改了</code>！官网都贴出了通告了！<a id="more"></a></p><p class="customize-img"><img src="/assets/blogImg/notice/busuanzi/busuanzi-1.png" alt="不蒜子更换域名通告"></p><p>作者的博客采用的主题为<code>yilia</code>，故这里贴出该主题的解决办法，其实就改个域名重新发布就OK了。</p><p>只需更改该目录下的<code>after-footer.ejs</code>文件即可。</p><p class="customize-img"><img src="/assets/blogImg/notice/busuanzi/busuanzi-2.png" alt="文件目录"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js••"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>更改为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p class="customize-img"><img src="/assets/blogImg/notice/busuanzi/busuanzi-3.png" alt="更改域名"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;想要告诉不知道的人&quot;&gt;&lt;a href=&quot;#想要告诉不知道的人&quot; class=&quot;headerlink&quot; title=&quot;想要告诉不知道的人&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;想要告诉不知道的人&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;你有博客吗？有的话继续往下看，没有的话就再见吧！有博客的人都是有故事的…废话不多说了，由于博客中会用到文章阅读量与网站访问人数的统计，我这边引用的是&lt;code&gt;不蒜子&lt;/code&gt;插件。前几天发现控制台不断报与不蒜子相关的404错误，一看就知道肯定有蹊跷，果然，&lt;code&gt;原来它域名更改了&lt;/code&gt;！官网都贴出了通告了！
    
    </summary>
    
      <category term="essays" scheme="http://zlia.tech/categories/essays/"/>
    
    
      <category term="notice" scheme="http://zlia.tech/tags/notice/"/>
    
  </entry>
  
  <entry>
    <title>简单喵下ActiveMQ生产者源码</title>
    <link href="http://zlia.tech/2018/09/02/explain-activemq-soucecod/"/>
    <id>http://zlia.tech/2018/09/02/explain-activemq-soucecod/</id>
    <published>2018-09-02T01:00:21.000Z</published>
    <updated>2018-11-14T13:27:29.053Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a><div><span>前提</span></div></h3><p>前提前提大前提！准备一份源码呗，activemq生产者的源码。何为生产者？就是发消息的源头，谁来发送消息谁就是生产者。有了生产者自然就会有消费者，今天着重看看生产者的故事，后面的几篇文章咱们都会一一进行讲解，包括服务端、消费者以及<code>ACK</code>模式，<code>消息的传送机制</code>，至于其他的内容还有待发掘，因为目前我也只是了解了部分！生产者的源码大伙可以从网上百度下，只要能跑起来就可以了，如果可以的话最好知道对方写了什么，对代码有个简单的理解，否则下面讲解的内容可能跟你的需求会有很大的出入，也帮助不了你哈，另一方面也是浪费了作者的苦心啦！自我迷恋中，切勿当真，哈哈。最好最好或者你有兴趣的话，可以clone下我的代码，里面都添加了对应的注释，<a href="https://github.com/JulianHang/activemq-client.git" target="_blank" rel="noopener">源码下载</a>。最后一个前提，作者使用的代码工具是<code>IDEA</code>，采用DEBUG模式来查看源码，所以读者对工具的操作最好有个简单的了解。好了，不啰嗦了！<a id="more"></a></p><h3 id="先看客户端如何连接到服务端"><a href="#先看客户端如何连接到服务端" class="headerlink" title="先看客户端如何连接到服务端"></a><div><span>先看客户端如何连接到服务端</span></div></h3><p>作者采用的代码工具是IDEA，所以不熟悉的读者最好先简单熟悉下！作者采取对象开始实例化时作为入口。</p><p class="customize-img"><img src="/assets/blogImg/activemq-producer/connectionFac-part-1.png" alt="实例化连接工厂"></p><p>由于代码跳转过于频繁，固采用择重点部分来讲解，同时用红色方块标记！这样子方便读者理解讲的是什么，毕竟看源码很容易迷失在代码的海洋中，甚至还会头晕，罪过罪过！要知道代码做了什么之前，先理解某个类是做什么用的，加深印象，鉴于理解，而读者只要翻译头部的英文即可大致明白，其他的类也是一个道理。该类是用来创建连接对象，对象有分队列、主题！说到这个，又得提一个点，咱们讲的内容都是基于主题来讲解的。</p><p>进入到内部代码中。</p><p class="customize-img"><img src="/assets/blogImg/activemq-producer/connectionFac-part-2.png" alt="连接工厂对象"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置账号、密码，为啥需要账号密码呢？连接服务端时可能需要提供账号密码来进行授权验证，默认是不需要的，可以在服务端的配置文件中增加授权验证功能</span></span><br><span class="line">setUserName(userName);</span><br><span class="line">setPassword(password);</span><br><span class="line"><span class="comment">//设置URL</span></span><br><span class="line">setBrokerURL(brokerURL);</span><br></pre></td></tr></table></figure><p class="customize-img"><img src="/assets/blogImg/activemq-producer/connectionFac-part-3.png" alt="连接对象"></p><p class="customize-img"><img src="/assets/blogImg/activemq-producer/connectionFac-part-4.png" alt="连接对象内部操作-1"></p><p class="customize-img"><img src="/assets/blogImg/activemq-producer/connectionFac-part-5.png" alt="连接对象内部操作-2"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将URL中QueryString的参数添加到Map中，如tcp://127.0.0.1:61614?wireFormat.cacheEnabled=false&amp;wireFormat.tightEncodingEnabled=false</span></span><br><span class="line"><span class="comment">//QueryString即为wireFormat.cacheEnabled=false&amp;wireFormat.tightEncodingEnabled=false，存入时以wireFormat.cacheEnabled为key，以false为value</span></span><br><span class="line">Map&lt;String, String&gt; options = <span class="keyword">new</span> HashMap&lt;String, String&gt;(URISupport.parseParameters(location));</span><br><span class="line"><span class="comment">//传输协议的配置信息对象，官方解释：专为在线路上的性能和大小而设计，具有更高的性能和更低的网络带宽</span></span><br><span class="line">WireFormat wf = createWireFormat(options);</span><br><span class="line"><span class="comment">//创建传输协议对象,如Tcp,同时将配置信息对象应用到该对象当中</span></span><br><span class="line">Transport transport = createTransport(location, wf);</span><br><span class="line"><span class="comment">//将QueryString中的参数配置应用到传输协议的配置信息对象当中，同时为每个过滤器设置相关联的传输协议对象来形成链条，以便后续对消息进行逐一处理</span></span><br><span class="line"><span class="comment">//链条的顺序：MutexTransport-&gt;WireFormatNegotiator-&gt;InactivityMonitor-&gt;TcpTransport</span></span><br><span class="line">Transport rc = configure(transport, wf, options);</span><br></pre></td></tr></table></figure><p class="customize-img"><img src="/assets/blogImg/activemq-producer/connectionFac-part-6.png" alt="连接对象内部操作-3"></p><p class="customize-img"><img src="/assets/blogImg/activemq-producer/connectionFac-part-7.png" alt="连接对象内部操作-4"></p><p>只是选择了部分代码进行讲解，因为有些代码官方并没有给出详细的说明！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...<span class="comment">//省略代码</span></span><br><span class="line"><span class="comment">//创建连接对象来存储连接信息，包括是否是异步发送，超时时间</span></span><br><span class="line"><span class="keyword">this</span>.info = <span class="keyword">new</span> ConnectionInfo(<span class="keyword">new</span> ConnectionId(uniqueId));</span><br><span class="line"><span class="comment">//创建连接会话对象，填充随机生成的连接ID，在同一个连接下的所有生产者消费者均采用同一个会话，多个生产者通过随机生成ID来区分</span></span><br><span class="line"><span class="keyword">this</span>.connectionSessionId = <span class="keyword">new</span> SessionId(info.getConnectionId(), -<span class="number">1</span>);</span><br><span class="line"><span class="comment">//设置监听，与服务端通信，包括发送连接信息、收发消息都会经过上面提到的链条逐一处理</span></span><br><span class="line"><span class="keyword">this</span>.transport.setTransportListener(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><h3 id="终于看到底层代码了"><a href="#终于看到底层代码了" class="headerlink" title="终于看到底层代码了"></a><div><span>终于看到底层代码了</span></div></h3><p class="customize-img"><img src="/assets/blogImg/activemq-producer/connectionFac-part-8.png" alt="连接对象内部操作-5"></p><p>我想大多数人都知道，实现连接底层的代码无非就是用的<code>socket</code>！好了，客户端到服务端的连接实现咱们已经阐述的差不多了，当然了，其中还有很多细节，包括涉及到模式，其实我到现在还不是很明白设计那些链条的意义都是什么？很疑惑，是出于什么情况下的考虑吗？就仿佛生产线一样，一个产品都需要经过每一个流程加工后才能到下一步，否则就是个废品！今天写的内容大多数以图片为主，主要讲几个重要的点通过代码加注释的方式点出来，一方面是希望读者能去详细查看内部代码做更进一步的了解，另一方面是其他的内容对于今天的主题来说可有可无，感兴趣的可以去了解下！下一步讲客户端如何开启事务及几种<code>ACK</code>模式。</p><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>链条</code></p><p><a href="https://github.com/JulianHang/activemq-client.git" target="_blank" rel="noopener">源码下载</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前提&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;前提前提大前提！准备一份源码呗，activemq生产者的源码。何为生产者？就是发消息的源头，谁来发送消息谁就是生产者。有了生产者自然就会有消费者，今天着重看看生产者的故事，后面的几篇文章咱们都会一一进行讲解，包括服务端、消费者以及&lt;code&gt;ACK&lt;/code&gt;模式，&lt;code&gt;消息的传送机制&lt;/code&gt;，至于其他的内容还有待发掘，因为目前我也只是了解了部分！生产者的源码大伙可以从网上百度下，只要能跑起来就可以了，如果可以的话最好知道对方写了什么，对代码有个简单的理解，否则下面讲解的内容可能跟你的需求会有很大的出入，也帮助不了你哈，另一方面也是浪费了作者的苦心啦！自我迷恋中，切勿当真，哈哈。最好最好或者你有兴趣的话，可以clone下我的代码，里面都添加了对应的注释，&lt;a href=&quot;https://github.com/JulianHang/activemq-client.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源码下载&lt;/a&gt;。最后一个前提，作者使用的代码工具是&lt;code&gt;IDEA&lt;/code&gt;，采用DEBUG模式来查看源码，所以读者对工具的操作最好有个简单的了解。好了，不啰嗦了！
    
    </summary>
    
      <category term="mq" scheme="http://zlia.tech/categories/mq/"/>
    
    
      <category term="activemq" scheme="http://zlia.tech/tags/activemq/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ的简单使用</title>
    <link href="http://zlia.tech/2018/08/18/activemq-understand/"/>
    <id>http://zlia.tech/2018/08/18/activemq-understand/</id>
    <published>2018-08-18T10:51:45.000Z</published>
    <updated>2018-09-02T01:07:12.801Z</updated>
    
    <content type="html"><![CDATA[<h3 id="接触消息队列"><a href="#接触消息队列" class="headerlink" title="接触消息队列"></a><div><span>接触消息队列</span></div></h3><p>原本一开始是打算直接从activemq的客户端讲起的，但是忽然发现，既然对activemq有了些许了解之后，至少应该知道消息队列是什么？或者是它的由来和一些应用场景，可是我并不知道。我觉得更多的人更倾向于该技术怎么使用，而并不关心它为什么会出现，也很难静得下心来看它的理念以及应用场景，包括我。因为我觉得那些概念看着看着就可能让我失去了兴趣，也就果断地放弃学些了，哈哈。当然了，现在还是个小小的程序员，等升了职位后就该去考虑了，偷懒了偷懒了！不过这里我也简单地看了一下几篇<code>消息队列</code>的文章，着实不错，有各种高级的架构啊，所以分享给各位<a href="https://blog.csdn.net/dj2008/article/details/78872889" target="_blank" rel="noopener">消息队列的使用场景</a>。有打破砂锅问到底心态的朋友可以去观望观望，定不会让你失望。<a id="more"></a></p><h3 id="ActiveMQ服务端跑起来吧"><a href="#ActiveMQ服务端跑起来吧" class="headerlink" title="ActiveMQ服务端跑起来吧"></a><div><span>ActiveMQ服务端跑起来吧</span></div></h3><p>既然有客户端，那就一定要先有服务端，那我们就先让服务端跑起来吧！acitvemq官网下载地址：<a href="http://activemq.apache.org/activemq-5155-release.html" target="_blank" rel="noopener">http://activemq.apache.org/activemq-5155-release.html</a> 。官网提供了Linux和window的版本，由于没有Linux环境故下载了window版本。</p><p class="customize-img"><img src="/assets/blogImg/activemq/download-activemq.png" alt="下载AcitveMQ服务器window版本"></p><p>下载好了就直接解压即可。在跑起来之前先来认识下每个目录的用处以便后续的开发：</p><p class="customize-img"><img src="/assets/blogImg/activemq/activemq-catalog.png" alt="下载AcitveMQ服务器window版本"></p><ul><li>bin：存放用来启动<code>服务器的脚本文件</code>，可以用普通用户或管理员的权限来启动。</li><li>conf：存放<code>服务器的相关配置文件</code>、管理端的配置文件以及安全权限控制。多说几句，<code>activmemq.xml</code>是用来配置服务器相关协议的端口、地址和相关属性，还有消息存储方式以及集群方式等等。</li><li>data：存放<code>消息存储的文件</code>以及日志文件。</li><li>docs：ActiveMQ的相关文档。</li><li>examples：服务器相关协议的客户端例子。</li><li>lib：存放ActiveMQ相关jar包。</li><li>webapps/webapps-demo：存放ActiveMQ管理端的相关文件。</li></ul><p>来吧！开始跑起来~进入到bin目录中并双击activemq.bat文件，若出现如下图所示则说明启动成功了！</p><p class="customize-img"><img src="/assets/blogImg/activemq/start-activemq.png" alt="启动AcitveMQ服务器"></p><p>这里就不带大家去看管理端长啥样了，要是有兴趣的话可以私底下去观摩观摩，管理端的默认账号密码都是<code>admin</code>。</p><h3 id="开始造人了，生产者与消费者"><a href="#开始造人了，生产者与消费者" class="headerlink" title="开始造人了，生产者与消费者"></a><div><span>开始造人了，生产者与消费者</span></div></h3><p>既然服务器都搭建完成了，那么就开始着手造生产者与消费者了。先创建一个简单的Java项目，这里之所以创建的是Java项目，是因为笔者是直接通过引入ActiveMQ Jar包的方式来进行开发的。当然了，也可以用Maven来进行操作，不过鉴于有些用户不会用maven，所以干脆来个最简单的使用方式。</p><p class="customize-img"><img src="/assets/blogImg/activemq/create-activemq.png" alt="创建ActiveMQ项目"></p><p>啥都没有，空空如也。有用户可能会觉得还要去下载个Jar来引入，好麻烦啊，我才不想去下载，但是如果够细心的话，其实刚才在讲解ActiveMQ目录结构的时候最底下就有一个<code>activemq-all-5.9.0.jar</code>文件，一看名字就知道是ActiveMQ的所有Jar包，哈哈！将其该Jar包引入到项目中去。</p><p class="customize-img"><img src="/assets/blogImg/activemq/import-activemq.png" alt="引入ActiveMQ包"></p><p>Jar包引入了，那就速速开始开发吧！具体的代码内容就不做展示了，若有需要请在最下面点击<code>源码下载</code>即可到Github上获取所需。开发的差不多了，就来看看效果吧，首先启动消费者，在启动生产者，结果如图所示。</p><p class="customize-img"><img src="/assets/blogImg/activemq/producer-result.png" alt="生产者结果"><br><img src="/assets/blogImg/activemq/consumer-result.png" alt="消费者结果"></p><p>是否感觉很简单很容易，但是越往后你就会发现越来越多坑，哈哈，就很敲代码一样！不过，这都是必经之路，否则难成大神。好了，今天的分享就到这里了~</p><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>activemq.xml 生产者与消费者 ActiveMQ管理端</code></p><p><a href="https://github.com/JulianHang/activemq-client.git" target="_blank" rel="noopener">源码下载</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;接触消息队列&quot;&gt;&lt;a href=&quot;#接触消息队列&quot; class=&quot;headerlink&quot; title=&quot;接触消息队列&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;接触消息队列&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;原本一开始是打算直接从activemq的客户端讲起的，但是忽然发现，既然对activemq有了些许了解之后，至少应该知道消息队列是什么？或者是它的由来和一些应用场景，可是我并不知道。我觉得更多的人更倾向于该技术怎么使用，而并不关心它为什么会出现，也很难静得下心来看它的理念以及应用场景，包括我。因为我觉得那些概念看着看着就可能让我失去了兴趣，也就果断地放弃学些了，哈哈。当然了，现在还是个小小的程序员，等升了职位后就该去考虑了，偷懒了偷懒了！不过这里我也简单地看了一下几篇&lt;code&gt;消息队列&lt;/code&gt;的文章，着实不错，有各种高级的架构啊，所以分享给各位&lt;a href=&quot;https://blog.csdn.net/dj2008/article/details/78872889&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;消息队列的使用场景&lt;/a&gt;。有打破砂锅问到底心态的朋友可以去观望观望，定不会让你失望。
    
    </summary>
    
      <category term="mq" scheme="http://zlia.tech/categories/mq/"/>
    
    
      <category term="activemq" scheme="http://zlia.tech/tags/activemq/"/>
    
  </entry>
  
  <entry>
    <title>读懂Javascript中的作用域链</title>
    <link href="http://zlia.tech/2018/06/03/js-scope/"/>
    <id>http://zlia.tech/2018/06/03/js-scope/</id>
    <published>2018-06-03T13:08:06.000Z</published>
    <updated>2018-08-18T07:32:37.303Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安静安静的看会书都不行"><a href="#安静安静的看会书都不行" class="headerlink" title="安静安静的看会书都不行"></a><div><span>安静安静的看会书都不行</span></div></h3><p>咦，咱们的文章标题是不是写错了。。其实是有原因的，以前没看到犀牛书以为应该是本通俗易懂的好书，不管是走到哪里都会看到有人推荐这本书。拿到这本书的时候我是很兴奋的，加上右下角又写着<code>淘宝前端译</code>，顿时觉得不愧是本好书！可惜啊，在看了不到两天后觉得这里头的语句何止是不通顺，甚至是读不懂，一开始以为我是不是很久没读书了，理解能力都下降了。好，继续读，天啊！大牛们这是直接翻译英文还是加上理解后在翻译呢，压力大的很，正好我也刚看到了作用域，身心觉得不能在放过了，要不就废了。于是，我借鉴了网上的相关知识并加上自己的理解来进行升级。<a id="more"></a></p><h3 id="犀牛书上关于作用域链的原话"><a href="#犀牛书上关于作用域链的原话" class="headerlink" title="犀牛书上关于作用域链的原话"></a><div><span>犀牛书上关于作用域链的原话</span></div></h3><p>在JavaScript的最顶层代码中，作用域链由一个全局对象组成。在不包含嵌套的函数体内，作用域链上有两个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象。在一个嵌套的函数体内，作用域链上至少有三个对象。当定义一个函数时，它实际上保存一个作用域链。当调用这个函数时，它创建一个新的对象来存储它的局部变量，并将这个对象添加至保存的那个作用域链上，同时创建一个新的更长的表示函数调用作用域的“链”。就这么几句话就想概括了这块的知识点，我服！不管它了，在理解这块知识点前先来介绍几个专业术语。</p><ul><li><code>执行环境</code>：定义了变量或函数，决定了它们各自的行为。每个执行环境中都有一个与之关联的执行上下文对象，该环境中的所有变量和函数都由这个对象来创建。而当执行环境中的代码被执行完毕后就会进入到销毁阶段，该环境中的变量和函数也会跟随着消失。<code>全局执行环境</code>是最外围的一个执行环境，在浏览器中，它的执行上下文对象是window，因此所有的变量以及函数都由window对象来创建成属性或方法。<code>每个函数都有执行环境</code>：当一个函数被调用时，该函数就会被推入到堆栈中，由于window是最先被推入的，所以该堆栈中最底部的环境永远是window。</li></ul><p class="customize-img"><img src="/assets/blogImg/js/execution-context.png" alt="执行环境"></p><p>执行环境的建立分两个阶段：<code>建立执行上下文对象</code>和<code>代码执行阶段</code>。</p><ul><li><code>执行上下文对象</code>：该对象是在函数被调用时，但还未执行代码时被创建的。在该对象中主要创建了作用域链、变量、函数、参数、this的指向对象，来看个具体的例子。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'hello'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//something</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>那么在调用foo(22)时，具体的建立阶段如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fooEexecutionContext = &#123;</span><br><span class="line">variableObject: &#123;</span><br><span class="line"><span class="built_in">arguments</span>: &#123;</span><br><span class="line"><span class="number">0</span>: <span class="number">22</span>,</span><br><span class="line">length: <span class="number">1</span></span><br><span class="line">&#125;,</span><br><span class="line">i: <span class="number">22</span>,</span><br><span class="line">b: pointer to <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)，//函数引用</span></span><br><span class="line"><span class="function"><span class="title">a</span>: <span class="title">undefined</span></span></span><br><span class="line"><span class="function">&#125;,</span></span><br><span class="line"><span class="function"><span class="title">scopeChain</span>: </span>&#123;&#125;,</span><br><span class="line"><span class="keyword">this</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由此可见，在创建执行上下文对象时，除了arguments、函数、参数被赋予了具体的值之外，其他的变量默认都是undefined。建立阶段结果后就进入到了具体的代码执行阶段，在代码执行完成后，执行上下文对象经过了如下的变化。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fooEexecutionContext = &#123;</span><br><span class="line">variableObject: &#123;</span><br><span class="line"><span class="built_in">arguments</span>: &#123;</span><br><span class="line"><span class="number">0</span>: <span class="number">22</span>,</span><br><span class="line">length: <span class="number">1</span></span><br><span class="line">&#125;,</span><br><span class="line">i: <span class="number">22</span>,</span><br><span class="line">b: pointer to <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)，//函数引用</span></span><br><span class="line"><span class="function"><span class="title">a</span>: '<span class="title">hello</span>'</span></span><br><span class="line"><span class="function">&#125;,</span></span><br><span class="line"><span class="function"><span class="title">scopeChain</span>: </span>&#123;&#125;,</span><br><span class="line"><span class="keyword">this</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到这里你会知道，函数中的变量只有在具体代码的执行阶段才会被真正的赋值，这也正好解释了js当中的声明提前机制，即使变量声明在变量使用的后面依然可以打印出变量值，只不过该值是undefined。</p><ul><li><code>活动对象</code>：当函数被调用的时候，一个对象将会被创建，即活动对象。该活动对象之后便会作为执行上下文对象来使用。</li></ul><h3 id="作用域链详解"><a href="#作用域链详解" class="headerlink" title="作用域链详解"></a><div><span>作用域链详解</span></div></h3><p>上面已经解释到，当函数被调用时，创建相应的执行环境、执行上下文对象并将其添加到作用链中，其实也就是执行环境被推入到堆栈中，该作用域的底部永远都是全局的执行上下文对象，因为它是最先被加载的。以下通过图片的形式来更为形象的说明。</p><p class="customize-img"><img src="/assets/blogImg/js/function-detail.png" alt="函数执行过程"></p><p>声明father函数时，会创建一个预先包含全局执行上下文对象的作用域链，这个作用域链会被保存在内部的属性中。当调用father函数时，会为函数创建一个执行环境，同时构建起执行环境的带有全局执行上下文对象的作用域链。紧接着，创建该函数的执行上下文对象并将其添加到该作用域中，也就是作用域当中最终有两个执行上下文对象，若是函数当中嵌套着函数，则对象的作用域应当有三个执行上下文对象，当最顶端的执行上下文对象被执行完成后，下一个即为包含该函数的执行上下文对象，就是外部函数，就这样一直延续到全局执行上下文对象。作用域链本质上是一个指向执行上下文对象的指针列表，每调用一个不同的函数都会创建一个作用域链，其用途是保证执行环境中的变量及函数被有序访问。</p><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>执行环境 执行上下文环境 函数执行过程图</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;安静安静的看会书都不行&quot;&gt;&lt;a href=&quot;#安静安静的看会书都不行&quot; class=&quot;headerlink&quot; title=&quot;安静安静的看会书都不行&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;安静安静的看会书都不行&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;咦，咱们的文章标题是不是写错了。。其实是有原因的，以前没看到犀牛书以为应该是本通俗易懂的好书，不管是走到哪里都会看到有人推荐这本书。拿到这本书的时候我是很兴奋的，加上右下角又写着&lt;code&gt;淘宝前端译&lt;/code&gt;，顿时觉得不愧是本好书！可惜啊，在看了不到两天后觉得这里头的语句何止是不通顺，甚至是读不懂，一开始以为我是不是很久没读书了，理解能力都下降了。好，继续读，天啊！大牛们这是直接翻译英文还是加上理解后在翻译呢，压力大的很，正好我也刚看到了作用域，身心觉得不能在放过了，要不就废了。于是，我借鉴了网上的相关知识并加上自己的理解来进行升级。
    
    </summary>
    
      <category term="frontend" scheme="http://zlia.tech/categories/frontend/"/>
    
    
      <category term="js" scheme="http://zlia.tech/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>尝尝markdown源码的味道</title>
    <link href="http://zlia.tech/2018/05/23/markdown-understand/"/>
    <id>http://zlia.tech/2018/05/23/markdown-understand/</id>
    <published>2018-05-22T16:16:23.000Z</published>
    <updated>2018-05-31T08:38:40.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一切动力源于好奇"><a href="#一切动力源于好奇" class="headerlink" title="一切动力源于好奇"></a><div><span>一切动力源于好奇</span></div></h3><p>为什么要写md的原理呢？因为md的语法本来就很有局限性，想要整个高大上的页面就显得很鸡肋，所以需要我们自己去定义一些语法来解析生成对应的标签。原本以为github或者google上应该有个现成什么的，至少也要有个大体的方向，可惜我是个菜鸟表示看不懂各位大神所描述的，看不懂看不懂，故打算自己看下源码，要求不高，大部分看懂就可以了，特地写了此篇文章来阐述自己对源码的理解，同时也为需要的人提供一些小小的帮助，嘻嘻！<a id="more"></a></p><h3 id="着手啃代码"><a href="#着手啃代码" class="headerlink" title="着手啃代码"></a><div><span>着手啃代码</span></div></h3><p>首先去github上clone个<a href="https://github.com/markedjs" target="_blank" rel="noopener">markdown源代码</a>，我在看源代码的时候喜欢先看大神写的小Demo，不知道其他大神是怎么欣赏别人文章的，好奇，也想学习学习。在项目中有个doc目录，打开它你就可以看到有个Demo目录，open it。只有100多行的代码，简单容易理解，所以建议大家也可以先看下Demo，先简单地浏览下。如果你是个有经验的前端开发者，我想你应该不会在我的文章里多呆一分钟吧，所以此篇文章的主要对象是初学者和不是从事前端开发的人员，因为我也不是个前端开发者，顶多是个业余的，惭愧惭愧，若接下来有什么理解错误的地方请谅解，若讲的不错请常来就好。你在浏览代码的过程中难免会发现有这么一个对象<code>marked</code>，为什么会是它呢？因为有这样一条语句<code>marked.parser</code>，其实就是解析的意思啦，好庸俗啊。。接着来，解析md语法的主要入口就是它，如果还不信的话可以在当前目录下打开index.html文件，打开后在其控制台（F12）下打印marked，会出现一个function对象，奇怪了，这是个什么鬼，双击后便可以看到另一个文件<code>marked.js</code>，这个文件在上一级目录lib下，它才是最主要的解析md语法的重点。回到刚才的Demo中，我们搜索下marked对象第一次出现的位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lexed = marked.lexer($inputElem.value);</span><br></pre></td></tr></table></figure><p>如果你认识lexer这个单词的话你应该就会明白这句话的意思是什么。<strong>词法分析器</strong>，实际上是根据是否匹配正则表达式从而进一步分析md的语法，最后组装好数据返回，这些数据主要是你用了哪些语法内容，如###之类，以及对应的值。接着来看下一步，parser方法是根据返回的数据解析成html，然后将内容innerHtml到页面上，最终的效果也就是你看到的页面。如果有同学觉得疑惑的话，你可以打开index.html页面进行调试便可以很容易的明白我所阐述的内容。</p><h3 id="深入代码内部击垮敌军"><a href="#深入代码内部击垮敌军" class="headerlink" title="深入代码内部击垮敌军"></a><div><span>深入代码内部击垮敌军</span></div></h3><p>现在我们只是大体的明白了md原理的表面，对于我们想要自定义语法来说，还远远不够，必须要深入到代码内部去，只有这样子才能彻底击垮敌军，来看看marked.js文件中的<code>lexer</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lexer.prototype.lex = <span class="function"><span class="keyword">function</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  src = src</span><br><span class="line">    .replace(<span class="regexp">/\r\n|\r/g</span>, <span class="string">'\n'</span>)</span><br><span class="line">    .replace(<span class="regexp">/\t/g</span>, <span class="string">'    '</span>)</span><br><span class="line">    .replace(<span class="regexp">/\u00a0/g</span>, <span class="string">' '</span>)</span><br><span class="line">    .replace(<span class="regexp">/\u2424/g</span>, <span class="string">'\n'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.token(src, <span class="literal">true</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在lexer方法中将制表符、换行等之类的表达式用对应的空格或者指定换行表达式来代替，以防后面解析时出现错误。在lexer内部中调用了<code>token</code>方法。在这个方法中，主要做的是根据md语法写的内容进行正则表达式匹配，其中的部分代码是匹配标题（#{1,6}）的方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// heading</span></span><br><span class="line">   <span class="keyword">if</span> (cap = <span class="keyword">this</span>.rules.heading.exec(src)) &#123;</span><br><span class="line">     src = src.substring(cap[<span class="number">0</span>].length);</span><br><span class="line">     <span class="keyword">this</span>.tokens.push(&#123;</span><br><span class="line">       type: <span class="string">'heading'</span>,</span><br><span class="line">       depth: cap[<span class="number">1</span>].length,</span><br><span class="line">       text: cap[<span class="number">2</span>]</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>匹配到对应的规则之后进行数据的封装，封装的数据主要是类型、内容、具体匹配了哪一种（Depth指的是匹配了h1、h2、h3中的哪一种）。到这里Demo中的marked.lexer方法就结束了，它返回了匹配成功后的数据封装。下一步来到<code>marked.parse</code>，将之前的数据封装传入，并构建标签分析器，专业术语我不知道，因为这一步会生成一个html，故称之为标签分析器，接着开始执行<code>tok</code>方法，部分代码用来匹配标题的方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'heading'</span>: &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.renderer.heading(</span><br><span class="line">       <span class="keyword">this</span>.inline.output(<span class="keyword">this</span>.token.text),</span><br><span class="line">       <span class="keyword">this</span>.token.depth,</span><br><span class="line">       <span class="built_in">unescape</span>(<span class="keyword">this</span>.inlineText.output(<span class="keyword">this</span>.token.text)));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>走下一步到<code>output</code>，根据内容参数来匹配正则表达式，当然了，这其中发生了很多事，有<code>merger</code>方法，主要用来合并相关匹配标签的正则表达；有<code>edit</code>方法，主要用来将通用的正则整合在一起。其实这两种方法都是在对正则表达式进行操作，可见作者对正则的理解很高深，至少在我看来正则知识较为难学，会让人头都脑壳痛。因为内容有可能会出现标签，如div，在escape方法中将其转换成$lt、$gt等之类的标记，防止出现解析错误造成乱码。大家有注意到格式转换后都会去调用this.render.text或者其他类似的方法，在其对应的方法中返回由标签包围的内容的字符串形式，最后在将其字符串打入到页面中即可呈现你想要的效果。若有同学想要改变标签的表现形式即可根据所需来对<code>this.render</code>中的具体方法来做修改，不妨试一试。</p><h3 id="战后总结"><a href="#战后总结" class="headerlink" title="战后总结"></a><div><span>战后总结</span></div></h3><p>表面上说是看了源码感觉很厉害的样子，但是里面的很多细节表示没有看懂或者理解不到位甚至是理解出错，顿时感觉自己的功力和水平还远远不够，难怪说程序员就是要一直学习下去，不然连个饭碗都端不起了，惭愧惭愧。有人说要想有所成长就必须要去看别人写的源码，看多了总会让人想吐，恶心，这还是一点点的代码，要是那种一片一片的代码，我想早就炸了，希望日后加强自身的知识储备，好好努力，加油！</p><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>lexe token parse output render</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一切动力源于好奇&quot;&gt;&lt;a href=&quot;#一切动力源于好奇&quot; class=&quot;headerlink&quot; title=&quot;一切动力源于好奇&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;一切动力源于好奇&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;为什么要写md的原理呢？因为md的语法本来就很有局限性，想要整个高大上的页面就显得很鸡肋，所以需要我们自己去定义一些语法来解析生成对应的标签。原本以为github或者google上应该有个现成什么的，至少也要有个大体的方向，可惜我是个菜鸟表示看不懂各位大神所描述的，看不懂看不懂，故打算自己看下源码，要求不高，大部分看懂就可以了，特地写了此篇文章来阐述自己对源码的理解，同时也为需要的人提供一些小小的帮助，嘻嘻！
    
    </summary>
    
      <category term="essays" scheme="http://zlia.tech/categories/essays/"/>
    
    
      <category term="markdown" scheme="http://zlia.tech/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>初识异常</title>
    <link href="http://zlia.tech/2018/05/06/exception-knowledge/"/>
    <id>http://zlia.tech/2018/05/06/exception-knowledge/</id>
    <published>2018-05-06T08:28:24.000Z</published>
    <updated>2018-12-13T15:00:32.520Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a><div><span>简介</span></div></h3><p>用户在运行程序的期间，往往有可能会出现各种各样的错误导致程序执行失败，其结果是用户数据丢失。出现这种情况的时候当然不能置之不理，要么就应该告诉用户该错误，要么是用户数据得到保存，否则用户流量将呈现下降的趋势。为了正确的处理错误，Java提供了一种称为：<code>异常处理的错误捕获机制处理</code>。该机制的任务就是将控制权从错误产生的地方转移给能够处理错误的处理器。当然了，想要正确的处理异常情况的前提是必须要研究程序中哪些地方会出现问题和错误。<a id="more"></a></p><blockquote><p>异常的处理机制就好比生活中较为常见的灾难预防措施，如在公共场所安防灭火器、洒水器。</p></blockquote><h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a><div><span>异常分类</span></div></h3><p>在Java程序设计语言中，异常对象都是派生于<code>Throwable</code>类的一个实例，若内置的异常类不能满足需求，则用户还可以创建自己的异常类。</p><p class="customize-img"><img src="/assets/blogImg/exception/throwable-hierarchy.png" alt="异常层次目录"></p><p>所有的异常都是由<code>Throwable</code>继承而来，在下一层又划分为两个分支：<code>Error</code>和<code>Exception</code>。</p><ul><li><code>Error</code>：描述了Java运行时系统的内部错误。在程序当中不应该抛出这种类型的错误，因为该错误除了通知用户之外，我们对它无能为力。</li><li><code>Exception</code>：<ul><li><code>IOException</code>：操作IO时出现的异常情况，如操作的文件不存在、试图在文件尾部后面读取数据。</li><li><code>RuntimeException</code>：由程序的错误编写而导致异常的出现，如错误的类型转换、数组角标越界。</li></ul></li></ul><h3 id="声明受查异常"><a href="#声明受查异常" class="headerlink" title="声明受查异常"></a><div><span>声明受查异常</span></div></h3><p>Java语言规范将派生于<code>Error</code>或<code>RuntimeException</code>的所有异常成为<code>非受查异常</code>，其他的所有异常称为<code>受查异常</code>。<br>为什么要声明异常呢？当你遇到无法处理的情况时是不是要告诉别人这件事我做不了你看着办，有点小尴尬的样子～至于为什么受查异常要声明而非受查异常不用声明呢？（声明了也不要紧，只是没必要）-见如下分析～</p><blockquote><p>处理文件时一般会先检查该文件是否存在，但是它是不是有可能在你检查完是否存在后就被删除了，所以受查异常更取决于环境而不只是代码。运行时异常（RuntimeException）出现的原因是由于代码编写的不规范而产生的，这完全是在我们的控制范围内，Java语言建议我们应该将更多的时间花费在修正程序中的错误上，而不是说明这些错误发生的可能性，所以非受查异常要么是我们无能为力的，要么是我们应该通过修正程序来避免发生。</p></blockquote><p>一个方法有可能要声明多个受查异常类型，那么就必须在方法的首部列出所有的异常类，每个异常类之间用逗号隔开。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.zlia.exception.knowledge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.EOFException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnimation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawImage</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">throws</span> FileNotFoundException , EOFException </span>&#123;</span><br><span class="line"><span class="comment">//do anything</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>Throwable RuntimeException IOException 受查异常 非受查异常</code></p><p><a href="https://github.com/JulianHang/core-java-i/tree/master/src/tech/zlia/knowledge/exception" target="_blank" rel="noopener">源码下载</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;简介&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;用户在运行程序的期间，往往有可能会出现各种各样的错误导致程序执行失败，其结果是用户数据丢失。出现这种情况的时候当然不能置之不理，要么就应该告诉用户该错误，要么是用户数据得到保存，否则用户流量将呈现下降的趋势。为了正确的处理错误，Java提供了一种称为：&lt;code&gt;异常处理的错误捕获机制处理&lt;/code&gt;。该机制的任务就是将控制权从错误产生的地方转移给能够处理错误的处理器。当然了，想要正确的处理异常情况的前提是必须要研究程序中哪些地方会出现问题和错误。
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
</feed>
