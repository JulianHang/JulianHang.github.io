<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>奇思妙想</title>
  
  <subtitle>越努力越幸运！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zlia.tech/"/>
  <updated>2020-01-13T15:46:26.662Z</updated>
  <id>http://zlia.tech/</id>
  
  <author>
    <name>zlia</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分析Executor家族成员</title>
    <link href="http://zlia.tech/2020/01/13/explain-executor-sourcecode/"/>
    <id>http://zlia.tech/2020/01/13/explain-executor-sourcecode/</id>
    <published>2020-01-13T15:32:50.000Z</published>
    <updated>2020-01-13T15:46:26.662Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前奏"><a href="#前奏" class="headerlink" title="前奏"></a><div><span>前奏</span></div></h3><p><code>Executor</code>是家族中的老大，其下还有ExecutorService、Executors、ThreadPoolExecutor、ScheduledThreadPoolExecutor和ForkJoinPool，对于ForkJoinPool是在JDK1.7中新增的，其中可能还涉及到诸多理论，故而打算会另起文章进行说明。不管是在工作还是面试中，难免会耳闻线程池，简单说下个人对线程池的理解，后续将对Executor的家族成员做一一介绍，让我们开始旅程吧，此次探索基于<code>JDK1.8</code>。</p><blockquote><p><code>线程池</code>：将创建好的线程放到一个池中进行使用、调度及管理，等到任务一提交后就可以直接运行了，省去了创建线程的时间，同时使用者不必考虑如何管理线程，让使用者更加专注于任务。线程池中会涉及到核心线程数（corePoolSize）、最大线程数（maximumPoolSize）、队列，假设线程个数小于核心线程数，对于新提交的任务会直接创建新线程，当线程个数超过核心线程数且队列未满时，将新任务放入到队列中，等到空闲线程后再去执行，万一要是队列满了且线程数不超过最大线程数时，则会创建新线程执行任务，哪天要是大于最大线程数，则任务将被拒绝，对于拒绝可指定不同的策略，后续将会详细介绍。</p></blockquote><h3 id="家族成员"><a href="#家族成员" class="headerlink" title="家族成员"></a><div><span>家族成员</span></div></h3><p class="customize-img"><img src="/assets/blogImg/java/executor/executor-class-structure.png" alt="Executor家族成员"></p><p>每个成员的地位很明确了，我们从Executors开始入手。</p><a id="more"></a><h4 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h4><p><code>Executors</code>是其家族成员的工厂类，是个便利的工具，使用常用的配置调用方法来创建ExecutorService、ScheduledExecutorService、ThreadFactory对象，工作中经常使用此方式来完成作业。</p><h5 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无法构造该对象实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executors</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无法构造该对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Executors</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建具有固定线程数的线程池</span></span><br><span class="line"><span class="comment">     * 该线程池采用的队列是无界队列，无界队列很容易理解，没有边界、没有上限、无限制添加，在我们熟悉的数据结构当中，内部采用的应该是链条式结构</span></span><br><span class="line"><span class="comment">     * 线程个数小于核心线程数时，对于新提交的任务直接创建新线程执行，当线程个数超过核心线程数时，对于新提交的任务就被放入到队列当中了</span></span><br><span class="line"><span class="comment">     * 恰好是个无界队列，也就是说万一要是没有空闲的线程的话，那此队列中的任务数量将会无限增大，或者说当任务的提交速速远大于任务的处理速度时，队列中的任务数量也会无限增大</span></span><br><span class="line"><span class="comment">     * 这也最终导致了线程池中最多只会有核心线程数的线程，最大线程数没啥用了，线程池中的线程在创建后即使空闲下来了也不会被关闭，除非主动调用shutdown方法</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 使用场景：</span></span><br><span class="line"><span class="comment">     * 由于任务有可能出现队列中进行等待，故而执行中的任务与等待中的任务不能有依赖关系，该种方式能够消除短暂的大量任务提交</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nThreads 核心线程数/最大线程数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 线程池对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">////////// ForkJoinPool将会新起文章进行讲解 /////////</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建具有固定线程数的线程池，线程由使用者自定义创建</span></span><br><span class="line"><span class="comment">     * 默认情况下，由Executors＃defaultThreadFactory来帮助使用者创建线程，所有的线程都位于同一个线程组中，并且拥有相同的优先级和非守护线程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 使用场景：</span></span><br><span class="line"><span class="comment">     * 1. 由于任务有可能出现队列中进行等待，故而执行中的任务与等待中的任务不能有依赖关系，该种方式能够消除短暂的大量任务提交</span></span><br><span class="line"><span class="comment">     * 2. 通过指定线程的工厂类来自定义线程的创建过程，可自定义每个线程的具有不同的优先级、线程组、线程的名称</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nThreads 核心线程数/最大线程数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threadFactory 线程的工厂类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 线程池对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建具有单个线程的线程池，也就是池中只有一个线程</span></span><br><span class="line"><span class="comment">     * 该线程池采用的无界队列，很可惜，对于多任务来说，只能有一个任务在执行，其他的任务都需要等待，这也保证了任务按顺序执行</span></span><br><span class="line"><span class="comment">     * 线程池中的线程在创建后即使空闲下来了也不会被关闭，除非主动调用shutdown方法</span></span><br><span class="line"><span class="comment">     * newSingleThreadExecutor与newFixedThreadPool(1)的区别：对于newFixedThreadPool方法来说，它是可以调用指定方法来重新配置线程的个数，而对于newSingleThreadExecutor来说，它的实现类并未拥有这种类型的方法，所以说它是不可配置* 的，也就是真正意义上的single</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 使用场景：</span></span><br><span class="line"><span class="comment">     * 1. 由于任务有可能出现队列中进行等待，故而执行中的任务与等待中的任务不能有依赖关系，该种方式能够消除短暂的大量任务提交</span></span><br><span class="line"><span class="comment">     * 2. 可用于执行优先级较低的任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 线程池对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建具有单个线程的线程池，线程由使用者自定义创建</span></span><br><span class="line"><span class="comment">     * 默认情况下，由Executors＃defaultThreadFactory来帮助使用者创建线程，所有的线程都位于同一个线程组中，并且拥有相同的优先级和非守护线程</span></span><br><span class="line"><span class="comment">     * 线程池中的线程在创建后即使空闲下来了也不会被关闭，除非主动调用shutdown方法</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 使用场景：</span></span><br><span class="line"><span class="comment">     * 1. 由于任务有可能出现队列中进行等待，故而执行中的任务与等待中的任务不能有依赖关系，该种方式能够消除短暂的大量任务提交</span></span><br><span class="line"><span class="comment">     * 2. 可用于执行优先级较低的任务</span></span><br><span class="line"><span class="comment">     * 3. 通过指定线程的工厂类来自定义线程的创建过程，可自定义每个线程的具有不同的优先级、线程组、线程的名称</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threadFactory 线程的工厂类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建无限制线程个数的线程池</span></span><br><span class="line"><span class="comment">     * 该线程池采用的是直接交接，简单理解就是提交的任务被直接交给线程，如果没有空闲的线程来运行任务的话，那么就创建一个新线程来执行它</span></span><br><span class="line"><span class="comment">     * 由于最大线程数是无限制，所以当任务的提交速速远大于任务的处理速速时，将会造成线程的无限增长</span></span><br><span class="line"><span class="comment">     * 当任务被处理完后，当前的线程就处于空闲状态，当空闲时间超过60s后该线程将被回收，若中途有其他任务则重复使用该线程，因此即使线程池长时间不使用的话也不会造成资源的浪费，因为线程都被回收了</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 使用场景:</span></span><br><span class="line"><span class="comment">     * 1. 由于没有等待队列，所以可以用来处理任务之间具有依赖关系的情况</span></span><br><span class="line"><span class="comment">     * 2. 处理大量小型异步任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 线程池对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建无限制线程个数的线程池，线程由使用者自定义创建</span></span><br><span class="line"><span class="comment">     * 默认情况下，由Executors＃defaultThreadFactory来帮助使用者创建线程，所有的线程都位于同一个线程组中，并且拥有相同的优先级和非守护线程</span></span><br><span class="line"><span class="comment">     * 线程池中的线程空闲超过60s后将被回收</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 使用场景：</span></span><br><span class="line"><span class="comment">     * 1. 由于没有等待队列，所以可以用来处理任务之间具有依赖关系的情况</span></span><br><span class="line"><span class="comment">     * 2. 处理大量小型任务</span></span><br><span class="line"><span class="comment">     * 3. 通过指定线程的工厂类来自定义线程的创建过程，可自定义每个线程的具有不同的优先级、线程组、线程的名称</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threadFactory 线程的工厂类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 线程池对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建具有单个定时线程的线程池</span></span><br><span class="line"><span class="comment">     * 定时线程：在指定的延迟后或周期性运行</span></span><br><span class="line"><span class="comment">     * 该线程池采用的延迟队列，内部采用数组来存储任务，采用Condition进行延迟操作，对于多任务来说，只能有一个任务在执行，其他的任务都需要等待，这也保证了任务按顺序执行</span></span><br><span class="line"><span class="comment">     * 线程池中的线程在创建后即使空闲下来了也不会被关闭，除非主动调用shutdown方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 使用场景：</span></span><br><span class="line"><span class="comment">     * 1. 延迟或周期性的优先级较低的任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 线程池对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建具有单个定时线程的线程池</span></span><br><span class="line"><span class="comment">     * 定时线程：在指定的延迟后或周期性运行</span></span><br><span class="line"><span class="comment">     * 默认情况下，由Executors＃defaultThreadFactory来帮助使用者创建线程，所有的线程都位于同一个线程组中，并且拥有相同的优先级和非守护线程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 使用场景：</span></span><br><span class="line"><span class="comment">     * 1. 延迟或周期性的优先级较低的任务</span></span><br><span class="line"><span class="comment">     * 2. 通过指定线程的工厂类来自定义线程的创建过程，可自定义每个线程的具有不同的优先级、线程组、线程的名称</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threadFactory 线程的工厂类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 线程池对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>, threadFactory));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建具有固定定时线程数的线程池</span></span><br><span class="line"><span class="comment">     * 定时线程：在指定的延迟后或周期性运行</span></span><br><span class="line"><span class="comment">     * 若corePoolSize &gt; 1, 对于多任务来说，可以有多个任务同时执行，不会按照顺序执行</span></span><br><span class="line"><span class="comment">     * 线程池中的线程在创建后即使空闲下来了也不会被关闭，除非主动调用shutdown方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 使用场景：</span></span><br><span class="line"><span class="comment">     * 1. 延迟或周期性的多任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> corePoolSize 核心线程数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 线程池对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建具有固定定时线程数的线程池</span></span><br><span class="line"><span class="comment">     * 定时线程：在指定的延迟后或周期性运行</span></span><br><span class="line"><span class="comment">     * 若corePoolSize &gt; 1, 对于多任务来说，可以有多个任务同时执行，不会按照顺序执行</span></span><br><span class="line"><span class="comment">     * 默认情况下，由Executors＃defaultThreadFactory来帮助使用者创建线程，所有的线程都位于同一个线程组中，并且拥有相同的优先级和非守护线程</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 使用场景：</span></span><br><span class="line"><span class="comment">     * 1. 延迟或周期性的多任务</span></span><br><span class="line"><span class="comment">     * 2. 通过指定线程的工厂类来自定义线程的创建过程，可自定义每个线程的具有不同的优先级、线程组、线程的名称</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> corePoolSize 核心线程数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threadFactory 线程的工厂类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 线程池对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义线程池，窄化了线程池中的方法，也就是说线程池中的一些方法是不可调用的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> executor 自定义线程池</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 窄化后的线程池对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">unconfigurableExecutorService</span><span class="params">(ExecutorService executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (executor == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DelegatedExecutorService(executor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义线程池（定时线程），窄化了线程池中的方法，也就是说线程池中的一些方法是不可调用的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> executor 自定义线程池</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 窄化后的线程池对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">unconfigurableScheduledExecutorService</span><span class="params">(ScheduledExecutorService executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (executor == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的线程工厂类，用于创建线程</span></span><br><span class="line"><span class="comment">     * 创建的线程将属于同一个线程组，拥有同样的优先级5和非守护线程，线程的名称：pool-poolNumberSequence-thread-threadNumberSequence</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 默认的线程工厂类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadFactory <span class="title">defaultThreadFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultThreadFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的线程工厂类，区别在于具备了与当前调用线程相同的权限，并且为每个线程设置了类加载器与访问控制上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 默认的线程工厂类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadFactory <span class="title">privilegedThreadFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PrivilegedThreadFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回Callable对象</span></span><br><span class="line"><span class="comment">     * RunnableAdapter#call只是单纯的调用run方法，并未启动线程</span></span><br><span class="line"><span class="comment">     * Callable与Runnable相比，可以有返回值</span></span><br><span class="line"><span class="comment">     * 不过即使run方法中抛出异常，该方法也捕捉不到，毕竟run方法无法抛出</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task 任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result 结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Callable对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回Callable对象</span></span><br><span class="line"><span class="comment">     * RunnableAdapter#call只是单纯的调用run方法，并未启动线程</span></span><br><span class="line"><span class="comment">     * Callable与Runnable相比，可以有返回值</span></span><br><span class="line"><span class="comment">     * 不过即使run方法中抛出异常，该方法也捕捉不到，毕竟run方法无法抛出</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task 任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Callable对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Object&gt; <span class="title">callable</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;Object&gt;(task, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回Callable对象</span></span><br><span class="line"><span class="comment">     * Callable与Runnable相比，可以有返回值</span></span><br><span class="line"><span class="comment">     * PrivilegedAction#run方法也是无法抛出异常，故该方法也是捕捉不到异常信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> action 任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Callable对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Object&gt; <span class="title">callable</span><span class="params">(<span class="keyword">final</span> PrivilegedAction&lt;?&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Callable&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> </span>&#123; </span><br><span class="line">                <span class="keyword">return</span> action.run(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回Callable对象</span></span><br><span class="line"><span class="comment">     * Callable与Runnable相比，可以有返回值</span></span><br><span class="line"><span class="comment">     * PrivilegedExceptionAction#run方法可以抛出异常，故而该方法可以捕捉异常信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> action 任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Callable对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Object&gt; <span class="title">callable</span><span class="params">(<span class="keyword">final</span> PrivilegedExceptionAction&lt;?&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Callable&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">                <span class="keyword">return</span> action.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回Callable对象，在特权环境下执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callable Callable对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Callable对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">privilegedCallable</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PrivilegedCallable&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回Callable对象，在特权环境下执行，拥有当前线程的访问控制权限与类加载器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callable Callable对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Callable对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">privilegedCallableUsingCurrentClassLoader</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PrivilegedCallableUsingCurrentClassLoader&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义Callable对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//任务</span></span><br><span class="line">        <span class="keyword">final</span> Runnable task;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用结果</span></span><br><span class="line">        <span class="keyword">final</span> T result;</span><br><span class="line">        RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">            <span class="keyword">this</span>.result = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            task.run(); <span class="comment">//只是单纯的调用run方法，并未开始线程</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///////其他类似的Callable对象就不做展示了///////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的线程工厂类，用于创建新线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自定义序列号，相同的数字表示同一个线程池对象</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程组</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自定义序列号，数字表示创建了多少个线程</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">        DefaultThreadFactory() &#123;</span><br><span class="line">            SecurityManager s = System.getSecurityManager();</span><br><span class="line">            group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();</span><br><span class="line">            namePrefix = <span class="string">"pool-"</span> + poolNumber.getAndIncrement() + <span class="string">"-thread-"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(group, r, namePrefix + threadNumber.getAndIncrement(), <span class="number">0</span>); <span class="comment">//创建的线程都属于同一个线程组，线程的名称根据线程的个数来区别</span></span><br><span class="line">            <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">                t.setDaemon(<span class="keyword">false</span>); <span class="comment">//创建的线程都属于非守护线程</span></span><br><span class="line">            <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">                t.setPriority(Thread.NORM_PRIORITY); <span class="comment">//创建的线程的优先级都是5</span></span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">////////其他ExecutorService也不做展示了////////</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li><p>newFixedThreadPool：创建具体<code>固定线程数</code>的线程池，内部采用<code>无界队列</code>。当线程个数小于核心线程数时，对于新提交的任务直接创建线程执行，当线程个数大于核心线程数时，对于新提交的任务就被放入到队列中。由于是个无界队列，也就是说当没有空闲的线程时，随着任务的不断提交队列将无限增大，或者说当任务的提交速度远大于任务的处理速度时，队列也会无限增大。正如方法名一样，线程池中的线程个数最多只有核心线程数，最大线程数没有起到作用，线程池中的线程即使空闲了也<code>不会被关闭</code>，除非主动调用shutdown方法。该方法还可以指定自定义线程工厂类，由使用者自己去决定如何创建线程，以及线程的名称、优先级、县线程组等。</p></li><li><p>newSingleThreadExecutor：创建具有<code>单个线程</code>的线程池，也就是说池中只有一个线程供使用，内部同样采用<code>无界队列</code>。由于只有一个线程处于活跃状态，只能有一个任务在执行，其余的任务只能在队列中等待着，这保证了它可以按<code>顺序</code>执行任务。线程池中的线程即使空闲了也<code>不会被关闭</code>，除非主动调用shutdown方法，该方法同样可以指定自定义线程工厂类。该方法与newFixedThreadPool(1)（简称nft）的区别在于，nft可以调用指定方法来重新配置核心线程数的值，而对于该方法而言，它的实现类并未拥有这种功能的方法，所有它是不可配置的，真正意义上的single。</p></li><li><p>newCachedThreadPool：创建<code>无限制线程个数</code>的线程池，内部采用<code>直接交接</code>的形式，很容易理解，来一个新任务我直接用取一个线程取执行，不管是复用还是新创建的线程，反正是不用等。由于线程个数是无限制的，也就是说当没有可以复用的空闲线程时，随着任务的不断提交线程池中的线程将无限增长。线程池中的线程一旦空闲下来的时间超过指定的保活时间（默认60s）将被<code>回收</code>，若中途有提交新任务则<code>复用</code>线程，因此线程池中的线程即使长时间不使用也不会造成资源的浪费，都被回收了。该方法同样可以指定自定义线程工厂类。</p></li><li><p>newSingleThreadScheduledExecutor：创建具有<code>单个定时线程</code>的线程池，所谓的定时线程是指延迟或周期性执行，内部采用<code>延迟队列</code>，该队列内部使用数组来存储任务，使用Condition进行延迟操作。由于只有一个线程处于活跃状态，只能有一个任务在执行，其余的任务只能在队列中等待着，这保证了它可以按<code>顺序</code>执行任务。线程池中的线程即使空闲了也<code>不会被关闭</code>，除非主动调用shutdown方法。该方法同样可以指定自定义线程工厂类。</p></li><li><p>newScheduledThreadPool：创建具有<code>固定定时线程数</code>的线程池，同样采用<code>延迟队列</code>。若核心线程数大于1，对于多任务来说可以同时运行多个。线程池中的线程即使空闲了也<code>不会被关闭</code>，除非主动调用shutdown方法。该方法同样可以指定自定义线程工厂类。</p></li><li><p>每个方法的使用场景可看具体方法。</p></li></ul><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p><code>ThreadPoolExecutor</code>是家族中的核心成员，担负了家族中的重要工作，简单来说底层就是使用该类对线程进行创建与管理，以及执行任务，内部维护了线程池的各种状态。</p><ul><li><p>运行中（RUNNING）：接收新任务并处理队列中的任务</p></li><li><p>关闭（SHUTDOWN）：不接收新任务，而是处理队列中的任务</p></li><li><p>停止（STOP）：不接受新任务，不处理队列中的任务及中断进行中的任务</p></li><li><p>终止中（TIDYING）：所有任务都已终止，工作线程为0</p></li><li><p>已终止（TERMINATED）：terminated方法执行完成</p></li></ul><p class="customize-img"><img src="/assets/blogImg/java/executor/thread-pool-state.png" alt="线程池状态图"></p><p>以上每个状态的中文解释可能不太准确，更多的是想帮助大家去理解，若觉得不适应或者晦涩难懂可以忽略，接着介绍下线程池的<code>拒绝任务策略</code>。</p><ul><li><p>ThreadPoolExecutor.AbortPolicy：当线程池拒绝任务时，采用直接抛出RejectedExecutionException异常</p></li><li><p>ThreadPoolExecutor.CallerRunsPolicy：当线程池拒绝任务时，采用只要线程池未关闭，由调用execute的线程运行任务，这提供了一种反馈机制，而若线程池已关闭，则任务将被丢弃</p></li><li><p>ThreadPoolExecutor.DiscardPolicy：当线程池拒绝任务时，采用直接丢弃了任务，相当于直接不执行任务了，很干脆</p></li><li><p>ThreaPollExecutor.DiscardOldestPolicy：当线程池拒绝任务时，采用只要线程池未关闭，则将丢弃队列中头部位置的任务（最早入队列的任务），然后重复执行指定任务（调用execute方法，有可能再次被拒绝导致又重复执行）</p></li></ul><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ctl包装了工作线程的数量（workerCount）与线程池的状态（runState），也就是说通过该变量既可以获取到工作线程的数量，也可以获取到线程池的状态，有点厉害啊！</span></span><br><span class="line"><span class="comment">     * 其中将工作线程的数量限制到 2^29 -1，简单来说，一个32位的int类型来说，后29位表示工作线程的数量，剩余3位表示线程池的状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过移位区分工作线程的数量与线程池的状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示工作线程的数量的最大值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * TERMINATED &gt; TIDYING &gt; STOP &gt; SHUTDOWN &gt; RUNNING</span></span><br><span class="line"><span class="comment">     * 由于工作线程取的是后29位，所以我们可以知道：TIDYING &gt; STOP + CAPACITY（这两者就差1）</span></span><br><span class="line"><span class="comment">     * 所以我们更能得出：TERMINATED &gt; TIDYING + CAPACITY &gt; TIDYING &gt; STOP + CAPACITY &gt; STOP &gt; SHUTDOWN + CAPACITY &gt; SHUTDOWN &gt; RUNNING + CAPACITY &gt; RUNNING</span></span><br><span class="line"><span class="comment">     * 而我们知道ctl代表着工作线程 + 线程池的状态，故而简化为：TERMINATED &gt; ctl（TIDYING） &gt; TIDYING &gt; ctl(STOP) &gt; STOP &gt; ctl(SHUTDOWN) &gt; SHUTDOWN &gt; ctl(RUNNING) &gt; RUNNING</span></span><br><span class="line"><span class="comment">     * 所以我们要想知道线程池处于哪个状态区间，则可以直接比较ctl与状态值，比如ctl &gt; STOP，则说明线程池处于TERMINATED或TIDYING</span></span><br><span class="line"><span class="comment">     * 这样子ctl就不用为了获取状态值而进行拆解，为什么要分析这东西呢，因为后面有方法涉及到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池处于运行中状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池处于关闭状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池处于停止状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池处于终止中状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池处于已终止状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储任务，工作线程从队列中获取任务并处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 目前只需要知道是锁就可以了，至于什么类型的锁以后会新起文章进行详细介绍</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储线程池中的所有工作线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 条件等待，与Lock组合使用，用于代替Synchronized与对象锁，以后也会新起文章进行讲解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition termination = mainLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池的最大线程数，简单来说就是线程池中有多少个线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 已完成任务的数量，该变量只会在工作线程结束后进行更新</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程的工厂类，用于创建线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拒绝任务的策略，当线程池达到最大线程数或关闭/停止状态时就会拒绝任务的提交</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当线程池中的线程个数大于核心线程数时，其空闲线程的存活时间，超过该时间后将被回收，若线程个数小于核心线程数则不会在回收空闲线程</span></span><br><span class="line"><span class="comment">     * 或者设置了allowCoreThreadTimeOut = true，表示所有线程的空闲时间超过指定时间后将被回收</span></span><br><span class="line"><span class="comment">     * 执行任务中的线程不算空闲线程，等待任务的线程是空闲线程，简单来说，空闲线程就是没事做</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 若未设置存活时间，即默认是0，表示永远不会回收线程，即使线程个数超过了核心线程数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认情况下是false，表示核心线程即使空闲了也不会被回收</span></span><br><span class="line"><span class="comment">     * 若为true，表示所有线程的空闲时间超过keepAliveTime后将被回收</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 核心线程数</span></span><br><span class="line"><span class="comment">     * allowCoreThreadTimeOut = false，最终可以保留核心线程数的工作线程</span></span><br><span class="line"><span class="comment">     * allowCoreThreadTimeOut = true，最终工作线程将为0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大线程数</span></span><br><span class="line"><span class="comment">     * 该数值受CAPACITY限制，也就是说最大是CAPACITY</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拒绝任务的默认策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler defaultHandler = <span class="keyword">new</span> AbortPolicy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化，采用默认拒绝任务的策略、默认的线程工厂类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize 核心线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maximumPoolSize 最大线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keepAliveTime 保活时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> workQueue 队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化，采用默认拒绝任务的策略、自定义线程工厂类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize 核心线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maximumPoolSize 最大线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keepAliveTime 保活时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> workQueue 队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory 线程的工厂类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化，采用默认的线程工厂类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize 核心线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maximumPoolSize 最大线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keepAliveTime 保活时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> workQueue 队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler 拒绝任务的策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize 核心线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maximumPoolSize 最大线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keepAliveTime 保活时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> workQueue 队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory 线程的工厂类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler 拒绝任务的策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> || maximumPoolSize &lt;= <span class="number">0</span> || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ? <span class="keyword">null</span> : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime); <span class="comment">//将时间转换成纳秒</span></span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="简单方法-1"><a href="#简单方法-1" class="headerlink" title="简单方法"></a>简单方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br><span class="line">1319</span><br><span class="line">1320</span><br><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br><span class="line">1345</span><br><span class="line">1346</span><br><span class="line">1347</span><br><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br><span class="line">1366</span><br><span class="line">1367</span><br><span class="line">1368</span><br><span class="line">1369</span><br><span class="line">1370</span><br><span class="line">1371</span><br><span class="line">1372</span><br><span class="line">1373</span><br><span class="line">1374</span><br><span class="line">1375</span><br><span class="line">1376</span><br><span class="line">1377</span><br><span class="line">1378</span><br><span class="line">1379</span><br><span class="line">1380</span><br><span class="line">1381</span><br><span class="line">1382</span><br><span class="line">1383</span><br><span class="line">1384</span><br><span class="line">1385</span><br><span class="line">1386</span><br><span class="line">1387</span><br><span class="line">1388</span><br><span class="line">1389</span><br><span class="line">1390</span><br><span class="line">1391</span><br><span class="line">1392</span><br><span class="line">1393</span><br><span class="line">1394</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过ctl原子变量获取线程池的状态</span></span><br><span class="line"><span class="comment"> * ~CAPACITY：对于取反运算符，只要先获取到CAPACITY的补码后对其进行取反（0变成1，1变成0）即可获取到结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ctl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> c &amp; ~CAPACITY; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过ctl原子变量获取工作线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c ctl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> c &amp; CAPACITY; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新ctl原子变量的值，即当线程池的状态或工作线程的数量发生变化时就会调用该方法</span></span><br><span class="line"><span class="comment"> * 在更新完ctl的值后就可以调用runStateOf方法获取线程池的状态，或调用workerCountOf方法获取工作线程的数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rs 线程池的状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> wc 工作线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> rs | wc; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工作线程，包装了提交的任务与线程</span></span><br><span class="line"><span class="comment"> * 执行路径：thread -&gt; worker -&gt; task</span></span><br><span class="line"><span class="comment"> * 该类实现了AQS，虽然对AQS还不了解，但并不影响我们看源码</span></span><br><span class="line"><span class="comment"> * 该类中定义了三种状态：-1表示工作线程还未启动  0表示工作线程未上锁   1表示工作线程上锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新创建的线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//任务</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当前工作线程完成的任务数量</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化工作线程</span></span><br><span class="line"><span class="comment">     * 此时工作线程的状态为-1，表示还未启动</span></span><br><span class="line"><span class="comment">     * 每一个新的工作线程会创建新线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstTask 任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">//该状态会在工作线程启动后将其变成1</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>); <span class="comment">//创建新线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动工作线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前工作线程是否上锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 工作线程是否上锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unused 未使用到</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否获取到锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试释放锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unused 未使用到</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取锁，一定会获取到锁，只不过可能需要阻塞等待，更多的知识以后会新起文章进行深入分析</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        acquire(<span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取锁，获取不到就直接返回了，不会阻塞等待</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否获取到锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        release(<span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前工作线程是否上锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 工作线程是否上锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> isHeldExclusively(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中断已启动的工作线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 比较当前线程池的状态是否小于指定状态值</span></span><br><span class="line"><span class="comment"> * 简单来说就是为了知道线程池处于哪个状态区间</span></span><br><span class="line"><span class="comment"> * 更为具体的分析可看最上面</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c ctl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 指定状态值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateLessThan</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 比较当前线程池的状态是否大于指定状态值</span></span><br><span class="line"><span class="comment"> * 简单来说就是为了知道线程池处于哪个状态区间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c ctl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 指定状态值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateAtLeast</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前线程池是否处于运行中状态（RUNNING）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c ctl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以原子化的方式增加工作线程的数量，这里利用CAS，以后也会新起文章进行讲解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expect 预期值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值，false表示实际值与预期值不同导致更新值失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndIncrementWorkerCount</span><span class="params">(<span class="keyword">int</span> expect)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ctl.compareAndSet(expect, expect + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以原子化的方式减少工作线程的数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expect 预期值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值，false表示实际值与预期值不同导致更新值失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndDecrementWorkerCount</span><span class="params">(<span class="keyword">int</span> expect)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ctl.compareAndSet(expect, expect - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decrementWorkerCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (! compareAndDecrementWorkerCount(ctl.get()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关闭或停止线程池时会调用此方法</span></span><br><span class="line"><span class="comment"> * 若线程池的当前状态大于指定状态，则不做任何操作，否则将其置为指定状态并更新工作线程的数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetState 指定状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">advanceRunState</span><span class="params">(<span class="keyword">int</span> targetState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (runStateAtLeast(c, targetState) ||</span><br><span class="line">            ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试终止线程池</span></span><br><span class="line"><span class="comment"> * 回收线程</span></span><br><span class="line"><span class="comment"> * 从TIDYING过渡到TERMINATED状态</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * STOP(线程池为空)：TIDYING</span></span><br><span class="line"><span class="comment"> * SHUTDOWN(线程池和队列为空)：TIDYING</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1. 从上面的线程池状态图可知，RUNNING是不可能直接过渡到TERMINATED，只能从TIDYING过渡到TERMINATED</span></span><br><span class="line"><span class="comment">         * 2. 满足TIDYING状态只能是STOP且线程池为空或SHUTDOWN且线程池和队列为空</span></span><br><span class="line"><span class="comment">         * 3. 当调用shutdown方法时，线程池的状态是SHUTDOWN，但是当队列中还有任务未执行时，回收所有空闲的工作线程！！！（有些空闲线程在被中断时因为队列中有任务而变成不是空闲），这正好符合我们说SHUTDOWN状态下的线程池会去处理队列中*    的任务，当队列中的任务执行完毕后在回收所有线程！！！</span></span><br><span class="line"><span class="comment">         * 4. 当调用shutdownNow方法时，线程池的状态是STOP，此时队列中的任务将会被清空，同时回收所有线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) || runStateAtLeast(c, TIDYING) || (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">//工作线程数大于0</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE); <span class="comment">//中断其中一个空闲线程，即使只是中断一个空闲线程，后续还会继续去中断其他空闲线程</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;  <span class="comment">//将线程池的状态变成TIDYING状态</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    terminated();<span class="comment">//调用terminated方法，交给每个子类去实现</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>)); <span class="comment">//将线程池的状态变成TERMINATED状态</span></span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定值判断是中断所有空闲线程还是只中断其中一个</span></span><br><span class="line"><span class="comment"> * 即使是只中断一个空闲线程，后续也会因为再次调用tryTerminate#interruptIdleWorkers在中断其他空闲线程，所以并不影响</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyOne 标志</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123; <span class="comment">//若工作线程被上锁了，说明工作线程正在执行任务，不能去中断，不属于空闲线程</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中断所有工作线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">            w.interruptIfStarted();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接拒绝新任务提交的策略</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> command 任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    handler.rejectedExecution(command, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定值决定是要判断线程池是处于RUNNING还是SHUTDOWN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> shutdownOK true表示要判断线程池是否处于SHUTDOWN，若是则返回true</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isRunningOrShutdown</span><span class="params">(<span class="keyword">boolean</span> shutdownOK)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">    <span class="keyword">return</span> rs == RUNNING || (rs == SHUTDOWN &amp;&amp; shutdownOK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除队列中的所有任务，并将其放入到数组中</span></span><br><span class="line"><span class="comment"> * 通常使用drainTo将任务放入到数组中. 但是，如果队列是DelayQueue或其他类型的队列，poll或drainTo可能无法删除某些元素，则将它们逐个删除.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 存放任务的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Runnable&gt; <span class="title">drainQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; q = workQueue;</span><br><span class="line">    ArrayList&lt;Runnable&gt; taskList = <span class="keyword">new</span> ArrayList&lt;Runnable&gt;();</span><br><span class="line">    q.drainTo(taskList);</span><br><span class="line">    <span class="keyword">if</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Runnable r : q.toArray(<span class="keyword">new</span> Runnable[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.remove(r))</span><br><span class="line">                taskList.add(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> taskList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行任务</span></span><br><span class="line"><span class="comment"> * 有可能是创建新线程去执行任务，也有可能是复用线程去执行任务</span></span><br><span class="line"><span class="comment"> * 若线程池已经关闭或者线程池饱和（线程个数达到最大线程数且队列已满）则会执行拒绝任务的策略，默认情况下是抛出异常，其他情况下都会正常执行任务</span></span><br><span class="line"><span class="comment"> * 注意：若线程池在关闭前就已经将任务入队列且没有remove成功，那么最终还是要正常执行</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 总结：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 线程池的状态处于RUNNING下：</span></span><br><span class="line"><span class="comment"> * 1. 对于新提交的任务，线程个数小于核心线程数，则新创建线程进行处理 （size &lt; corePoolSize）</span></span><br><span class="line"><span class="comment"> * 2. 对于新提交的任务，线程个数大于核心线程小于最大线程数，则尝试放入到队列中 （corePoolSize &lt; size &lt; maximumPoolSize）</span></span><br><span class="line"><span class="comment"> *    21. 若此时队列未满，则放入成功，后续会正常执行</span></span><br><span class="line"><span class="comment"> *    22. 若此时队列已满（放入失败），则直接创建新线程去执行</span></span><br><span class="line"><span class="comment"> * 3. 对于新提交的任务，线程个数大于核心线程数且等于最大线程数，则尝试放入到队列中，若队列已经满了，这时的线程池已经饱和了，只能拒绝任务，若队列未满，则加入到队列中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 线程处的状态已经关闭，这里有个点需要注意下，应该采用的双重检查，所以以下的分析会说是第一次检查时关闭还是第二次检查时关闭</span></span><br><span class="line"><span class="comment"> * 1. 对于新提交的任务，线程个数小于核心线程数，拒绝任务</span></span><br><span class="line"><span class="comment"> * 2. 对于新提交的任务，线程个数大于核心线程数小于最大线程数，第一次检查时线程池已关闭，说明还未入队列中，拒绝任务</span></span><br><span class="line"><span class="comment"> * 2. 对于新提交的任务，线程个数大于核心线程数小于最大线程数，第一检查处于RUNNING，入队列中，第二次检查时关闭了，去移除任务，要是移除失败了，那么最终还是会去正常执行任务，若移除成功了，则拒绝任务</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> command 任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">     * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">     * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">     * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">     * threads when it shouldn't, by returning false.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">     * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">     * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">     * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">     * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">     * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">     * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">     * and so reject the task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 若线程池中的线程个数小于核心线程数，则创建一个新线程去执行任务，新线程中包含有任务</span></span><br><span class="line"><span class="comment">     * 2. 若线程个数大于核心线程数，则判断线程池是否处于RUNNING，且尝试去入队列，这里要注意下双重检查的处理</span></span><br><span class="line"><span class="comment">     *    21. 若第二次检查时线程池关闭了，照道理应该remove任务，不过有可能移除失败，没办法还是必须去处理它</span></span><br><span class="line"><span class="comment">     *    22. 若线程池处于RUNNING，则正常处理</span></span><br><span class="line"><span class="comment">     * 3. 若线程池并不处于RUNNING，即第一次检查时就关闭了，不好意思了，拒绝任务</span></span><br><span class="line"><span class="comment">     * 4. 若线程池处于RUNNING，但是入队列失败了，那么判断是否有多余的线程，若没有，则说明线程池达到饱和，只能拒绝任务了，若有则创建新线程去执行任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123; <span class="comment">//1</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>)) <span class="comment">//若创建新线程失败或抛出异常，则返回false，addWorker方法中会判断线程池的状态是否处于RUNNING</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<span class="comment">//2 workQueue.offer返回true表示入队列成功</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 双重检查，上面的注释说的是：线程池在第一次检查之后就被关闭了，有可能是多线程下导致的，若是第二次检查中线程池已经关闭了，那么就要把之前入队列时的任务移除掉，并使用了拒绝策略</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command)) </span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 双重检查，此时有两种情况：</span></span><br><span class="line"><span class="comment">         * 1. 线程池的状态处于RUNNING，但是却没有工作线程，那么队列中还有刚才添加的任务没处理呢，所以只能在创建一个新线程来处理任务了</span></span><br><span class="line"><span class="comment">         * 2. 线程池已经关闭了，那么照道理应该移除掉队列中的任务，但是要是没移除掉呢，也就是remove返回false，那它还是会新创建一个线程去处理队列中的任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此时有两种情况：</span></span><br><span class="line"><span class="comment">     * 1. 线程池的状态处于SHUNDOWN/STOP/TIDYING/TERMINATED，说明线程池已经关闭了，那么该任务已经是没有入到队列中，所以最终会返回false，所以直接执行拒绝策略</span></span><br><span class="line"><span class="comment">     * 2. 线程池的状态处于RUNNING，但是任务入队列失败了，有可能是队列满了，也有可能是异常发生了，那么它会在addWorker中判断是否有多余的线程可以创建（与最大线程数比较），若有则正常执行任务，若没有，不好意思了，拒绝任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))<span class="comment">//3,4 </span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建工作线程</span></span><br><span class="line"><span class="comment"> * 若线程池处于SHUTDOWN或STOP，则返回false</span></span><br><span class="line"><span class="comment"> * 若线程工程类创建线程失败或返回null或抛出异常，则返回false</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> firstTask 工作线程的首个任务，若firstTask = null表示只是为了创建一个新线程去处理队列中的任务，若firstTask != null表示正是为了处理指定任务而创建的新线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> core true表示使用核心线程数作为判断线程个数的标准，false表示使用最大线程数作为判断线程个数的标准</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否成功创建工作线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1. 若线程池已经关闭且队列中已经没有任务了，那么应该返回false</span></span><br><span class="line"><span class="comment">         * 2. 若线程池已经关闭但队列中还有任务，那么应该创建新线程去执行，这种情况下是没有工作线程下才会调用此方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span> &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) <span class="comment">//若线程个数已经超过标准了，是不会在创建了，直接返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c)) <span class="comment">//增加工作线程的数量</span></span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs) <span class="comment">//走到这里说明，线程池的状态或者工作线程个数发生了改变</span></span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask); <span class="comment">//创建工作线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//双重检查</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 此时有两种情况：</span></span><br><span class="line"><span class="comment">                 * 1. 线程池的状态处于RUNNING，为了执行任务而创建新的线程</span></span><br><span class="line"><span class="comment">                 * 2. 线程池已经关闭，但是队列中还有任务（若队列中没任务了则在上面就已经返回false了），所以必须要创建一个新线程去执行队列中的任务（此时的情况是没有工作线程了必须要创建一个，若还存在工作线程，压根就不会调用此方法）</span></span><br><span class="line"><span class="comment">                 * 3. 线程池已经关闭，firstTask != null表示要执行新提交的任务，那么这个时候是拒绝的，而若firstTask = null表示创建新线程是为了执行队列中的任务，如第2点</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive())</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>; <span class="comment">//表示创建工作线程成功</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start(); <span class="comment">//通过该方式去启动工作线程</span></span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted) <span class="comment">//线程工程类创建线程失败或返回null或抛出异常，线程池已关闭拒绝新提交的任务，线程启动失败</span></span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理创建工作线程失败后的动作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w 工作线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">            workers.remove(w); <span class="comment">//移除指定工作线程</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        tryTerminate();<span class="comment">//</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 回收工作线程</span></span><br><span class="line"><span class="comment"> * 有可能是线程池处于RUNNING却因为工作线程突发异常导致被回收，有可能是因为关闭了线程池导致回收线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w 工作线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> completedAbruptly 工作线程是否发生异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">//若突发异常导致工作线程发生异常，该值为true，应该主动调用方法去减少工作线程的数量，正常情况下工作线程在被回收时会在指定方法中调用getTask -&gt; decrementWorkerCount</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        workers.remove(w); <span class="comment">//移除指定工作线程</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tryTerminate(); <span class="comment">//尝试去终止线程池</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123; <span class="comment">//线程池的状态处于SHUTDONW/RUNNING</span></span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty()) <span class="comment">//不存在工作线程，但队列中还有任务未处理</span></span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min) <span class="comment">//若线程个数满足上面的条件则不需要创建新线程了</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 有可能因为工作线程发生异常导致被回收，线程池中不存在工作线程，但此时队列中还有任务，所以必须要创建新线程去处理队列中的任务</span></span><br><span class="line"><span class="comment">         * 按照线程池的策略，原先线程个数大于核心线程数在被回收到导致变成了小于，那么它会弥补新的一个线程，同样的原先线程个数小于核心线程数，它也会弥补新的一个线程，但若是即使被回收了也仍是大于，则不会新增了</span></span><br><span class="line"><span class="comment">         * 按照我的理解它是为了保证不会降低效率</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取队列中的任务</span></span><br><span class="line"><span class="comment"> * 工作线程一直处理阻塞或阻塞指定时间</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 总结：</span></span><br><span class="line"><span class="comment"> * 1. 线程个数超过最大线程数（重新调用setMaximumPoolSize），会返回null</span></span><br><span class="line"><span class="comment"> * 2. 线程池处于SHUTDOWN且队列为空，返回null</span></span><br><span class="line"><span class="comment"> * 3. 线程池处于STOP，返回null</span></span><br><span class="line"><span class="comment"> * 4. 线程个数小于最大线程数，线程池处于RUNNING</span></span><br><span class="line"><span class="comment"> *    41. 若设置了allowCoreThreadTimeOut = true，所有工作线程的空闲时间超过保活时间后会被回收</span></span><br><span class="line"><span class="comment"> *    42. 若设置了allowCoreThreadTimeOut = false，且线程个数大于核心线程数的工作线程的空闲时间超过保活时间会被回收，即最终只有核心线程数的工作线程存在，通过调用shutdown回收最后的工作线程</span></span><br><span class="line"><span class="comment"> * 5. 若队列中还有任务存在，不管是哪一种情况至少都会有一个工作线程存在</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">//表示工作线程的空闲时间是否超过了指定时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1. 线程池处于SHUTDOWN，但是队列中还有任务（我还要工作），但如果队列为空，说明已经没有任务了，该工作线程可以被回收了</span></span><br><span class="line"><span class="comment">         * 2. 线程池处于STOP，队列中的任务实际上已经被清空了，也不会允许任务的提交，该工作线程也可以被回收了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);<span class="comment">//获取线程个数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 线程池处于RUNNING，那么就该考虑怎么回收工作线程了，注意keepAliveTime &gt; 0 否则不管如何都回收不了工作线程</span></span><br><span class="line"><span class="comment">         * 1. 若设置allowCoreThreadTimeOut = true，则当所有的工作线程的空闲时间超过指定时间后会被回收，即所有的工作线程都会被回收</span></span><br><span class="line"><span class="comment">         * 2. 若设置allowCoreThreadTimeOut = false，线程个数大于核心线程数的工作线程的空闲时间超过指定时间后会被回收，即最终的工作线程个数等于核心线程数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1. 工作线程数超过最大线程数，自然要被回收了，工作线程太多了</span></span><br><span class="line"><span class="comment">         * 2. 线程个数小于最大线程数，工作线程的空闲时间是否超过了指定时间，若没超过则不会进入if语句中了，表示当前的工作线程要继续干活</span></span><br><span class="line"><span class="comment">         *    若超过指定时间了，那么还要确认下自己是否是最后一个工作线程，若是最后一个工作线程就要判断队列中是否还有任务，毕竟不能所有工作线程都被回收了，总要有人留下来处理任务吧，若不存在任务则被回收，若存在就要留下来为队列中的任*    务服务了，有点难受了，若不是最后一个线程，先走为妙，总有人要留下来背锅的，哈哈哈，所以也会被回收</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c)) <span class="comment">//工作线程被回收时要减少数量</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 这里涉及到两种策略：注意keepAliveTime &gt; 0 否则不管如何都回收不了工作线程</span></span><br><span class="line"><span class="comment">             * 1. 工作线程要受保活时间的限制进行回收，这种情况下有两个可能，第一种是设置了allowCoreThreadTimeOut = true，即所有的线程都要受保活时间的限制，另外一种是allowCoreThreadTimeOut = false，且线程个数大于核心线程数</span></span><br><span class="line"><span class="comment">             *    了，有些工作线程需要被回收，这两种的线程都会被回收，即timed = true，poll方法表示我只等指定长时间，超过后就返回了（阻塞指定时间）</span></span><br><span class="line"><span class="comment">             * 2. 工作线程不受保活时间的限制，allowCoreThreadTimeOut = false，且线程个数小于核心线程数，此时timed = false，take会一直阻塞，直到被中断</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); <span class="comment">//从队列中获取任务，若获取到直接返回，若获取不到任务，则会阻塞一段时间或一直阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) </span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>; <span class="comment">//走到这里说明阻塞一点时间后仍没有任务，继续循环判断是否要被回收还要是继续等待</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123; <span class="comment">//工作线程阻塞时被中断了</span></span><br><span class="line">            timedOut = <span class="keyword">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行工作线程</span></span><br><span class="line"><span class="comment"> * 若getTask返回null会跳出循环导致工作线程被回收</span></span><br><span class="line"><span class="comment"> * 可能因为抛出异常导致工作线程被回收，如beforeExecute/afterExecute</span></span><br><span class="line"><span class="comment"> * 通过afterExecute/UncaughtExceptionHandler可知道任务发生异常的信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w 工作线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock();</span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>; <span class="comment">//是否因为发生异常导致工作线程被回收</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//重复从队列中获取任务去执行，若当前工作线程已经执行完自身的任务就要帮忙去处理队列中的任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">    </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 双重检查</span></span><br><span class="line"><span class="comment">             * 在第一次检查STOP时，线程池的状态处于STOP，既然后续外部代码改变了中断状态，这里的代码也会再次判断，总而言之结果都会中断</span></span><br><span class="line"><span class="comment">             * 在第一次检查STOP时，线程池的状态处于RUNNING/SHUTDOWN，Thread.interrupted这个语句是必须要有的，假设外部代码会改变中断状态，当你调用shutdown##interruptIdleWorkers时可能会出现线程从来都没有被中断过（中断被清除）* 那么将导致一直阻塞，所以这里加上Thread.interrupted是为了消除外部代码的干扰，这也导致了工作线程的中断状态被重置了，对于此时线程池处于STOP，它的中断状态就不对了，所以又做了第二次检查就是将其修改成中断状态</span></span><br><span class="line"><span class="comment">             * 以上的解释纯属个人理解！！！</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task); <span class="comment">//若该方法发生异常将直接导致工作线程被回收，没办法收集异常信息</span></span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown); <span class="comment">//收集执行任务时发生的异常，该方法也有可能会发生异常</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly); <span class="comment">//回收工作线程，有可能是因为发生异常，有可能是设置了保活时间等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关闭线程池</span></span><br><span class="line"><span class="comment"> * 有可能该方法已经调用结束了但任务还未执行完，不过这不影响</span></span><br><span class="line"><span class="comment"> * 队列中的任务会继续被执行，但是会拒绝新任务的提交</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(SHUTDOWN); <span class="comment">//将线程池的状态设置为SHUTDOWN</span></span><br><span class="line">        interruptIdleWorkers(); <span class="comment">//中断所有空闲线程，相当于一直阻塞代码将不会继续阻塞了</span></span><br><span class="line">        onShutdown();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();<span class="comment">//回收所有空闲线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 停止线程池并返回队列中的任务（未执行的任务）</span></span><br><span class="line"><span class="comment"> * 尽最大的努力去中断所有正在执行的任务，同时移除队列中的任务，拒绝新任务的提交</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 队列中的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(STOP); <span class="comment">//将线程池的状态设置为STOP</span></span><br><span class="line">        interruptWorkers(); <span class="comment">//中断所有工作线程</span></span><br><span class="line">        tasks = drainQueue(); <span class="comment">//移除队列中的任务</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();<span class="comment">//回收线程</span></span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池是否处于STOP或SHUTDOWN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ! isRunning(ctl.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程处是否处于SHUTDOWN/STOP/TIDYING</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTerminating</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">return</span> ! isRunning(c) &amp;&amp; runStateLessThan(c, TERMINATED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池是否处于TERMINATED</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> runStateAtLeast(ctl.get(), TERMINATED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 允许等待指定时间后获取线程池是否处于TERMINATED</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout 等待时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (runStateAtLeast(ctl.get(), TERMINATED)) <span class="comment">//线程池是否处于TERMINATED</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            nanos = termination.awaitNanos(nanos); <span class="comment">//等待指定时间</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当线程池不在被引用/使用和没有工作线程的情况下调用shutdown</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm == <span class="keyword">null</span> || acc == <span class="keyword">null</span>) &#123;</span><br><span class="line">        shutdown();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PrivilegedAction&lt;Void&gt; pa = () -&gt; &#123; shutdown(); <span class="keyword">return</span> <span class="keyword">null</span>; &#125;;</span><br><span class="line">        AccessController.doPrivileged(pa, acc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置线程的工厂类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory 线程的工厂类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setThreadFactory</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (threadFactory == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程的工厂类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程的工厂类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ThreadFactory <span class="title">getThreadFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> threadFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置拒绝任务的策略</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler 策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRejectedExecutionHandler</span><span class="params">(RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取拒绝任务的策略</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RejectedExecutionHandler <span class="title">getRejectedExecutionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置核心线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize 核心线程数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCorePoolSize</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> delta = corePoolSize - <span class="keyword">this</span>.corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(ctl.get()) &gt; corePoolSize) <span class="comment">//若当前线程池的线程个数超过指定的核心线程数，则回收所有空闲线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delta &gt; <span class="number">0</span>) &#123; <span class="comment">// 若当前线程池的线程个数小于指定的核心线程数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 新增工作线程无非就是为了能够帮忙处理队列中的任务，所以当队列中任务个数小于要新增的线程个数时，那就不要新增那么多工作线程了，这是要浪费的节奏</span></span><br><span class="line"><span class="comment">         * 当队列中的任务个数大于要新增的线程个数时，不好意思了，最多只能增加到指定的核心线程数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> k = Math.min(delta, workQueue.size());</span><br><span class="line">        <span class="keyword">while</span> (k-- &gt; <span class="number">0</span> &amp;&amp; addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (workQueue.isEmpty())<span class="comment">//当队列被清空了，就不需要再新增工作线程了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取核心线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 核心线程数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCorePoolSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> corePoolSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 预先创建并开启线程，等待任务到来</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> false表示所有核心线程都已开启，true表示已经创建并开启一个线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">prestartCoreThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> workerCountOf(ctl.get()) &lt; corePoolSize &amp;&amp;</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 预先创建并开启至少一个线程，即使核心线程数是0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ensurePrestart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> wc = workerCountOf(ctl.get());</span><br><span class="line">    <span class="keyword">if</span> (wc &lt; corePoolSize)</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wc == <span class="number">0</span>)</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 预先创建并开启所有核心线程数的工作线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 创建并开启线程的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prestartAllCoreThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>))</span><br><span class="line">        ++n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取是否所有线程都受保活时间的限制</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否所有线程都受保活时间的限制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">allowsCoreThreadTimeOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> allowCoreThreadTimeOut;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置是否所有线程都受保活时间的限制</span></span><br><span class="line"><span class="comment"> * 若为false表示核心线程个数的线程不会受保活时间的限制，但若线程个数超过了核心线程个数就会受到限制，直到线程个数降低到核心线程个数</span></span><br><span class="line"><span class="comment"> * 若为true表示所有的线程都受保活时间的限制，即线程的空闲时间超过保活时间则会被回收</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">allowCoreThreadTimeOut</span><span class="params">(<span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; keepAliveTime &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Core threads must have nonzero keep alive times"</span>);</span><br><span class="line">    <span class="keyword">if</span> (value != allowCoreThreadTimeOut) &#123;</span><br><span class="line">        allowCoreThreadTimeOut = value;</span><br><span class="line">        <span class="keyword">if</span> (value)</span><br><span class="line">            interruptIdleWorkers(); <span class="comment">//回收空闲线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置最大线程数</span></span><br><span class="line"><span class="comment"> * 若线程池中的线程个数大于指定的最大线程数，则它们会在下次空闲时被回收</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maximumPoolSize 最大线程数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaximumPoolSize</span><span class="params">(<span class="keyword">int</span> maximumPoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maximumPoolSize &lt;= <span class="number">0</span> || maximumPoolSize &lt; corePoolSize)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(ctl.get()) &gt; maximumPoolSize)</span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取最大线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最大线程数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaximumPoolSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maximumPoolSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置空闲线程的保活时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> time 时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKeepAliveTime</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (time &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (time == <span class="number">0</span> &amp;&amp; allowsCoreThreadTimeOut())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Core threads must have nonzero keep alive times"</span>);</span><br><span class="line">    <span class="keyword">long</span> keepAliveTime = unit.toNanos(time);</span><br><span class="line">    <span class="keyword">long</span> delta = keepAliveTime - <span class="keyword">this</span>.keepAliveTime;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = keepAliveTime;</span><br><span class="line">    <span class="keyword">if</span> (delta &lt; <span class="number">0</span>)</span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取保活时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 保活时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getKeepAliveTime</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unit.convert(keepAliveTime, TimeUnit.NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取队列</span></span><br><span class="line"><span class="comment"> * 获取队列主要是为了调试与监控，该队列一直在变化着</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BlockingQueue&lt;Runnable&gt; <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> workQueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从队列中移除指定任务</span></span><br><span class="line"><span class="comment"> * 有些情况下队列中并不是直接存放任务，有可能任务被包装进另外一种形式的对象中，然后在将该对象放入队列中，这种情况下不能使用该方法去移除，而应该是purgee方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = workQueue.remove(task);</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从队列中移除已取消的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">purge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; q = workQueue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Iterator&lt;Runnable&gt; it = q.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            Runnable r = it.next();</span><br><span class="line">            <span class="keyword">if</span> (r <span class="keyword">instanceof</span> Future&lt;?&gt; &amp;&amp; ((Future&lt;?&gt;)r).isCancelled())</span><br><span class="line">                it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ConcurrentModificationException fallThrough) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object r : q.toArray())</span><br><span class="line">            <span class="keyword">if</span> (r <span class="keyword">instanceof</span> Future&lt;?&gt; &amp;&amp; ((Future&lt;?&gt;)r).isCancelled())</span><br><span class="line">                q.remove(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程池中工作线程的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 工作线程的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPoolSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Remove rare and surprising possibility of</span></span><br><span class="line">        <span class="comment">// isTerminated() &amp;&amp; getPoolSize() &gt; 0</span></span><br><span class="line">        <span class="keyword">return</span> runStateAtLeast(ctl.get(), TIDYING) ? <span class="number">0</span> : workers.size();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取正在执行任务的工作线程的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 正在执行任务的工作线程的个数</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getActiveCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">            <span class="keyword">if</span> (w.isLocked()) <span class="comment">//工作线程上锁表示正在执行任务</span></span><br><span class="line">                ++n;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程池中曾经存在的最大线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLargestPoolSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> largestPoolSize;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程池中所有任务的个数，任务包括已执行、正在执行、未执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTaskCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> n = completedTaskCount;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            n += w.completedTasks;</span><br><span class="line">            <span class="keyword">if</span> (w.isLocked())</span><br><span class="line">                ++n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + workQueue.size();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程池中已执行的任务的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCompletedTaskCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> n = completedTaskCount;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">            n += w.completedTasks;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当线程池拒绝任务时，采用只要线程池未关闭，由调用execute的线程运行任务，若线程池已关闭，则任务将被丢弃</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只要线程池未关闭，由调用execute的线程运行任务，若线程池已关闭，则任务将被丢弃</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r 任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 线程池对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            r.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当线程池拒绝任务时，直接抛出RejectedExecutionException异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接抛出异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r 任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 线程池对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException always</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() + <span class="string">" rejected from "</span> + e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当线程池拒绝任务时，直接丢弃任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接丢弃任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r 任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 线程池对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当线程池拒绝任务时，采用只要线程池未关闭，则将丢弃队列中头部位置的任务（最早入队列的任务），然后重复执行指定任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只要线程池未关闭，则将丢弃队列中头部位置的任务（最早入队列的任务），然后重复执行指定任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r 任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 线程池对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            e.getQueue().poll();</span><br><span class="line">            e.execute(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同下，此方法会一直阻塞直到有任务完成，所有照道理不会cathc到TimeoutException异常才对</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tasks 任务列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timed 是否等待一段时间，false：将会一直等待有任务完成</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nanos 等待时间，以纳秒为时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> doInvokeAny(tasks, <span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException cannotHappen) &#123;</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行集合中的任务，出现以下的情况将不会在执行剩余的任务，也就是说，至始至终只会有一个任务会完成，若一直没有任务完成且未设置等待时间，则一直等待</span></span><br><span class="line"><span class="comment"> * 1、其中一个任务完成，则取消其他执行中的任务</span></span><br><span class="line"><span class="comment"> * 2、等待一段时间后退出并取消任务</span></span><br><span class="line"><span class="comment"> * 3、所有的任务都抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tasks 任务列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timed 是否等待一段时间，false：将会一直等待有任务完成</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nanos 等待时间，以纳秒为时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">doInvokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tasks == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> ntasks = tasks.size();</span><br><span class="line">    <span class="keyword">if</span> (ntasks == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(ntasks);</span><br><span class="line">    ExecutorCompletionService&lt;T&gt; ecs = <span class="keyword">new</span> ExecutorCompletionService&lt;T&gt;(<span class="keyword">this</span>); <span class="comment">//该类没什么特别，只是将已完成的任务放到队列中，以便可以获取，底层实际上还是靠线程池去执行任务</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        ExecutionException ee = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">        Iterator&lt;? extends Callable&lt;T&gt;&gt; it = tasks.iterator();</span><br><span class="line"></span><br><span class="line">        futures.add(ecs.submit(it.next())); <span class="comment">//先尝试提交一个任务</span></span><br><span class="line">        --ntasks; <span class="comment">//未提交的任务个数</span></span><br><span class="line">        <span class="keyword">int</span> active = <span class="number">1</span>;<span class="comment">//执行中的任务个数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Future&lt;T&gt; f = ecs.poll(); <span class="comment">//尝试获取之前提交的任务是否完成，若是已完成则f将不会空，若未完成则f为空</span></span><br><span class="line">            <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ntasks &gt; <span class="number">0</span>) &#123; <span class="comment">//是否还有未提交的任务，在尝试提交一个</span></span><br><span class="line">                    --ntasks;</span><br><span class="line">                    futures.add(ecs.submit(it.next()));</span><br><span class="line">                    ++active;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (active == <span class="number">0</span>) <span class="comment">//若已经不存在执行中的任务，说明从一开始到现在都没有任务完成或任务都抛出异常了，已经没有未提交的任务了，也不存在执行中的任务了，直接退出</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123; <span class="comment">//是否尝试等待一段时间去获取已完成的任务</span></span><br><span class="line">                    <span class="comment">// 走到这里说明已没有未提交的任务了，现在就等着执行中的任务执行完成，不过它不是一直等着，而是等待一段时间后若任务还是未完成，那么将抛出异常来直接退出，不在等待了</span></span><br><span class="line">                    f = ecs.poll(nanos, TimeUnit.NANOSECONDS);</span><br><span class="line">                    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">                    nanos = deadline - System.nanoTime();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f = ecs.take(); <span class="comment">//走到这里说明已经没有未提交的任务了，现在就一直等着执行中的任务执行完成，然后获取它就可以了，简单来说就是这里会被阻塞住，直到队列中添加了已完成的任务</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123; <span class="comment">//说明有任务已经完成</span></span><br><span class="line">                --active;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> f.get(); <span class="comment">//直接获取结果</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException eex) &#123; <span class="comment">//记录异常信息</span></span><br><span class="line">                    ee = eex;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException rex) &#123;</span><br><span class="line">                    ee = <span class="keyword">new</span> ExecutionException(rex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ee == <span class="keyword">null</span>)</span><br><span class="line">            ee = <span class="keyword">new</span> ExecutionException(); <span class="comment">//走到这里说明所有的任务都抛出异常了</span></span><br><span class="line">        <span class="keyword">throw</span> ee;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++)</span><br><span class="line">            futures.get(i).cancel(<span class="keyword">true</span>); <span class="comment">//1、有任务已完成，取消剩余的执行中的任务  2、所有的任务都抛出异常了  3、等待一段时间后而退出的，则取消任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同下，此方法会阻塞一段时间，有可能抛出TimeoutException异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tasks 任务列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timed 是否等待一段时间，false：将会一直等待有任务完成</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nanos 等待时间，以纳秒为时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doInvokeAny(tasks, <span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行集合中的所有任务，若有一个任务被中断，则取消所有任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tasks 任务列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值，若是抛出异常则说明任务被中断了，若没有抛出异常则说明所有任务都正常完成了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (tasks == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size()); <span class="comment">//保存所有任务</span></span><br><span class="line">    <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Callable&lt;T&gt; t : tasks) &#123;</span><br><span class="line">            RunnableFuture&lt;T&gt; f = newTaskFor(t);</span><br><span class="line">            futures.add(f);</span><br><span class="line">            execute(f); <span class="comment">//执行任务</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++) &#123;</span><br><span class="line">            Future&lt;T&gt; f = futures.get(i);</span><br><span class="line">            <span class="keyword">if</span> (!f.isDone()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    f.get();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (CancellationException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        done = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> futures;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!done)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++) <span class="comment">//走到这里的话说明有任务被中断了，取消所有任务，已完成的任务没办法取消，这块内容跟Future有关</span></span><br><span class="line">                futures.get(i).cancel(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行集合中的所有任务，若有一个任务被中断或等待超时了，则取消任务，已完成的任务没办法取消</span></span><br><span class="line"><span class="comment"> * 参数中的时间包括提交任务的时间 + 等待任务的时间</span></span><br><span class="line"><span class="comment"> * 该方法有可能因为等待超时而返回、也有可能因为被中断而返回、也有可能正常返回，对于中断我们可以在外层通过catch判断，但是剩下的两个情况我们没办法判断是否任务正常完成了，除非自己在调用isCancelled去一个一个判断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tasks 任务列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout 等待时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TimeUnit unit) <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (tasks == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());<span class="comment">//保存所有任务</span></span><br><span class="line">    <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Callable&lt;T&gt; t : tasks)</span><br><span class="line">            futures.add(newTaskFor(t));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanos;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = futures.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            execute((Runnable)futures.get(i));</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> futures;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            Future&lt;T&gt; f = futures.get(i);</span><br><span class="line">            <span class="keyword">if</span> (!f.isDone()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> futures;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    f.get(nanos, TimeUnit.NANOSECONDS); <span class="comment">//等待一段时间</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (CancellationException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">                    <span class="keyword">return</span> futures;</span><br><span class="line">                &#125;</span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        done = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> futures;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!done)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++) <span class="comment">//走到这里说明有任务被中断了或等待时间超时了</span></span><br><span class="line">                futures.get(i).cancel(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成异步形式的任务，为了异步获取结果</span></span><br><span class="line"><span class="comment"> * 关于Future的知识点将会另外新起文章进行讲解</span></span><br><span class="line"><span class="comment"> * 这里为啥会多一个value呢? 与下面的重载方法相比，Runnable并不存在返回值，故提供了此值，相当于Runnable + value = Callable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> runnable 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 结果值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 异步形式的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成异步形式的任务，为了异步获取结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> callable 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 异步形式的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提交任务并执行，返回异步对象来获取结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 异步对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提交任务并执行，返回异步对象来获取结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> result 结果值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 异步对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提交任务并执行，返回异步对象来获取结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 异步对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><ul><li><p>线程池的状态处于<code>RUNNING</code>下：</p><ul><li><p>对于新提交的任务，<code>线程个数小于核心线程数</code>，则新创建线程进行处理 （size &lt; corePoolSize）</p></li><li><p>对于新提交的任务，<code>线程个数大于核心线程小于最大线程数</code>，则尝试放入到队列中 （corePoolSize &lt; size &lt; maximumPoolSize）</p><ul><li><p>若此时队列未满，则放入成功，后续会正常执行</p></li><li><p>若此时队列已满（放入失败），则直接创建新线程去执行</p></li></ul></li><li><p>对于新提交的任务，<code>线程个数大于核心线程数且等于最大线程数</code>，则尝试放入到队列中，若队列已经满了，这时的线程池已经饱和了，只能拒绝任务，若队列未满，则加入到队列中</p></li></ul></li><li><p>线程个数小于最大线程数，线程池处于RUNNING</p><ul><li><p>若设置了allowCoreThreadTimeOut = true，所有工作线程的空闲时间超过保活时间后会被回收</p></li><li><p>若设置了allowCoreThreadTimeOut = false，且线程个数大于核心线程数的工作线程的空闲时间超过保活时间会被回收，即最终只有核心线程数的工作线程存在，通过调用shutdown回收最后的工作线程</p></li></ul></li><li><p>若队列中还有任务存在，不管是哪一种情况至少都会有一个工作线程存在</p></li><li><p>线程池的状态——RUNNING/SHUTDONW/STOP/TIDYING/TERMINATED</p></li><li><p>线程池<code>拒绝任务</code>的策略：</p><ul><li><p>ThreadPoolExecutor.AbortPolicy：当线程池拒绝任务时，采用直接抛出RejectedExecutionException异常</p></li><li><p>ThreadPoolExecutor.CallerRunsPolicy：当线程池拒绝任务时，采用只要线程池未关闭，由调用execute的线程运行任务，这提供了一种反馈机制，而若线程池已关闭，则任务将被丢弃</p></li><li><p>ThreadPoolExecutor.DiscardPolicy：当线程池拒绝任务时，采用直接丢弃了任务，相当于直接不执行任务了，很干脆</p></li><li><p>ThreaPollExecutor.DiscardOldestPolicy：当线程池拒绝任务时，采用只要线程池未关闭，则将丢弃队列中头部位置的任务（最早入队列的任务），然后重复执行指定任务（调用execute方法，有可能再次被拒绝导致又重复执行）</p></li></ul></li><li><p>invokeAny与invokeAll的使用与区别</p></li></ul><h4 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h4><p><code>ScheduledThreadPoolExecutor</code>是家族中的第二骨干，能够延迟或周期性执行任务，由于其继承了ThreadPoolExecutor类，故而它也拥有线程池状态的概念！//TODO</p><h5 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">implements</span> <span class="title">ScheduledExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当线程池处于SHUTDOWN状态时是否继续执行周期性任务-scheduleWithFixedDelay/scheduleAtFixedRate</span></span><br><span class="line"><span class="comment">     * 默认情况是false，表示不会继续执行周期性任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> continueExistingPeriodicTasksAfterShutdown;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当线程池处于SHUTDOWN状态时是否执行延迟任务</span></span><br><span class="line"><span class="comment">     * 默认情况下是true，表示会执行延迟任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> executeExistingDelayedTasksAfterShutdown = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当任务被成功取消时是否立即从队列中删除此任务</span></span><br><span class="line"><span class="comment">     * 默认情况是false，表示已取消的任务不会马上从队列中删除，只有在关闭线程池的时候才会清除，所以建议将其设置成true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> removeOnCancel = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每个任务的序号，依次呈现递增</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong sequencer = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化，采用延迟队列，该队列中使用了数组作为其数据结构，会自动扩容，所以相当于是个无界队列，设置最大线程池没效果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize 核心线程数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS, <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化，采用延迟队列，自定义线程的工厂类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize 核心线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory 线程的工厂类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS, <span class="keyword">new</span> DelayedWorkQueue(), threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化，采用延迟队列，设置拒绝任务的策略</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize 核心线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler 拒绝任务的策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS, <span class="keyword">new</span> DelayedWorkQueue(), handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化，采用延迟队列，设置拒绝任务的策略，自定义线程的工厂类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize 核心线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory 线程的工厂类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler 拒绝任务的策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS, <span class="keyword">new</span> DelayedWorkQueue(), threadFactory, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="简单方法-2"><a href="#简单方法-2" class="headerlink" title="简单方法"></a>简单方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 立即执行任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> command 任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    schedule(command, <span class="number">0</span>, NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 延迟指定的时间后执行任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> command 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delay 延迟时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 异步任务对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="keyword">long</span> delay, TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableScheduledFuture&lt;?&gt; t = decorateTask(command, <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command, <span class="keyword">null</span>, triggerTime(delay, unit))); <span class="comment">//可根据需需求自定义任务，即可自行包装任务，通过覆写decorateTask方法即可</span></span><br><span class="line">    delayedExecute(t); <span class="comment">//将任务放到队列中</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 延迟指定的时间后执行任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> command 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delay 延迟时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 异步任务对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable, <span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableScheduledFuture&lt;V&gt; t = decorateTask(callable, <span class="keyword">new</span> ScheduledFutureTask&lt;V&gt;(callable, triggerTime(delay, unit)));</span><br><span class="line">    delayedExecute(t); <span class="comment">//将任务放到队列中</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以固定的频率重复执行任务，注重频率</span></span><br><span class="line"><span class="comment"> * 下一个任务的执行时间为上一个任务开始执行的时间加上period</span></span><br><span class="line"><span class="comment"> * 注意一下, 延迟initialDelay时间后开始执行任务，而后续的任务将以固有频率（period）执行</span></span><br><span class="line"><span class="comment"> * 若下一个任务的执行时间到了，但上一个任务还未执行完毕，则当上一个任务执行完毕后下一个任务立即被执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> command 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialDelay 延迟时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> period 固有频率</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 异步对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    ScheduledFutureTask&lt;Void&gt; sft = <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command, <span class="keyword">null</span>, triggerTime(initialDelay, unit), unit.toNanos(period));</span><br><span class="line">    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);</span><br><span class="line">    sft.outerTask = t;</span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以固定的周期重复执行任务，注重周期</span></span><br><span class="line"><span class="comment"> * 下一个任务的执行时间为上一个任务执行完毕后的时间加上period，所以每个任务的执行时间依赖于上一个任务的执行时间，导致每个任务的执行时间不固定</span></span><br><span class="line"><span class="comment"> * 注意一下, 延迟initialDelay时间后开始执行任务，而后续的任务将以固有频率（period）执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> command 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialDelay 延迟时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> period 固有频率</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 异步对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> delay, TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    ScheduledFutureTask&lt;Void&gt; sft =</span><br><span class="line">        <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command, <span class="keyword">null</span>, triggerTime(initialDelay, unit), unit.toNanos(-delay));</span><br><span class="line">    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);</span><br><span class="line">    sft.outerTask = t;</span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包装任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> runnable 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task 包装对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包装对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> &lt;V&gt; <span class="function">RunnableScheduledFuture&lt;V&gt; <span class="title">decorateTask</span><span class="params">(Runnable runnable, RunnableScheduledFuture&lt;V&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包装任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> runnable 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task 包装对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包装对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> &lt;V&gt; <span class="function">RunnableScheduledFuture&lt;V&gt; <span class="title">decorateTask</span><span class="params">(Callable&lt;V&gt; callable, RunnableScheduledFuture&lt;V&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将任务放入到队列中</span></span><br><span class="line"><span class="comment"> * 在第一次检查时线程池处于SHUTDOWN状态时，则直接拒绝任务</span></span><br><span class="line"><span class="comment"> * 在第二次检查时线程池处于SHUTDOWN状态时，则根据属性来决定是否要处理队列中的任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task 任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">delayedExecute</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isShutdown()) <span class="comment">//第一次检查，若此时线程池处于SHUTDOWN状态（或者比SHUTDOWN更大的状态值），则直接拒绝任务，默认情况下会抛出异常</span></span><br><span class="line">        reject(task);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.getQueue().add(task);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 走到这里说明任务已经放入队列中</span></span><br><span class="line"><span class="comment">         * 第二次检查，若此时线程池处于SHUTDOWN状态，则判断是否是重复执行的任务，在根据其continueExistingPeriodicTasksAfterShutdown/executeExistingDelayedTasksAfterShutdown参数来决定是否要处理队列中的任务</span></span><br><span class="line"><span class="comment">         * 默认情况下，针对非重复执行的任务会处理队列中的任务，即canRunInCurrentRunState返回true，最终将不会移除任务</span></span><br><span class="line"><span class="comment">         * 默认情况下，针对重复执行的任务将不会处理队列中的任务，即canRunInCurrentRunState返回false，最终将移除任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp; !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp; remove(task))</span><br><span class="line">            task.cancel(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ensurePrestart();<span class="comment">//因为队列中已经存在任务了，为了防止因为线程池处于SHUTDOWN状态导致不存在任何的工作线程去处理队列中的任务，所以这里必须至少要有一个工作线程存在</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取任务的具体执行时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delay 任务的延迟时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 任务的具体执行时间 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">triggerTime</span><span class="params">(<span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> triggerTime(unit.toNanos((delay &lt; <span class="number">0</span>) ? <span class="number">0</span> : delay));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取任务的具体执行时间，防止任务之间通过compareTo方法比较时溢出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delay 任务的延迟时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 任务的具体执行时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">triggerTime</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> now() + ((delay &lt; (Long.MAX_VALUE &gt;&gt; <span class="number">1</span>)) ? delay : overflowFree(delay));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 约束队列中所有任务的延迟时间在Long.MAX_VALUE之内，避免任务之间通过compareTo方法比较时溢出，简单来说就是防止任务的排序出现错误顺序</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 假设如果没有调用overflowFree，那么会造成什么后果呢？以下的场景参考自网友的文章：</span></span><br><span class="line"><span class="comment"> * 为了方便说明，会采用假设的手法，假设当前时间：100，即：000 0110 0100</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 按照注释中的说法应该是下一个任务已经达到了延迟时间，但却因为上一个任务还未结束导致无法执行下一个任务，简单来说就是下一个任务被延误了，所以它的执行时间会小于当前时间，假设是95</span></span><br><span class="line"><span class="comment"> * 这个时候又加入了新的任务，而新任务的执行时间设置为Long.MAX_VALUE = 1023，即：0011 1111 1111，在生成任务对象时会调用triggerTime方法计算time，即 100 + 1023 = -925，即：111 1001 1101</span></span><br><span class="line"><span class="comment"> * 紧接着调用siftUp方法进行排序，在siftUp中会调用compareTo进行任务之间的比较，在compareTo方法中使用long diff = time - x.time = -925 - 95 = -1020，那么将返回-1，-1说明新任务的延迟时间比队列中任务的延迟时间更短，可是显然不是* 的，正常情况下应该返回1</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 若是执行了overflowFree又会怎么样呢? </span></span><br><span class="line"><span class="comment"> * long headDelay = 95 - 100 = -5 , 此时的delay = 1023，显然 delay - headDelay = 1023 - (-5) 必然是个负数，就不做计算了，紧接着 delay = 1023 -5 = 1018，同样执行triggerTime计算time，即 1018 + 100 = -930</span></span><br><span class="line"><span class="comment"> * 同样执行long diff = time - x.time = -930 - 95 = 1023 &gt; 0，所以会返回1，符合正常的预期（-930：100 0101 1110  -95：111 1010 0001）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 所以，overflowFree方法中把延误的时间给减去，就是为了避免在compareTo方法中出现溢出情况，说实话，这段代码我也看的很痛苦，要不是参考了网友写的文章，我还真看不明白了！</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delay 任务的延迟时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 任务的延迟时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">overflowFree</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;</span><br><span class="line">    Delayed head = (Delayed) <span class="keyword">super</span>.getQueue().peek();</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> headDelay = head.getDelay(NANOSECONDS);</span><br><span class="line">        <span class="keyword">if</span> (headDelay &lt; <span class="number">0</span> &amp;&amp; (delay - headDelay &lt; <span class="number">0</span>))</span><br><span class="line">            delay = Long.MAX_VALUE + headDelay;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> delay;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前时间，以纳秒为单位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">now</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> System.nanoTime();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以异步的形式包装任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledFutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableScheduledFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任务的序号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行任务的具体时间，以纳秒为单位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义重复执行任务的周期或延迟时间</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 1. 正数表示执行任务的周期，主要针对scheduleAtFixedRate方法，注意一下该方法是在上一个任务开始执行的时间加上周期来决定下一个任务的开始执行时间，所以有可能出现下一个任务已经到达了开始执行的时间，而上一个任务还未执行完毕</span></span><br><span class="line"><span class="comment">     *    这个时候说明下一个任务会被延迟执行了，不过绝不会出现下一个任务与上一个任务重叠执行，会等上一个任务执行后才执行</span></span><br><span class="line"><span class="comment">     * 2. 负数表示执行任务的延迟时间，主要针对scheduleWithFixedDelay方法，注意一下该方法是在上一个任务执行完毕后延迟多少时间后才开始执行下一个任务</span></span><br><span class="line"><span class="comment">     * 3. 0表示不会重复执行任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> period;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示当前任务对象，用于重复执行任务，当上一个任务执行完毕后，更新指定属性并重新将该对象重新放入到队列中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RunnableScheduledFuture&lt;V&gt; outerTask = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置索引，用于快速取消</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> heapIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化，设置任务、执行任务的结果、第一次执行任务的延迟时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r 任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result 结果值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ns 延迟时间，以毫秒为单位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns) &#123;</span><br><span class="line">        <span class="keyword">super</span>(r, result);</span><br><span class="line">        <span class="keyword">this</span>.time = ns;</span><br><span class="line">        <span class="keyword">this</span>.period = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化，设置任务、执行任务的结果、第一次执行任务的延迟时间、任务的执行周期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r 任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result 结果值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ns 延迟时间，以毫秒为单位 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> period 任务的执行周期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns, <span class="keyword">long</span> period) &#123;</span><br><span class="line">        <span class="keyword">super</span>(r, result);</span><br><span class="line">        <span class="keyword">this</span>.time = ns;</span><br><span class="line">        <span class="keyword">this</span>.period = period;</span><br><span class="line">        <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化，设置任务、第一次执行任务的延迟时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ScheduledFutureTask(Callable&lt;V&gt; callable, <span class="keyword">long</span> ns) &#123;</span><br><span class="line">        <span class="keyword">super</span>(callable);</span><br><span class="line">        <span class="keyword">this</span>.time = ns;</span><br><span class="line">        <span class="keyword">this</span>.period = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下次执行任务的时间与当前时间的间隔</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit 时间格式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unit.convert(time - now(), NANOSECONDS); <span class="comment">//将指定时间转换成指定格式的时间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将任务进行排序，以便将执行时间更小的任务排到队列的前头</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> other 另外一个任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (other == <span class="keyword">this</span>) <span class="comment">// compare zero if same object</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (other <span class="keyword">instanceof</span> ScheduledFutureTask) &#123;</span><br><span class="line">            ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;</span><br><span class="line">            <span class="keyword">long</span> diff = time - x.time;</span><br><span class="line">            <span class="keyword">if</span> (diff &lt; <span class="number">0</span>) <span class="comment">//比较任务的具体执行时间</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sequenceNumber &lt; x.sequenceNumber) <span class="comment">//若任务的执行时间相同则比较序号</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> diff = getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);</span><br><span class="line">        <span class="keyword">return</span> (diff &lt; <span class="number">0</span>) ? -<span class="number">1</span> : (diff &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前任务是否重复执行，不管是周期性还是延迟执行时间，对应了scheduleAtFixedRate与scheduleWithFixedDelay方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前任务是否重复执行，true表示是重复执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPeriodic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> period != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为重复执行的任务设置下次执行的具体时间，该方法只会在上一个任务执行完毕后调用，只有是重复执行的任务才会调用该方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setNextRunTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> p = period;</span><br><span class="line">        <span class="keyword">if</span> (p &gt; <span class="number">0</span>) <span class="comment">//正数表示重复执行的周期</span></span><br><span class="line">            time += p;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//负数表示重复执行的延迟时间，等到上一个任务执行完毕后延迟指定时间后才开始执行下一个任务</span></span><br><span class="line">            time = triggerTime(-p); <span class="comment">//原本p是个负数，-p就变成了正数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否成功取消任务</span></span><br><span class="line"><span class="comment">     * 1. 若任务还未执行，任务的状态为NEW，调用该方法时，任务的状态将根据mayInterruptIfRunning值变更成INTERRUPTING/CANCELLED</span></span><br><span class="line"><span class="comment">     *    因为任务还未运行，所以mayInterruptIfRunning的值应该为false，所以最终super.cancel返回true</span></span><br><span class="line"><span class="comment">     * 2. 若任务正在运行中，任务的状态还是为NEW，调用该方法时，任务的状态将根据mayInterruptIfRunning值变更成INTERRUPTING/CANCELLED</span></span><br><span class="line"><span class="comment">     *    由于任务正在运行，所以mayInterruptIfRunning的值有可能为true，也有可能为false</span></span><br><span class="line"><span class="comment">     * 21. 若mayInterruptIfRunning = true，任务的状态将变成INTERRUPTING，同时中断正在运行任务的线程，此时要注意一下，要看下线程是否响应了中断，比如出现wait、join、slepp、I/O阻塞才会响应中断而抛出中断异常，其他情况</span></span><br><span class="line"><span class="comment">     *     下只是简单地设置了中断状态，并未抛出异常，最终又将任务的状态变成INTERRUPTED，同时返回true，可实际上任务还是如实完成了</span></span><br><span class="line"><span class="comment">     * 22. 若mayInterruptIfRunning = false，任务的状态将变成CANCELLED，同时返回true，可实际上任务还是如实完成了</span></span><br><span class="line"><span class="comment">     * 3. 若任务已执行完成了，自然是无非取消的</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 综上所述：只有两种情况下任务会被成功取消/中断</span></span><br><span class="line"><span class="comment">     * 1. 任务还未开始执行可以成功取消</span></span><br><span class="line"><span class="comment">     * 2. 运行中的任务在响应中断的情况下会抛出异常，这个时候可根据业务来抉择是否取消继续运行</span></span><br><span class="line"><span class="comment">     * 3. 其他情况下虽然会返回true，但任务还是会如是地运行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mayInterruptIfRunning 是否中断正在运行任务的线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否成功取消任务，此结果值无法决定任务是否真正被取消了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> cancelled = <span class="keyword">super</span>.cancel(mayInterruptIfRunning);</span><br><span class="line">        <span class="keyword">if</span> (cancelled &amp;&amp; removeOnCancel &amp;&amp; heapIndex &gt;= <span class="number">0</span>) <span class="comment">//即使返回cancelled = true，任务还是有可能如实地运行，此时的队列移除更多的是针对未开始执行的任务</span></span><br><span class="line">            remove(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> cancelled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Overrides FutureTask version so as to reset/requeue if periodic.</span></span><br><span class="line"><span class="comment">     * 执行任务</span></span><br><span class="line"><span class="comment">     * 针对非重复执行的任务来说，直接执行即可</span></span><br><span class="line"><span class="comment">     * 针对重复执行的任务来说，在执行完任务后，又将该任务放入到队列中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> periodic = isPeriodic(); <span class="comment">//是否是重复执行的任务</span></span><br><span class="line">        <span class="keyword">if</span> (!canRunInCurrentRunState(periodic)) <span class="comment">//查看当前线程池的状态是否允许运行任务</span></span><br><span class="line">            cancel(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!periodic) <span class="comment">//若不是重复执行的任务，则直接运行任务</span></span><br><span class="line">            ScheduledFutureTask.<span class="keyword">super</span>.run();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 在runAndReset方法中运行任务，若任务运行失败了或被取消了，则返回false，导致周期性运行任务不在执行</span></span><br><span class="line"><span class="comment">         * FutureTask#runAndReset中并未设置任务的结果</span></span><br><span class="line"><span class="comment">         * 注意一下，将runner设置null是为了防止周期任务使用同一个线程，按道理来说，一个任务执行完毕了，该线程的任务也就即使了，等到下一个任务开始执行时，又会是另外一个线程</span></span><br><span class="line"><span class="comment">         * 从outerTask变量我们可以看出它保存了任务的信息，不管是对于上一个任务还是下一个任务来说都是同一个对象，所以我们有必要去更新runner变量的引用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ScheduledFutureTask.<span class="keyword">super</span>.runAndReset()) &#123;</span><br><span class="line">            setNextRunTime(); <span class="comment">//下一个执行的具体时间</span></span><br><span class="line">            reExecutePeriodic(outerTask); <span class="comment">//将重复执行的任务又放入到队列中等待下次执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将重复执行的任务放入到队列中</span></span><br><span class="line"><span class="comment"> * 注意一下，该方法只会被重复执行的任务所调用</span></span><br><span class="line"><span class="comment"> * 该方法与delayedExecute作用类似，在线程池处于SHUTDOWN状态下，添加任务到队列时会被直接拒绝，这很符合ThreadPoolExecutor的特性，而该方法添加任务时会根据参数来决定是否入队列，毕竟它已经执行过一次了</span></span><br><span class="line"><span class="comment"> * 所以ScheduledThreadPoolExecutor与ThreadPoolExecutor在这点的策略上会有所不同</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task 重复执行的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reExecutePeriodic</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//双重检查相当于在说明两件事，放不放到队列中是一回事，处不处理队列中的任务又是一个回事</span></span><br><span class="line">    <span class="keyword">if</span> (canRunInCurrentRunState(<span class="keyword">true</span>)) &#123; <span class="comment">//第一次检查，若此时线程池处于SHUTDOWN状态，则根据continueExistingPeriodicTasksAfterShutdown参数来决定是否继续执行任务</span></span><br><span class="line">        <span class="keyword">super</span>.getQueue().add(task);</span><br><span class="line">        <span class="keyword">if</span> (!canRunInCurrentRunState(<span class="keyword">true</span>) &amp;&amp; remove(task)) <span class="comment">//在第二次检查，走到这里说明任务已经放入到队列中了，此时若线程池处于SHUNTDOWN状态，则判断是否要处理队列中的任务，若不处理则移除</span></span><br><span class="line">            task.cancel(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ensurePrestart(); <span class="comment">//因为队列中已经存在任务了，为了防止因为线程池处于SHUTDOWN状态导致不存在任何的工作线程去处理队列中的任务，所以这里必须至少要有一个工作线程存在</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据当前线程池的状态决定是否允许执行任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> periodic 当前任务是否属于重复执行任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否允许执行任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canRunInCurrentRunState</span><span class="params">(<span class="keyword">boolean</span> periodic)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isRunningOrShutdown(periodic ? continueExistingPeriodicTasksAfterShutdown : executeExistingDelayedTasksAfterShutdown);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关闭线程池时清理队列中不执行的任务</span></span><br><span class="line"><span class="comment"> * 该方法是在关闭线程池时被调用，参看ThreadPoolExecutor#shutdown</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; q = <span class="keyword">super</span>.getQueue();</span><br><span class="line">    <span class="keyword">boolean</span> keepDelayed = getExecuteExistingDelayedTasksAfterShutdownPolicy(); <span class="comment">//当线程池处于SHUTDOWN状态时，是否继续执行非周期性任务</span></span><br><span class="line">    <span class="keyword">boolean</span> keepPeriodic = getContinueExistingPeriodicTasksAfterShutdownPolicy();<span class="comment">//当线程池处于SHUTDOWN状态时，是否继续执行周期性任务</span></span><br><span class="line">    <span class="keyword">if</span> (!keepDelayed &amp;&amp; !keepPeriodic) &#123; <span class="comment">//若两个都是false，则清空队列并更改任务的状态</span></span><br><span class="line">        <span class="keyword">for</span> (Object e : q.toArray())</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RunnableScheduledFuture&lt;?&gt;)</span><br><span class="line">                ((RunnableScheduledFuture&lt;?&gt;) e).cancel(<span class="keyword">false</span>);</span><br><span class="line">        q.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object e : q.toArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RunnableScheduledFuture) &#123;</span><br><span class="line">                RunnableScheduledFuture&lt;?&gt; t = (RunnableScheduledFuture&lt;?&gt;)e;</span><br><span class="line">                <span class="comment">//队列中不执行的任务将被移除</span></span><br><span class="line">                <span class="keyword">if</span> ((t.isPeriodic() ? !keepPeriodic : !keepDelayed) || t.isCancelled()) &#123; <span class="comment">// also remove if already cancelled</span></span><br><span class="line">                    <span class="keyword">if</span> (q.remove(t))</span><br><span class="line">                        t.cancel(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate(); <span class="comment">//尝试去终止线程池</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 立即执行任务，返回异步对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 异步对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">return</span> schedule(task, <span class="number">0</span>, NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 立即执行任务，返回异常对象，可获取任务的返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 异步对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> schedule(Executors.callable(task, result), <span class="number">0</span>, NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 立即执行任务，返回异步对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 异步对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> schedule(task, <span class="number">0</span>, NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当关闭线程池时，设置是否继续执行周期性任务的属性</span></span><br><span class="line"><span class="comment"> * 若是立即关闭线程池（shutdownNow）或此属性设置成false，则周期性任务不会被执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 关闭线程池时，是否继续执行周期性任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContinueExistingPeriodicTasksAfterShutdownPolicy</span><span class="params">(<span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">    continueExistingPeriodicTasksAfterShutdown = value;</span><br><span class="line">    <span class="keyword">if</span> (!value &amp;&amp; isShutdown())</span><br><span class="line">        onShutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当关闭线程时是否继续执行周期性任务的属性值，默认情况下是false</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 属性值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getContinueExistingPeriodicTasksAfterShutdownPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> continueExistingPeriodicTasksAfterShutdown;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当关闭线程池时，设置是否继续执行非周期性任务（延迟任务）的属性</span></span><br><span class="line"><span class="comment"> * 若是立即关闭线程池（shutdownNow）或此属性设置成false，则非周期性任务不会被执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 关闭线程池时，是否继续执行非周期性任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExecuteExistingDelayedTasksAfterShutdownPolicy</span><span class="params">(<span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">    executeExistingDelayedTasksAfterShutdown = value;</span><br><span class="line">    <span class="keyword">if</span> (!value &amp;&amp; isShutdown())</span><br><span class="line">        onShutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当关闭线程时是否继续执行非周期性任务的属性值，默认情况下是true</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 属性值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getExecuteExistingDelayedTasksAfterShutdownPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> executeExistingDelayedTasksAfterShutdown;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当任务被取消时，设置是否立即移除该任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 当任务被取消时，是否立即移除任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRemoveOnCancelPolicy</span><span class="params">(<span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">    removeOnCancel = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当任务被取消时，是否立即移除该任务，默认情况是false，建议设置成true</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 属性值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getRemoveOnCancelPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeOnCancel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该队列是基于二叉堆的数据结构，堆中分为最大堆与最小堆，它采用了最小堆，可参看之前的文章http://zlia.tech/2020/01/10/explain-binary-heap</span></span><br><span class="line"><span class="comment"> * 该队列会将执行时间较小的任务排列到前头，但是注意一下它只保证父节点的执行时间比子节点的执行时间小，而子节点之间的关系并不一定是有序的</span></span><br><span class="line"><span class="comment"> * 若对堆不熟悉或者不认识的读者最好先去了解下，因为本章不会详细介绍二叉堆的知识点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedWorkQueue</span> <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">Runnable</span>&gt; <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">Runnable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组的初始容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义数组用于存储二叉堆的所有节点，由于是数组故而需要扩容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> RunnableScheduledFuture&lt;?&gt;[] queue = <span class="keyword">new</span> RunnableScheduledFuture&lt;?&gt;[INITIAL_CAPACITY];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 防止并发</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉堆中所有节点的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Leader-Follower模型的变体，何为Leader-Follower自行搜索即可</span></span><br><span class="line"><span class="comment">     * 最小化不必要的等待时间</span></span><br><span class="line"><span class="comment">     * 若当前线程是个Leader（一种标识），始终都只有一个Leader线程，Leader线程只会等待任务执行的延迟时间，而其他的Follower线程处于一直等待状态，这就是所谓的Leader-Follower模型的变体</span></span><br><span class="line"><span class="comment">     * Leader线程在return之前必须去唤醒其他的线程，因为其他线程都处于等待状态下</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Thread leader = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 条件锁</span></span><br><span class="line"><span class="comment">     * 添加新任务时或线程成为Leader线程时，该锁会被唤醒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition available = lock.newCondition();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置索引</span></span><br><span class="line"><span class="comment">     * heapIndex用于快速取消，当取消一个任务时，该任务的索引会被设置成-1，且该索引处变成了null，如果在cancel方法中不加上heapIndex的判断，remove依然会走完</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setIndex</span><span class="params">(RunnableScheduledFuture&lt;?&gt; f, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ScheduledFutureTask)</span><br><span class="line">            ((ScheduledFutureTask)f).heapIndex = idx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上浮插入的节点以满足二叉堆的性质</span></span><br><span class="line"><span class="comment">     * 二叉堆的性质：ScheduledThreadPoolExecutor#DelayWorkQueue中采用的是最小堆，即父节点的时间比子节点的时间要小</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 插入的节点的操作步骤一般如下：</span></span><br><span class="line"><span class="comment">     * 1. 将插入的节点放到数组的末尾</span></span><br><span class="line"><span class="comment">     * 2. 由于需要父节点的时间比子节点的时间要小，故要与父节点进行比较</span></span><br><span class="line"><span class="comment">     * 3. 若插入的节点比父节点小，则将插入的节点与父节点进行值交换，在交换后它又有了新的父节点，故而需要继续往上比较，直到到底堆顶或不在小于父节点，相当于在重复步骤2</span></span><br><span class="line"><span class="comment">     * 4. 若插入的节点比父节点大，直接结束</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 假设一个节点的索引为：N，其父节点的索引为：(N - 1)/2，左子节点的索引为：2N + 1，其右子节点的索引为：2N + 2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k 插入的节点的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 插入的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, RunnableScheduledFuture&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">//父节点的索引</span></span><br><span class="line">            RunnableScheduledFuture&lt;?&gt; e = queue[parent]; <span class="comment">//父节点</span></span><br><span class="line">            <span class="keyword">if</span> (key.compareTo(e) &gt;= <span class="number">0</span>) <span class="comment">//插入的节点与父节点进行比较，若大于则直接退出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 走到这里说明插入节点的值小于父节点的值，不过它不是急于将插入节点的值直接放入到父节点的位置上，因为即使在交换后它仍然还有父节点，还需要在往上进行比较</span></span><br><span class="line"><span class="comment">             * 所以能确定的是将父节点放到插入节点的位置上，而对于插入的节点等最终比较完毕了在放入，即while循环后续的代码</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            queue[k] = e;</span><br><span class="line">            setIndex(e, k);</span><br><span class="line">            k = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = key;</span><br><span class="line">        setIndex(key, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下沉节点以满足二叉堆的性质</span></span><br><span class="line"><span class="comment">     * 思路：</span></span><br><span class="line"><span class="comment">     * - 不管移除的是哪个节点，拿数组末尾的节点是最少成本的，因为拿该节点的值去覆盖移除节点的值来使其还是一颗完全二叉树，所以最终只要让其满足二叉堆性质就可以了</span></span><br><span class="line"><span class="comment">     * - 针对移除节点来说，就相当于把移除节点的位置空出来了，因为是二叉堆要满足其性质，所以就要考虑是它的子节点还是末尾的节点更适合来做移除节点的位置（最大堆/最小堆）</span></span><br><span class="line"><span class="comment">     * - 因为末尾元素最终都会被移动到指定位置，故而先将末尾位置置null</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 针对要移除的节点分为两种情况（最小堆）：</span></span><br><span class="line"><span class="comment">     * 1. 移除的节点无子节点，也就是说是叶子节点，如下步骤：</span></span><br><span class="line"><span class="comment">     *       11. 直接将末尾的节点的值覆盖，同时将末尾位置设置成null，因为它并无节点，所以不用考虑是否比子节点大，但是有一点要考虑是覆盖完后是否比父节点还要小</span></span><br><span class="line"><span class="comment">     *       12. 若比父节点还要小的话就要做上浮操作，即调用siftUp即可，最后退出</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. 删除的节点有子节点，如下步骤：</span></span><br><span class="line"><span class="comment">     *       21. 先比较两个子节点的值的大小，获取值最小的节点</span></span><br><span class="line"><span class="comment">     *       22. 在将值最小的节点与末尾的节点进行比较（若只有一个子节点的话，那么只能是左子节点，就直接比较大小）</span></span><br><span class="line"><span class="comment">     *       23. 若是末尾的节点更小的话，那么直接覆盖移除的节点的值即可，同时将末尾位置设置成null，最后退出</span></span><br><span class="line"><span class="comment">     *       24. 若是其子节点更小的话，那么用其值最小的节点覆盖到移除的节点的值，此时值最小的节点的位置就空出来了（相当于此时它被移除了），那么此时重复步骤12</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 假设一个节点的索引为：N，其父节点的索引为：(N - 1)/2，左子节点的索引为：2N + 1，其右子节点的索引为：2N + 2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k 移除节点的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 末尾节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, RunnableScheduledFuture&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">//通过该值来判断移除节点是否有子节点，可以画几个例子验证下，我也不懂怎么来的，只能说写算法的人牛逼</span></span><br><span class="line">        <span class="keyword">while</span> (k &lt; half) &#123; <span class="comment">//若是进入循环说明移除节点是存在子节点的，有可能是存在左右子节点，也有可能只存在左子节点</span></span><br><span class="line">            <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">//移除节点的左子节点</span></span><br><span class="line">            RunnableScheduledFuture&lt;?&gt; c = queue[child]; <span class="comment">//左子节点的值</span></span><br><span class="line">            <span class="keyword">int</span> right = child + <span class="number">1</span>;<span class="comment">//移除节点的右子节点</span></span><br><span class="line">            <span class="keyword">if</span> (right &lt; size &amp;&amp; c.compareTo(queue[right]) &gt; <span class="number">0</span>) <span class="comment">//先判断是否存在右子节点，若左右子节点都存在，那么要找出值最小的节点</span></span><br><span class="line">                c = queue[child = right];</span><br><span class="line">            <span class="keyword">if</span> (key.compareTo(c) &lt;= <span class="number">0</span>) <span class="comment">//末尾节点与值最小的节点进行比较</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = c; <span class="comment">//这里的操作与siftUp同理</span></span><br><span class="line">            setIndex(c, k);</span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = key;</span><br><span class="line">        setIndex(key, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列以50%的速率进行扩容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = queue.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">// grow 50%</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            newCapacity = Integer.MAX_VALUE;</span><br><span class="line">        queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取队列中指定任务的索引</span></span><br><span class="line"><span class="comment">     * 若不存在指定任务则返回-1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 指定任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 指定任务的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x <span class="keyword">instanceof</span> ScheduledFutureTask) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = ((ScheduledFutureTask) x).heapIndex;</span><br><span class="line">                <span class="comment">// Sanity check; x could conceivably be a</span></span><br><span class="line">                <span class="comment">// ScheduledFutureTask from some other pool.</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; size &amp;&amp; queue[i] == x)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                    <span class="keyword">if</span> (x.equals(queue[i]))</span><br><span class="line">                        <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取队列中是否包含指定任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 指定任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否包含指定任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> indexOf(x) != -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取队列中是否成功移除指定任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 指定任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = indexOf(x);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            setIndex(queue[i], -<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> s = --size;</span><br><span class="line">            RunnableScheduledFuture&lt;?&gt; replacement = queue[s]; <span class="comment">//获取末尾的节点</span></span><br><span class="line">            queue[s] = <span class="keyword">null</span>; <span class="comment">//预先将末尾的节点置null，因为末尾的节点会移动到其他位置上</span></span><br><span class="line">            <span class="keyword">if</span> (s != i) &#123; <span class="comment">//若为true，说明移除的节点不是末尾节点</span></span><br><span class="line">                siftDown(i, replacement);<span class="comment">//下沉只是以移除节点为起始段往下开始比较，但它的上部分并未比较，所以有可能出现移动完毕的节点比父节点的值还大</span></span><br><span class="line">                <span class="keyword">if</span> (queue[i] == replacement) <span class="comment">//走到这里说明下沉结束，表示末尾的节点已经移动完成，移动后有可能出现末尾节点的值比父节点的值还小，针对siftDown方法注释中的11-12点</span></span><br><span class="line">                    siftUp(i, replacement);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取队列中的第一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; peek() &#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列中插入指定任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 指定任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(Runnable x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;)x;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = size;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">                grow(); <span class="comment">//队列扩容</span></span><br><span class="line">            size = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                queue[<span class="number">0</span>] = e;</span><br><span class="line">                setIndex(e, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                siftUp(i, e); <span class="comment">//插入节点后进行上浮操作</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (queue[<span class="number">0</span>] == e) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 这里需要注意下！！！</span></span><br><span class="line"><span class="comment">                 * 走到这里表明队列中的堆顶节点已经换成插入的节点，简单来说就是队列更新了，在这个过程中有可能已经在执行take方法中的 available.awaitNanos(delay) 语句，那么此时的等待时间已经没有意义了</span></span><br><span class="line"><span class="comment">                 * 所以执行了available.signal（个人觉得还应该去判断是否堆顶节点改变了，但不一定是插入的节点成为了新的堆顶节点），因为队列的堆顶节点都更新了，需要重新获取并等待，由于可能存在多个线程，故将leader设置成null，让线程* 之间去竞争谁成为Leader线程</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                leader = <span class="keyword">null</span>;</span><br><span class="line">                available.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除堆顶节点</span></span><br><span class="line"><span class="comment">     * 执行该方法说明已经到达任务的执行时间，需要将该节点从队列中移除掉，就相当于了移除掉了堆顶节点，按照siftDown的思路我们知道拿末尾节点是最小成本的</span></span><br><span class="line"><span class="comment">     * 在remove方法中还调用了siftUp，但由于是这里是从堆顶开始比较，所以无需在往上比较了</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> f 堆顶节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 堆顶节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> RunnableScheduledFuture&lt;?&gt; finishPoll(RunnableScheduledFuture&lt;?&gt; f) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = --size;</span><br><span class="line">        RunnableScheduledFuture&lt;?&gt; x = queue[s];</span><br><span class="line">        queue[s] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">            siftDown(<span class="number">0</span>, x);</span><br><span class="line">        setIndex(f, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 立即获取可执行的堆顶节点</span></span><br><span class="line"><span class="comment">     * 可执行表示已到达执行任务的时间，若还未到达则返回null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 堆顶节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; poll() &#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span> || first.getDelay(NANOSECONDS) &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> finishPoll(first);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取可执行的堆顶节点</span></span><br><span class="line"><span class="comment">     * 可执行表示已到达执行任务的时间，若未到达则会进行等待</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 这里使用了Leader-Follower模型的变体，简单来说，多个线程会同时去抢夺队列中的堆顶节点，谁抢到了谁就成为Leader线程，而其他线程要一直阻塞着，这些线程成为Follower线程</span></span><br><span class="line"><span class="comment">     * 1. 假设A线程抢到了，那么最终会执行到 available.awaitNanos(delay) 等待一定的时间，注意一下，该方法是会释放锁的！！！当初也是因为没注意到该点也花费了很多时间</span></span><br><span class="line"><span class="comment">     * 2. 既然释放了锁，那么其他Follower线程也就可以进行来了，陆续执行到 available.await() 语句上进行阻塞</span></span><br><span class="line"><span class="comment">     * 3. 想象一下，如果不对其他线程进行阻塞，同样执行到 available.awaitNanos(delay) 语句，A线程已经执行完毕了早就返回了，而你这个时候的等待时间就相当于是白费了，所以它直接采用了一直等待的策略</span></span><br><span class="line"><span class="comment">     * 3. 等待Leader线程执行完毕后才会唤醒其中一个线程，这个时候唤醒的线程就变成了Leader线程</span></span><br><span class="line"><span class="comment">     * 4. 所以说Leader-Follower模型的变体是始终都只有一个Leader线程，多个Follower线程</span></span><br><span class="line"><span class="comment">     * 总结：Leader-Follower模型的变体减少了不必要的等待时间</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 可执行的堆顶节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; take() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                    available.await();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) </span><br><span class="line">                        <span class="keyword">return</span> finishPoll(first); <span class="comment">//走到这里说明是可执行的任务</span></span><br><span class="line">                    first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line">                    <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                        available.await();</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        Thread thisThread = Thread.currentThread();</span><br><span class="line">                        leader = thisThread;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            available.awaitNanos(delay);<span class="comment">//Leader线程阻塞一定的延迟时间，注意该方法会释放锁</span></span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                                leader = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; queue[<span class="number">0</span>] != <span class="keyword">null</span>) <span class="comment">//始终都会有一个Leader线程</span></span><br><span class="line">                available.signal();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取可执行的堆顶节点</span></span><br><span class="line"><span class="comment">     * 可执行表示已到达执行任务的时间，若在指定时间内还未到达则返回null，所以等待时间最好大于延迟时间</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 1. 若nanos &lt; delay 最终会返回null，需要多次调用poll才能获取到可执行的任务</span></span><br><span class="line"><span class="comment">     * 2. 若nanos &gt; delay 最终只会等待延迟时间后就返回</span></span><br><span class="line"><span class="comment">     * 3. 当Leader != null时，说明已经有Leader线程在处理堆顶节点了，其他线程等着就是了</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 等待时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 可执行的堆顶节点或null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; poll(<span class="keyword">long</span> timeout, TimeUnit unit) <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        nanos = available.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> finishPoll(first);<span class="comment">//走到这里说明是可执行的任务</span></span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt; delay || leader != <span class="keyword">null</span>) <span class="comment">//若nanos &lt; delay 最终会返回null，需要多次调用poll才能获取到可执行的任务；若leader != null，说明有Leader线程获取了堆顶节点，其他线程等着就是了</span></span><br><span class="line">                        nanos = available.awaitNanos(nanos);</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        Thread thisThread = Thread.currentThread();</span><br><span class="line">                        leader = thisThread;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">long</span> timeLeft = available.awaitNanos(delay);</span><br><span class="line">                            nanos -= delay - timeLeft;<span class="comment">//计算剩余的等待时间</span></span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                                leader = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; queue[<span class="number">0</span>] != <span class="keyword">null</span>)</span><br><span class="line">                available.signal();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                RunnableScheduledFuture&lt;?&gt; t = queue[i];</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue[i] = <span class="keyword">null</span>;</span><br><span class="line">                    setIndex(t, -<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取可执行的堆顶节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 可执行的堆顶节点或null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> RunnableScheduledFuture&lt;?&gt; peekExpired() &#123;</span><br><span class="line">        <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line">        RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> (first == <span class="keyword">null</span> || first.getDelay(NANOSECONDS) &gt; <span class="number">0</span>) ?</span><br><span class="line">            <span class="keyword">null</span> : first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清除可执行的所有节点，并将这些节点放入集合中</span></span><br><span class="line"><span class="comment">     * 该方法会在调用ThreadPoolExecutor#shutdownNow时被调用，实际上最终队列中的任务都会被清除</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c 集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 可执行节点的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> Runnable&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RunnableScheduledFuture&lt;?&gt; first;</span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((first = peekExpired()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                c.add(first);   <span class="comment">// In this order, in case add() throws.</span></span><br><span class="line">                finishPoll(first);</span><br><span class="line">                ++n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清除可执行节点，并将这些节点放入集合中，与上面的方法相比控制了清除节点的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c 集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 可执行节点的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> Runnable&gt; c, <span class="keyword">int</span> maxElements)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (maxElements &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RunnableScheduledFuture&lt;?&gt; first;</span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n &lt; maxElements &amp;&amp; (first = peekExpired()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                c.add(first);   <span class="comment">// In this order, in case add() throws.</span></span><br><span class="line">                finishPoll(first);</span><br><span class="line">                ++n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用迭代器可获取队列中的任务，这里就不贴了...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><ul><li><p>当线程池处于SHUTDOWN时，是否继续执行队列中的任务，包括重复执行的任务与延迟的任务，针对这两者取决于continueExistingPeriodicTasksAfterShutdown与executeExistingDelayedTasksAfterShutdown属性</p></li><li><p>重复执行任务的原理：任务对象中有一个outerTask属性指向自身，在上一个任务执行完毕后会更新下一个任务的执行时间，并将下一个任务再次放入到队列中（上一个任务在执行前就已经从队列中移除了），重复此操作</p></li><li><p>scheduleAtFixedRate：按照一定的频率去执行任务，下一个任务的执行时间从上一个任务开始执行的时间开始算起，所以有可能导致已经到达下一个任务的执行了，但上一个任务还未执行结束的情况，直到上一个任务执行结束了，下一个任务立即被执行</p></li><li><p>scheduleWithFixedDelay：按照一定的周期去执行任务，下一个任务的执行时间从上一个任务执行结束后的时间开始算起，所以下一个任务的执行时间严重依赖于上一个任务</p></li><li><p>removeOnCancel：该属性表明当取消队列中的任务时是否立即将任务从队列中移除，建议设置成true，而默认情况下是false，这会造成时间成本上的浪费，简单来说，被取消的任务会更改其状态，除此之外，它仍会像其他任务一样被获取然后等待一定的延迟时间后，直到可执行了，那么此时去执行时发现它的状态不对，就只能不了了之了，要是延迟时间在长点…，不可想象了！</p></li><li><p>DelayedWorkQueue队列采用二叉堆（最小堆）数据结构，其中使用了Leader-Follower模型的变体，始终只有一个Leader线程在处理队列中的堆顶节点，其他Follower线程只能等待着</p></li><li><p>老版本的JDK中通常使用Timer，但其实该类存在一些<code>缺陷</code>：通过单线程来执行所有的任务，若其中一个任务执行时间过长，将会导致其他任务无法执行或者无法准时执行；若其中一个任务抛出异常，其他的任务将不会再运行；Timer的执行时间依赖于系统时间，也就是说针对不同的平台，比如Window、Linux平台下可能会有不同的行为，而ScheduledThreadPool中的now采用的System.nanoTime，该方法不关联系统时间，它代表了从某个固定时间点到现在所经过的毫秒数，该计算方式跟JVM有关系，不同的JVM可能固定时间点不同，对于不同的平台使用的JVM肯定是同一个，所以不管再哪个平台下任务的行为都是一样的</p></li></ul><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a><div><span>总结</span></div></h3><p>知识点过多，建议当作好几篇文章分开看，笔者断断续续花了应该有2个月时间，若有错误欢迎指出！</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><div><span>参考资料</span></div></h3><p>《Java编程思想》</p><p><a href="https://blog.csdn.net/chang_ge/article/details/80080382" target="_blank" rel="noopener">https://blog.csdn.net/chang_ge/article/details/80080382</a></p><p><a href="https://blog.csdn.net/lmj623565791/article/details/27109467" target="_blank" rel="noopener">https://blog.csdn.net/lmj623565791/article/details/27109467</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前奏&quot;&gt;&lt;a href=&quot;#前奏&quot; class=&quot;headerlink&quot; title=&quot;前奏&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前奏&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Executor&lt;/code&gt;是家族中的老大，其下还有ExecutorService、Executors、ThreadPoolExecutor、ScheduledThreadPoolExecutor和ForkJoinPool，对于ForkJoinPool是在JDK1.7中新增的，其中可能还涉及到诸多理论，故而打算会另起文章进行说明。不管是在工作还是面试中，难免会耳闻线程池，简单说下个人对线程池的理解，后续将对Executor的家族成员做一一介绍，让我们开始旅程吧，此次探索基于&lt;code&gt;JDK1.8&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;线程池&lt;/code&gt;：将创建好的线程放到一个池中进行使用、调度及管理，等到任务一提交后就可以直接运行了，省去了创建线程的时间，同时使用者不必考虑如何管理线程，让使用者更加专注于任务。线程池中会涉及到核心线程数（corePoolSize）、最大线程数（maximumPoolSize）、队列，假设线程个数小于核心线程数，对于新提交的任务会直接创建新线程，当线程个数超过核心线程数且队列未满时，将新任务放入到队列中，等到空闲线程后再去执行，万一要是队列满了且线程数不超过最大线程数时，则会创建新线程执行任务，哪天要是大于最大线程数，则任务将被拒绝，对于拒绝可指定不同的策略，后续将会详细介绍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;家族成员&quot;&gt;&lt;a href=&quot;#家族成员&quot; class=&quot;headerlink&quot; title=&quot;家族成员&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;家族成员&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p class=&quot;customize-img&quot;&gt;&lt;img src=&quot;/assets/blogImg/java/executor/executor-class-structure.png&quot; alt=&quot;Executor家族成员&quot;&gt;&lt;/p&gt;
&lt;p&gt;每个成员的地位很明确了，我们从Executors开始入手。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>认识堆</title>
    <link href="http://zlia.tech/2020/01/10/explain-binary-heap/"/>
    <id>http://zlia.tech/2020/01/10/explain-binary-heap/</id>
    <published>2020-01-10T03:00:30.000Z</published>
    <updated>2020-01-10T03:00:30.287Z</updated>
    
    <content type="html"><![CDATA[<h3 id="堆的概念"><a href="#堆的概念" class="headerlink" title="堆的概念"></a><div><span>堆的概念</span></div></h3><p>堆实际上是一颗树，只不过在其基础上又加上新的性质，常见的堆有：二叉堆、二项堆、斐波那契堆等，其性质如下：</p><ul><li><p>是一颗树，百度百科/维基百科上都说是一颗完全二叉树，但实际中二项堆并不是</p></li><li><p>父节点的值总是<code>大于或等于</code>（<code>小于或等于</code>）任何一个子节点的值，注意始终都没有说子节点之间的关系，也就是说子节点之间的关系并不重要</p></li></ul><p>针对性质二又可以分为<code>最大堆/大根堆</code>与<code>最小堆/小根堆</code>，解释如下：</p><blockquote><p><code>最大堆/大根堆</code>：堆中的父节点的值总是大于等于它的子节点</p></blockquote><blockquote><p><code>最小堆/小根堆</code>：堆中的父节点的值总是小于等于它的子节点</p></blockquote><blockquote><p><code>堆顶</code>：二叉树的第一个节点称为根节点，而二叉堆称为堆顶</p></blockquote><p>较为经常使用的是二叉堆，虽然通常说的堆结构即是指二叉堆，以至于两者的概念有点混淆，即使是百科也存在模糊不清，一会说是树又是完全二叉树？但我仍然还是想作一下区分，毕竟堆中还有其他的数据结构，而其数据结构必然符合堆的性质，所以我认为堆是一棵树！</p><a id="more"></a><h4 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h4><p>二叉堆是一颗<code>完全二叉树</code>，对于完全二叉树的定义可参看之前的<a href="http://zlia.tech/2019/09/11/explain-binarytree">文章</a>。二叉堆的存储结构一般用<code>数组</code>来表示，假设某一个节点的索引为：N，其左节点的索引应为：2N + 1，其右子节点的索引为：2N + 2，如下所示:</p><p class="customize-img"><img src="/assets/blogImg/algorithm/heap/binaryheap-structure-2.png" alt="二叉堆结构"></p><p>发现没有，它是按照二叉树的前序方式排列到数组中，所谓<code>前序</code>简单来说就是父节点放第一个，中序就是父节点放中间，后序自然就是父节点放最后一个了。还有一点需要注意下，二叉堆中并未要求左右子节点的值大小要求，也可以将值理解成<code>优先级</code>，对于最大堆来说，认为值越大说明优先级越高，位置更靠前，而对于最小堆来说，认定值越小优先级越高，这就看需要了！对于二叉树来说，通常左节点的值要比父节点小，而右子节点的值要比父节点大，但对于二叉堆来说，左右节点的值要么是大于等于父节点的值要么是小于等于。</p><h4 id="二项堆"><a href="#二项堆" class="headerlink" title="二项堆"></a>二项堆</h4><p>二项堆是二项树的集合，简单来说，就是在二项树的基础上加上了其他性质，二项树的性质如下：</p><ul><li><p>高/深度为K的树，根节点下有K个子节点，每个子节点的高/深度分别是K-1、K-2、…2、1、0</p></li><li><p>高/深度为K的树，共有有2<sup>K-1</sup>个节点，百科中认为高/深度是从0开始算起，有些书籍是从1开始算起，因为之前有关树的介绍文章中也是1，故而还是按照以前的说法！</p></li></ul><p>接下来说说二项堆的性质：</p><ul><li><p>每颗二项树都是<code>最小堆</code>，即父节点的值总是小于等于它的子节点</p></li><li><p>不能有两颗或以上的二项树有相同的高/深度，换句话说，具有高/深度的二项树有0或1个</p></li></ul><p>与二叉堆相比，其优势是可以快速合并两个堆，一般使用<code>链表</code>作为其存储结构，由于过于复杂直接引用了网上的图片，如下图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/heap/binomialheap-structure-3.png" alt="二项堆结构"></p><h4 id="斐波那契堆"><a href="#斐波那契堆" class="headerlink" title="斐波那契堆"></a>斐波那契堆</h4><p>网上资料，包括百科都解释地稀里糊涂，各种语言实现，我想说能先把概念描述清楚了在谈其他吗？基本上每篇文章都是照搬《算法导论》的知识点，我没看过这本书，所以不敢往下结论，只是在这里告诉读者有这么一种类型的堆！顺便附上网上引用的关于其存储结构的图片，如下图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/heap/fibonacciheap-4.png" alt="斐波那契堆结构"></p><h3 id="二叉堆的设计与实现"><a href="#二叉堆的设计与实现" class="headerlink" title="二叉堆的设计与实现"></a><div><span>二叉堆的设计与实现</span></div></h3><p>尝试手写了二叉堆，因为其较为常用，剩下两种数据结构比较难，对于基础不好或是不感兴趣的读者建议绕开！有兴趣的同学可以去github上观摩-<a href="https://github.com/JulianHang/little-java-project/blob/master/src/tech/zlia/interest/algorithm/tree/heap/MaximumBinaryHeap.java" target="_blank" rel="noopener">二叉堆设计</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><div><span>总结</span></div></h3><p>笔者也是第一次接触到关于堆的概念，所以此篇文章更多的是帮助读者去认识它！若有讲解不到位的地方欢迎指出，将积极改正。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;堆的概念&quot;&gt;&lt;a href=&quot;#堆的概念&quot; class=&quot;headerlink&quot; title=&quot;堆的概念&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;堆的概念&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;堆实际上是一颗树，只不过在其基础上又加上新的性质，常见的堆有：二叉堆、二项堆、斐波那契堆等，其性质如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;是一颗树，百度百科/维基百科上都说是一颗完全二叉树，但实际中二项堆并不是&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;父节点的值总是&lt;code&gt;大于或等于&lt;/code&gt;（&lt;code&gt;小于或等于&lt;/code&gt;）任何一个子节点的值，注意始终都没有说子节点之间的关系，也就是说子节点之间的关系并不重要&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;针对性质二又可以分为&lt;code&gt;最大堆/大根堆&lt;/code&gt;与&lt;code&gt;最小堆/小根堆&lt;/code&gt;，解释如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;最大堆/大根堆&lt;/code&gt;：堆中的父节点的值总是大于等于它的子节点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;最小堆/小根堆&lt;/code&gt;：堆中的父节点的值总是小于等于它的子节点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;堆顶&lt;/code&gt;：二叉树的第一个节点称为根节点，而二叉堆称为堆顶&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;较为经常使用的是二叉堆，虽然通常说的堆结构即是指二叉堆，以至于两者的概念有点混淆，即使是百科也存在模糊不清，一会说是树又是完全二叉树？但我仍然还是想作一下区分，毕竟堆中还有其他的数据结构，而其数据结构必然符合堆的性质，所以我认为堆是一棵树！&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="algorithm" scheme="http://zlia.tech/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>揭开面纱-ThreadGroup</title>
    <link href="http://zlia.tech/2019/12/12/explain-threadgroup-sourcecode/"/>
    <id>http://zlia.tech/2019/12/12/explain-threadgroup-sourcecode/</id>
    <published>2019-12-12T09:41:37.000Z</published>
    <updated>2019-12-15T03:56:12.410Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开门见山"><a href="#开门见山" class="headerlink" title="开门见山"></a><div><span>开门见山</span></div></h3><p>ThreadGroup在实际开发中很少用到，不过由于它跟Thread的关系比较密切，所以还是了解下为妙，揭开ThreadGroup的面纱是基于<code>JDK1.8</code>。通过阅读注释及相关文章，可以知道ThreadGroup的结构如下：</p><p class="customize-img"><img src="/assets/blogImg/java/thread-group/threadgroup-structure.png" alt="线程组结构"></p><p>除了初始线程组（JVM所属）以外，每个线程组都有一个父线程组及子线程组，父线程组中有个成员变量（groups）来记录它所有的子线程组，所以线程组之间的关系被看作是一棵<code>树</code>。线程组下有多个线程，我们可以将线程组理解成是对一组线程进行操作。</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadGroup</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//父线程组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程组的名称</span></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程组的最大优先级，该优先级不能大于父线程组的优先级</span></span><br><span class="line">    <span class="keyword">int</span> maxPriority;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程组是否已经销毁（清除）</span></span><br><span class="line">    <span class="keyword">boolean</span> destroyed;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//线程组是否是守护线程组</span></span><br><span class="line">    <span class="keyword">boolean</span> daemon;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//未启动的线程个数，即未调用start方法的线程个数</span></span><br><span class="line">    <span class="keyword">int</span> nUnstartedThreads = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//已启动的线程个数，即已调用start方法的线程个数</span></span><br><span class="line">    <span class="keyword">int</span> nthreads;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//已启动的线程个数，该数组会通过创建新数组拷贝源数组的方式进行扩容，新数组的容量是源数据的2倍</span></span><br><span class="line">    Thread threads[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子线程组的个数</span></span><br><span class="line">    <span class="keyword">int</span> ngroups;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储所有子线程组</span></span><br><span class="line">    ThreadGroup groups[];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造线程组，该构造方式通常是创建系统级别的线程组，如由底层C代码来构造初始线程组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"system"</span>;</span><br><span class="line">    <span class="keyword">this</span>.maxPriority = Thread.MAX_PRIORITY;</span><br><span class="line">    <span class="keyword">this</span>.parent = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 线程组的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadGroup</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Thread.currentThread().getThreadGroup(), name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造线程组并指定父线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parant 父线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 线程组的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadGroup</span><span class="params">(ThreadGroup parent, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(checkParentAccess(parent), parent, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造线程组并指定父线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unused 未使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parant 父线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 线程组的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadGroup</span><span class="params">(Void unused, ThreadGroup parent, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.maxPriority = parent.maxPriority;</span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.daemon;</span><br><span class="line">    <span class="keyword">this</span>.vmAllowSuspension = parent.vmAllowSuspension;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    parent.add(<span class="keyword">this</span>); <span class="comment">//指定父线程组后，要将其添加到父线程组所属的子线程组数组中，维护其关系</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程组的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程组的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程组的父线程组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ThreadGroup <span class="title">getParent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>)</span><br><span class="line">        parent.checkAccess();</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程组的最大优先级</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程组的最大优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getMaxPriority</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxPriority;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程组是否是守护线程组</span></span><br><span class="line"><span class="comment"> * 若当前线程组是守护线程组，则当线程组中的线程都终止了或其子线程组都终止了则会自动调用destroy方法</span></span><br><span class="line"><span class="comment"> * 实际上在线程终止底层后调用Thread#exit方法，通过该方法来终止守护线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否是守护线程组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isDaemon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> daemon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程组是否已销毁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否已销毁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isDestroyed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> destroyed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置线程组是否是守护线程组</span></span><br><span class="line"><span class="comment"> * true-属于守护线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> daemon 标志</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setDaemon</span><span class="params">(<span class="keyword">boolean</span> daemon)</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">this</span>.daemon = daemon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置线程组的最大优先级</span></span><br><span class="line"><span class="comment"> * 线程的优先级与线程组的最大优先级互不影响，也就是说即使线程的优先级比线程组的最大优先级还高也不影响</span></span><br><span class="line"><span class="comment"> * 当前线程组的最大优先级不能超过父线程组的最大优先级</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pri 最大优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setMaxPriority</span><span class="params">(<span class="keyword">int</span> pri)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ngroupsSnapshot;</span><br><span class="line">    ThreadGroup[] groupsSnapshot;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="keyword">if</span> (pri &lt; Thread.MIN_PRIORITY || pri &gt; Thread.MAX_PRIORITY) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxPriority = (parent != <span class="keyword">null</span>) ? Math.min(pri, parent.maxPriority) : pri; <span class="comment">//当前线程组的最大优先级不能超过父线程组的最大优先级</span></span><br><span class="line">        ngroupsSnapshot = ngroups;</span><br><span class="line">        <span class="keyword">if</span> (groups != <span class="keyword">null</span>) &#123;</span><br><span class="line">            groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i++) &#123;</span><br><span class="line">        groupsSnapshot[i].setMaxPriority(pri); <span class="comment">//递归更改其子线程组的最大优先级</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前线程组是否与指定线程组是同一个对象或是指定线程组的父线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> g 指定线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parentOf</span><span class="params">(ThreadGroup g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; g != <span class="keyword">null</span> ; g = g.parent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前线程组的活跃线程个数</span></span><br><span class="line"><span class="comment"> * 注意：线程组中还有子线程组，所以计算时也会包含子线程组</span></span><br><span class="line"><span class="comment"> * 该结果只是一个估算值，因为线程数一直在动态变化着，同时JVM也会有一些线程，所以可能会影响该计数结果</span></span><br><span class="line"><span class="comment"> * 该方法主要用来调试与监控</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程组的活跃线程个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">activeCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="keyword">int</span> ngroupsSnapshot;</span><br><span class="line">    ThreadGroup[] groupsSnapshot;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result = nthreads;</span><br><span class="line">        ngroupsSnapshot = ngroups;</span><br><span class="line">        <span class="keyword">if</span> (groups != <span class="keyword">null</span>) &#123;</span><br><span class="line">            groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i++) &#123;</span><br><span class="line">        result += groupsSnapshot[i].activeCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前线程组及其子线程组的活跃线程拷贝到指定数组中</span></span><br><span class="line"><span class="comment"> * 要严格确保指定数组的大小大于活跃线程的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tarray 指定数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程组的活跃线程个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">enumerate</span><span class="params">(Thread list[])</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">return</span> enumerate(list, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前线程组的活跃线程拷贝到指定数组中</span></span><br><span class="line"><span class="comment"> * 通过recurse参数来决定是否拷贝子线程组</span></span><br><span class="line"><span class="comment"> * 要严格确保指定数组的大小大于活跃线程的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tarray 指定数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> recurse 决定是否拷贝子线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程组的活跃线程个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">enumerate</span><span class="params">(Thread list[], <span class="keyword">boolean</span> recurse)</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">return</span> enumerate(list, <span class="number">0</span>, recurse);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前线程组的活跃线程拷贝到指定数组中</span></span><br><span class="line"><span class="comment"> * 通过recurse参数来决定是否拷贝子线程组</span></span><br><span class="line"><span class="comment"> * 要严格确保指定数组的大小大于活跃线程的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tarray 指定数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 从指定数组的指定起始索引开始添加</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> recurse 决定是否拷贝子线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程组的活跃线程个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">enumerate</span><span class="params">(Thread list[], <span class="keyword">int</span> n, <span class="keyword">boolean</span> recurse)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ngroupsSnapshot = <span class="number">0</span>;</span><br><span class="line">    ThreadGroup[] groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nt = nthreads;</span><br><span class="line">        <span class="keyword">if</span> (nt &gt; list.length - n) &#123; <span class="comment">//若指定数组的长度小于活跃线程的个数，则超过的活跃线程将被忽略</span></span><br><span class="line">            nt = list.length - n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nt; i++) &#123; <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (threads[i].isAlive()) &#123;</span><br><span class="line">                list[n++] = threads[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (recurse) &#123; <span class="comment">// 是否加入子线程组的活跃线程</span></span><br><span class="line">            ngroupsSnapshot = ngroups;</span><br><span class="line">            <span class="keyword">if</span> (groups != <span class="keyword">null</span>) &#123;</span><br><span class="line">                groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (recurse) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i++) &#123;</span><br><span class="line">            n = groupsSnapshot[i].enumerate(list, n, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前线程组的子线程组个数</span></span><br><span class="line"><span class="comment"> * 注意：当前线程组中还有子线程组，所以计算时也会包含子线程组</span></span><br><span class="line"><span class="comment"> * 该结果只是一个估算值，因为线程数一直在动态变化着</span></span><br><span class="line"><span class="comment"> * 该方法主要用来调试与监控</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程组的活跃线程个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">activeGroupCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ngroupsSnapshot;</span><br><span class="line">    ThreadGroup[] groupsSnapshot;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ngroupsSnapshot = ngroups;</span><br><span class="line">        <span class="keyword">if</span> (groups != <span class="keyword">null</span>) &#123;</span><br><span class="line">            groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = ngroupsSnapshot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i++) &#123;</span><br><span class="line">        n += groupsSnapshot[i].activeGroupCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前线程组及其子线程组的子线程组拷贝到指定数组中</span></span><br><span class="line"><span class="comment"> * 要严格确保指定数组的大小大于子线程组的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tarray 指定数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程组的子线程组个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">enumerate</span><span class="params">(ThreadGroup list[])</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">return</span> enumerate(list, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////其他enumerate方法就不做展示了，都是类似的/////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 终止当前线程组的所有线程，包括其子线程下的所有线程</span></span><br><span class="line"><span class="comment"> * 由于Thread#stop方法已废弃，故而该方法也是没啥用的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stopOrSuspend(<span class="keyword">false</span>))</span><br><span class="line">        Thread.currentThread().stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归挂起或终止当前线程组的所有线程，除了当前线程之外（会在调用方挂起或终止当前线程）</span></span><br><span class="line"><span class="comment"> * 同时也会挂起或终止其子线程组的所有线程</span></span><br><span class="line"><span class="comment"> * 该方法通过返回值来判断当前线程是否存在于当前线程组或子线程组中，若存在则在该方法返回后也会对当前线程进行挂机或终止，若不存在则不会进行任何操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> suspend true表示挂起  false表示终止</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 当前线程是否存在于当前线程组或子线程组中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">stopOrSuspend</span><span class="params">(<span class="keyword">boolean</span> suspend)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> suicide = <span class="keyword">false</span>;</span><br><span class="line">    Thread us = Thread.currentThread(); <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="keyword">int</span> ngroupsSnapshot;</span><br><span class="line">    ThreadGroup[] groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nthreads ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (threads[i]==us)</span><br><span class="line">                suicide = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (suspend)</span><br><span class="line">                threads[i].suspend();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                threads[i].stop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ngroupsSnapshot = ngroups;</span><br><span class="line">        <span class="keyword">if</span> (groups != <span class="keyword">null</span>) &#123;</span><br><span class="line">            groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i++)</span><br><span class="line">        suicide = groupsSnapshot[i].stopOrSuspend(suspend) || suicide;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> suicide;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中断当前线程组的所有线程，包括子线程组的所有线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ngroupsSnapshot;</span><br><span class="line">    ThreadGroup[] groupsSnapshot;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nthreads ; i++) &#123;</span><br><span class="line">            threads[i].interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        ngroupsSnapshot = ngroups;</span><br><span class="line">        <span class="keyword">if</span> (groups != <span class="keyword">null</span>) &#123;</span><br><span class="line">            groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i++) &#123;</span><br><span class="line">        groupsSnapshot[i].interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 销毁当前线程组及其子线程组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ngroupsSnapshot;</span><br><span class="line">    ThreadGroup[] groupsSnapshot;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="keyword">if</span> (destroyed || (nthreads &gt; <span class="number">0</span>)) &#123; <span class="comment">//如果还有运行中的线程则不允许销毁</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        ngroupsSnapshot = ngroups;</span><br><span class="line">        <span class="keyword">if</span> (groups != <span class="keyword">null</span>) &#123;</span><br><span class="line">            groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123; <span class="comment">//除了初始线程以外，线程组在销毁后需要清理资源</span></span><br><span class="line">            destroyed = <span class="keyword">true</span>;</span><br><span class="line">            ngroups = <span class="number">0</span>;</span><br><span class="line">            groups = <span class="keyword">null</span>;</span><br><span class="line">            nthreads = <span class="number">0</span>;</span><br><span class="line">            threads = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i += <span class="number">1</span>) &#123; <span class="comment">//销毁子线程组</span></span><br><span class="line">        groupsSnapshot[i].destroy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123; <span class="comment">//从父线程组中移除当前线程组，解除关系</span></span><br><span class="line">        parent.remove(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从当前线程组的子线程组中移除指定线程组</span></span><br><span class="line"><span class="comment"> * 若当前线程组是守护线程组，且不存在运行中及未启动的线程，且不不存在子线程组，相当于要移除的线程组是最后一个线程组，则销毁自身</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> g 指定线程组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadGroup g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroups ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (groups[i] == g) &#123;</span><br><span class="line">                ngroups -= <span class="number">1</span>;</span><br><span class="line">                System.arraycopy(groups, i + <span class="number">1</span>, groups, i, ngroups - i); <span class="comment">//在子线程组中移除指定线程组</span></span><br><span class="line">                groups[ngroups] = <span class="keyword">null</span>; <span class="comment">//手动置为null以便垃圾回收器能回收它</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nthreads == <span class="number">0</span>) &#123; <span class="comment">//这里我唯一想到的是可能有其他线程使用了当前对象锁</span></span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (daemon &amp;&amp; (nthreads == <span class="number">0</span>) &amp;&amp;  (nUnstartedThreads == <span class="number">0</span>) &amp;&amp; (ngroups == <span class="number">0</span>)) <span class="comment">//当前线程组是守护线程组，且不存在运行中及未启动的线程，且不存在子线程组</span></span><br><span class="line">        &#123;</span><br><span class="line">            destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对未启动的线程进行计数</span></span><br><span class="line"><span class="comment"> * 未启动的线程不会添加到线程组中，这样即使从未启动过的线程也会被收集，但是必须对它们进行计数，以便不会破坏守护线程组.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addUnstarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        nUnstartedThreads++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加已启动的线程到线程组中</span></span><br><span class="line"><span class="comment"> * 该方法可能会被JVM调用，因为有初始线程组要添加已启动的系统线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (threads == <span class="keyword">null</span>) &#123;</span><br><span class="line">            threads = <span class="keyword">new</span> Thread[<span class="number">4</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nthreads == threads.length) &#123;</span><br><span class="line">            threads = Arrays.copyOf(threads, nthreads * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        threads[nthreads] = t; <span class="comment">//添加已启动的线程</span></span><br><span class="line"></span><br><span class="line">        nthreads++; <span class="comment">//计数已启动的线程个数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为只有在线程启动后才会调用该方法，故而未启动的线程个数应该减去1</span></span><br><span class="line">        nUnstartedThreads--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定线程启动失败后会调用此方法</span></span><br><span class="line"><span class="comment"> * 线程启动失败后，应该对未启动的线程个数进行计数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t 指定线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadStartFailed</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        remove(t);</span><br><span class="line">        nUnstartedThreads++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从当前线程组中移除指定线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t 指定线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nthreads ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (threads[i] == t) &#123;</span><br><span class="line">                System.arraycopy(threads, i + <span class="number">1</span>, threads, i, --nthreads - i);</span><br><span class="line">                threads[nthreads] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定线程终止后调用此方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t 指定线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadTerminated</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        remove(t);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nthreads == <span class="number">0</span>) &#123; <span class="comment">//这里我唯一想到的是可能有其他线程使用了当前对象锁</span></span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (daemon &amp;&amp; (nthreads == <span class="number">0</span>) &amp;&amp; (nUnstartedThreads == <span class="number">0</span>) &amp;&amp; (ngroups == <span class="number">0</span>)) <span class="comment">//当前线程组是守护线程组，且不存在运行中及未启动的线程，且不存在子线程组</span></span><br><span class="line">        &#123;</span><br><span class="line">            destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印线程组的信息到标准输出，包括活跃的线程及其子线程组的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    list(System.out, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印线程组的信息到标准输出，包括活跃的线程及其子线程组的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">list</span><span class="params">(PrintStream out, <span class="keyword">int</span> indent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ngroupsSnapshot;</span><br><span class="line">    ThreadGroup[] groupsSnapshot;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; indent ; j++) &#123;</span><br><span class="line">            out.print(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        out.println(<span class="keyword">this</span>);</span><br><span class="line">        indent += <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nthreads ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; indent ; j++) &#123;</span><br><span class="line">                out.print(<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(threads[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ngroupsSnapshot = ngroups;</span><br><span class="line">        <span class="keyword">if</span> (groups != <span class="keyword">null</span>) &#123;</span><br><span class="line">            groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i++) &#123;</span><br><span class="line">        groupsSnapshot[i].list(out, indent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当线程未设置自定义异常处理器，则当线程发生异常时，会调用该方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t 当前发生异常的线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 异常信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123; </span><br><span class="line">        parent.uncaughtException(t, e); <span class="comment">//若线程未设置自定义异常处理器，则使用父线程组的异常</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Thread.UncaughtExceptionHandler ueh = Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">        <span class="keyword">if</span> (ueh != <span class="keyword">null</span>) &#123; <span class="comment">//线程是否设置了默认的异常处理器</span></span><br><span class="line">            ueh.uncaughtException(t, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> ThreadDeath)) &#123;</span><br><span class="line">            System.err.print(<span class="string">"Exception in thread \""</span> + t.getName() + <span class="string">"\" "</span>);</span><br><span class="line">            e.printStackTrace(System.err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">"[name="</span> + getName() + <span class="string">",maxpri="</span> + maxPriority + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>除了初始线程组以外，每个线程组都有一个父线程组及子线程组，这样子的关系被看作是一棵树</p></li><li><p>若线程组是守护线程组，则在满足一定的条件下会自动调用销毁方法</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;开门见山&quot;&gt;&lt;a href=&quot;#开门见山&quot; class=&quot;headerlink&quot; title=&quot;开门见山&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;开门见山&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;ThreadGroup在实际开发中很少用到，不过由于它跟Thread的关系比较密切，所以还是了解下为妙，揭开ThreadGroup的面纱是基于&lt;code&gt;JDK1.8&lt;/code&gt;。通过阅读注释及相关文章，可以知道ThreadGroup的结构如下：&lt;/p&gt;
&lt;p class=&quot;customize-img&quot;&gt;&lt;img src=&quot;/assets/blogImg/java/thread-group/threadgroup-structure.png&quot; alt=&quot;线程组结构&quot;&gt;&lt;/p&gt;
&lt;p&gt;除了初始线程组（JVM所属）以外，每个线程组都有一个父线程组及子线程组，父线程组中有个成员变量（groups）来记录它所有的子线程组，所以线程组之间的关系被看作是一棵&lt;code&gt;树&lt;/code&gt;。线程组下有多个线程，我们可以将线程组理解成是对一组线程进行操作。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>尽力去探究Thread的方方面面</title>
    <link href="http://zlia.tech/2019/12/11/explain-thread-sourcecode/"/>
    <id>http://zlia.tech/2019/12/11/explain-thread-sourcecode/</id>
    <published>2019-12-11T08:37:08.000Z</published>
    <updated>2020-01-02T09:35:56.385Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>接下来的这一段时间都将探索跟线程有关的内容，包括各种锁，对Thread的总结如下：</p><blockquote><p>线程具有<code>优先级</code>，高优先级的线程优先于低优先级的线程执行，当在某个线程中创建新线程时，新线程的优先级被设置成当前线程的优先级；JVM启动时，默认有一个非守护线程（调用某个类的main方法）；线程能被标记为<code>守护线程</code>，每个线程都可以<code>指定名称</code>，未指定的情况下将由底层帮其生成一个新名称；有两种方式来创建线程，如下所示：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 在只有一个实例的情况下只能创建一个线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"TestA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在只有一个实例的情况下可创建多个线程，这种方式更为常见</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestB</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"TestB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="方方面面"><a href="#方方面面" class="headerlink" title="方方面面"></a><div><span>方方面面</span></div></h3><p>探索Thread源码是基于<code>JDK1.8</code>，在探索之前先了解下<code>线程的状态</code>。</p><ul><li><p><code>新建（NEW）</code>：新创建一个对象，但还没有开始调start方法。</p></li><li><p><code>可运行（RUNNABLE）</code>：调用start方法后，该线程处于就绪状态，简单来就是还未运行，当线程调度器把时间片分配给该线程后变成了运行中状态。</p></li><li><p><code>阻塞（BLOCKED）</code>：等待同步控制方法或代码块上的对象锁，因为该对象锁已经被其他线程所占用。当线程处于阻塞状态时，线程调度器将忽略该线程，不会分配任何CPU时间，直到该线程进入到就绪状态，它才有可能执行操作。</p></li><li><p><code>等待（WAITING）</code>：等待另外一个线程执行特定的操作，如唤醒（通知）或终止，调用Object#wait、Thread#join、LockSupport#park后会处于该状态。</p></li><li><p><code>超时等待（TIMED_WAITING）</code>：该状态与等待有些类似，只不过它是有限时间内的等待，也就是说，当另外一个线程未执行特定的操作时，经过指定的时间后该线程将会变成该状态（此时未获取到锁），当获取到锁之后就会变成可运行状态（这个状态的转变是个人猜想的，Java规范与注释都未明确说明），调用Thread#sleep(long)、Object#wait(long)、Thread#join(long)、LockSupport#parkUntil可能会处于该状态。顺便提一下，若方法中的参数都为0，那么就相当于直接调用了wait方法，此时的状态会是等待</p></li><li><p><code>终止（TERMINATED）</code>：线程执行完成，指的是从run方法返回。</p></li></ul><p class="customize-img"><img src="/assets/blogImg/java/thread/thread-statue.png" alt="线程状态图"></p><p>简要阐述下几个<code>重要概念</code>，该内容摘抄自Java规范。</p><blockquote><p>Object#wait、Object#notify、Object#notify只能在同步控制方法或同步代码块（synchronized）中使用，否则即使能通过编译，但在运行时会抛出IllegalMonitorStateException异常，因为这些方法在调用时会操作锁，所以它必须先获取到锁。Thread#sleep与Thread#yield可以在非同步控制方法中调用，因为它们始终没有释放锁，更不用谈操作了。</p></blockquote><blockquote><p>针对Object#wait(long millisecs, int nanosecs)方法，注意nanosecs参数要在0-999999范围内（毫秒与纳秒单位换算是6个0），millisecs不能为负。</p></blockquote><blockquote><p>我们都知道每个对象都有一个关联的监视器，即通常所说的锁，除此之外，还具有一个关联的等待容器，很容易理解，里头存放的就是处于等待状态的线程（稍微纠结了一下，阻塞状态的线程不会处于该容器中，因为它是跟监视器有关的），也就是说当前线程调用Object#wait方法后，该线程会被添加到Object的等待容器中，并释放对象锁（不管此时有多少嵌套层级的锁都会得到释放，相当于将锁的计数减到0），处于等待容器中的线程不会执行任何其他指令。而当执行notify、notifyAll、interrupt或wait超时后，该线程可能会从等待容器中删除，在获取到对象锁后，该线程会使对象重新上锁（之前是多少嵌套，现在就会有多少嵌套，相当于做了恢复），在获到CPU时间片后从而继续执行。顺便提一下，对象内部持有对锁的计数（猜测），只有当该数量变成0后其他线程才能获取该对象锁。（<code>理解这点概念很重要</code>！！！否则概念多了容易乱）</p></blockquote><blockquote><p>notify<code>无法保证</code>在等待容量中选择哪个线程作为删除，notifyAll会将所有线程从等待容量中删除。</p></blockquote><blockquote><p>interrupt会在对象重新上锁（什么时候重新上锁上面提到过）后引发InterruptedException异常，在try-catch块中获取到的中断状态（isInterrupted）为false，更具体的信息可看方法说明。</p></blockquote><blockquote><p>如果线程在等待时既被通知（notify）又被中断（interrupt），则可能是先通知后中断，也有可能是先中断后通知。</p></blockquote><p>到这里应该对线程的状态有所了解了，读者可以发现实际上线程并没有<code>运行中</code>的状态，而在操作系统层面，它却有执行中的状态，这是为何？一个方面，CPU为每个线程分配时间片进行调度，时间片一般是几十毫秒，当其中一个线程执行一个时间片后会切换到下一个线程，在切换前会保存当前线程的状态，以便下次切换回来时可以加载该线程的状态，这样子的一个过程称为上下文切换，很显然线程之间的切换是非常快的，那么此时去区分运行中与就绪状态是没有多大意思的，有可能上一秒你看到的是运行中状态，可实际上还没等你反应过来后就变成了就绪状态，也许你只能看到这两个状态在互相闪烁着；另外一个方面，Thread注释中说：处于可运行状态下的线程正在JVM中执行，但它可能正在等待来自于操作系统的其他资源，比如处理器，JVM把那些资源都视作资源，比如CPU、各种硬件，有东西在为线程服务，它就认为线程在执行。对于操作系统来说它的侧重点是CPU，它必须要明确每个线程的具体状态，否则对于可运行状态来说，它怎么知道线程是否是可以调度的（部分观点摘自其他人的文章）。最后在提一点，JVM设置线程的状态是为了防止已经启动的线程被重新启动。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册本地方法，比如start0、stop0，至于做了什么只能说太过于底层了，不懂C、C++的可以忽略了</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程的名称</span></span><br><span class="line"><span class="comment">     * 为什么线程的名称要加上volatile关键词呢?</span></span><br><span class="line"><span class="comment">     * 首先volatile保证了内存的可见性，即其中一个线程修改了某个共享变量，其他的线程能够马上看到该变量修改后的值，更多的知识点将会另起文章阐述</span></span><br><span class="line"><span class="comment">     * 有可能多个线程共享该名称变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程的优先级</span></span><br><span class="line"><span class="comment">     * 注意：对于不同的平台可能优先级不同，有的是3个优先级、有的是10个优先级，所以在设置优先级时最好写Thread.MAX_PRIORITY</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> priority;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该线程是否是守护（后台）线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> daemon = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程要执行的任务，即最后会调用该任务的run方法 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Runnable target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程所属的线程组，一般情况下线程并未指定线程组的话默认是采用主线程的线程组，而主线程是从哪里的呢，这就要看JVM启动了...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ThreadGroup group;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类加载器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ClassLoader contextClassLoader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问控制，对访问控制进行操作或决定</span></span><br><span class="line"><span class="comment">     * 1. 决定是否允许还是拒绝对关键系统资源的访问 </span></span><br><span class="line"><span class="comment">     * 2. 特权代码，影响访问控制决定</span></span><br><span class="line"><span class="comment">     * 3. 可获取当前上下文，针对已保存的上下文做出来自不同上下文的访问控制决定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AccessControlContext inheritedAccessControlContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当线程没有指定线程名时，内部会帮助我们生成一个新名字-Thread-number，而其中的number会随着线程的增加而递增，如Thread-1、Thread-2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadInitNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每个线程都有自己的一个本地栈-ThreadLocal，ThreadLocal通过ThreadLocalMap来维护变量</span></span><br><span class="line"><span class="comment">     * ThreadLocalMap底层维护了一个数组，数组中维护了键值对的关系，其中键是当前ThreadLocal对象，也就是说，一个ThreadLocal只能绑定一个值，若是想绑定多个值的话就要定义多个ThreadLocal对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将当前线程的ThreadLocal设置到创建后的线程中，不知道使用的场景是哪里？</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置栈大小，在更底层的代码中用到，该属性依赖于不同的平台会有不同的行为</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> stackSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可中断对象，主要用来I/O阻塞的线程调用interrupt后，需要去唤醒selector</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Interruptible blocker;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 未处理异常的默认处理器，即异常没有被捕获，通常情况下为null，即直接在控制台打印异常堆栈信息</span></span><br><span class="line"><span class="comment">     * 若设置了默认处理器，则所有的线程都会应用该默认处理器，而如果又同时设置了自定义处理器，则指定线程只会应用自定义处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> UncaughtExceptionHandler defaultUncaughtExceptionHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常未处理的自定义处理器，当未指定该自定义处理器后会走默认的处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> UncaughtExceptionHandler uncaughtExceptionHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录线程ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为了生成线程ID，呈现递增趋势，一开始该值并不是0，因为JVM内部也会创建系统线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> threadSeqNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程的状态</span></span><br><span class="line"><span class="comment">     * 0-NEW  1-RUNNABLE 4-RUNNABLE 2-TERMINATED 16-WAITING  32-TIMED-WAITING 1024-BLOCKED</span></span><br><span class="line"><span class="comment">     * 其中1和4应该就是所谓的就绪与运行中，只不过哪个对应哪个就不可而知，操作系统的线程状态映射到JVM的线程状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> threadStatus = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最低优先级</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正常优先级</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大优先级</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化线程</span></span><br><span class="line"><span class="comment"> * 自动生成线程的名称，格式：Thread-i，i是个整数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化线程</span></span><br><span class="line"><span class="comment"> * 自动生成线程的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 指定任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化线程</span></span><br><span class="line"><span class="comment"> * 自动生成线程的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 指定任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> acc 访问控制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Thread(Runnable target, AccessControlContext acc) &#123;</span><br><span class="line">    init(<span class="keyword">null</span>, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>, acc, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化线程</span></span><br><span class="line"><span class="comment"> * 自动生成线程的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> group 线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 指定任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(ThreadGroup group, Runnable target)</span> </span>&#123;</span><br><span class="line">    init(group, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化线程，指定线程的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 线程的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, <span class="keyword">null</span>, name, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化线程，指定线程的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> group 线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 线程的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(ThreadGroup group, String name)</span> </span>&#123;</span><br><span class="line">    init(group, <span class="keyword">null</span>, name, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化线程，指定线程的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 指定任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 线程的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target, String name)</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, target, name, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化线程，指定线程的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> group 线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 指定任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 线程的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(ThreadGroup group, Runnable target, String name)</span> </span>&#123;</span><br><span class="line">    init(group, target, name, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化线程，指定线程的名称</span></span><br><span class="line"><span class="comment"> * stackSize依赖于不同的平台会有不同的值，所以使用该构造函数时要小心点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> group 线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 指定任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 线程的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stackSize 栈大小 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(ThreadGroup group, Runnable target, String name, <span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">    init(group, target, name, stackSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该方法主要使用在nio的selector中，这里是存储可中断的匿名类</span></span><br><span class="line"><span class="comment"> * 当在I/O阻塞中的线程调用interrupt时，需要去唤醒selector</span></span><br><span class="line"><span class="comment"> * 可全局搜索该方法的调用即可知道它的使用目的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> b 可中断对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blockedOn</span><span class="params">(Interruptible b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        blocker = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">nextThreadNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> threadInitNumber++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程ID</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextThreadID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++threadSeqNumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前线程的引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Thread <span class="title">currentThread</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每个线程都有一个CPU时间片，该方法指在自愿放弃CPU时间片，让其他线程能够更快的执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使线程进入指定时间的休眠，该方法不会释放锁，可以在非同步控制方法或同步块内使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> millis 休眠指定时间，毫秒为单位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使线程进入指定时间的休眠，该方法不会释放锁，可以在非同步控制方法或同步块内使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> millis 指定毫秒时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nanos 指定纳秒时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123; <span class="comment">//纳秒与毫秒的单位换算是6个0</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; millis == <span class="number">0</span>)) &#123;</span><br><span class="line">        millis++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(millis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> g 线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 指定任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 指定线程名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stackSize 线程的栈大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name, <span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">    init(g, target, name, stackSize, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> g 线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 指定任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 指定线程名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stackSize 线程的栈大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> acc 访问控制，如是否允许访问系统资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inheritThreadLocals 是否将当前线程的inheritableThreadLocals设置到创建后的线程中，类似于继承</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name, <span class="keyword">long</span> stackSize, AccessControlContext acc, <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    Thread parent = currentThread(); <span class="comment">//获取当前线程</span></span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = security.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = parent.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g.checkAccess(); <span class="comment">//确定当前正在运行的线程是否有权修改此线程组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g.addUnstarted(); <span class="comment">//记录未启动的线程个数，即未调用start方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.group = g;</span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon(); <span class="comment">//若创建线程的当前线程是后台（守护）线程，则创建后的线程也是个后台线程</span></span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority(); <span class="comment">//创建后的线程会被为当前线程的优先级</span></span><br><span class="line">    <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">    <span class="keyword">this</span>.inheritedAccessControlContext = acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">    tid = nextThreadID(); <span class="comment">//设置线程ID</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动线程，底层由JVM调用指定任务的run方法</span></span><br><span class="line"><span class="comment"> * 该方法只能调用一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>) <span class="comment">//threadStatus表示当前线程处于NEW状态</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">    group.add(<span class="keyword">this</span>); <span class="comment">//将当前线程添加到线程组，至少线程组到底做了什么可能需要另外起文章来探索</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0(); <span class="comment">//启动线程</span></span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123; <span class="comment">//若启动失败的话，需要去线程组中将其移除掉</span></span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动线程，底层将C++的线程与Java的线程进行了绑定，至于C++中的线程又做了什么就不得而知了，能猜到应该是跟操作系统打交道了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行任务</span></span><br><span class="line"><span class="comment"> * 若线程未调用start，直接调用run方法的话，那么就相当于执行一个方法，并未存在什么新线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 由JVM调用此方法，使线程在退出之前进行资源清理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (group != <span class="keyword">null</span>) &#123;</span><br><span class="line">        group.threadTerminated(<span class="keyword">this</span>);</span><br><span class="line">        group = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    threadLocals = <span class="keyword">null</span>;</span><br><span class="line">    inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">    inheritedAccessControlContext = <span class="keyword">null</span>;</span><br><span class="line">    blocker = <span class="keyword">null</span>;</span><br><span class="line">    uncaughtExceptionHandler = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 终止线程，即使已经启动的线程也会马上被终止</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1. 该方法已经被废弃了，为什么会被废弃呢？官方定义如下：</span></span><br><span class="line"><span class="comment"> * stop本质上是不安全的. 终止一个线程会造成该线程持有的锁得到释放（当ThreadDeath异常向上传播到堆栈时，锁将被释放）</span></span><br><span class="line"><span class="comment"> * 如果之前由这些锁保护的任何对象处于不一致状态，其他线程可能立即查看这些状态不一致的对象. 这样子的对象被认为已受损.</span></span><br><span class="line"><span class="comment"> * 当线程操作受损对象时会导致不可预测的行为，该行为可能很难被检测到. 不像非受查异常（Exception），ThreadDeath默默地杀死了线程（简单来说，我们无法从ThreadDeath异常上得到任何的消息）</span></span><br><span class="line"><span class="comment"> * 因此，用户没有警告其程序可能已损坏，该损坏是不可预测的.</span></span><br><span class="line"><span class="comment"> * 举个例子：</span></span><br><span class="line"><span class="comment"> * synchronized void f() &#123; </span></span><br><span class="line"><span class="comment"> *       x = 1; </span></span><br><span class="line"><span class="comment"> *       x = 2;</span></span><br><span class="line"><span class="comment"> *       x = 3;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * 不调用stop方法的情况下是可以正常运行的，但是在调用了stop方法后，程序立马被停止了，此时我们并不知道程序执行到了哪里，是 x = 1还是 x = 2 还是 x = 3</span></span><br><span class="line"><span class="comment"> * 所以即使其他线程获取到锁之后也无法确定x的值，第一次执行是1，第二次执行有可能是2，这就导致了结果的不可预测，这就相当于执行中的程序在任意时刻突然被破坏了</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2. 我不能捕捉ThreadDeath异常并修复受损的对象吗?</span></span><br><span class="line"><span class="comment"> *    线程可以在几乎任何地方抛出ThreadDeath异常，那我们怎么知道造成了对象的受损了，那就得慢慢分析每个抛出该异常的方法了.</span></span><br><span class="line"><span class="comment"> *    从第一个线程清除时（在catch或finally子句中），线程可以引发第二个ThreadDeath异常（最后要抛出ThreadDeath来确保线程被终止）. 必须重复进行清理，直到成功.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. 使用什么方式来代替stop?</span></span><br><span class="line"><span class="comment"> *    通过简单地修改变量的值来表明线程应该被终止，线程应定期检查该变量，如果该变量表明要终止运行，则应有序地从其run方法返回.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    方式一：</span></span><br><span class="line"><span class="comment"> *    private volatile Thread blinker;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *    public void stop() &#123;</span></span><br><span class="line"><span class="comment"> *       blinker = null;</span></span><br><span class="line"><span class="comment"> *    &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    public void run() &#123;</span></span><br><span class="line"><span class="comment"> *      Thread thisThread = Thread.currentThread();</span></span><br><span class="line"><span class="comment"> *      while(blinker == thisThread)&#123;</span></span><br><span class="line"><span class="comment"> *         try &#123;</span></span><br><span class="line"><span class="comment"> *              Thread.sleep(interval);</span></span><br><span class="line"><span class="comment"> *          &#125; catch(InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment"> *              </span></span><br><span class="line"><span class="comment"> *          &#125;</span></span><br><span class="line"><span class="comment"> *          repaint(); //业务逻辑</span></span><br><span class="line"><span class="comment"> *       &#125;</span></span><br><span class="line"><span class="comment"> *    &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    方式二：</span></span><br><span class="line"><span class="comment"> *    private final AtomicBoolean running = new AtomicBoolean(false);</span></span><br><span class="line"><span class="comment"> *    private int interval;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    public ControlSubThread(int sleepInterval) &#123;</span></span><br><span class="line"><span class="comment"> *       interval = sleepInterval;</span></span><br><span class="line"><span class="comment"> *    &#125;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *    public void stop() &#123;</span></span><br><span class="line"><span class="comment"> *       running.set(false);</span></span><br><span class="line"><span class="comment"> *    &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    public void run() &#123; </span></span><br><span class="line"><span class="comment"> *      running.set(true);</span></span><br><span class="line"><span class="comment"> *      while (running.get()) &#123;</span></span><br><span class="line"><span class="comment"> *         try &#123; </span></span><br><span class="line"><span class="comment"> *             Thread.sleep(interval); </span></span><br><span class="line"><span class="comment"> *         &#125; catch (InterruptedException e)&#123; </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *         &#125;</span></span><br><span class="line"><span class="comment"> *      &#125;</span></span><br><span class="line"><span class="comment"> *    &#125;</span></span><br><span class="line"><span class="comment"> *    </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread()) &#123;</span><br><span class="line">            security.checkPermission(SecurityConstants.STOP_THREAD_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>) &#123;</span><br><span class="line">        resume(); <span class="comment">//唤醒挂起的线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用程序中不能去catch ThreadDeath的实例，若真要catch，则处理完逻辑之后必须在重新抛出ThreadDeath异常对象，以便确定线程被终止</span></span><br><span class="line"><span class="comment">     * 线程中可以自定义异常处理器，只不过该异常处理器在针对ThreadDeath时不会打印任何消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    stop0(<span class="keyword">new</span> ThreadDeath()); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中断线程</span></span><br><span class="line"><span class="comment"> * 1. 若是调用wait、join、sleep方法时导致线程处于等待状态，可调用此方法来中断线程，即从这些方法处返回并抛出InterruptedException异常，同时清除中断状态</span></span><br><span class="line"><span class="comment"> * 2. 若是调用I/O操作导致线程处于阻塞状态，可调用此方法来将通道关闭，同时会抛出一个异常，及设置中断状态</span></span><br><span class="line"><span class="comment"> * 3. 若是调用selector.select导致线程处于阻塞状态，可调用此方法来使select立即返回，并设置中断状态</span></span><br><span class="line"><span class="comment"> * 4. 如果上述条件均不成立，则将设置该线程的中断状态.</span></span><br><span class="line"><span class="comment"> * 中断未启动的线程不会产生任何影响.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker; <span class="comment">//上面咱们提到了关于blocker的作用，主要用于nio中的selector</span></span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interrupt0();</span><br><span class="line">            b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();<span class="comment">// 1、2、4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中断线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">interrupt0</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前线程是否被中断，该方法会清除中断状态</span></span><br><span class="line"><span class="comment"> * 如果方法调用多次，则多次调用后会返回false，除了在多次调用后又发生中断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否被中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程是否被中断，该方法不会清除中断状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程是否被中断，是否清除中断状态取决于ClearInterrupted参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ClearInterrupted 是否清除中断状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该方法原先被设计为破坏线程，并未清理资源，也就是说线程持有的锁会继续持有，并未释放锁，幸好还未实现就已经被废弃了</span></span><br><span class="line"><span class="comment"> * 官方说若是实现了它，将与Thread#suspend方法一样容易导致死锁，锁未得到释放，其他线程无法访问</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程是否处于活动状态中，活动状态表示：线程已启动（已调用start）且尚未终结</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 挂起/暂停线程</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1. 该方法已废弃，为什么呢? 官方定义如下：</span></span><br><span class="line"><span class="comment"> * suspend本质上是容易死锁的. 当某个线程被挂起时，其任务还持有对关键系统资源的锁，其他线程都访问不了该资源.</span></span><br><span class="line"><span class="comment"> * 若有其他线程在调用resume之前尝试获取该锁，则会导致死锁（线程并未释放锁）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2. 使用什么方式来代替suspend?</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    private volatile boolean threadSuspended;</span></span><br><span class="line"><span class="comment"> *   </span></span><br><span class="line"><span class="comment"> *    public synchronized void mousePressed() &#123;</span></span><br><span class="line"><span class="comment"> *        //业务逻辑</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *        threadSuspended = !threadSuspended;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *         if (!threadSuspended) &#123;</span></span><br><span class="line"><span class="comment"> *            notify();</span></span><br><span class="line"><span class="comment"> *         &#125;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     public void run() &#123;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          wihle(true) &#123;  //这里并未退出该任务</span></span><br><span class="line"><span class="comment"> *              try &#123;</span></span><br><span class="line"><span class="comment"> *                  Thread.sleep(interval);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                  if(threadSuspended) &#123; //这样子的方式可以在线程没有被挂起的情况不用花费synchronized关键词引起的代价</span></span><br><span class="line"><span class="comment"> *                      synchronized(this) &#123;</span></span><br><span class="line"><span class="comment"> *                          while(threadSuspended) &#123;</span></span><br><span class="line"><span class="comment"> *                              wait();</span></span><br><span class="line"><span class="comment"> *                          &#125;</span></span><br><span class="line"><span class="comment"> *                      &#125;</span></span><br><span class="line"><span class="comment"> *                  &#125;</span></span><br><span class="line"><span class="comment"> *              &#125; catch(InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment"> *    </span></span><br><span class="line"><span class="comment"> *              &#125;</span></span><br><span class="line"><span class="comment"> *          &#125;</span></span><br><span class="line"><span class="comment"> *          //业务逻辑</span></span><br><span class="line"><span class="comment"> *    &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. stop与suspend结合</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    public void run() &#123;</span></span><br><span class="line"><span class="comment"> *      Thread thisThread = Thread.currentThread();</span></span><br><span class="line"><span class="comment"> *      while (blinker == thisThread) &#123; //调用stop后会正常退出</span></span><br><span class="line"><span class="comment"> *          try &#123;</span></span><br><span class="line"><span class="comment"> *              Thread.sleep(interval);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              synchronized(this) &#123;</span></span><br><span class="line"><span class="comment"> *                 while (threadSuspended &amp;&amp; blinker==thisThread)</span></span><br><span class="line"><span class="comment"> *                     wait();</span></span><br><span class="line"><span class="comment"> *             &#125;</span></span><br><span class="line"><span class="comment"> *          &#125; catch (InterruptedException e)&#123;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *         &#125;</span></span><br><span class="line"><span class="comment"> *          //业务逻辑</span></span><br><span class="line"><span class="comment"> *      &#125;</span></span><br><span class="line"><span class="comment"> *    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public synchronized void stop() &#123;</span></span><br><span class="line"><span class="comment">    blinker = null;</span></span><br><span class="line"><span class="comment">    notify();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">suspend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    suspend0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 挂起线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">suspend0</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 恢复线程</span></span><br><span class="line"><span class="comment"> * 该方法仅与suspend一起使用，但由于suspend容易造成死锁而被废弃了，故而resume也用不到了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    resume0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置线程的优先级</span></span><br><span class="line"><span class="comment"> * 1 &lt; newPriority &lt; g.maxPriority &lt;= 10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newPriority 指定优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">    ThreadGroup g;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((g = getThreadGroup()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">            newPriority = g.getMaxPriority();</span><br><span class="line">        &#125;</span><br><span class="line">        setPriority0(priority = newPriority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取优先级</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPriority</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> priority;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置线程的名称</span></span><br><span class="line"><span class="comment"> * 即使线程已经启动了依然还是可以设置线程的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 指定线程的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>) &#123; <span class="comment">// threadStatus != 0 表示线程已启动</span></span><br><span class="line">        setNativeName(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ThreadGroup <span class="title">getThreadGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> group;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前线程组的活跃线程个数</span></span><br><span class="line"><span class="comment"> * 注意：线程组中还有子线程组，所以计算时也会包含子线程组</span></span><br><span class="line"><span class="comment"> * 该结果只是一个估算值，因为线程数一直在动态变化着，同时JVM也会有一些线程，所以可能会影响该计数结果</span></span><br><span class="line"><span class="comment"> * 该方法主要用来调试与监控</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程组的活跃线程个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">activeCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().getThreadGroup().activeCount();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前线程组的活跃线程拷贝到指定数组中</span></span><br><span class="line"><span class="comment"> * 要严格确保指定数组的大小大于活跃线程的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tarray 指定数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程组的活跃线程个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">enumerate</span><span class="params">(Thread tarray[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().getThreadGroup().enumerate(tarray);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算线程的栈帧，何为栈帧? 这就涉及到JVM的知识了，笔者还在慢慢往上走呢.</span></span><br><span class="line"><span class="comment"> * 调用该方法时，线程应该被挂起，而suspend已被废弃了，故而该方法也没啥用了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">countStackFrames</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前线程最多等待指定时间</span></span><br><span class="line"><span class="comment"> * t1.join(time);</span></span><br><span class="line"><span class="comment"> * 这里指的当前线程并不是t1，而是执行这些所属的线程，也就是main线程，按照最上面的概念来说，应该是当前线程添加到了t1对象的等待容器中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> millis 指定毫秒时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay); <span class="comment">//等待状态下的线程若是调用interruput去中断的话则会直接抛出InterruptedException异常后恢复运行，若是使用notify的话，那么最终都会等待指定的millis时间才会恢复运行</span></span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前线程最多等待指定时间</span></span><br><span class="line"><span class="comment"> * 若指定时间设置为0，则会一直等下去</span></span><br><span class="line"><span class="comment"> * 做了一些参数校验</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> millis 指定毫秒时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nanos 指定纳秒数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; millis == <span class="number">0</span>)) &#123;</span><br><span class="line">        millis++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    join(millis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前线程处于等待状态中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印线程的堆栈到标准输出</span></span><br><span class="line"><span class="comment"> * 该方法仅用于调试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dumpStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Exception(<span class="string">"Stack trace"</span>).printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据传入的值来决定将线程变成后台线程还是用户线程</span></span><br><span class="line"><span class="comment"> * 当所有正在运行的线程都是后台线程时，JVM退出</span></span><br><span class="line"><span class="comment"> * 该方法必须在start之前调用</span></span><br><span class="line"><span class="comment"> * false-用户线程   true-后台线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> on 标志</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setDaemon</span><span class="params">(<span class="keyword">boolean</span> on)</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (isAlive()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">    &#125;</span><br><span class="line">    daemon = on;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程是否是后台（守护）线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否是后台线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isDaemon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> daemon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前线程是否有权限修改当前对象所属的线程，若没有权限则抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkAccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        security.checkAccess(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印线程的名称，优先级，线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadGroup group = getThreadGroup();</span><br><span class="line">    <span class="keyword">if</span> (group != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Thread["</span> + getName() + <span class="string">","</span> + getPriority() + <span class="string">","</span> + group.getName() + <span class="string">"]"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Thread["</span> + getName() + <span class="string">","</span> + getPriority() + <span class="string">","</span> + <span class="string">""</span> + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前线程是否持有指定对象锁</span></span><br><span class="line"><span class="comment"> * true-表示当前线程持有指定对象锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否持有指定对象锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">holdsLock</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程的ID</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程的ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前线程的状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 当前线程的状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sun.misc.VM.toThreadState(threadStatus);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置未处理异常的默认处理器</span></span><br><span class="line"><span class="comment"> * 若设置了默认处理器，则所有的线程都将应用到，相当于全局处理器，而如果同时设置了自定义处理器，那么指定线程只会应用自定义处理器（可看dispatchUncaughtException方法）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> eh 默认处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDefaultUncaughtExceptionHandler</span><span class="params">(UncaughtExceptionHandler eh)</span> </span>&#123;</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sm.checkPermission(</span><br><span class="line">            <span class="keyword">new</span> RuntimePermission(<span class="string">"setDefaultUncaughtExceptionHandler"</span>)</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">     defaultUncaughtExceptionHandler = eh;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取未处理异常的默认处理器</span></span><br><span class="line"><span class="comment"> * 返回null表示没有设置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 默认处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UncaughtExceptionHandler <span class="title">getDefaultUncaughtExceptionHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> defaultUncaughtExceptionHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取未处理异常的自定义处理器</span></span><br><span class="line"><span class="comment"> * 若未设置自定义处理器，则走线程组的异常处理，线程组中会获取默认处理器，若也未设置，则打印堆栈信息到控制台，若设置了则走默认处理器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 自定义处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UncaughtExceptionHandler <span class="title">getUncaughtExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uncaughtExceptionHandler != <span class="keyword">null</span> ? uncaughtExceptionHandler : group;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置自定义处理器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> eh 自定义处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUncaughtExceptionHandler</span><span class="params">(UncaughtExceptionHandler eh)</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    uncaughtExceptionHandler = eh;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下发异常到指定处理器上，该方法只会被JVM调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchUncaughtException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">    getUncaughtExceptionHandler().uncaughtException(<span class="keyword">this</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>创建线程有<code>两个方式</code>，一种是继承Thread，第二种是实现Runnable，第二种方式更为常见，且能够在只有一个任务实例的情况下创建多个线程。</p></li><li><p>线程的<code>6</code>个状态-新建、可运行、阻塞、等待、超时等待、终止。</p></li><li><p>wait的实现机制是通过对象的等待容器，更具体的描述可参考概念。</p></li><li><p>我们都知道每个线程都有一个本地栈，实际上是通过Thread对象中的threadLocals变量维护起来的，也就是说即使将ThreadLocal变量传入到不同的线程中也不会造成多线程之间共享同一个ThreadLocal，因为每个线程都有一个ThreadLocal对象，即上面提到的threadLocals变量，在为ThreadLocal设值时，每个线程都会检查当前线程下的threadLocals变量是否初始化了，若没有则初始化该变量。有一点需要注意下，ThreadLocal中通过维护一个Map来保存键值对的关系，而其中的键值就是当前的ThreadLocal对象，也就是说，将ThreadLocal传入到不同的线程中会造成它们的threadLocals变量所引用的键值是同一个，不过这丝毫不影响。</p></li><li><p>sleep、yield<code>不会</code>释放对象锁，可以在非同步控制方法或同步块中使用；wait、join、notify、notifyAll释放对象锁，必须在同步控制方法或同步块中使用，因为它们对锁进行了操作，故而需要先获取到锁才能操作。</p></li><li><p>stop：因为会造成数据的不完整，最终会导致不可预测的行为而废弃；suspend：因为始终都没有释放锁，容易造成死锁而废弃；destroy：官方说还未实现就已经废弃了，同样会造成死锁；resume：该方法仅与suspend一起使用，由于suspend已经被废弃了，那它也只好跟着牺牲了。</p></li><li><p>未处理异常的默认处理器与自定义处理器的使用。</p></li></ul><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a><div><span>重点</span></div></h3><p><code>线程的状态转变</code> <code>wait/join/notify/notify/sleep/yield</code></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><div><span>参考资料</span></div></h3><p>《Java编程思想》</p><p>《Java并发编程的艺术》</p><p><a href="https://www.javazhiyin.com/52519.html" target="_blank" rel="noopener">https://www.javazhiyin.com/52519.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;接下来的这一段时间都将探索跟线程有关的内容，包括各种锁，对Thread的总结如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;线程具有&lt;code&gt;优先级&lt;/code&gt;，高优先级的线程优先于低优先级的线程执行，当在某个线程中创建新线程时，新线程的优先级被设置成当前线程的优先级；JVM启动时，默认有一个非守护线程（调用某个类的main方法）；线程能被标记为&lt;code&gt;守护线程&lt;/code&gt;，每个线程都可以&lt;code&gt;指定名称&lt;/code&gt;，未指定的情况下将由底层帮其生成一个新名称；有两种方式来创建线程，如下所示：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 在只有一个实例的情况下只能创建一个线程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestA&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Thread&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;TestA&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 在只有一个实例的情况下可创建多个线程，这种方式更为常见&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestB&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Runnable&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;TestB&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>为入门操作系统而读-《计算机的心智-操作系统之哲学原理》</title>
    <link href="http://zlia.tech/2019/12/03/read-computer-mind/"/>
    <id>http://zlia.tech/2019/12/03/read-computer-mind/</id>
    <published>2019-12-03T10:27:16.000Z</published>
    <updated>2019-12-03T10:27:16.129Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>为什么会想着入门操作系统呢？还是跟Java有关系，在深入学习的过程中发现很多点都会涉及到操作系统底层的知识，特别是并发这块内容，而笔者我现在只是刚刚起步学习就已经要了解与操作系统相关的内容，所以还是早点入坑吧。为什么是先看这本书呢？当然了，我不会无缘无故随便看一本，是经过从前人的推荐到知识点的考察才最终定下来！《计算机的心智-操作系统之哲学原理》这本书出版于09年，也算是一本年代已久的书籍，不过相对于计算机的诞生时间来说，它的知识点应该不会显得过时，该书在商城上可能买不到了，笔者也是找的PDF，Google一下就有了。打算借着这本书的知识点来对操作系统的入门做一个总结，同时也希望能够帮助其他有缘人吧。</p><a id="more"></a><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a><div><span>概念</span></div></h3><ul><li><p><code>中断</code>：当你正在看电影时，突然心血来潮迫不及待想要听上一首周杰伦的新歌曲，看似很简单的操作，实际上CPU会打断正在执行的任务并保存当前任务的上下文信息，转而去帮你完成更重要的任务，等重要的任务完成后会根据之前保存的上下文信息进行任务的恢复，以便继续执行，不过若中断发生异常可能会直接导致任务终止。中断分为硬件中断与软件中断，两者都可以通过总线向CPU发送中断请求（CPU内部有个中断控制器负责接收），可能同时出现多个中断请求，但每次CPU只能响应其中一个，所以会根据预先设置好的优先级进行排队，等候CPU处理，所谓的处理就会转入相应的中断服务程序，也就是上面提到的更重要的任务。在多CPU中，有一个全局中断控制器负责将接收到的中断请求按照某个规则下发到指定CPU中。</p></li><li><p><code>内核态与用户态</code>：有的程序可以访问计算机的任何资源，而有的计算机只能访问非常受限的少量资源。操作系统作为计算机的管理者，它应该享有更多的方便或特权，否则怎么管理计算机？所以内核态就是拥有资源多的状态，或者说访问资源多的状态，我们也称之为特权态。相对来说，用户态就是非特权态，在此种状态下访问的资源将受到限制。计算机如何知道现在正在运行的程序是内核态还是用户态呢？CPU内部有一个状态位，通过设置该状态位来表示内核态与用户态，程序在运行时，CPU是什么态，这个程序就运行在什么态上。既然已经知道了某个程序是哪种状态了，那么如何通过状态来限制其访问的资源呢？要限制一个程序对资源的访问，需要对程序执行的每一条指令进行检查才能完成。而这种检查就是地址翻译，程序发出的每一条指令都要经过这个地址翻译过程，通过对翻译的控制，就可以限制程序对资源的访问，很明显这是针对用户态来说。对于内核态，程序可以绕过内存地址翻译而直接执行指令。</p></li><li><p><code>进程</code>：表示执行中的程序，一旦程序在计算机中运行起来，它就成为了一个进程。每个进程都有一个地址空间，该地址空间存储了可执行文件的代码与数据，进程可以创建子进程，子进程又可以创建进程，在Linux中这些进程称为进程组。系统对进程的管理通过进程表来实现，进程表里存放的是关于进程的一切信息。</p></li><li><p><code>线程</code>：程序执行流的最小单元。一个进程至少有一个线程，在多线程下可共享进程的资源，如全局变量、堆内存，但也有一些只有自身才能访问的资源，如栈内存、寄存器、线程本地存储（ThreadLocal）。</p></li><li><p><code>多线程的调度</code>：CPU通过给每个线程分配时间片来实现多线程的调度。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程，让我们感觉多个线程是同时执行，时间片一般是几十毫秒。CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务，可以再加载这个任务的状态，所以任务从保存到再加载的过程就是一次<code>上下文切换</code>。</p></li><li><p><code>内存架构</code>：由高速缓存、主存、磁盘等组成的一个内存架构。高速缓存的特点是低容量、高速度、高价格；主存的特点是中容量、中速度、中价格；磁盘则是大容量、地速度、低成本的存储媒介。</p></li><li><p><code>内存管理</code>：对内存架构进行管理，使程序在内存架构的任何一个层次上的存放对于用户来说都是一样的。用户无需担心自己的程序是存在高速缓存、主存、磁盘，反正运行、计算、输出的结果都是一样的。让内存管理实现这种媒介透明的手段就是<code>虚拟内存</code>。</p></li><li><p><code>虚拟内存</code>：程序在运行时会加载到主存中，但是主存的容量非常有限，这将限制我们只能编写很小的程序。加大主存？这显然不合理，无疑增加了更多的成本，所以这就诞生了虚拟内存：不增加成本的情况下扩大内存容量。虚拟内存的中心思想是将主存扩大到便宜、大容量的磁盘上，即将磁盘空间看作是主存空间的一部分。程序存放在磁盘上就相当于存放在主存内。程序既可以完全存放在主存，也可以完全存放在磁盘上，当然也可以部分存放在主存、部分存放在磁盘。而程序执行时，程序发出的地址到底是在主存还是在磁盘则由操作系统的内存管理模块负责判断，并到相应的地方进行读写操作。</p></li></ul><p>操作系统的概念是真的多，还有很多重要的概念并未提及，比如缓存一致性、多核、原子操作。</p><h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a><div><span>评价</span></div></h3><p>该书以一种通俗易懂的方式引出知识点，结合生活中的例子对知识点的原理进行一步步地深入分析，点到为止！很适合入门级的操作系统书籍。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;为什么会想着入门操作系统呢？还是跟Java有关系，在深入学习的过程中发现很多点都会涉及到操作系统底层的知识，特别是并发这块内容，而笔者我现在只是刚刚起步学习就已经要了解与操作系统相关的内容，所以还是早点入坑吧。为什么是先看这本书呢？当然了，我不会无缘无故随便看一本，是经过从前人的推荐到知识点的考察才最终定下来！《计算机的心智-操作系统之哲学原理》这本书出版于09年，也算是一本年代已久的书籍，不过相对于计算机的诞生时间来说，它的知识点应该不会显得过时，该书在商城上可能买不到了，笔者也是找的PDF，Google一下就有了。打算借着这本书的知识点来对操作系统的入门做一个总结，同时也希望能够帮助其他有缘人吧。&lt;/p&gt;
    
    </summary>
    
      <category term="essays" scheme="http://zlia.tech/categories/essays/"/>
    
    
      <category term="operating-system" scheme="http://zlia.tech/tags/operating-system/"/>
    
  </entry>
  
  <entry>
    <title>每日知识点20191107</title>
    <link href="http://zlia.tech/2019/11/26/core-java-knowledge-20191107/"/>
    <id>http://zlia.tech/2019/11/26/core-java-knowledge-20191107/</id>
    <published>2019-11-26T08:34:07.000Z</published>
    <updated>2019-11-26T08:34:07.855Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java"><a href="#java" class="headerlink" title="java"></a><div><span>java</span></div></h3><ul><li><p>Exception#fillInStackTrace：将当前调用栈信息填入到原来异常对象，相当于更新最新的抛出点（catch异常后又抛出的点）</p></li><li><p>try-finally某些情况下会吃掉抛出的异常</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>覆盖方法时，只能抛出在基类方法的异常说明里列出的那些异常或其子类或选择不抛出，但是此限制对构造器不起作用，派生类构造器可以抛出任何异常，只需要在异常说明中包含基类构造器的异常说明</p></li><li><p>Collections.nCopies能添加新元素，Collections.fill只能替换元素，无法添加新元素</p></li><li><p>通配符代表着持有具有某种具体类型的同构集合</p></li></ul><a id="more"></a><ul><li>下面的代码摘抄自编程思想P550</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestS</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标准输入、输出和错误IO流进行重定向</span></span><br><span class="line"><span class="comment">     * 一开始只有in.out中有数据，而test.out中是空内容，执行完程序后，test.out中的数据和in.out是一致的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        PrintStream console = System.out;</span><br><span class="line">        BufferedInputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"in.out"</span>));</span><br><span class="line">        PrintStream out = <span class="keyword">new</span> PrintStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"test.out"</span>)));</span><br><span class="line">        System.setIn(in);<span class="comment">//默认是从控制台读取数据，但是这里进行了重定向，于是从in.out中读取数据</span></span><br><span class="line">        System.setOut(out);<span class="comment">//默认是将数据写入到控制台，但是这里进行了重定向，于是写入到test.out中</span></span><br><span class="line">        System.setErr(out);<span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认情况下是从控制台读取数据，然而这里是读取in.out文件中的数据</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s ;</span><br><span class="line">        <span class="keyword">while</span>((s = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        out.close();</span><br><span class="line">        System.setOut(console);<span class="comment">//切换到默认情况下</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>容错：发生故障时，如何让系统继续运行</p></li><li><p>高可用：系统中断时，如何尽快恢复</p></li><li><p>灾备：系统毁灭时，如何抢救数据</p></li><li><p>TestA.class.isAssignableFrom(TestB.class)：TestA与TestB是同一个类类型或TestA是TestB的父类或TestA是TestB的父接口</p></li><li><p>java中采用高位优先（大端模式）进行存储字节数据，也就是高位存储在低地址，低位存储在高地址上</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java&quot;&gt;&lt;a href=&quot;#java&quot; class=&quot;headerlink&quot; title=&quot;java&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;java&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Exception#fillInStackTrace：将当前调用栈信息填入到原来异常对象，相当于更新最新的抛出点（catch异常后又抛出的点）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;try-finally某些情况下会吃掉抛出的异常&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RuntimeException();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;覆盖方法时，只能抛出在基类方法的异常说明里列出的那些异常或其子类或选择不抛出，但是此限制对构造器不起作用，派生类构造器可以抛出任何异常，只需要在异常说明中包含基类构造器的异常说明&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Collections.nCopies能添加新元素，Collections.fill只能替换元素，无法添加新元素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通配符代表着持有具有某种具体类型的同构集合&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="daily-konwledge-point-java" scheme="http://zlia.tech/tags/daily-konwledge-point-java/"/>
    
  </entry>
  
  <entry>
    <title>探索ByteBuffer底层实现</title>
    <link href="http://zlia.tech/2019/11/26/explain-bytebuffer-sourcecode/"/>
    <id>http://zlia.tech/2019/11/26/explain-bytebuffer-sourcecode/</id>
    <published>2019-11-26T08:27:15.000Z</published>
    <updated>2019-11-26T08:27:15.081Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>由于最近在了解IO相关知识，而正好看到了nio，这是我以前从来没接触过的，虽然它很早就出现了，所以先来看看有关于它的一些基础。探索<code>ByteBuffer</code>源代码是基于<code>JDK1.8</code>版本的，ByteBuffer的父类是<code>Buffer</code>，通过阅读注释后对Buffer总结如下：</p><blockquote><p>缓冲区是特定基本类型的元素的线性有限序列，除了内容之外，缓冲区的基本属性还包括<code>capacity</code>、<code>limit</code>、<code>position</code>、<code>mark</code>。假设缓冲区是一本1000页的书籍，你已经看到800页了，其中在500页处有个很重要的知识点，你做了个标记以便下次能够轻松找到它。那么capacity指代的就是1000，意思就是这本书的最大页数，缓冲区的最大容量，该属性值不会为负不会改变；limit指代的是800，意思是目前只学了这么多知识，可以理解为界限；position指代的是具体某一页，也就是你每看一页，position就会有所增加；mark很容易理解，指代的是我们标记到具体某一页。在实际代码中有读、写模式，我们将读模式比喻成复习，也就是说你可以从第0页复习到第800页，此时的postion从0-800，limit保持800不变，也可以从你所标记的点到第800页，此时的position从mark-800，但是切记不能从第0页复习而后直接跳到mark处，这样子就导致知识点的不连续性，简单来说<code>0 &lt;= mark &lt;= posiiton &lt;= limit &lt;= capacity</code>；将写模式比喻成继续学习新知识点，也就是从第801页继续往后看，position会逐步增加。对于只读缓冲区来说，不允许修改它的内容，但是limit、position、mark是可以变化的。最后一点是缓冲区属于非线程安全！</p></blockquote><p>提供一张图片方便理解。接下来在总结下ByteBuffer，以便对其有个大概性的了解。</p><p class="customize-img"><img src="/assets/blogImg/java/bytebuffer/bytebuffer-variable.png" alt="Buffer相关变量"></p><blockquote><p><code>字节缓冲区</code>，可创建视图缓冲区，视图缓冲区指的是包含其他基本类型值的缓冲区，如CharBuffer，视图缓冲区的索引不是以字节为单位，而是根据其值的特定类型的大小决定的，如CharBuffer是2个字节。字节缓冲区可分为直接或间接，直接缓冲区的内容存放在堆外内存，JVM将尽最大努力直接执行原生IO操作，而间接缓冲区存放在堆内存中，交由JVM操作，与操作系统并未直接交互，直接缓冲区通常比间接缓冲区具有更高的分配和释放成本，简单来说，对于大型缓冲区来说直接分配直接缓冲区。</p></blockquote><p>概念性的内容就阐述到这里了，接着就直接进入源码世界吧！</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><p>由于ByteBuffer是个抽象类，故方法可能涉及到多个类，先贴一张继承结构类图。</p><p class="customize-img"><img src="/assets/blogImg/java/bytebuffer/bytebuffer-hierarchy.png" alt="Buffer继承结构"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 抽象类没办法直接创建该对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuffer</span> <span class="keyword">extends</span> <span class="title">Buffer</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ByteBuffer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储缓冲区的内容</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] hb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓冲区的第一个元素在hb数组中索引</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓冲区是否是只读缓冲区</span></span><br><span class="line">    <span class="keyword">boolean</span> isReadOnly;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓冲区的字节顺序</span></span><br><span class="line">    <span class="keyword">boolean</span> bigEndian = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该属性定义在Buffer中，标记缓冲区中的某个位置  mark &lt;= position</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mark = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该属性定义在Buffer中，代表缓冲区中下一个读取或写入的元素的索引 position &lt;= limit</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该属性定义在Buffer中，代表着界限，该值在写模式下等于capacity，读模式下等于position写模式下的索引 limit &lt;= capacity</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该属性定义在Buffer中，代表着缓冲区的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化，设置属性值</span></span><br><span class="line"><span class="comment"> * 在初始化之前需要校验这些成员属性是否合法性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mark 标记缓冲区中的某个索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pos 下一个读取或写入的元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lim 界限-读模式下等于position写模式下的索引，简单来说就是记住最后写入内容的索引，以便知道读取结束了；写模式下等于capacity，以便知道缓冲区已经写满了，不能再写了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cap 缓冲区的容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hb 字节数组-存储缓冲区的内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> offset 缓冲区中第一个元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ByteBuffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap, <span class="keyword">byte</span>[] hb, <span class="keyword">int</span> offset) &#123;</span><br><span class="line">    <span class="keyword">super</span>(mark, pos, lim, cap);</span><br><span class="line">    <span class="keyword">this</span>.hb = hb;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mark 标记缓冲区中的某个索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pos 下一个读取或写入的元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lim 界限-读模式下等于position写模式下的索引，简单来说就是记住最后写入内容的索引，以便知道读取结束了；写模式下等于capacity，以便知道缓冲区已经写满了，不能再写了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cap 缓冲区的容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ByteBuffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap) &#123;</span><br><span class="line">    <span class="keyword">this</span>(mark, pos, lim, cap, <span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该构造函数中涉及到的知识点比较多，笔者也是不懂，借助别人分析的文章进行讲解</span></span><br><span class="line"><span class="comment"> * 申请堆外内存与设置释放堆外内存机制</span></span><br><span class="line"><span class="comment"> * 堆外内存是不受JVM管理，这导致了堆外内存没办法被JVM回收，所以它通过在堆内存中创建对象，当该对象被回收时，会先调用Cleaner#clean，而在该方法中调用了Deallocator#run，这样子就将堆外内存释放了</span></span><br><span class="line"><span class="comment"> * 这里涉及到了虚引用的使用，可参考Reference类中的代码，或者看有关文章</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cap 要申请的容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">DirectByteBuffer(<span class="keyword">int</span> cap) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="keyword">boolean</span> pa = VM.isDirectMemoryPageAligned(); <span class="comment">// 判断是否需要页面对齐，默认是false，何为页面对齐，目前我是不知道有什么用</span></span><br><span class="line">    <span class="keyword">int</span> ps = Bits.pageSize();</span><br><span class="line">    <span class="keyword">long</span> size = Math.max(<span class="number">1L</span>, (<span class="keyword">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap); <span class="comment">// 主要用于判断申请的堆外内存是否超过了最大值，这里的代码就不做深入了，要求大概能懂就行了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size); <span class="comment">// 申请堆外内存</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (<span class="keyword">byte</span>) <span class="number">0</span>); <span class="comment">// 初始化堆外内存空间为0</span></span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap)); <span class="comment">// 使用Cleaner机制回收堆外内存</span></span><br><span class="line">    att = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 校验并设置属性</span></span><br><span class="line"><span class="comment"> * 由于mark &lt;= position &lt;= limit 所以只要校验mark、position即可</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> limit 界限值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 当前对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">limit</span><span class="params">(<span class="keyword">int</span> newLimit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((newLimit &gt; capacity) || (newLimit &lt; <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    limit = newLimit;</span><br><span class="line">    <span class="keyword">if</span> (position &gt; limit) position = limit;</span><br><span class="line">    <span class="keyword">if</span> (mark &gt; limit) mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 校验并设置属性</span></span><br><span class="line"><span class="comment"> * 由于mark &lt;= position 所以只要校验mark即可</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newPosition 下一个读取或写入的元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 当前对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">position</span><span class="params">(<span class="keyword">int</span> newPosition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((newPosition &gt; limit) || (newPosition &lt; <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    position = newPosition;</span><br><span class="line">    <span class="keyword">if</span> (mark &gt; position) mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过申请堆外内存来构造直接缓冲区</span></span><br><span class="line"><span class="comment"> * 当该对象被回收时会出发释放堆外内存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity 申请的容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造间接缓冲区</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity 缓冲区的容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(capacity, capacity); <span class="comment">// 虽然这是另外一个类，实际上挺简单的，所以这里就不做继续阐述了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个包含指定字节数组的缓冲区</span></span><br><span class="line"><span class="comment"> * 若在外部修改该字节数组，对应的缓冲区内容也会变化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arry 指定字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> offset 下一个要读取或写入的元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length 指定写入或读取的元素的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] array, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(array, offset, length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException x) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个包含指定字节数组的缓冲区</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 指定字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> wrap(array, <span class="number">0</span>, array.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个包含从position到limit之间的源缓冲区内容的新缓冲区（HeapByteBuffer）</span></span><br><span class="line"><span class="comment"> * 源缓冲区与新缓冲区共享同一个字节数组，两者的属性position、limit、capacity是相互独立的</span></span><br><span class="line"><span class="comment"> * 在源缓冲区构建完后它的offset就已经确定下来了，而对于position来说，它会随着读或写不断的变化，但它始终 &gt;= offset，因为offset代表着缓冲区的第一个元素对应到字节数组上的索引</span></span><br><span class="line"><span class="comment"> * position相当于它离第一个元素多远，offset + position = 当前读或者写入的元素对应到字节数组上的索引，所以对于新缓冲区来说，它的第一个元素对应到字节数组上的索引就是position + offset，不知道说清楚没有</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0  1  2  3  4  5  6  7  8  9  10</span></span><br><span class="line"><span class="comment"> * 假设这是字节数组，1：offset  position：3（此时的3并不是指的3索引，而是指定离第一个元素有多远，那么position对应的索引应该是1 + 3 = 4索引）</span></span><br><span class="line"><span class="comment"> * 该类中的arrayOffset方法在第一次获取offset值时个人觉得写的不对，就好比我上面已经指定了position的值了，可惜返回的结果并不是我想要的，而在调用完slice完后再次通过arrayOffset获取offset，这次的结果确实正确的，于是我就有点纳闷了</span></span><br><span class="line"><span class="comment"> * 况且它的注释已经写的很明白了</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新缓冲区，与源缓冲区共享同一个字节数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">slice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(hb, -<span class="number">1</span>, <span class="number">0</span>, <span class="keyword">this</span>.remaining(), <span class="keyword">this</span>.remaining(), <span class="keyword">this</span>.position() + offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取缓冲区中剩余元素的数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 剩余元素的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">remaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> limit - position;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取position的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> position</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">position</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> position;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对于直接缓冲区来说，笔者不敢保证是否共享同一块内存区域，这块的知识点并不是很充裕</span></span><br><span class="line"><span class="comment"> * 注释上说，若调用该方法的是个直接缓冲区，那么新缓冲区将是个只读缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">slice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="keyword">this</span>.position();</span><br><span class="line">    <span class="keyword">int</span> lim = <span class="keyword">this</span>.limit();</span><br><span class="line">    <span class="keyword">assert</span> (pos &lt;= lim);</span><br><span class="line">    <span class="keyword">int</span> rem = (pos &lt;= lim ? lim - pos : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> off = (pos &lt;&lt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">assert</span> (off &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(<span class="keyword">this</span>, -<span class="number">1</span>, <span class="number">0</span>, rem, rem, off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 复制源缓冲区，包括其属性position、limit、capacity、offset</span></span><br><span class="line"><span class="comment"> * 源缓冲区与新缓冲区共享同一个字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">duplicate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(hb, <span class="keyword">this</span>.markValue(), <span class="keyword">this</span>.position(), <span class="keyword">this</span>.limit(), <span class="keyword">this</span>.capacity(), offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注释上说，若调用该方法的是个直接缓冲区，那么新缓冲区将是个只读缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">duplicate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(<span class="keyword">this</span>, <span class="keyword">this</span>.markValue(), <span class="keyword">this</span>.position(), <span class="keyword">this</span>.limit(), <span class="keyword">this</span>.capacity(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 复制源缓冲区，但是不允许新缓冲区修改内容，源缓冲区还是可以继续修改其内容，毕竟它不属于只读</span></span><br><span class="line"><span class="comment"> * HeapByteBufferR类中覆写了put方法，调用put方法都将抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">asReadOnlyBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBufferR(hb, <span class="keyword">this</span>.markValue(), <span class="keyword">this</span>.position(), <span class="keyword">this</span>.limit(), <span class="keyword">this</span>.capacity(), offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取缓冲区中position上的字节</span></span><br><span class="line"><span class="comment"> * 缓冲区中position会对应到字节数组中的索引来获取字节</span></span><br><span class="line"><span class="comment"> * 调用完该方法后position会自增</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 与该方法类似的直接缓冲区的知识点将尽量讲解，不懂的点我不会讲解！！！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 字节</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hb[ix(nextGetIndex())];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取下一个读取的元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 下一个读取的元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextGetIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position &gt;= limit)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line">    <span class="keyword">return</span> position++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取字节数组上对应的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 对应position</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 字节数组上对应的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">ix</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定字节写入到缓冲区中position位置上</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 指定字节</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">    hb[ix(nextPutIndex())] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取下一个写入的元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 下一个写入的元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextPutIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position &gt;= limit)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    <span class="keyword">return</span> position++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取缓冲区中指定位置上的字节</span></span><br><span class="line"><span class="comment"> * 注意这里并没有修改position的值</span></span><br><span class="line"><span class="comment"> * 这里一直称作是指定位置，而不是指定索引，因为该位置并不是字节数组中的索引，而是缓冲区的指定位置对应到字节数组的指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定位置上的字节</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hb[ix(checkIndex(i))];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 校验指定索引是否超过界限</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">checkIndex</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((i &lt; <span class="number">0</span>) || (i &gt;= limit))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定字节写入到缓冲区中指定位置上</span></span><br><span class="line"><span class="comment"> * 注意这里并没有修改position的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 指定字节</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">    hb[ix(checkIndex(i))] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将缓冲区中的剩余元素复制指定数量，从指定字节数组的指定起始索引处开始复制缓冲区的内容</span></span><br><span class="line"><span class="comment"> * 校验字节数组的参数是否合法</span></span><br><span class="line"><span class="comment"> * 若所需数量大于缓冲区的剩余元素长度，则会抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dst 指定字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> offset 指定起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length 指定数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    checkBounds(offset, length, dst.length);</span><br><span class="line">    <span class="keyword">if</span> (length &gt; remaining())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line">    <span class="keyword">int</span> end = offset + length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = offset; i &lt; end; i++)</span><br><span class="line">        dst[i] = get();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将缓冲区中的剩余元素复制到指定字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dst 指定字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(dst, <span class="number">0</span>, dst.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定缓冲区的剩余元素复制到当前缓冲区</span></span><br><span class="line"><span class="comment"> * 若当前缓冲区是个只读，则抛出异常</span></span><br><span class="line"><span class="comment"> * 若当前的缓冲区的剩余元素个数小于指定缓冲区的剩余元素个数，简单来说，就是不够放了，那么抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src 指定缓冲区</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(ByteBuffer src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (src == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (isReadOnly())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ReadOnlyBufferException();</span><br><span class="line">    <span class="keyword">int</span> n = src.remaining();</span><br><span class="line">    <span class="keyword">if</span> (n &gt; remaining())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        put(src.get());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从指定字节数组的指定起始位置开始遍历指定数量，将遍历后的元素复制到缓冲区中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src 指定字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> offset 指定起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length 指定数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span>[] src, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    checkBounds(offset, length, src.length);</span><br><span class="line">    <span class="keyword">if</span> (length &gt; remaining())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    <span class="keyword">int</span> end = offset + length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = offset; i &lt; end; i++)</span><br><span class="line">        <span class="keyword">this</span>.put(src[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将字节数组的内容复制到缓冲区中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src 指定字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span>[] src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> put(src, <span class="number">0</span>, src.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否是可访问数组（缓冲区），代表非只读缓冲区已初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否是可访问数组（缓冲区）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (hb != <span class="keyword">null</span>) &amp;&amp; !isReadOnly;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取字节数组</span></span><br><span class="line"><span class="comment"> * 若修改缓冲区的内容，则返回的字节数组的内容也将跟着变化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 字节数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] array() &#123;</span><br><span class="line">    <span class="keyword">if</span> (hb == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    <span class="keyword">if</span> (isReadOnly)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ReadOnlyBufferException();</span><br><span class="line">    <span class="keyword">return</span> hb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取缓冲区的第一个元素对应到字节数组中的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">arrayOffset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hb == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    <span class="keyword">if</span> (isReadOnly)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ReadOnlyBufferException();</span><br><span class="line">    <span class="keyword">return</span> offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将缓冲区的剩余元素拷贝到缓冲区的起始位置</span></span><br><span class="line"><span class="comment"> * postion上的字节被拷贝到索引0上</span></span><br><span class="line"><span class="comment"> * 该方法最好在缓冲区写完数据后调用，防止数据不完整</span></span><br><span class="line"><span class="comment"> * positions设置到limit，limit设置到capacity，mark = -1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   buf.clear();</span></span><br><span class="line"><span class="comment"> *   while (in.read(buf) &gt;= 0 || buf.position != 0) &#123; // in.read(buf)：从channel读取数据到buf中 channel -&gt; buf</span></span><br><span class="line"><span class="comment"> *       buf.flip();  // 将limit设置到position, position = 0  实际上就是将写模式切换到读模式，一般在写完后要开始读取数据了调用</span></span><br><span class="line"><span class="comment"> *       out.write(buf);  // 将buf中的数据写入到channel中  buf -&gt; channel</span></span><br><span class="line"><span class="comment"> *       buf.compact();    // In case of partial write</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">compact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.arraycopy(hb, ix(position()), hb, ix(<span class="number">0</span>), remaining());</span><br><span class="line">    position(remaining());</span><br><span class="line">    limit(capacity());</span><br><span class="line">    discardMark(); <span class="comment">//mark = -1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否是直接缓冲区</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否是直接缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDirect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 比较两个缓冲区的剩余元素是否完全相同</span></span><br><span class="line"><span class="comment"> * 若有一处不同则直接返回结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> that 另一个缓冲区</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 比较结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ByteBuffer that)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">this</span>.position() + Math.min(<span class="keyword">this</span>.remaining(), that.remaining());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.position(), j = that.position(); i &lt; n; i++, j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = compare(<span class="keyword">this</span>.get(i), that.get(j));</span><br><span class="line">        <span class="keyword">if</span> (cmp != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> cmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.remaining() - that.remaining();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取缓冲区的字节顺序，默认是高位优先</span></span><br><span class="line"><span class="comment"> * 不同的机器可能会使用不同的字节排序方法来存储数据</span></span><br><span class="line"><span class="comment"> * 高位优先：高位字节存放在内存的低地址，低位字节存放在高地址</span></span><br><span class="line"><span class="comment"> * 低位优先：低位字节存放在内存的高地址，高位字节存放在低地址</span></span><br><span class="line"><span class="comment"> * 对于不同的基本类型的位数是不一样的</span></span><br><span class="line"><span class="comment"> * 高位  低位   </span></span><br><span class="line"><span class="comment"> * 0001 1111</span></span><br><span class="line"><span class="comment"> * 低地址 -----&gt; 高地址</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 代表字节顺序的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ByteOrder <span class="title">order</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bigEndian ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改缓冲区的字节顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ByteBuffer <span class="title">order</span><span class="params">(ByteOrder bo)</span> </span>&#123;</span><br><span class="line">    bigEndian = (bo == ByteOrder.BIG_ENDIAN);</span><br><span class="line">    nativeByteOrder = (bigEndian == (Bits.byteOrder() == ByteOrder.BIG_ENDIAN));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取缓冲区的position与position对应的字节，根据当前字节顺序将两个字节组成一个char值，然后将position + 2</span></span><br><span class="line"><span class="comment"> * 因为char类型是占用两个字节, 所以会将两个字节变成1个char类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 97 |  bytes</span></span><br><span class="line"><span class="comment"> * |       |       |       |   a    |  chars</span></span><br><span class="line"><span class="comment"> * |   0   |   0   |   0   |   97   |  shorts</span></span><br><span class="line"><span class="comment"> * |       0       |       97       |   ints</span></span><br><span class="line"><span class="comment"> * 以此类推....</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> char值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Bits.getChar(<span class="keyword">this</span>, ix(nextGetIndex(<span class="number">2</span>)), bigEndian);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定char值写入到缓冲区中指定位置上</span></span><br><span class="line"><span class="comment"> * 由于char占用两个字节，分为高位与低位，根据缓冲区中字节的顺序进行存储，默认情况是将高位存储在低地址，低位存储在高地址</span></span><br><span class="line"><span class="comment"> * 最终position会加2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 指定char值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">putChar</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">    Bits.putChar(<span class="keyword">this</span>, ix(nextPutIndex(<span class="number">2</span>)), x, bigEndian);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取缓冲区中指定位置上的char值</span></span><br><span class="line"><span class="comment"> * 注意这里并没有修改position的值</span></span><br><span class="line"><span class="comment"> * char值占用两个字节，所以会将position与position + 1上的字节进行组合，position放在高位、position + 1放在低位</span></span><br><span class="line"><span class="comment"> * 这里一直称作是指定位置，而不是指定索引，因为该位置并不是字节数组中的索引，而是缓冲区的指定位置对应到字节数组的指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定位置上的char值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getChar</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Bits.getChar(<span class="keyword">this</span>, ix(checkIndex(i, <span class="number">2</span>)), bigEndian);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定char值写入到缓冲区中指定位置上</span></span><br><span class="line"><span class="comment"> * 注意这里并没有修改position的值</span></span><br><span class="line"><span class="comment"> * char值可分成高低位，根据缓冲区中的字节顺序进行存放，默认情况下将高位存储在低地址，低位存储在高地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 指定char值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">putChar</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">    Bits.putChar(<span class="keyword">this</span>, ix(checkIndex(i, <span class="number">2</span>)), x, bigEndian);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将字节缓冲区转换成字符缓冲区</span></span><br><span class="line"><span class="comment"> * 实际上内部还是通过字节缓冲区来操作，由于char占用两个字节，所以该对象对应的position、limit、capacity可能都会/2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 字符缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CharBuffer <span class="title">asCharBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">this</span>.remaining() &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> off = offset + position();</span><br><span class="line">    <span class="keyword">return</span> (bigEndian ? (CharBuffer)(<span class="keyword">new</span> ByteBufferAsCharBufferB(<span class="keyword">this</span>, -<span class="number">1</span>, <span class="number">0</span>, size, size, off)) : (CharBuffer)(<span class="keyword">new</span> ByteBufferAsCharBufferL(<span class="keyword">this</span>, -<span class="number">1</span>, <span class="number">0</span>, size, size, off)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于转换成其他类型，如short、int、float、double都是一样的道理，就不在做展示了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 相当于从写模式切换到读模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否缓冲区中还有剩余元素</span></span><br><span class="line"><span class="comment"> * 要么是写满缓冲区、要么是缓冲区的内容读完了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区是否还有剩余元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasRemaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> position &lt; limit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重新读取/写入缓冲区</span></span><br><span class="line"><span class="comment"> * 可重复读取缓冲区的内容，可重复写入来覆盖缓冲区的内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>缓冲区的基本属性有position、limit、capacity、mark，这些属性必须满足<code>0 &lt;= mark &lt;= posiiton &lt;= limit &lt;= capacity</code></p></li><li><p>可创建视图缓冲区，视图缓冲区指的是包含其他基本类型值的缓冲区，省去了类型转换的麻烦。但是千万记住视图缓冲区的索引不是以字节为单位，而是根据其值的特定类型的大小决定的</p></li><li><p>直接缓冲区建议还是了解下，不过本文没有讲的很详细，笔者能力有限</p></li><li><p>高低位、高地址、低地址，缓冲区的字节顺序</p></li><li><p>compact：将缓冲区的剩余元素拷贝到缓冲区的起始位置，修改position = limit，limit = capacity</p></li><li><p>slice：构造一个包含从position到limit之间的源缓冲区内容的新缓冲区，源缓冲区与新缓冲区共享同一个字节数组，但两者的基本属性是相互的独立</p></li><li><p>duplicate：复制源缓冲区的内容构造一个新缓冲区，包括复制基本属性，两个缓冲区共享同一个字节数组</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>基本属性</code> <code>compact、slice、duplicate</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;由于最近在了解IO相关知识，而正好看到了nio，这是我以前从来没接触过的，虽然它很早就出现了，所以先来看看有关于它的一些基础。探索&lt;code&gt;ByteBuffer&lt;/code&gt;源代码是基于&lt;code&gt;JDK1.8&lt;/code&gt;版本的，ByteBuffer的父类是&lt;code&gt;Buffer&lt;/code&gt;，通过阅读注释后对Buffer总结如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;缓冲区是特定基本类型的元素的线性有限序列，除了内容之外，缓冲区的基本属性还包括&lt;code&gt;capacity&lt;/code&gt;、&lt;code&gt;limit&lt;/code&gt;、&lt;code&gt;position&lt;/code&gt;、&lt;code&gt;mark&lt;/code&gt;。假设缓冲区是一本1000页的书籍，你已经看到800页了，其中在500页处有个很重要的知识点，你做了个标记以便下次能够轻松找到它。那么capacity指代的就是1000，意思就是这本书的最大页数，缓冲区的最大容量，该属性值不会为负不会改变；limit指代的是800，意思是目前只学了这么多知识，可以理解为界限；position指代的是具体某一页，也就是你每看一页，position就会有所增加；mark很容易理解，指代的是我们标记到具体某一页。在实际代码中有读、写模式，我们将读模式比喻成复习，也就是说你可以从第0页复习到第800页，此时的postion从0-800，limit保持800不变，也可以从你所标记的点到第800页，此时的position从mark-800，但是切记不能从第0页复习而后直接跳到mark处，这样子就导致知识点的不连续性，简单来说&lt;code&gt;0 &amp;lt;= mark &amp;lt;= posiiton &amp;lt;= limit &amp;lt;= capacity&lt;/code&gt;；将写模式比喻成继续学习新知识点，也就是从第801页继续往后看，position会逐步增加。对于只读缓冲区来说，不允许修改它的内容，但是limit、position、mark是可以变化的。最后一点是缓冲区属于非线程安全！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提供一张图片方便理解。接下来在总结下ByteBuffer，以便对其有个大概性的了解。&lt;/p&gt;
&lt;p class=&quot;customize-img&quot;&gt;&lt;img src=&quot;/assets/blogImg/java/bytebuffer/bytebuffer-variable.png&quot; alt=&quot;Buffer相关变量&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;字节缓冲区&lt;/code&gt;，可创建视图缓冲区，视图缓冲区指的是包含其他基本类型值的缓冲区，如CharBuffer，视图缓冲区的索引不是以字节为单位，而是根据其值的特定类型的大小决定的，如CharBuffer是2个字节。字节缓冲区可分为直接或间接，直接缓冲区的内容存放在堆外内存，JVM将尽最大努力直接执行原生IO操作，而间接缓冲区存放在堆内存中，交由JVM操作，与操作系统并未直接交互，直接缓冲区通常比间接缓冲区具有更高的分配和释放成本，简单来说，对于大型缓冲区来说直接分配直接缓冲区。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;概念性的内容就阐述到这里了，接着就直接进入源码世界吧！&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>深入理解String与new String</title>
    <link href="http://zlia.tech/2019/11/09/string-newString-compare/"/>
    <id>http://zlia.tech/2019/11/09/string-newString-compare/</id>
    <published>2019-11-09T15:41:06.000Z</published>
    <updated>2019-11-28T06:14:33.667Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>字符串是最常用的类型之一，趁此机会准备探索下它的源码。有关该类的注释作一个总结：</p><blockquote><p>String-字符串，是个常量，它们被创建后<code>其值</code>就不允许被改变，由于它是不可变的，所以它们可以被共享，在内部提供了多个方法来操作字符串。</p></blockquote><p>探索之前我曾看过其他人写的有关于此的文章，发现<code>JDK1.7版本前后的内存模型</code>不一样，而这部分的内容还没有排上行程，简单来说，我还不懂…所以不敢妄下结论，这篇文章的内容也不会从这方面展开来讲，此次探索是基于<code>JDK1.8</code>。</p><a id="more"></a><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a><div><span>原理</span></div></h3><p>字符串是存放在<code>常量池</code>中，至于什么是常量池不准备讨论它。先来个简单的示例方便分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String testOne = <span class="keyword">new</span> String(<span class="string">"testOne"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例就是这么简单…先让我们来看看仅仅是这么一句话，而它的底层都做了什么。紧接着反编译它的字节码文件，命令是<code>javap -v TestString</code>，输出的信息内容比较多，咱们只要常量池的内容，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/java/string/constant-pool-1.png" alt="常量池-1"></p><p>实际上我也看的不是很懂，但有几个点咱们是能确定的，也就是说<code>常量池中有testOne字符串</code>，而此时的字节码文件是编译而来的，并未实际上的运行，所以该字符串对象在堆内存中还未创建，这就说明了在编译阶段时字符串就存在于常量池中，同时也验证了一点：<code>常量池中的字符串对象</code>与运行时在<code>堆内存中创建的字符串对象</code>完全是两个对象，因为在编译时期堆内存中的对象还未出生呢，所以不可能引用到它…不知道我讲明白了没有。接着我们从另外一个角度去分析这段示例，因为后续的其他示例可能会羞涩难懂，所以先从简单的示例开始逐渐熟悉起来，最终也是希望读者能够理解这方面的知识。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    Constant pool:</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 编号  类型                值              注释            --------&gt; 这里的注释不一定对，只是作一个标记方便理解        </span></span><br><span class="line">    #1 = Methodref          #6.#22         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">    #2 = Class              #23            // java/lang/String</span><br><span class="line">    #3 = String             #18            // testOne</span><br><span class="line">    #4 = Methodref          #2.#24         // java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V</span><br><span class="line">    #5 = Class              #25            // test20190820/TestString</span><br><span class="line">    #6 = Class              #26            // java/lang/Object</span><br><span class="line">    #7 = Utf8               &lt;init&gt;</span><br><span class="line">    #8 = Utf8               ()V</span><br><span class="line">    #9 = Utf8               Code</span><br><span class="line">    #10 = Utf8               LineNumberTable</span><br><span class="line">    #11 = Utf8               LocalVariableTable</span><br><span class="line">    #12 = Utf8               this</span><br><span class="line">    #13 = Utf8               Ltest20190820/TestString;</span><br><span class="line">    #14 = Utf8               main</span><br><span class="line">    #15 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">    #16 = Utf8               args</span><br><span class="line">    #17 = Utf8               [Ljava/lang/String;</span><br><span class="line">    #18 = Utf8               testOne</span><br><span class="line">    #19 = Utf8               Ljava/lang/String;</span><br><span class="line">    #20 = Utf8               SourceFile</span><br><span class="line">    #21 = Utf8               TestString.java</span><br><span class="line">    #22 = NameAndType        #7:#8          // "&lt;init&gt;":()V</span><br><span class="line">    #23 = Utf8               java/lang/String</span><br><span class="line">    #24 = NameAndType        #7:#27         // "&lt;init&gt;":(Ljava/lang/String;)V</span><br><span class="line">    #25 = Utf8               test20190820/TestString</span><br><span class="line">    #26 = Utf8               java/lang/Object</span><br><span class="line">    #27 = Utf8               (Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><p>执行<code>javap -c TestString</code>获取底层代码执行逻辑，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/java/string/constant-pool-2.png" alt="常量池-2"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test20190820</span>.<span class="title">TestString</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> test20190820.TestString(); <span class="comment">//这里是构造器的执行逻辑，咱们忽略它，毕竟不是重点</span></span><br><span class="line">        Code:</span><br><span class="line">        <span class="number">0</span>: aload_0</span><br><span class="line">        1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">        <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>; <span class="comment">//下面的内容涉及到字节码的指令，网上很多资料，可自行查阅</span></span><br><span class="line">    Code:</span><br><span class="line">    <span class="comment">// #2：对应常量池中编号#2，加上注释我们得出这里是创建字符串对象  -&gt; new String();</span></span><br><span class="line">    0: new           #2                  // class java/lang/String</span><br><span class="line">    <span class="comment">// dup：复制0序号中的引用并压入栈中  -&gt; 也就是将字符串对象的引用放入到栈中</span></span><br><span class="line">    <span class="number">3</span>: dup</span><br><span class="line">    <span class="comment">// ldc：从常量池中加载指定项的引用到栈  #3：同上，对应着常量池的编号#3 -&gt; 将"testOne"字符串的引用加载到栈中</span></span><br><span class="line">    4: ldc           #3                  // String testOne</span><br><span class="line">    <span class="comment">// invokespecial：初始化常量池中的指定项  -&gt; 调用字符串对象的初始化并将4序号中的引用作为参数传入，形成new String("testOne")</span></span><br><span class="line">    6: invokespecial #4                  // Method java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V</span><br><span class="line">    <span class="comment">// astore_n：将引用赋值给第n个局部变量  -&gt; 将6序号的引用赋值给第一个局部变量，String testOne = new String("testOne")，jvm中是有记录局部变量的信息</span></span><br><span class="line">    <span class="number">9</span>: astore_1</span><br><span class="line">    <span class="comment">// 退出方法的标志</span></span><br><span class="line">    <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的分析可以知道：<code>常量池中的字符串对象与在堆内存中创建的字符串对象是两个对象</code>，这一点很重要！接下来是各种示例，我们将采用上面的方式进行分析。</p><h4 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String testOne = <span class="keyword">new</span> String(<span class="string">"testOne"</span>);</span><br><span class="line">        String testOneAnother = <span class="string">"testOne"</span>;</span><br><span class="line">        System.out.println(testOne == testOneAnother); <span class="comment">//false -&gt; 上面说了testOne和testOneAnother是两个对象，所以很容易得出结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        String s2 = <span class="string">"a"</span>;</span><br><span class="line">        String s3 = <span class="string">"bc"</span>;</span><br><span class="line">        String s4 = s2 + s3; <span class="comment">// StringBuilder.append(a).append(bc) -&gt; StringBuilder.toString() -&gt; new String("abc")</span></span><br><span class="line">        System.out.println(s1 == s4); <span class="comment">//false, s1指向了常量池中的字符串abc，s4相当于生成了新的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里就不贴常量池的信息了，反正我们能确定的是在编译时期字符串已经加载到常量池中了，所以常量池中应该存在abc、a、bc字符串</span></span><br><span class="line"><span class="comment"> * 贴出代码的执行逻辑：</span></span><br><span class="line"><span class="comment"> *  public static void main(java.lang.String[]);</span></span><br><span class="line"><span class="comment"> *      Code:</span></span><br><span class="line"><span class="comment"> *          0: ldc           #2                  // String abc   -&gt;  ldc：从常量池中加载指定项的引用到栈</span></span><br><span class="line"><span class="comment"> *          2: astore_1                                          -&gt;  abstor_1：将引用赋值给第1个局部变量， 即 s1 = "abc"</span></span><br><span class="line"><span class="comment"> *          3: ldc           #3                  // String a</span></span><br><span class="line"><span class="comment"> *          5: astore_2                                          -&gt;  s2 = "a"</span></span><br><span class="line"><span class="comment"> *          6: ldc           #4                  // String bc</span></span><br><span class="line"><span class="comment"> *          8: astore_3                                          -&gt;  s3 = "bc"</span></span><br><span class="line"><span class="comment"> *          9: new           #5                  // class java/lang/StringBuilder    -&gt; 创建StringBuilder对象</span></span><br><span class="line"><span class="comment"> *          12: dup    -&gt;  复制StringBuilder对象的引用并压入栈中</span></span><br><span class="line"><span class="comment"> *          13: invokespecial #6                  // Method java/lang/StringBuilder."&lt;init&gt;":()V    -&gt; 初始化StringBuilder对象</span></span><br><span class="line"><span class="comment"> *          16: aload_2                            -&gt; 加载第二个局部变量的值</span></span><br><span class="line"><span class="comment"> *          17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;  -&gt; 调用常量池中指定项的方法，即调用StringBuilder对象中的append方法，并传入序号 *                                                                                                                                           16中的引用，所以最终是StringBuilder#append(a)</span></span><br><span class="line"><span class="comment"> *          20: aload_3</span></span><br><span class="line"><span class="comment"> *          21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line"><span class="comment"> *          24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;      -&gt; StringBuilder#toString, 可以看下该类的toString方法，生成了一个新的对象，该对象中的字符串不会再*                                                                                                                        常量池中生成</span></span><br><span class="line"><span class="comment"> *          27: astore        4                    -&gt; 将序号24中的引用赋值给第4个局部变量 s4 = StringBuilder.toString = new String()</span></span><br><span class="line"><span class="comment"> *          29: getstatic     #9                  // Field java/lang/System.out:Ljava/io/PrintStream;   -&gt; 下面的就讨论了，执行的是System.out.println代码片段了</span></span><br><span class="line"><span class="comment"> *          32: aload_1</span></span><br><span class="line"><span class="comment"> *          33: aload         4</span></span><br><span class="line"><span class="comment"> *          35: if_acmpne     42</span></span><br><span class="line"><span class="comment"> *          38: iconst_1</span></span><br><span class="line"><span class="comment"> *          39: goto          43</span></span><br><span class="line"><span class="comment"> *          42: iconst_0</span></span><br><span class="line"><span class="comment"> *          43: invokevirtual #10                 // Method java/io/PrintStream.println:(Z)V</span></span><br><span class="line"><span class="comment"> *          46: return</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 从上面的分析中我们得出结论：s1指向常量池中的字符串对象abc，而从序号16-27我们知道生成了新的对象，相当于是执行了new String("abc")，而这不就又回到了示例一了吗，结果自然是false</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        <span class="keyword">final</span> String s2 = <span class="string">"a"</span>;</span><br><span class="line">        <span class="keyword">final</span> String s3 = <span class="string">"bc"</span>;</span><br><span class="line">        String s4 = s2 + s3; <span class="comment">//由于s2、s3被final修饰了，故而直接替换变量的值，最后s4 = "abc"，直接使用了常量池中的字符串对象abc</span></span><br><span class="line">        System.out.println(s1 == s4); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同样贴出代码的执行逻辑：</span></span><br><span class="line"><span class="comment"> *  public static void main(java.lang.String[]);</span></span><br><span class="line"><span class="comment"> *      Code:</span></span><br><span class="line"><span class="comment"> *          0: ldc           #2                  // String abc  -&gt; ldc：从常量池中加载指定项的引用到栈</span></span><br><span class="line"><span class="comment"> *          2: astore_1                                         -&gt; s1 = "abc"</span></span><br><span class="line"><span class="comment"> *          3: ldc           #3                  // String a</span></span><br><span class="line"><span class="comment"> *          5: astore_2                                         -&gt; s2 = "a" </span></span><br><span class="line"><span class="comment"> *          6: ldc           #4                  // String bc</span></span><br><span class="line"><span class="comment"> *          8: astore_3                                         -&gt; s3 = "bc"</span></span><br><span class="line"><span class="comment"> *          9: ldc           #2                  // String abc</span></span><br><span class="line"><span class="comment"> *          11: astore        4                                 -&gt; s4 = "abc"  示例三与示例二的区别在于加了final修饰，被final修饰的变量会在编译阶段直接替换成对应的值，即"a" + "bc"，而这个在示例四中我们也会分析到，是直接采用</span></span><br><span class="line"><span class="comment"> *                                                                             字符串合并，而合并后的字符串abc在常量池中已经存在了，故直接使用</span></span><br><span class="line"><span class="comment"> *          13: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line"><span class="comment"> *          16: aload_1</span></span><br><span class="line"><span class="comment"> *          17: aload         4</span></span><br><span class="line"><span class="comment"> *          19: if_acmpne     26</span></span><br><span class="line"><span class="comment"> *          22: iconst_1</span></span><br><span class="line"><span class="comment"> *          23: goto          27</span></span><br><span class="line"><span class="comment"> *          26: iconst_0</span></span><br><span class="line"><span class="comment"> *          27: invokevirtual #6                  // Method java/io/PrintStream.println:(Z)V</span></span><br><span class="line"><span class="comment"> *          30: return</span></span><br><span class="line"><span class="comment"> * 从上面的分析中我们得出结论：s1指向了常量池中的字符串对象abc，s4也是指向了常量池中的字符串对象abc</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="示例四"><a href="#示例四" class="headerlink" title="示例四"></a>示例四</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        String s2 = <span class="string">"a"</span> + <span class="string">"bc"</span>; <span class="comment">//s1、s2指向同一个字符串</span></span><br><span class="line">        String s3 = <span class="string">"test"</span> + <span class="string">"One"</span>; <span class="comment">//说明常量池是直接存储合并后的字符串</span></span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里多贴出常量池的信息，为了说明s3的行为</span></span><br><span class="line"><span class="comment"> * Constant pool:</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * #30 = Utf8               abc</span></span><br><span class="line"><span class="comment"> * #31 = Utf8               testOne</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * 省略了一部分信息，说明常量池是直接存储合并后的字符串，而并分开存储，所以常量池中只会有"testOne"，并没有"test"或"One"</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  public static void main(java.lang.String[]);</span></span><br><span class="line"><span class="comment"> *       Code:</span></span><br><span class="line"><span class="comment"> *          0: ldc           #2                  // String abc</span></span><br><span class="line"><span class="comment"> *          2: astore_1                            -&gt; s1 = "abc" 指向常量池中#2的引用</span></span><br><span class="line"><span class="comment"> *          3: ldc           #2                  // String abc</span></span><br><span class="line"><span class="comment"> *          5: astore_2                            -&gt; s2 = "abc" 从常量池中#2的引用，可以看到引用的字符串对象是同一个</span></span><br><span class="line"><span class="comment"> *          6: ldc           #3                  // String testOne</span></span><br><span class="line"><span class="comment"> *          8: astore_3</span></span><br><span class="line"><span class="comment"> *          9: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line"><span class="comment"> *          12: aload_1</span></span><br><span class="line"><span class="comment"> *          13: aload_2</span></span><br><span class="line"><span class="comment"> *          14: if_acmpne     21</span></span><br><span class="line"><span class="comment"> *          17: iconst_1</span></span><br><span class="line"><span class="comment"> *          18: goto          22</span></span><br><span class="line"><span class="comment"> *          21: iconst_0</span></span><br><span class="line"><span class="comment"> *          22: invokevirtual #5                  // Method java/io/PrintStream.println:(Z)V</span></span><br><span class="line"><span class="comment"> *          25: return</span></span><br><span class="line"><span class="comment"> * 从上面的分析中我们得出结论：s1、s2指向了常量池中的同一个字符串对象</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="示例五"><a href="#示例五" class="headerlink" title="示例五"></a>示例五</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        String s2 = <span class="string">"a"</span>;</span><br><span class="line">        String s3 = s2 + <span class="string">"bc"</span>; <span class="comment">// StringBuilder.append(a).append(bc) -&gt; StringBuilder.toString() -&gt; new String("abc")</span></span><br><span class="line">        System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * public static void main(java.lang.String[]);</span></span><br><span class="line"><span class="comment"> *       Code:</span></span><br><span class="line"><span class="comment"> *          0: ldc           #2                  // String abc</span></span><br><span class="line"><span class="comment"> *          2: astore_1                             -&gt; s1 = "abc"</span></span><br><span class="line"><span class="comment"> *          3: ldc           #3                  // String a</span></span><br><span class="line"><span class="comment"> *          5: astore_2                             -&gt; s2 = "a"</span></span><br><span class="line"><span class="comment"> *          6: new           #4                  // class java/lang/StringBuilder   -&gt; 创建StringBuilder对象</span></span><br><span class="line"><span class="comment"> *          9: dup           -&gt;  复制StringBuilder对象的引用并压入栈中</span></span><br><span class="line"><span class="comment"> *          10: invokespecial #5                  // Method java/lang/StringBuilder."&lt;init&gt;":()V   -&gt; 初始化StringBuilder</span></span><br><span class="line"><span class="comment"> *          13: aload_2                             -&gt; 加载第二个局部变量的值</span></span><br><span class="line"><span class="comment"> *          14: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;   -&gt; StringBuilder.append("a")</span></span><br><span class="line"><span class="comment"> *          17: ldc           #7                  // String bc</span></span><br><span class="line"><span class="comment"> *          19: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;   -&gt; StringBuilder.append("bc")</span></span><br><span class="line"><span class="comment"> *          22: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;    -&gt; StringBuilder.toString</span></span><br><span class="line"><span class="comment"> *          25: astore_3                           -&gt; s3 = "abc"</span></span><br><span class="line"><span class="comment"> *          26: getstatic     #9                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line"><span class="comment"> *          29: aload_1</span></span><br><span class="line"><span class="comment"> *          30: aload_3</span></span><br><span class="line"><span class="comment"> *          31: if_acmpne     38</span></span><br><span class="line"><span class="comment"> *          34: iconst_1</span></span><br><span class="line"><span class="comment"> *          35: goto          39</span></span><br><span class="line"><span class="comment"> *          38: iconst_0</span></span><br><span class="line"><span class="comment"> *          39: invokevirtual #10                 // Method java/io/PrintStream.println:(Z)V</span></span><br><span class="line"><span class="comment"> *          42: return</span></span><br><span class="line"><span class="comment"> * 从上面的分析中我们得出结论：s1指向常量池中的字符串对象abc，而从序号9-25我们知道生成了新的对象，相当于是执行了new String("abc")，结果自然是false</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="示例六"><a href="#示例六" class="headerlink" title="示例六"></a>示例六</h4><p>先来看下String#intern方法作了什么动作，还是采用此分析方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String testOne = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"bc"</span>); <span class="comment">//常量池中存储字符串a、bc，最终testOne指向堆内存中的对象，而该对象对应的字符串是不会在常量池中存在</span></span><br><span class="line">        String testOneAnother = testOne.intern(); <span class="comment">//先去常量池中查询是否已经存在该字符串，如果存在，则返回常量池中的引用，若不存在则不会将该对象的字符串拷贝到常量池中，而是在常量池中持有对该对象的引用</span></span><br><span class="line">                                                  <span class="comment">//这里的引用没办法从该方式得出，可能需要看下native的方法，反正我是看了别人的分析，虽然我是知道原理但还是忍不住看了以下底层实现</span></span><br><span class="line">        System.out.println(testOne == testOneAnther) <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constant pool:</span></span><br><span class="line"><span class="comment"> *  ...</span></span><br><span class="line"><span class="comment"> * #31 = Utf8               a</span></span><br><span class="line"><span class="comment"> *  ...</span></span><br><span class="line"><span class="comment"> * #34 = Utf8               bc</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="示例七"><a href="#示例七" class="headerlink" title="示例七"></a>示例七</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"bc"</span>);</span><br><span class="line">        s1.intern(); <span class="comment">//执行方法前我们知道常量池中并未有abc字符串，执行该方法后，常量池中已经存在指向s1对象的引用，即"abc"字符串的引用</span></span><br><span class="line">        String s2 = <span class="string">"abc"</span>; <span class="comment">// 常量池中已经存在"abc"字符串的引用，即为s1对象的引用</span></span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * public static void main(java.lang.String[]);</span></span><br><span class="line"><span class="comment"> *      Code:</span></span><br><span class="line"><span class="comment"> *          0: new           #2                  // class java/lang/StringBuilder    -&gt; 创建StringBuilder对象</span></span><br><span class="line"><span class="comment"> *          3: dup                                -&gt; 复制StringBuilder对象的引用并压入栈中</span></span><br><span class="line"><span class="comment"> *          4: invokespecial #3                  // Method java/lang/StringBuilder."&lt;init&gt;":()V  -&gt; 初始化StringBuilder</span></span><br><span class="line"><span class="comment"> *          7: new           #4                  // class java/lang/String    -&gt; 创建字符串对象 new String()</span></span><br><span class="line"><span class="comment"> *          10: dup                               -&gt; 复制String对象的引用并压入栈中</span></span><br><span class="line"><span class="comment"> *          11: ldc           #5                  // String a</span></span><br><span class="line"><span class="comment"> *          13: invokespecial #6                  // Method java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V    -&gt; new String("a")</span></span><br><span class="line"><span class="comment"> *          16: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; -&gt; StringBuilder.append()</span></span><br><span class="line"><span class="comment"> *          19: new           #4                  // class java/lang/String    -&gt;  创建字符串对象 new String()</span></span><br><span class="line"><span class="comment"> *          22: dup                               -&gt; 复制String对象的引用并压入栈中</span></span><br><span class="line"><span class="comment"> *          23: ldc           #8                  // String bc</span></span><br><span class="line"><span class="comment"> *          25: invokespecial #6                  // Method java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V   -&gt; new String("bc")</span></span><br><span class="line"><span class="comment"> *          28: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; -&gt; StringBuilder.append()</span></span><br><span class="line"><span class="comment"> *          31: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;  -&gt; StringBuilder.toString()</span></span><br><span class="line"><span class="comment"> *          34: astore_1                          -&gt; s1 = "abc", 由StringBuilder#toString创建的字符串对象</span></span><br><span class="line"><span class="comment"> *          35: aload_1                           -&gt; 加载第一个局部变量的值</span></span><br><span class="line"><span class="comment"> *          36: invokevirtual #10                 // Method java/lang/String.intern:()Ljava/lang/String;  -&gt; s1.intern()</span></span><br><span class="line"><span class="comment"> *          39: pop                               -&gt; pop：移除栈顶的值</span></span><br><span class="line"><span class="comment"> *          40: ldc           #11                 // String abc</span></span><br><span class="line"><span class="comment"> *          42: astore_2                          -&gt; s2 = "abc"</span></span><br><span class="line"><span class="comment"> *          43: getstatic     #12                 // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line"><span class="comment"> *          46: aload_1</span></span><br><span class="line"><span class="comment"> *          47: aload_2</span></span><br><span class="line"><span class="comment"> *          48: if_acmpne     55</span></span><br><span class="line"><span class="comment"> *          51: iconst_1</span></span><br><span class="line"><span class="comment"> *          52: goto          56</span></span><br><span class="line"><span class="comment"> *          55: iconst_0</span></span><br><span class="line"><span class="comment"> *          56: invokevirtual #13                 // Method java/io/PrintStream.println:(Z)V</span></span><br><span class="line"><span class="comment"> *          59: return</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="示例八"><a href="#示例八" class="headerlink" title="示例八"></a>示例八</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>); <span class="comment">//生成两个对象，堆内存一个，常量池一个</span></span><br><span class="line">        s1.intern(); <span class="comment">//常量池中已经存在该字符串对象，故而直接返回</span></span><br><span class="line">        String s2 = <span class="string">"abc"</span>; <span class="comment">//指向常量池的字符串对象</span></span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//false  -&gt; s1指向堆内存中的对象，s2指向常量池的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>在编译阶段，字符串已经被存储与常量池中</p></li><li><p>new String(“abc”)：一共有两个不同的对象，一个在堆内存、一个在常量池</p></li><li><p>s2 + s3拼接（s2、s3未被final修饰）：底层创建StringBuilder对象，通过append拼接起来，最终调用toString生成一个新的对象</p></li><li><p>“a” + “bc”直接拼接：直接将拼接后的字符串存储于常量池中</p></li><li><p>s2 + “bc”拼接（s2未被final修饰）：底层创建StringBuilder对象，通过append拼接起来，最终调用toString生成一个新的对象</p></li><li><p>s.intern：若常量池中存在字符串，则直接返回引用，若不存在，则在常量池中生成指向该字符串对象的引用，后续若有声明此字符串，会返回指向该字符串对象的引用，也就是同一个引用（参考示例七、八）</p></li></ul><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a><div><span>重点</span></div></h3><p><code>new String与String的区别</code> <code>(s1 + s2)与(&quot;a&quot; + &quot;bc&quot;)的区别</code> <code>intern</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;字符串是最常用的类型之一，趁此机会准备探索下它的源码。有关该类的注释作一个总结：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;String-字符串，是个常量，它们被创建后&lt;code&gt;其值&lt;/code&gt;就不允许被改变，由于它是不可变的，所以它们可以被共享，在内部提供了多个方法来操作字符串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;探索之前我曾看过其他人写的有关于此的文章，发现&lt;code&gt;JDK1.7版本前后的内存模型&lt;/code&gt;不一样，而这部分的内容还没有排上行程，简单来说，我还不懂…所以不敢妄下结论，这篇文章的内容也不会从这方面展开来讲，此次探索是基于&lt;code&gt;JDK1.8&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Comparable VS Comparator</title>
    <link href="http://zlia.tech/2019/11/06/comparable-comparator-compare/"/>
    <id>http://zlia.tech/2019/11/06/comparable-comparator-compare/</id>
    <published>2019-11-06T10:45:42.000Z</published>
    <updated>2019-11-06T10:45:42.075Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>在阅读TreeMap源码时发现了Comparable与Comparator，光是名字看起来就很像，既然都是比较器，那有何区别呢？实际上我对于比较器的使用场景并不是很多，所以这篇还是借鉴了别人的想法。</p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a><div><span>比较</span></div></h3><p>通过下面的这段代码来说明问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Apple appleOne = <span class="keyword">new</span> Apple(<span class="number">1</span>, <span class="string">"red"</span>);</span><br><span class="line">        Apple appleTwo = <span class="keyword">new</span> Apple(<span class="number">2</span>, <span class="string">"green"</span>);</span><br><span class="line">        appleOne.compareTo(appleTwo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Apple</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    Apple(<span class="keyword">int</span> size, String color)&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Apple o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size &gt; o.size ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">//比较Apple的大小</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getter、setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>代码上挺简单的，只是比较了Apple的大小，现在来思考一下，哪一天突然想比较Apple的颜色了，那岂不是要改代码了，而对于新需求我们通常说现有代码尽量保持不变，通过新增类的方式来满足，所以Comparable的缺点很明显，一旦某个类指定了比较方式后就无法做修改（除非是修改代码…），即使能修改代码我们也不知道会不会造成新的问题或新的需求产生，所以这是行不通的。而对于Comparator来说，它就显得更加灵活了，支持多个比较器，只要新增类即可，看如下的代码展示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Apple appleOne = <span class="keyword">new</span> Apple(<span class="number">1</span>, <span class="string">"red"</span>);</span><br><span class="line">        Apple appleTwo = <span class="keyword">new</span> Apple(<span class="number">2</span>, <span class="string">"green"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较Apple的大小</span></span><br><span class="line">        AppleCompareSize acs = <span class="keyword">new</span> AppleCompareSize();</span><br><span class="line">        acs.compare(appleOne, appleTwo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较Apple的颜色</span></span><br><span class="line">        AppleCompareColor acc = <span class="keyword">new</span> AppleCompareColor();</span><br><span class="line">        acc.compare(appleOne, appleTwo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    Apple(<span class="keyword">int</span> size, String color) &#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getter、setter</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleCompareSize</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Apple</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Apple o1, Apple o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getSize() &gt; o2.getSize() ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleCompareColor</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Apple</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Apple o1, Apple o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getColor().compareTo(o2.getColor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该很容易就能看出效果了，即使别人已经写好了一个比较器，对于新需求，我们只要增加即可，并不会出现修改或污染其他人代码的情况。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><div><span>总结</span></div></h3><p>Comparator与Comaparable的最大区别在于<code>Comparator能够定义多种不同的比较策略</code>，即新增多个比较来，同时避免往比较对象（Apple）中添加其他代码（比较）</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;在阅读TreeMap源码时发现了Comparable与Comparator，光是名字看起来就很像，既然都是比较器，那有何区别呢？实际上我对于比较器的使用场景并不是很多，所以这篇还是借鉴了别人的想法。&lt;/p&gt;
&lt;h3 id=&quot;比较&quot;&gt;&lt;a href=&quot;#比较&quot; class=&quot;headerlink&quot; title=&quot;比较&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;比较&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;通过下面的这段代码来说明问题。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Apple appleOne = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Apple(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Apple appleTwo = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Apple(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        appleOne.compareTo(appleTwo);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Apple&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Comparable&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;Apple&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String color;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Apple(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; size, String color)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.size = size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.color = color;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;compareTo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Apple o)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; size &amp;gt; o.size ? &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; : &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//比较Apple的大小&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//getter、setter&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索LinkedHashSet底层实现</title>
    <link href="http://zlia.tech/2019/11/06/explain-linkedhashset-sourcecode/"/>
    <id>http://zlia.tech/2019/11/06/explain-linkedhashset-sourcecode/</id>
    <published>2019-11-06T06:24:42.000Z</published>
    <updated>2019-11-06T06:24:42.323Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>额… 底层实现了LinkedHashMap，它的数据结构是<code>数组 + 链表 + 红黑树</code>，内部通过一条<code>链表</code>来维护<code>有序性</code>，按照插入顺序进行排列。代码只有100行…</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定初始容量与加载因子来初始化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loadFactor 指定加载因子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定初始容量来初始化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">16</span>, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定集合来初始化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Math.max(<span class="number">2</span>*c.size(), <span class="number">11</span>), .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>LinkedHashSet底层基于LinkedHashMap</p></li><li><p>LinkedHashSet有序、不可重复、非线程安全</p></li><li><p>LinkedHashSet允许空元素</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>基于LinkedHashMap</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;额… 底层实现了LinkedHashMap，它的数据结构是&lt;code&gt;数组 + 链表 + 红黑树&lt;/code&gt;，内部通过一条&lt;code&gt;链表&lt;/code&gt;来维护&lt;code&gt;有序性&lt;/code&gt;，按照插入顺序进行排列。代码只有100行…&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索TreeSet底层实现</title>
    <link href="http://zlia.tech/2019/11/06/explain-treeset-sourcecode/"/>
    <id>http://zlia.tech/2019/11/06/explain-treeset-sourcecode/</id>
    <published>2019-11-06T03:20:51.000Z</published>
    <updated>2019-11-06T03:20:51.091Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>TreeSet的内部实现基于TreeMap，所以它的数据结构是<code>红黑树</code>。注释也不总结了，此探索是基于<code>JDK1.8</code>，直接进入正题。</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//存储元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//既然用了TreeMap就要考虑值应该存什么，就是它了，不管新增的元素是什么，它都作为值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定NavigableMap实现类来初始化</span></span><br><span class="line"><span class="comment"> * ConcurrentSkipListMap是NavigableMap的实现类！！！埋下伏笔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class="line">    <span class="keyword">this</span>.m = m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定比较器进行初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> comparator 比较器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;&gt;(comparator));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定集合进行初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定Set集合进行初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s Set集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(SortedSet&lt;E&gt; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(s.comparator());</span><br><span class="line">    addAll(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.navigableKeySet().iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取按降序排列的迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 降序排列的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.descendingKeySet().iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取按降序排列的Set集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 降序排列的Set集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">descendingSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeSet&lt;&gt;(m.descendingMap());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TreeSet集合的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TreeSet集合是否为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TreeSet是否包含指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.containsKey(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否新增成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量添加指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Use linear-time version if applicable</span></span><br><span class="line">    <span class="keyword">if</span> (m.size()==<span class="number">0</span> &amp;&amp; c.size() &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        c <span class="keyword">instanceof</span> SortedSet &amp;&amp;</span><br><span class="line">        m <span class="keyword">instanceof</span> TreeMap) &#123;</span><br><span class="line">        SortedSet&lt;? extends E&gt; set = (SortedSet&lt;? extends E&gt;) c;</span><br><span class="line">        TreeMap&lt;E,Object&gt; map = (TreeMap&lt;E, Object&gt;) m;</span><br><span class="line">        Comparator&lt;?&gt; cc = set.comparator();</span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> E&gt; mc = map.comparator();</span><br><span class="line">        <span class="keyword">if</span> (cc==mc || (cc != <span class="keyword">null</span> &amp;&amp; cc.equals(mc))) &#123;</span><br><span class="line">            map.addAllForTreeSet(set, PRESENT); <span class="comment">//指定集合来添加一颗红黑树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定起始元素与结束元素及是否包含起始、结束元素来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * 当前对象是已经排好序了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromElement 起始元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromInclusive 子集中是否包含起始元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toElement 结束元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toInclusive 子集中是否包含结束元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, <span class="keyword">boolean</span> fromInclusive, E toElement,   <span class="keyword">boolean</span> toInclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeSet&lt;&gt;(m.subMap(fromElement, fromInclusive, toElement, toInclusive));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定结束元素及是否包含结束元素来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * 当前对象是已经排好序了，相当于起始元素已经指定好了</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toElement 结束元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inclusive 子集中是否包含结束元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement, <span class="keyword">boolean</span> inclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeSet&lt;&gt;(m.headMap(toElement, inclusive));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定起始元素及是否包含起始元素来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * 相当于介绍元素已经指定好了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromElement 起始元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inclusive 子集中是否包含起始元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement, <span class="keyword">boolean</span> inclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeSet&lt;&gt;(m.tailMap(fromElement, inclusive));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定起始元素与结束元素来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * 包含起始元素、不包含结束元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromElement 起始元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toElement 结束元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SortedSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, E toElement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> subSet(fromElement, <span class="keyword">true</span>, toElement, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取比较器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 比较器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator() &#123;</span><br><span class="line">    <span class="keyword">return</span> m.comparator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取排序后的第一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 排序后的第一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.firstKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取排序后的最后一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 排序后的最后一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">last</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.lastKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取小于指定元素的最大值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 小于指定元素的最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">lower</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.lowerKey(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取等于或小于指定元素的最大值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 等于或小于指定元素的最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">floor</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.floorKey(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取等于或大于指定元素的最小值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 等于或大于指定元素的最小值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">ceiling</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.ceilingKey(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取大于指定元素的最小值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 大于指定元素的最小值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">higher</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.higherKey(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取排序后的第一个元素并移除</span></span><br><span class="line"><span class="comment"> * 获取最左边的元素并移除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最左边的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map.Entry&lt;E,?&gt; e = m.pollFirstEntry();</span><br><span class="line">    <span class="keyword">return</span> (e == <span class="keyword">null</span>) ? <span class="keyword">null</span> : e.getKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取排序后的最后一个元素并移除</span></span><br><span class="line"><span class="comment"> * 获取最右边的元素并移除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最右边的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map.Entry&lt;E,?&gt; e = m.pollLastEntry();</span><br><span class="line">    <span class="keyword">return</span> (e == <span class="keyword">null</span>) ? <span class="keyword">null</span> : e.getKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>TreeSet底层是TreeMa，所以它的数据结构是红黑树</p></li><li><p>TreeSet有序、不可重复、非线程安全</p></li><li><p>TreeSet默认按照自然顺序排列元素，可指定比较器来自定义排序</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>基于TreeMap</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;TreeSet的内部实现基于TreeMap，所以它的数据结构是&lt;code&gt;红黑树&lt;/code&gt;。注释也不总结了，此探索是基于&lt;code&gt;JDK1.8&lt;/code&gt;，直接进入正题。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索HashSet底层实现</title>
    <link href="http://zlia.tech/2019/11/05/explain-hashset-sourcecode/"/>
    <id>http://zlia.tech/2019/11/05/explain-hashset-sourcecode/</id>
    <published>2019-11-05T12:59:05.000Z</published>
    <updated>2019-11-05T12:59:05.138Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>HashSet的底层实现依赖于HashMap，所以它的数据结构也是<code>数组 + 链表 + 红黑树</code>，而对于它的类注释也没什么好总结的，探索HashSet底层实现是基于<code>JDK1.8</code>。仔细一想，HashSet存在的意义是什么？有时候需要添加元素时，也就是只有单个对象，并没有所谓的键值对，或许还有些用处，可这ArrayList也能做到啊！可是相比之下，HashSet由于有HashMap撑腰，它的性能要高于ArrayList，所以我认为HashSet是List和Map独有的特性结合后的产物。</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//可序列化、可克隆</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接使用了HashMap来存储它的元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//既然用了HashMap就要考虑值应该存什么，就是它了，不管新增的元素是什么，它都作为值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定集合来初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量与加载因子来初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor 指定加载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量来初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量与加载因子来初始化</span></span><br><span class="line"><span class="comment"> * 对比上面这里构造了LinkedHashMap，说明它是有序的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor 指定加载因子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dummy 无实际意义，为了与上面的构造函数区分开来</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取元素个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashSet是否为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashSet是否包含指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否新增成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 浅克隆</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        newSet.map = (HashMap&lt;E, Object&gt;) map.clone();</span><br><span class="line">        <span class="keyword">return</span> newSet;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>HashSet无序、不可重复、非线程安全</p></li><li><p>HashSet允许存放空元素</p></li><li><p>HashSet底层基于HashMap</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>基于HashMap</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;HashSet的底层实现依赖于HashMap，所以它的数据结构也是&lt;code&gt;数组 + 链表 + 红黑树&lt;/code&gt;，而对于它的类注释也没什么好总结的，探索HashSet底层实现是基于&lt;code&gt;JDK1.8&lt;/code&gt;。仔细一想，HashSet存在的意义是什么？有时候需要添加元素时，也就是只有单个对象，并没有所谓的键值对，或许还有些用处，可这ArrayList也能做到啊！可是相比之下，HashSet由于有HashMap撑腰，它的性能要高于ArrayList，所以我认为HashSet是List和Map独有的特性结合后的产物。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>比较Map实现类的不同点</title>
    <link href="http://zlia.tech/2019/11/05/map-different-compare/"/>
    <id>http://zlia.tech/2019/11/05/map-different-compare/</id>
    <published>2019-11-05T08:22:02.000Z</published>
    <updated>2019-11-05T13:10:22.159Z</updated>
    
    <content type="html"><![CDATA[<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a><div><span>比较</span></div></h3><p>趁热打铁！比较最近学习到的几个Map实现类，也正好总结下！此比较是基于<code>JDK1.8</code>，直接用表格展示。</p><table><thead><tr><th style="text-align:center">比较点</th><th style="text-align:center">HashMap</th><th style="text-align:center">Hashtable</th><th style="text-align:center">IdentityHashMap</th><th style="text-align:center">LinkedHashMap</th><th style="text-align:center">TreeMap</th><th style="text-align:center">WeakHashMap</th></tr></thead><tbody><tr><td style="text-align:center">数据结构</td><td style="text-align:center">数组<br>链表<br>红黑树</td><td style="text-align:center">数组<br>链表</td><td style="text-align:center">数组<br>（哈希探针表）</td><td style="text-align:center">数组<br>链表<br>红黑树</td><td style="text-align:center">红黑树</td><td style="text-align:center">数组<br>链表</td></tr><tr><td style="text-align:center">是否有序/可重复</td><td style="text-align:center">无序不可重复</td><td style="text-align:center">无序不可重复</td><td style="text-align:center">无序不可重复</td><td style="text-align:center">默认按插入顺序排列<br>可按访问顺序排列<br>不可重复</td><td style="text-align:center">默认按自然顺序<br>可指定比较器进行自定义排序<br>不可重复</td><td style="text-align:center">无序不可重复</td></tr><tr><td style="text-align:center">键值对为null</td><td style="text-align:center">允许</td><td style="text-align:center">不允许</td><td style="text-align:center">允许</td><td style="text-align:center">允许</td><td style="text-align:center">默认排序中键不允许，值允许<br>自定义排序中键值对都允许</td><td style="text-align:center">允许</td></tr><tr><td style="text-align:center">默认初始容量</td><td style="text-align:center">16</td><td style="text-align:center">11</td><td style="text-align:center">64</td><td style="text-align:center">16</td><td style="text-align:center"></td><td style="text-align:center">16</td></tr><tr><td style="text-align:center">默认加载因子</td><td style="text-align:center">0.75</td><td style="text-align:center">0.75</td><td style="text-align:center">1/3</td><td style="text-align:center">0.75</td><td style="text-align:center"></td><td style="text-align:center">0.75</td></tr><tr><td style="text-align:center">扩容策略</td><td style="text-align:center">2 * capacity</td><td style="text-align:center">2 * capacity + 1</td><td style="text-align:center">2 * capacity</td><td style="text-align:center">2 * capacity</td><td style="text-align:center"></td><td style="text-align:center">2 * capacity</td></tr><tr><td style="text-align:center">计算hash方式</td><td style="text-align:center">hash ^ (hash &gt;&gt;&gt; 16)</td><td style="text-align:center">hash &amp; 0x7FFFFFFF</td><td style="text-align:center">(hash &lt;&lt; 1) - (hash &lt;&lt; 8)</td><td style="text-align:center">hash ^ (hash &gt;&gt;&gt; 16)</td><td style="text-align:center"></td><td style="text-align:center">有点复杂，就不贴了</td></tr><tr><td style="text-align:center">计算索引</td><td style="text-align:center">hash &amp; (capacity - 1)</td><td style="text-align:center">hash % capacity</td><td style="text-align:center">hash &amp; (capacity - 1)</td><td style="text-align:center">hash &amp; (capacity - 1)</td><td style="text-align:center"></td><td style="text-align:center">hash &amp; (capacity - 1)</td></tr><tr><td style="text-align:center">新增节点</td><td style="text-align:center">尾插法</td><td style="text-align:center">头插法</td><td style="text-align:center"></td><td style="text-align:center">尾插法</td><td style="text-align:center"></td><td style="text-align:center">头插法</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;比较&quot;&gt;&lt;a href=&quot;#比较&quot; class=&quot;headerlink&quot; title=&quot;比较&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;比较&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;趁热打铁！比较最近学习到的几个Map实现类，也正好总结下！此比较是基于&lt;code&gt;JDK1.
      
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索EnumMap底层实现</title>
    <link href="http://zlia.tech/2019/11/05/explain-enummap-sourcecode/"/>
    <id>http://zlia.tech/2019/11/05/explain-enummap-sourcecode/</id>
    <published>2019-11-05T08:17:02.000Z</published>
    <updated>2019-11-05T09:28:40.140Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>EnumMap初次见面，请多多关照！对于该类的注释直接上总结：</p><blockquote><p>专门用于<code>枚举类型</code>的键的Map实现。EnumMap内部的数据结构是数组，按枚举常量的声明顺序排列它的键，与其他Map实现类不同的是，它的迭代器并不会抛出快速失败错误！</p></blockquote><p>该类的代码不到1000行，速速解决掉，探索EnumMap底层实现是基于<code>JDK1.8</code>。</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumMap</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">K</span>&gt;, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 枚举类型的类类型</span></span><br><span class="line"><span class="comment">     * 为什么需要类类型呢? </span></span><br><span class="line"><span class="comment">     * 因为在一开始初始化时，EnumMap就会将枚举类的所有对象加载到数组中，所以每次添加节点时，实际上只是添加了值对象而已</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;K&gt; keyType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 包含枚举类的所有对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> K[] keyUniverse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储值对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Object[] vals;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点个数</span></span><br><span class="line"><span class="comment">     * vals数组中存储的值对象个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存entrySet方法的返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化键数组与值数组</span></span><br><span class="line"><span class="comment"> * 这个就是上面我们所说将枚举类型的所有对象存储到键数组中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keyType 枚举类型的类类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EnumMap</span><span class="params">(Class&lt;K&gt; keyType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.keyType = keyType;</span><br><span class="line">    keyUniverse = getKeyUniverse(keyType);<span class="comment">//该方法会将枚举类的所有对象按照声明的顺序存放</span></span><br><span class="line">    vals = <span class="keyword">new</span> Object[keyUniverse.length];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定EnumMap来初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m EnumMap对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EnumMap</span><span class="params">(EnumMap&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    keyType = m.keyType;</span><br><span class="line">    keyUniverse = m.keyUniverse;</span><br><span class="line">    vals = m.vals.clone();</span><br><span class="line">    size = m.size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定集合来初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EnumMap</span><span class="params">(Map&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m <span class="keyword">instanceof</span> EnumMap) &#123;</span><br><span class="line">        EnumMap&lt;K, ? extends V&gt; em = (EnumMap&lt;K, ? extends V&gt;) m;</span><br><span class="line">        keyType = em.keyType;</span><br><span class="line">        keyUniverse = em.keyUniverse;</span><br><span class="line">        vals = em.vals.clone();</span><br><span class="line">        size = em.size;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (m.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Specified map is empty"</span>);</span><br><span class="line">        keyType = m.keySet().iterator().next().getDeclaringClass();</span><br><span class="line">        keyUniverse = getKeyUniverse(keyType);</span><br><span class="line">        vals = <span class="keyword">new</span> Object[keyUniverse.length];</span><br><span class="line">        putAll(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 倘若值为null则采用NULL_KEY作为值</span></span><br><span class="line"><span class="comment"> * 正如方法名一样，隐藏Null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> NULL_KEY或指定值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">maskNull</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (value == <span class="keyword">null</span> ? NULL : value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 倘若值为NULL_KEY则返回null</span></span><br><span class="line"><span class="comment"> * 正如方法名一样，揭露Null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或指定值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">unmaskNull</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (V)(value == NULL ? <span class="keyword">null</span> : value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取节点个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 节点个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组中是否包含指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    value = maskNull(value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object val : vals)</span><br><span class="line">        <span class="keyword">if</span> (value.equals(val))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组中是否包含指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isValidKey(key) &amp;&amp; vals[((Enum&lt;?&gt;)key).ordinal()] != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键是否有效</span></span><br><span class="line"><span class="comment"> * 是否符合指定的类类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否有效</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; keyClass = key.getClass();</span><br><span class="line">    <span class="keyword">return</span> keyClass == keyType || keyClass.getSuperclass() == keyType; <span class="comment">//keyClass.getSuperclass这个判断语句没有什么意义，枚举类既不能继承其他类，也不能被继承，两个类就无法发生关系，那这个判断结果只会是false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组中是否包含指定键值对</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含键值对</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">containsMapping</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isValidKey(key) &amp;&amp; maskNull(value).equals(vals[((Enum&lt;?&gt;)key).ordinal()]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键获取值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (isValidKey(key) ? unmaskNull(vals[((Enum&lt;?&gt;)key).ordinal()]) : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增键值对</span></span><br><span class="line"><span class="comment"> * 可能会发生替换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    typeCheck(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = key.ordinal();</span><br><span class="line">    Object oldValue = vals[index];</span><br><span class="line">    vals[index] = maskNull(value);</span><br><span class="line">    <span class="keyword">if</span> (oldValue == <span class="keyword">null</span>)</span><br><span class="line">        size++;</span><br><span class="line">    <span class="keyword">return</span> unmaskNull(oldValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键移除值对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isValidKey(key))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> index = ((Enum&lt;?&gt;)key).ordinal();</span><br><span class="line">    Object oldValue = vals[index];</span><br><span class="line">    vals[index] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldValue != <span class="keyword">null</span>)</span><br><span class="line">        size--;</span><br><span class="line">    <span class="keyword">return</span> unmaskNull(oldValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键值对移除值对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除值对象成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">removeMapping</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isValidKey(key))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> index = ((Enum&lt;?&gt;)key).ordinal();</span><br><span class="line">    <span class="keyword">if</span> (maskNull(value).equals(vals[index])) &#123;</span><br><span class="line">        vals[index] = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量添加集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123; <span class="comment">//枚举类之间无法继承，所以这里压根就只能指定K、V</span></span><br><span class="line">    <span class="keyword">if</span> (m <span class="keyword">instanceof</span> EnumMap) &#123;</span><br><span class="line">        EnumMap&lt;?, ?&gt; em = (EnumMap&lt;?, ?&gt;)m;</span><br><span class="line">        <span class="keyword">if</span> (em.keyType != keyType) &#123;</span><br><span class="line">            <span class="keyword">if</span> (em.isEmpty())</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException(em.keyType + <span class="string">" != "</span> + keyType);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; keyUniverse.length; i++) &#123;</span><br><span class="line">            Object emValue = em.vals[i];</span><br><span class="line">            <span class="keyword">if</span> (emValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vals[i] == <span class="keyword">null</span>)</span><br><span class="line">                    size++;</span><br><span class="line">                vals[i] = emValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.putAll(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中间省略了相关迭代器...较为简单相似，有兴趣的读者可自行查看</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空值数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Arrays.fill(vals, <span class="keyword">null</span>);</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取枚举类中所有对象的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keyType 枚举类类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有对象的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;K extends Enum&lt;K&gt;&gt; K[] getKeyUniverse(Class&lt;K&gt; keyType) &#123;</span><br><span class="line">    <span class="keyword">return</span> SharedSecrets.getJavaLangAccess().getEnumConstantsShared(keyType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>专门用于其键为<code>枚举类型</code>的Map实现</p></li><li><p>EnumMap的数据结构是数组，按枚举常量的声明顺序进行排列</p></li><li><p>EnumMap的键不允许为空，值允许为空</p></li><li><p>EnumMap的迭代器不会发生快速失败</p></li><li><p>EnumMap有序、不可重复、非线程安全</p></li><li><p>EnumMap在初始化时将枚举类中的所有对象存储到数组中，而后续的增删改查实际上都是对其值对象的操作</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>内部实现机制</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;EnumMap初次见面，请多多关照！对于该类的注释直接上总结：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;专门用于&lt;code&gt;枚举类型&lt;/code&gt;的键的Map实现。EnumMap内部的数据结构是数组，按枚举常量的声明顺序排列它的键，与其他Map实现类不同的是，它的迭代器并不会抛出快速失败错误！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该类的代码不到1000行，速速解决掉，探索EnumMap底层实现是基于&lt;code&gt;JDK1.8&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索WeakHashMap底层实现</title>
    <link href="http://zlia.tech/2019/11/04/explain-weakhashmap-sourcecode/"/>
    <id>http://zlia.tech/2019/11/04/explain-weakhashmap-sourcecode/</id>
    <published>2019-11-04T10:00:55.000Z</published>
    <updated>2019-11-05T06:34:25.218Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>探索<code>WeakHashMap</code>底层实现是基于<code>JDK1.8</code>，它的数据结构是<code>数组 + 链表</code>。就不贴它的注释了，直接总结一下吧：</p><blockquote><p>WeakHashMap基于<code>弱键</code>实现了Map接口，也就是说，当某个键不在使用时会被丢弃，对应的键值对将会被自动移除。如何确定不在使用取决于GC是否运行，而对于GC何时运行我们并不知道，所以某个键何时被丢弃我们也不得而知，至于GC如何运行就是另外一个话题了，有可能导致上一分钟与下一分钟获取到的结果是不一致的。另一个方面，WeakHashMap的值对象由强引用所持有（何为强引用下面会介绍），应确保值对象不会直接或间接引用自身的键或其他键，这会导致键无法被丢弃。</p></blockquote><ul><li><p>强引用：简单来说指向new出来的对象就是一个强引用，可以说是经常使用。对于强引用来说，它们不会被GC回收，即使内存空间不足，JVM宁愿抛出内存溢出错误也不敢动它们，总体来说还是很有威信的。</p></li><li><p>软引用：首先给强引用包裹上一层<code>SoftReference</code>，通过SoftReference获取到的引用即为软引用。对于软引用来说，在内存充足的情况下，GC可以选择性的清除，而一旦内存不足了，它们一个都跑不了，都会被清除掉。软引用最常用用于实现对内存敏感的缓存。</p></li><li><p>弱引用：首先给强引用包裹上一层<code>WeakReference</code>，通过WeakReference获取到的引用即为弱引用，看到这里你应该就已经明白了WeakHashMap内部的机制。对于弱引用来说，GC压根就不管内存是否充足，直接回收，很没有人性！</p></li><li><p>虚引用：首先给强引用包裹上一层<code>PhantomReference</code>，通过PhantomReference获取到的引用即为虚引用。对于虚引用来说，它在任何时候都可能被回收，常用于跟踪对象。</p></li></ul><p>还有一个方面，读者最好去了解下<code>Reference</code>类，内部通过队列实现了一些机制。</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><p>前奏都准备好了，开始进入正题吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始容量，必须是2的幂次方，可参考HashMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大容量，必须是2的幂次方</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认加载因子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希表，长度必须是2的幂次方</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Entry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希表中包含节点的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩容前需要判断的阈值</span></span><br><span class="line"><span class="comment">     * 若超过该值则扩容，若没超过则不需要</span></span><br><span class="line"><span class="comment">     * 该值的计算方式：capacity * load factor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载因子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用队列</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 为什么需要引用队列呢?</span></span><br><span class="line"><span class="comment">     * 通过上面的介绍我们可以知道哈希表中某些键可能会被移除掉，而移除是GC帮我们做的，那WeakHashMap怎么知道哪些键被移除掉了以便更新自己的键值对，就是该队列做了它们两个之间的媒介</span></span><br><span class="line"><span class="comment">     * 上面让读者去了解Reference类，下面讲的内容其实都在该类中有提到，比较简单</span></span><br><span class="line"><span class="comment">     * GC在丢弃某个键时会将它的键值对，也就是节点信息存放到Reference类中的pending队列中，Reference类在初始化时会启动一个线程，那么该线程会将pending队列中的节点信息放入到queue队列中</span></span><br><span class="line"><span class="comment">     * 也就是在告诉WeakHashMap，队列中的这些节点是我要删除的，你记得更新</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存entrySet方法的返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结构修改的次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> modCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量与加载因子构造哈希表</span></span><br><span class="line"><span class="comment"> * 在上面中我们提到了容量必须是2的幂次方，所以调用tableSizeFor方法来进行调整</span></span><br><span class="line"><span class="comment"> * Float.isNaN：检测是否是数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor 指定加载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeakHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Initial Capacity: "</span>+ initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Load factor: "</span>+ loadFactor);</span><br><span class="line">    <span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (capacity &lt; initialCapacity) <span class="comment">//这段代码有点精髓啊，个人感觉比HashMap中的算法简单，两者要表达的意思是一致的，都是获取大于initialCapacity的最小值</span></span><br><span class="line">        capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    table = newTable(capacity);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(capacity * loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量与默认加载因子（0.75）构造哈希表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeakHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始容量（16）与默认加载因子（0.75）构造哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeakHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定集合添加到哈希表中，采用默认加载因子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeakHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);<span class="comment">//Math.max是为了获取尽可能大的容量</span></span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定长度构造哈希表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 指定长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">private</span> Entry&lt;K,V&gt;[] newTable(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">return</span> (Entry&lt;K,V&gt;[]) <span class="keyword">new</span> Entry&lt;?,?&gt;[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 倘若键为null则采用NULL_KEY作为键</span></span><br><span class="line"><span class="comment"> * 正如方法名一样，隐藏Null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> NULL_KEY或指定键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">maskNull</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? NULL_KEY : key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 倘若键为NULL_KEY则返回null</span></span><br><span class="line"><span class="comment"> * 正如方法名一样，揭露Null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 哈希表中的键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或指定键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">unmaskNull</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (key == NULL_KEY) ? <span class="keyword">null</span> : key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 两个对象是否相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> y 另外一个对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否相等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">eq</span><span class="params">(Object x, Object y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == y || x.equals(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算哈希值</span></span><br><span class="line"><span class="comment"> * 这边的计算哈希值比HashMap复杂多了，涉及到算法的内容我感觉我没办法理解到位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = k.hashCode();</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算哈希表中的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h 哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length 哈希表的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清除哈希表中过时的节点信息</span></span><br><span class="line"><span class="comment"> * 过时指的是已经被丢弃的键，也可以说是被GC回收的键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object x; (x = queue.poll()) != <span class="keyword">null</span>; ) &#123;<span class="comment">//poll：队列中获取首部节点并删除</span></span><br><span class="line">        <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, table.length);</span><br><span class="line"></span><br><span class="line">            Entry&lt;K,V&gt; prev = table[i]; <span class="comment">//代表当前节点的上一个节点</span></span><br><span class="line">            Entry&lt;K,V&gt; p = prev;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (prev == e) <span class="comment">//说明当前节点是链表的首部节点</span></span><br><span class="line">                        table[i] = next;</span><br><span class="line">                    <span class="keyword">else</span> <span class="comment">//说明当前节点不是首部节点</span></span><br><span class="line">                        prev.next = next;</span><br><span class="line">                    <span class="comment">// Must not null out e.next;</span></span><br><span class="line">                    <span class="comment">// stale entries may be in use by a HashIterator</span></span><br><span class="line">                    e.value = <span class="keyword">null</span>; <span class="comment">// Help GC</span></span><br><span class="line">                    size--;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取哈希表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Entry&lt;K,V&gt;[] getTable() &#123;</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取哈希表的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希表的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表是否为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希表是否为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键获取指</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    <span class="keyword">int</span> h = hash(k);</span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    <span class="keyword">int</span> index = indexFor(h, tab.length);</span><br><span class="line">    Entry&lt;K,V&gt; e = tab[index];</span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == h &amp;&amp; eq(k, e.get()))</span><br><span class="line">            <span class="keyword">return</span> e.value;</span><br><span class="line">        e = e.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否包含指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getEntry(key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键获取节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    <span class="keyword">int</span> h = hash(k);</span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    <span class="keyword">int</span> index = indexFor(h, tab.length);</span><br><span class="line">    Entry&lt;K,V&gt; e = tab[index];</span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span> &amp;&amp; !(e.hash == h &amp;&amp; eq(k, e.get())))</span><br><span class="line">        e = e.next;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增节点</span></span><br><span class="line"><span class="comment"> * 链表中采用头插法的方式进行新增节点</span></span><br><span class="line"><span class="comment"> * 若超过阈值则会进行扩容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    <span class="keyword">int</span> h = hash(k);</span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(h, tab.length); <span class="comment">//获取索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123; <span class="comment">//链表中判断是否重复</span></span><br><span class="line">        <span class="keyword">if</span> (h == e.hash &amp;&amp; eq(k, e.get())) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (value != oldValue)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    Entry&lt;K,V&gt; e = tab[i];</span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry&lt;&gt;(k, value, queue, h, e);</span><br><span class="line">    <span class="keyword">if</span> (++size &gt;= threshold)</span><br><span class="line">        resize(tab.length * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt;[] oldTable = getTable();</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry&lt;K,V&gt;[] newTable = newTable(newCapacity);</span><br><span class="line">    transfer(oldTable, newTable); <span class="comment">//将源哈希表中的所有节点信息复制到目标哈希表中</span></span><br><span class="line">    table = newTable;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果忽略null元素并处理队列导致大量收缩，则还原旧表。 这应该很少见，但是可以避免持有大量无用节点的哈希表的无限扩展。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold / <span class="number">2</span>) &#123;</span><br><span class="line">        threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//GC回收了大量的节点后则不进行扩容</span></span><br><span class="line">        expungeStaleEntries(); <span class="comment">//检测新表中哪些节点已经被丢弃了</span></span><br><span class="line">        transfer(newTable, oldTable);</span><br><span class="line">        table = oldTable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将源哈希表中的所有节点信息复制到目标哈希表中</span></span><br><span class="line"><span class="comment"> * 源哈希表中可能出现被丢弃的键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src 源哈希表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dest 目标哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry&lt;K,V&gt;[] src, Entry&lt;K,V&gt;[] dest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; ++j) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        src[j] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            Object key = e.get(); <span class="comment">//若当前节点已经被GC回收了，则此方法返回将返回null</span></span><br><span class="line">            <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.next = <span class="keyword">null</span>;  <span class="comment">// Help GC</span></span><br><span class="line">                e.value = <span class="keyword">null</span>; <span class="comment">//  "   "</span></span><br><span class="line">                size--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, dest.length); <span class="comment">//该索引出现的可能应该跟HashMap是一样的，原索引或与原索引 + 旧容量的大小，只不过它是一个一个的计算并添加，而HashMap是分批计算，一次性添加</span></span><br><span class="line">                e.next = dest[i];</span><br><span class="line">                dest[i] = e;</span><br><span class="line">            &#125;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量添加节点到哈希表中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numKeysToBeAdded = m.size();</span><br><span class="line">    <span class="keyword">if</span> (numKeysToBeAdded == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 倘若指定集合的键值对数量超过阈值则进行扩容. 这是保守的；</span></span><br><span class="line"><span class="comment">      * 很明显的条件应该是 (m.size + size) &gt;= threshold， 但是这个条件会导致适当的容量变成2倍，如果被添加的键已经存在于哈希表中.</span></span><br><span class="line"><span class="comment">      * 通过使用保守的计算，我们最多只能调整一种尺寸。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">if</span> (numKeysToBeAdded &gt; threshold) &#123;</span><br><span class="line">        <span class="keyword">int</span> targetCapacity = (<span class="keyword">int</span>)(numKeysToBeAdded / loadFactor + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (targetCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            targetCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = table.length;</span><br><span class="line">        <span class="keyword">while</span> (newCapacity &lt; targetCapacity)</span><br><span class="line">            newCapacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity &gt; table.length) <span class="comment">//预先计算好要添加节点的数量以便进行一次性扩容</span></span><br><span class="line">            resize(newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</span><br><span class="line">        put(e.getKey(), e.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键移除节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    <span class="keyword">int</span> h = hash(k);</span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(h, tab.length);</span><br><span class="line">    Entry&lt;K,V&gt; prev = tab[i];</span><br><span class="line">    Entry&lt;K,V&gt; e = prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">        <span class="keyword">if</span> (h == e.hash &amp;&amp; eq(k, e.get())) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">if</span> (prev == e)</span><br><span class="line">                tab[i] = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                prev.next = next;</span><br><span class="line">            <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = e;</span><br><span class="line">        e = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键移除节点是否成功</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 移除节点是否成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeMapping</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">    Object k = maskNull(entry.getKey());</span><br><span class="line">    <span class="keyword">int</span> h = hash(k);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(h, tab.length);</span><br><span class="line">    Entry&lt;K,V&gt; prev = tab[i];</span><br><span class="line">    Entry&lt;K,V&gt; e = prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">        <span class="keyword">if</span> (h == e.hash &amp;&amp; e.equals(entry)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">if</span> (prev == e)</span><br><span class="line">                tab[i] = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                prev.next = next;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = e;</span><br><span class="line">        e = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (queue.poll() != <span class="keyword">null</span>) <span class="comment">//清空队列中只有一部分过时节点</span></span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    Arrays.fill(table, <span class="keyword">null</span>); <span class="comment">//清空哈希表后</span></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空哈希表后可能导致GC，另外一部分节点会被添加到队列中，所以此处需要再次清空队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (queue.poll() != <span class="keyword">null</span>)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表中是否包含指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> containsNullValue();</span><br><span class="line"></span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tab.length; i-- &gt; <span class="number">0</span>;)</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">            <span class="keyword">if</span> (value.equals(e.value))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表中是否包含null值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含null值 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">containsNullValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tab.length; i-- &gt; <span class="number">0</span>;)</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">            <span class="keyword">if</span> (e.value==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表中的节点，该类继承了WeakReference加上调用了父类的构造，说明它的键是个弱引用</span></span><br><span class="line"><span class="comment"> * 该类中的其他方法就不做展示了，比较简单</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    V value;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     * 指定键生成弱引用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queue 与弱引用关联的队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash 哈希值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> next 下一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Entry(Object key, V value, ReferenceQueue&lt;Object&gt; queue, <span class="keyword">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(key, queue);</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.hash  = hash;</span><br><span class="line">        <span class="keyword">this</span>.next  = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历所有键并执行指定动作</span></span><br><span class="line"><span class="comment"> * 遍历过程中不允许WeakHashMap调用任何会修改结构的方法，否则最后会抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action 指定动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    Entry&lt;K, V&gt;[] tab = getTable();</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K, V&gt; entry : tab) &#123;</span><br><span class="line">        <span class="keyword">while</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object key = entry.get();</span><br><span class="line">            <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                action.accept((K)WeakHashMap.unmaskNull(key), entry.value);</span><br><span class="line">            &#125;</span><br><span class="line">            entry = entry.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (expectedModCount != modCount) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历哈希表并执行指定动作后获取新值，利用新值替换所有节点的旧值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> function 指定动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; function)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(function);</span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    Entry&lt;K, V&gt;[] tab = getTable();;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K, V&gt; entry : tab) &#123;</span><br><span class="line">        <span class="keyword">while</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object key = entry.get();</span><br><span class="line">            <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                entry.value = function.apply((K)WeakHashMap.unmaskNull(key), entry.value);</span><br><span class="line">            &#125;</span><br><span class="line">            entry = entry.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (expectedModCount != modCount) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一些重复性的东西，比如包含键、值、键值对的迭代器、可分割迭代器就不讲解了，可参考HashMap</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>WeakHashMap的键值对允许为null</p></li><li><p>WeakHashMap采用弱键，当某个键不在使用时会被GC回收，而键对应的节点也会被移除掉</p></li><li><p>WeakHashMap无序不可重复、非线程安全</p></li><li><p>在添加节点，值对象最好不要与任何的键直接或间接的关联，否则GC无法丢弃该键</p></li><li><p>WeakHashMap#ReferendeQueue是用来查看哈希表中哪些键被丢球了，以便哈希表能够及时更新</p></li><li><p>WeakHashMap的容量必须是2的幂次方</p></li><li><p>WeakHashMap在新增节点时采用的是头插法</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>弱键</code> <code>ReferenceQueue</code> <code>头插法</code> <code>强、软、弱、虚引用</code> <code>Reference</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;探索&lt;code&gt;WeakHashMap&lt;/code&gt;底层实现是基于&lt;code&gt;JDK1.8&lt;/code&gt;，它的数据结构是&lt;code&gt;数组 + 链表&lt;/code&gt;。就不贴它的注释了，直接总结一下吧：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;WeakHashMap基于&lt;code&gt;弱键&lt;/code&gt;实现了Map接口，也就是说，当某个键不在使用时会被丢弃，对应的键值对将会被自动移除。如何确定不在使用取决于GC是否运行，而对于GC何时运行我们并不知道，所以某个键何时被丢弃我们也不得而知，至于GC如何运行就是另外一个话题了，有可能导致上一分钟与下一分钟获取到的结果是不一致的。另一个方面，WeakHashMap的值对象由强引用所持有（何为强引用下面会介绍），应确保值对象不会直接或间接引用自身的键或其他键，这会导致键无法被丢弃。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;强引用：简单来说指向new出来的对象就是一个强引用，可以说是经常使用。对于强引用来说，它们不会被GC回收，即使内存空间不足，JVM宁愿抛出内存溢出错误也不敢动它们，总体来说还是很有威信的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;软引用：首先给强引用包裹上一层&lt;code&gt;SoftReference&lt;/code&gt;，通过SoftReference获取到的引用即为软引用。对于软引用来说，在内存充足的情况下，GC可以选择性的清除，而一旦内存不足了，它们一个都跑不了，都会被清除掉。软引用最常用用于实现对内存敏感的缓存。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;弱引用：首先给强引用包裹上一层&lt;code&gt;WeakReference&lt;/code&gt;，通过WeakReference获取到的引用即为弱引用，看到这里你应该就已经明白了WeakHashMap内部的机制。对于弱引用来说，GC压根就不管内存是否充足，直接回收，很没有人性！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;虚引用：首先给强引用包裹上一层&lt;code&gt;PhantomReference&lt;/code&gt;，通过PhantomReference获取到的引用即为虚引用。对于虚引用来说，它在任何时候都可能被回收，常用于跟踪对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有一个方面，读者最好去了解下&lt;code&gt;Reference&lt;/code&gt;类，内部通过队列实现了一些机制。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索Hashtable底层实现</title>
    <link href="http://zlia.tech/2019/10/31/explain-hashtable-sourcecode/"/>
    <id>http://zlia.tech/2019/10/31/explain-hashtable-sourcecode/</id>
    <published>2019-10-31T10:15:34.000Z</published>
    <updated>2019-11-29T02:18:43.657Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>探索<code>Hashtable</code>底层实现是基于<code>JDK1.8</code>，它的数据结构是<code>数组 + 链表</code>。在不考虑线程是否安全的前提下，它的很多细节处理都不如HashMap，何况如今的HashMap又加了<code>红黑树</code>，查询修改肯定比不上，因为红黑树的时间复杂度是O（logN），而链表的时间复杂度是O（N），新增与删除无法比较，毕竟两者的策略不一致；而倘若比较讨论并发的话，<code>ConcurrentHashMap</code>比它更适合，Hashtable的作者也说了，看来是已经废弃的节奏了。</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><p>既然是与HashMap类似，那数据结构上肯定比它简单，我们就速速通过！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//可克隆、序列化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希表，负责存储节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希表中节点的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阈值 = 初始容量 * 加载因子    当超过指定阈值时会对哈希表重新散列，所有节点（链表）重新计算在新表中的索引，这就相当于所有节点都要参与计算、在新表中设置，效率非常地下</span></span><br><span class="line"><span class="comment">     * HashMap是先将所有节点分成两部分，最终只需要在新表中设置这两部分即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载因子，容量大小不变的情况下，加载因子过大减少空间开销，增加查询成本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结构修改的次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//包含所有键的迭代器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Set&lt;K&gt; keySet;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//包含所有键值对的迭代器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//包含所有值的迭代器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Collection&lt;V&gt; values;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大容量，若设置过高的话可能会发生内存泄露</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义键类型，用于迭代器或枚举</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEYS = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义值类型，用于迭代器或枚举</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALUES = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义键值对类型，用于迭代器或枚举</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ENTRIES = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量与加载因子构造哈希表</span></span><br><span class="line"><span class="comment"> * Float.isNaN：检测是否是数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor 指定加载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span> + initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Load: "</span>+loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</span><br><span class="line">        initialCapacity = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    table = <span class="keyword">new</span> Entry&lt;?,?&gt;[initialCapacity]; <span class="comment">//初始化哈希表</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>); <span class="comment">//设置阈值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量与默认加载因子（0.75）构造哈希表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始容量（11）与默认加载因子（0.75）构造哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定集合添加到哈希表中，采用默认加载因子</span></span><br><span class="line"><span class="comment"> * 设置尽可能大的初始容量以便减少重新散列的次数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(Map&lt;? extends K, ? extends V&gt; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Math.max(<span class="number">2</span>*t.size(), <span class="number">11</span>), <span class="number">0.75f</span>);</span><br><span class="line">    putAll(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取哈希表中的元素个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希表中的元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断哈希表是否为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希表是否为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有键的枚举</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有键的枚举</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Enumeration&lt;K&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.&lt;K&gt;getEnumeration(KEYS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有值的枚举</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有值的枚举</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Enumeration&lt;V&gt; <span class="title">elements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.&lt;V&gt;getEnumeration(VALUES);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表中是否包含指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tab.length ; i-- &gt; <span class="number">0</span> ;) &#123; <span class="comment">//遍历哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[i] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.value.equals(value)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表中是否包含指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> contains(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表中是否包含指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 0x7FFFFFFF = 0111 1111 1111 1111 1111 1111 1111 1111</span></span><br><span class="line"><span class="comment">     * hash &amp; 0x7FFFFFFF 是为了保证结果不出现负数的情况，否则负数取余之后的结果也就为负数了，索引并没有负数</span></span><br><span class="line"><span class="comment">     * hash &amp; 0x7FFFFFFF % tab.leng 是为了取在[0, tab.length -1]区间内的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键获取值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; <span class="comment">//hash与equasl都相等才算是相等</span></span><br><span class="line">            <span class="keyword">return</span> (V)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容并重新散列所有节点</span></span><br><span class="line"><span class="comment"> * 新容量 = 旧容量 * 2 + 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = table.length;</span><br><span class="line">    Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">            <span class="comment">// Keep running with MAX_ARRAY_SIZE buckets</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;?,?&gt;[] newMap = <span class="keyword">new</span> Entry&lt;?,?&gt;[newCapacity];</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">    table = newMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123; <span class="comment">//将哈希表中的所有节点，包括链表都进行重新散列</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != <span class="keyword">null</span> ; ) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = old;</span><br><span class="line">            old = old.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> index = (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;<span class="comment">//重新计算在新表中的索引</span></span><br><span class="line">            e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">            newMap[index] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增节点</span></span><br><span class="line"><span class="comment"> * 采用头插法，每新增一个节点就放到链表的头部</span></span><br><span class="line"><span class="comment"> * 节点个数超过阈值时会进行扩容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">        <span class="comment">// Rehash the table if the threshold is exceeded</span></span><br><span class="line">        rehash();</span><br><span class="line"></span><br><span class="line">        tab = table;</span><br><span class="line">        hash = key.hashCode();</span><br><span class="line">        index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creates the new entry.</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">    tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增节点</span></span><br><span class="line"><span class="comment"> * 若发生重复则进行值替换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make sure the value is not null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123; <span class="comment">//遍历链表看看是否有重复的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            V old = entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键移除节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K,V&gt; prev = <span class="keyword">null</span> ; e != <span class="keyword">null</span> ; prev = e, e = e.next) &#123; <span class="comment">//遍历链表 prev：前一个节点  e：当前节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                prev.next = e.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[index] = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量添加节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : t.entrySet())</span><br><span class="line">        put(e.getKey(), e.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = tab.length; --index &gt;= <span class="number">0</span>; )</span><br><span class="line">        tab[index] = <span class="keyword">null</span>;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 浅拷贝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 克隆后的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Hashtable&lt;?,?&gt; t = (Hashtable&lt;?,?&gt;)<span class="keyword">super</span>.clone();</span><br><span class="line">        t.table = <span class="keyword">new</span> Entry&lt;?,?&gt;[table.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = table.length ; i-- &gt; <span class="number">0</span> ; ) &#123;</span><br><span class="line">            t.table[i] = (table[i] != <span class="keyword">null</span>)</span><br><span class="line">                ? (Entry&lt;?,?&gt;) table[i].clone() : <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t.keySet = <span class="keyword">null</span>;</span><br><span class="line">        t.entrySet = <span class="keyword">null</span>;</span><br><span class="line">        t.values = <span class="keyword">null</span>;</span><br><span class="line">        t.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据类型获取枚举</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type 类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 枚举</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Enumeration&lt;T&gt; <span class="title">getEnumeration</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyEnumeration();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Enumerator&lt;&gt;(type, <span class="keyword">false</span>);<span class="comment">//false不允许删除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据类型获取迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type 类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Iterator&lt;T&gt; <span class="title">getIterator</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyIterator();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Enumerator&lt;&gt;(type, <span class="keyword">true</span>);<span class="comment">//true允许删除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有键的迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有键的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (keySet == <span class="keyword">null</span>)</span><br><span class="line">        keySet = Collections.synchronizedSet(<span class="keyword">new</span> KeySet(), <span class="keyword">this</span>);<span class="comment">//线程安全</span></span><br><span class="line">    <span class="keyword">return</span> keySet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有键值对的迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有键值对的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    <span class="keyword">if</span> (entrySet==<span class="keyword">null</span>)</span><br><span class="line">        entrySet = Collections.synchronizedSet(<span class="keyword">new</span> EntrySet(), <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> entrySet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有值的迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有值的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (values==<span class="keyword">null</span>)</span><br><span class="line">        values = Collections.synchronizedCollection(<span class="keyword">new</span> ValueCollection(), <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前节点的哈希值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前节点的键</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前节点的值</span></span><br><span class="line">    V value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前节点的下一个节点</span></span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有些方法并没有展示，请参考HashMap</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>Hashtable的键值对不允许为空，因为它是直接拿这个键去获取哈希值，这不就造成空指针了（感觉有点白痴），它还对值做了空指针判断</p></li><li><p>Hashtable默认初始容量11、默认加载因子0.75</p></li><li><p>Hashtable扩容时以<code>2倍 + 1</code>进行增长，旧表中的所有节点重新散列到新表中，效率较为低下</p></li><li><p>Hashtable计算索引时采用的是取余，而HashMap采用的与运算</p></li><li><p>Hashtable新增节点时采用的头插法</p></li><li><p>Hashtable计算hash值的方式可能会出现高位不同低位相同的两个不同数造成最终的索引相同，相比hashMap，它的hash计算方式降低了碰撞的概率</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>键值对不允许null</code> <code>计算索引采用取余</code> <code>头插法</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;探索&lt;code&gt;Hashtable&lt;/code&gt;底层实现是基于&lt;code&gt;JDK1.8&lt;/code&gt;，它的数据结构是&lt;code&gt;数组 + 链表&lt;/code&gt;。在不考虑线程是否安全的前提下，它的很多细节处理都不如HashMap，何况如今的HashMap又加了&lt;code&gt;红黑树&lt;/code&gt;，查询修改肯定比不上，因为红黑树的时间复杂度是O（logN），而链表的时间复杂度是O（N），新增与删除无法比较，毕竟两者的策略不一致；而倘若比较讨论并发的话，&lt;code&gt;ConcurrentHashMap&lt;/code&gt;比它更适合，Hashtable的作者也说了，看来是已经废弃的节奏了。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索TreeMap底层实现</title>
    <link href="http://zlia.tech/2019/10/31/explain-treemap-sourcecode/"/>
    <id>http://zlia.tech/2019/10/31/explain-treemap-sourcecode/</id>
    <published>2019-10-31T03:31:42.000Z</published>
    <updated>2019-11-06T03:13:15.560Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>探索<code>TreeMap</code>底层实现是基于<code>JDK1.8</code>，通过该类的注释可以了解它的数据结构是<code>红黑树</code>，默认是按照<code>自然顺序</code>进行排序（所有的键都必须去实现<code>Comparable</code>），当然也可以通过<code>指定比较器</code>进行排序（所有的键都必须实现<code>Comparator</code>）。至于什么是红黑树，读者最好有一定的了解，那看懂它的源码也就是分分钟的事了。</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//可序列化、克隆</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 比较器</span></span><br><span class="line"><span class="comment">     * 通过该比较器来维持顺序，若为null则按照自然顺序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 红黑树的根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 红黑树中节点的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结构修改的次数，用来检测快速失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 红色标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED   = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 黑色标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存entrySet方法的返回值，用于迭代器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> EntrySet entrySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储按照降序排列的键值对</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;K,V&gt; descendingMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储按照降序排列的键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> KeySet&lt;K&gt; navigableKeySet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始化</span></span><br><span class="line"><span class="comment"> * 按照自然顺序排列，所有的键都必须实现Comparable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    comparator = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定比较器来初始化</span></span><br><span class="line"><span class="comment"> * 按照比较器中定义的规则进行排列，所有的键都必须实现Comparator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> comparator 比较器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定集合到红黑树中</span></span><br><span class="line"><span class="comment"> * 按照自然顺序排列，所有的键都必须实现Comparable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    comparator = <span class="keyword">null</span>;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 添加指定有序集合到红黑树中，并采用该有序集合的比较器作为红黑树的比较器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 有序集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    comparator = m.comparator();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        buildFromSorted(m.size(), m.entrySet().iterator(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取红黑树中节点的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 节点的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树中是否包含指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getEntry(key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键获取红黑树节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 红黑树节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Offload comparator-based version for sake of performance</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) <span class="comment">//比较结果小于0说明在左子树上</span></span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) <span class="comment">//比较结果大于0说明在右子树上</span></span><br><span class="line">            p = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在红黑树中通过指定键与指定比较器获取节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntryUsingComparator</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        K k = (K) key;</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; p = root; <span class="comment">//获取红黑树的根节点</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = cpr.compare(k, p.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) <span class="comment">//比较结果小于0说明在左子树上</span></span><br><span class="line">                p = p.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)<span class="comment">//比较结果大于0说明在右子树上</span></span><br><span class="line">                p = p.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取等于或大于指定键的最小节点，若不存在，即红黑树中最大的键小于指定键则返回null</span></span><br><span class="line"><span class="comment"> * 大于指定键的最小节点：表示大于指定键且与指定键最为接近</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或指定键的最小节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getCeilingEntry</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = compare(key, p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) <span class="comment">//比较结果小于0可以明确的是已经找到大于指定键的节点了，但可能不是最小节点，故而往左子树继续查找</span></span><br><span class="line">                p = p.left;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) &#123; <span class="comment">//比较结果大于0说明还没有找到大于指定键的节点，故而继续往右子树上找</span></span><br><span class="line">                p = p.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 走到这里是已经没有右子树可以查找了，说明已经没有大于指定键的节点了，那么我们需要尝试往上查询之前找到的大于指定键的最近节点或压根就没有大于指定键的节点</span></span><br><span class="line"><span class="comment">                 * 针对查找大于指定键的节点，那么指定键的节点一定在该节点的左子树上（总体来看），所以最终只要不断去查找某个节点是否在其父节点的左子树即可，若是则它的父节点就是大于指定键的最近节点，若最终</span></span><br><span class="line"><span class="comment">                 * parent == null说明整个树始终都没有大于指定键的节点，也就返回null</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                Entry&lt;K,V&gt; parent = p.parent;</span><br><span class="line">                Entry&lt;K,V&gt; ch = p;</span><br><span class="line">                <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; ch == parent.right) &#123;</span><br><span class="line">                    ch = parent;</span><br><span class="line">                    parent = parent.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取等于或小于指定键的最大节点，若不存在，即红黑树中最小的键大于指定键则返回null</span></span><br><span class="line"><span class="comment"> * 小于指定键的最大节点：表示小于指定键且与指定键最为接近</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或指定键的最大节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getFloorEntry</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = compare(key, p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) <span class="comment">//比较结果大于0可以明确的是已经找到小于指定键的节点了，但可能不是最大节点，故而往右子树继续查找</span></span><br><span class="line">                p = p.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) &#123; <span class="comment">//比较结果小于0说明还没有找到小于指定键的节点，故而继续往左子树上找</span></span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 走到这里是已经没有左子树可以查找了，说明已经没有小于指定键的节点了，那么我们需要尝试往上查询之前找到的小于指定键的最近节点或压根就没有小于指定键的节点</span></span><br><span class="line"><span class="comment">                 * 针对查找小于指定键的节点，那么指定键的节点一定在该节点的右子树上（总体来看），所以最终只要不断去查找某个节点是否在其父节点的右子树即可，若是则它的父节点就是小于指定键的最近节点，若最终</span></span><br><span class="line"><span class="comment">                 * parent == null说明整个树始终都没有小于指定键的节点，也就返回null</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                Entry&lt;K,V&gt; parent = p.parent;</span><br><span class="line">                Entry&lt;K,V&gt; ch = p;</span><br><span class="line">                <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; ch == parent.left) &#123;</span><br><span class="line">                    ch = parent;</span><br><span class="line">                    parent = parent.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取大于指定键的最小节点，若不存在则返回null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或指定键的最小节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getHigherEntry</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = compare(key, p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.left != <span class="keyword">null</span>)</span><br><span class="line">                p = p.left;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                p = p.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; parent = p.parent;</span><br><span class="line">                Entry&lt;K,V&gt; ch = p;</span><br><span class="line">                <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; ch == parent.right) &#123;</span><br><span class="line">                    ch = parent;</span><br><span class="line">                    parent = parent.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取小于指定键的最大节点，若不存在则返回null</span></span><br><span class="line"><span class="comment"> * lower &lt; key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或指定键的最大节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getLowerEntry</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = compare(key, p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.right != <span class="keyword">null</span>)</span><br><span class="line">                p = p.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; parent = p.parent;</span><br><span class="line">                Entry&lt;K,V&gt; ch = p;</span><br><span class="line">                <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; ch == parent.left) &#123;</span><br><span class="line">                    ch = parent;</span><br><span class="line">                    parent = parent.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增节点后维持红黑树的平衡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 新增节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    x.color = RED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123; <span class="comment">//x的父节点是红色</span></span><br><span class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123; <span class="comment">//x的父节点在x的爷爷节点的左子树上</span></span><br><span class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); <span class="comment">//x的叔叔节点</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123; <span class="comment">//x的叔叔节点是红色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//x的叔叔节点是黑色</span></span><br><span class="line">                <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123; <span class="comment">//x在x的父节点的右子树上</span></span><br><span class="line">                    x = parentOf(x);<span class="comment">//x变成了x的父节点</span></span><br><span class="line">                    rotateLeft(x);<span class="comment">//将x的父节点进行左旋</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//x在x的父节点的左子树上</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                rotateRight(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//x的父节点在x的爷爷节点的右子树上</span></span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); <span class="comment">//x的叔叔节点</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123; <span class="comment">//x在x的父节点的左子树上</span></span><br><span class="line">                    x = parentOf(x);<span class="comment">//x变成了x的父节点</span></span><br><span class="line">                    rotateRight(x);<span class="comment">//将x的父节点进行右旋</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//x在x的父节点的右子树上</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除节点并调整红黑树使之平衡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 移除节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123; <span class="comment">//移除节点有两个子节点</span></span><br><span class="line">        Entry&lt;K,V&gt; s = successor(p); <span class="comment">//查找大于指定节点的最小节点</span></span><br><span class="line">        p.key = s.key;</span><br><span class="line">        p.value = s.value; <span class="comment">//替换值</span></span><br><span class="line">        p = s;</span><br><span class="line">    &#125; <span class="comment">// p has 2 children</span></span><br><span class="line"></span><br><span class="line">    Entry&lt;K,V&gt; replacement = (p.left != <span class="keyword">null</span> ? p.left : p.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123; <span class="comment">//移除节点至少有一个子节点，先更改移除节点的子节点与其父节点的关系</span></span><br><span class="line">        replacement.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">            p.parent.left  = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = replacement;</span><br><span class="line"></span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK) <span class="comment">//移除节点为黑色的情况才会导致红黑是失去平衡</span></span><br><span class="line">            fixAfterDeletion(replacement);  <span class="comment">//最后调整红黑树使之平衡</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) &#123; <span class="comment">//只有一个节点的情况下</span></span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//移除节点无子节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">                p.parent.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right)</span><br><span class="line">                p.parent.right = <span class="keyword">null</span>;</span><br><span class="line">            p.parent = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取大于指定节点的最小节点</span></span><br><span class="line"><span class="comment"> * 提供一篇文章：https://blog.csdn.net/iwts_24/article/details/87165743  讲的内容不错</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t 指定节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或大于指定节点的最小节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">successor</span><span class="params">(Entry&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; p = t.right;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 在有右子树的情况下查找大于指定键的最小节点，所以应该查找它的右子树的最左边的节点，因为越左边说明越靠近指定键</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *              5</span></span><br><span class="line"><span class="comment">         *            /   \</span></span><br><span class="line"><span class="comment">         *           3     6</span></span><br><span class="line"><span class="comment">         *         /  \</span></span><br><span class="line"><span class="comment">         *        1    4</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         *       1   3 4 5 6</span></span><br><span class="line"><span class="comment">         * t = 3，则 p = 4</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 下面这段代码和上面的getCeilingEntry方法是一样的</span></span><br><span class="line"><span class="comment">         * 在没有右子树的情况下往上查找大于指定键的最小节点，即当某个节点为其父节点的左子树时就是了</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *              5</span></span><br><span class="line"><span class="comment">         *            /   \</span></span><br><span class="line"><span class="comment">         *           3     6</span></span><br><span class="line"><span class="comment">         *         /  \</span></span><br><span class="line"><span class="comment">         *        1    4</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         *       1   3 4 5 6</span></span><br><span class="line"><span class="comment">         * t = 4，则 p = 5</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Entry&lt;K,V&gt; p = t.parent;</span><br><span class="line">        Entry&lt;K,V&gt; ch = t;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; ch == p.right) &#123;</span><br><span class="line">            ch = p;</span><br><span class="line">            p = p.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除节点后调整红黑树的平衡</span></span><br><span class="line"><span class="comment"> * 因为这里涉及到红黑树的算法，较为复杂，目前我也还没有完全理解，虽然之前尝试写过一篇关于红黑树的文章，但发现还是有些问题，所以打算后面探索算法的时候在更改</span></span><br><span class="line"><span class="comment"> * 由于咱们只是探索TreeMap的源码，所以这部分的内容个人觉得并不用花太多的时间去关注</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 移除节点或替代节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != root &amp;&amp; colorOf(x) == BLACK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; sib = rightOf(parentOf(x));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);</span><br><span class="line">                setColor(parentOf(x), RED);</span><br><span class="line">                rotateLeft(parentOf(x));</span><br><span class="line">                sib = rightOf(parentOf(x));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(leftOf(sib))  == BLACK &amp;&amp;</span><br><span class="line">                colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED);</span><br><span class="line">                x = parentOf(x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(leftOf(sib), BLACK);</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    rotateRight(sib);</span><br><span class="line">                    sib = rightOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(rightOf(sib), BLACK);</span><br><span class="line">                rotateLeft(parentOf(x));</span><br><span class="line">                x = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// symmetric</span></span><br><span class="line">            Entry&lt;K,V&gt; sib = leftOf(parentOf(x));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);</span><br><span class="line">                setColor(parentOf(x), RED);</span><br><span class="line">                rotateRight(parentOf(x));</span><br><span class="line">                sib = leftOf(parentOf(x));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK &amp;&amp;</span><br><span class="line">                colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED);</span><br><span class="line">                x = parentOf(x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(rightOf(sib), BLACK);</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    rotateLeft(sib);</span><br><span class="line">                    sib = leftOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(leftOf(sib), BLACK);</span><br><span class="line">                rotateRight(parentOf(x));</span><br><span class="line">                x = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setColor(x, BLACK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    root = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 浅拷贝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 克隆后的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TreeMap&lt;?,?&gt; clone;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        clone = (TreeMap&lt;?,?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将成员属性恢复到初始值，预防后续两个对象产生影响</span></span><br><span class="line">    clone.root = <span class="keyword">null</span>;</span><br><span class="line">    clone.size = <span class="number">0</span>;</span><br><span class="line">    clone.modCount = <span class="number">0</span>;</span><br><span class="line">    clone.entrySet = <span class="keyword">null</span>;</span><br><span class="line">    clone.navigableKeySet = <span class="keyword">null</span>;</span><br><span class="line">    clone.descendingMap = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建红黑树</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        clone.buildFromSorted(size, entrySet().iterator(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键值对来构建一颗红黑树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> size 红黑树的节点个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> it 包含键值对的迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str 包含键值对的输出流，it与str应该其中有一个不为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> defaultVal 若不为空，则使用该默认值作为键的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildFromSorted</span><span class="params">(<span class="keyword">int</span> size, Iterator&lt;?&gt; it, java.io.ObjectInputStream str, V defaultVal)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span>  java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line">    root = buildFromSorted(<span class="number">0</span>, <span class="number">0</span>, size-<span class="number">1</span>, computeRedLevel(size), it, str, defaultVal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算节点的高度达到某个值时应该变成红色，为了能够更好的分配红黑树的颜色</span></span><br><span class="line"><span class="comment"> * 至于它是怎么计算的，只能说这些写算法的人是真的牛逼</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sz 红黑树的节点个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 高度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">computeRedLevel</span><span class="params">(<span class="keyword">int</span> sz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = sz - <span class="number">1</span>; m &gt;= <span class="number">0</span>; m = m / <span class="number">2</span> - <span class="number">1</span>)</span><br><span class="line">        level++;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键值对来构建一颗红黑树</span></span><br><span class="line"><span class="comment"> * 注释上说明了构建后的红黑树的颜色分配很鲜明，实际上最终是通过redLevel来确定哪一部分是黑色，哪一部分是红色，但是顺序依然还是原来的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> level 当前节点的高度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lo 当前节点的子树的第一个节点的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hi 子树的最后一个节点的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> redLevel 当前节点达到此高度时应该是红色</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> it 包含键值对的迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str 包含键值对的输出流，it与str应该其中有一个不为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> defaultVal 若不为空，则使用该默认值作为键的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 根节点，红黑树的结构可能会发生变化，但是它的顺序不会变</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">buildFromSorted</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> redLevel, Iterator&lt;?&gt; it, java.io.ObjectInputStream str, V defaultVal)</span> <span class="keyword">throws</span>  java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hi &lt; lo) <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//hi &gt;= lo 说明子树已经构造完成</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">//取中间位置，无符号右移相当于除以2</span></span><br><span class="line"></span><br><span class="line">    Entry&lt;K,V&gt; left  = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (lo &lt; mid) </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 通过递归的方式构建当前节点的左子树</span></span><br><span class="line"><span class="comment">         * 若你了解红黑树的中序遍历，那应该就很容易理解了</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         *                   4</span></span><br><span class="line"><span class="comment">         *                 3    5</span></span><br><span class="line"><span class="comment">         *               2        6</span></span><br><span class="line"><span class="comment">         *             1            7</span></span><br><span class="line"><span class="comment">         *                           8</span></span><br><span class="line"><span class="comment">         * 中序遍历：  1 2 3 4 5 6 7 8 9    索引是从0开始的，类似数组</span></span><br><span class="line"><span class="comment">         * lo：0  hi：8 mid：4 redLevel：3  故当前节点是5，那么要构建左子树的话，可以认为5的左边的那些数字都是它的左子树中的节点，lo应该从0开始，hi应该是3</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        left = buildFromSorted(level+<span class="number">1</span>, lo, mid - <span class="number">1</span>, redLevel, it, str, defaultVal);</span><br><span class="line"></span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="keyword">if</span> (it != <span class="keyword">null</span>) &#123; <span class="comment">//通过迭代器获取键值对</span></span><br><span class="line">        <span class="keyword">if</span> (defaultVal==<span class="keyword">null</span>) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;)it.next();</span><br><span class="line">            key = (K)entry.getKey();</span><br><span class="line">            value = (V)entry.getValue();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            key = (K)it.next();</span><br><span class="line">            value = defaultVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 通过流的方式获取键值对</span></span><br><span class="line">        key = (K) str.readObject();</span><br><span class="line">        value = (defaultVal != <span class="keyword">null</span> ? defaultVal : (V) str.readObject());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry&lt;K,V&gt; middle =  <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (level == redLevel) <span class="comment">//上面说了某个节点达到此高度时就要变成红色</span></span><br><span class="line">        middle.color = RED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123; <span class="comment">//左子树构建完了就要关联关系</span></span><br><span class="line">        middle.left = left;</span><br><span class="line">        left.parent = middle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mid &lt; hi) &#123; <span class="comment">//通过递归的方式构建当前节点的右子树</span></span><br><span class="line">        Entry&lt;K,V&gt; right = buildFromSorted(level+<span class="number">1</span>, mid+<span class="number">1</span>, hi, redLevel,</span><br><span class="line">                                           it, str, defaultVal);</span><br><span class="line">        middle.right = right;</span><br><span class="line">        right.parent = middle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> middle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 封装键值对，以便控制某些方法不允许暴露给开发者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定键值对</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 封装后的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; Map.<span class="function">Entry&lt;K,V&gt; <span class="title">exportEntry</span><span class="params">(TreeMap.Entry&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (e == <span class="keyword">null</span>) ? <span class="keyword">null</span> : <span class="keyword">new</span> AbstractMap.SimpleImmutableEntry&lt;&gt;(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有键的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有键的Set集合 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> navigableKeySet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有键的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有键的Set集合 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableSet&lt;K&gt; <span class="title">navigableKeySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    KeySet&lt;K&gt; nks = navigableKeySet;</span><br><span class="line">    <span class="keyword">return</span> (nks != <span class="keyword">null</span>) ? nks : (navigableKeySet = <span class="keyword">new</span> KeySet&lt;&gt;(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含按照降序排列的键的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含降序排列的键的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableSet&lt;K&gt; <span class="title">descendingKeySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> descendingMap().navigableKeySet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取按照降序排列的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 降序排列的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableMap&lt;K, V&gt; <span class="title">descendingMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NavigableMap&lt;K, V&gt; km = descendingMap;</span><br><span class="line">    <span class="keyword">return</span> (km != <span class="keyword">null</span>) ? km : (descendingMap = <span class="keyword">new</span> DescendingSubMap&lt;&gt;(<span class="keyword">this</span>, <span class="keyword">true</span>, <span class="keyword">null</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">null</span>, <span class="keyword">true</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有值的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有值的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Collection&lt;V&gt; vs = values;</span><br><span class="line">    <span class="keyword">if</span> (vs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        vs = <span class="keyword">new</span> Values();</span><br><span class="line">        values = vs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有键值对的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有键值对的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    EntrySet es = entrySet;</span><br><span class="line">    <span class="keyword">return</span> (es != <span class="keyword">null</span>) ? es : (entrySet = <span class="keyword">new</span> EntrySet());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定起始键与结束键及是否包含起始、结束键来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * 当前对象是已经排好序了</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * TreeMap&lt;Integer, String&gt; treeMap = new TreeMap&lt;&gt;();</span></span><br><span class="line"><span class="comment"> * treeMap.put(5, "2");</span></span><br><span class="line"><span class="comment"> * treeMap.put(4, "2");</span></span><br><span class="line"><span class="comment"> * treeMap.put(10, "2");</span></span><br><span class="line"><span class="comment"> * treeMap.put(1, "2");</span></span><br><span class="line"><span class="comment"> * treeMap.put(20, "2");</span></span><br><span class="line"><span class="comment"> * treeMap.put(7, "2");</span></span><br><span class="line"><span class="comment"> * treeMap.put(8, "2");</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * System.out.println(treeMap.keySet()); -&gt; [1, 4, 5, 7, 8, 10, 20]</span></span><br><span class="line"><span class="comment"> * System.out.println(treeMap.subMap(2,true, 6, true).keySet());  -&gt; [4, 5]  实际上是在treeMap取2-6区间中的所有键 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromKey 起始键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromInclusive 子集中是否包含起始键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toKey 结束键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toInclusive 子集中是否包含结束键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableMap&lt;K,V&gt; <span class="title">subMap</span><span class="params">(K fromKey, <span class="keyword">boolean</span> fromInclusive, K toKey,   <span class="keyword">boolean</span> toInclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AscendingSubMap&lt;&gt;(<span class="keyword">this</span>, <span class="keyword">false</span>, fromKey, fromInclusive, <span class="keyword">false</span>, toKey, toInclusive);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定结束键及是否包含结束键来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * 当前对象是已经排好序了</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参照上面的代码</span></span><br><span class="line"><span class="comment"> * System.out.println(treeMap.headMap(4, true).keySet()); -&gt; [1, 4]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toKey 结束键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inclusive 子集中是否包含结束键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableMap&lt;K,V&gt; <span class="title">headMap</span><span class="params">(K toKey, <span class="keyword">boolean</span> inclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AscendingSubMap&lt;&gt;(<span class="keyword">this</span>, <span class="keyword">true</span>,  <span class="keyword">null</span>,  <span class="keyword">true</span>, <span class="keyword">false</span>, toKey, inclusive);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定起始键及是否包含起始键来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromKey 起始键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inclusive 子集中是否包含起始键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableMap&lt;K,V&gt; <span class="title">tailMap</span><span class="params">(K fromKey, <span class="keyword">boolean</span> inclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AscendingSubMap&lt;&gt;(<span class="keyword">this</span>, <span class="keyword">false</span>, fromKey, inclusive, <span class="keyword">true</span>,  <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定起始键与结束键来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * 包含起始键、不包含结束键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromKey 起始键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toKey 结束键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SortedMap&lt;K,V&gt; <span class="title">subMap</span><span class="params">(K fromKey, K toKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> subMap(fromKey, <span class="keyword">true</span>, toKey, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定结束键来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * 不包含结束键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toKey 结束键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SortedMap&lt;K,V&gt; <span class="title">headMap</span><span class="params">(K toKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> headMap(toKey, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定起始键来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * 包含起始键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromKey 起始键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SortedMap&lt;K,V&gt; <span class="title">tailMap</span><span class="params">(K fromKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tailMap(fromKey, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 替换指定键的节点的值，过程中要比较节点的值与指定值是否相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> oldValue 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newValue 新值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否替换成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">if</span> (p!=<span class="keyword">null</span> &amp;&amp; Objects.equals(oldValue, p.value)) &#123;</span><br><span class="line">        p.value = newValue;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 替换指定键的节点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 新值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">if</span> (p!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        V oldValue = p.value;</span><br><span class="line">        p.value = value;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按排列后的顺序遍历所有节点并执行指定动作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action 执行指定动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K, V&gt; e = getFirstEntry(); e != <span class="keyword">null</span>; e = successor(e)) &#123; <span class="comment">//successor是获取大于当前节点的最小节点，按照红黑树的中序排列后，实际上就是获取的下一个元素</span></span><br><span class="line">        action.accept(e.key, e.value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (expectedModCount != modCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按排列后的顺序遍历所有节点并执行指定动作后获取新值，利用新值替换所有节点的旧值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> function 指定动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; function)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(function);</span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K, V&gt; e = getFirstEntry(); e != <span class="keyword">null</span>; e = successor(e)) &#123;</span><br><span class="line">        e.value = function.apply(e.key, e.value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (expectedModCount != modCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 比较两个键</span></span><br><span class="line"><span class="comment"> * 若未指定比较器，则必须实现Comparable，通过覆写该类来进行比较</span></span><br><span class="line"><span class="comment"> * 若是指定了比较器，则必须实现Comparator，通过覆写该类来进行比较</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k1 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k2 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 比较结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object k1, Object k2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> comparator==<span class="keyword">null</span> ? ((Comparable&lt;? <span class="keyword">super</span> K&gt;)k1).compareTo((K)k2) : comparator.compare((K)k1, (K)k2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 比较两个值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o1 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o2 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 比较结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">valEquals</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (o1==<span class="keyword">null</span> ? o2==<span class="keyword">null</span> : o1.equals(o2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上面提到的关于获取子集的内容就列出重要的方法，其余的方法都是类似的，就不做重复性的工作了</span></span><br><span class="line"><span class="comment"> * 获取子集时是已经按顺序排列好了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NavigableSubMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前对象，也就是从该对象中获取子集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> TreeMap&lt;K,V&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 起始键与结束键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> K lo, hi;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * fromStart为true的话表示当前对象的第一个键作为起始，相当于是已经明确了起始键，若为false就说明起始键需要调用者指定</span></span><br><span class="line"><span class="comment">     * toEnd为true的话表示当前对象的最后一个键作为结尾，相当于是已经明确了结束键，若为false就说明结束键需要调用者指定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> fromStart, toEnd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子集是否需要包含起始键、结束键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> loInclusive, hiInclusive;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定键是否小于起始键</span></span><br><span class="line"><span class="comment">     * 若等于则看loInclusive变量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否小于起始键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tooLow</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!fromStart) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = m.compare(key, lo);</span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (c == <span class="number">0</span> &amp;&amp; !loInclusive))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定键是否大于结束键</span></span><br><span class="line"><span class="comment">     * 若等于则看hiInclusive变量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否大于起始键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tooHigh</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!toEnd) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = m.compare(key, hi);</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">0</span> || (c == <span class="number">0</span> &amp;&amp; !hiInclusive))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定键是否在起始键与结束键之间，该区间可能是[lo,hi]、(lo,hi) 、[lo,hi)、(lo,hi] 这取决于loInclusive、hiInclusive</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否在起始键与结束键之间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">inRange</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !tooLow(key) &amp;&amp; !tooHigh(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定键是否在起始键与结束键之间，区间是[lo,hi]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否在起始键与结束键之间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">inClosedRange</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (fromStart || m.compare(key, lo) &gt;= <span class="number">0</span>)</span><br><span class="line">            &amp;&amp; (toEnd || m.compare(hi, key) &gt;= <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定键是否在起始键与结束键之间</span></span><br><span class="line"><span class="comment">     * inclusive为true时，key在起始键与结束键之间不会报错，不过若key刚好是等于起始键或结束键，那么对应的区间必须是闭区间，假设key等于起始键，那么它的区间应该是[lo,hi)或[lo,ih]，若是等于结束键，那么区间应该是(lo,hi]或[lo,hi]</span></span><br><span class="line"><span class="comment">     * inclusive为false时，key在起始键与结束键之间不会报错，不过若key刚好是等于起始键或结束键，不管区间如何，都不会报错</span></span><br><span class="line"><span class="comment">     * 当然了，不管inclusive的值如何，如果指定键大于结束键或小于起始键，那肯定会报错</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inclusive 子集中是否包含指定键 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">inRange</span><span class="params">(Object key, <span class="keyword">boolean</span> inclusive)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inclusive ? inRange(key) : inClosedRange(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前对象中大于或等于起始键的节点</span></span><br><span class="line"><span class="comment">     * 因为指定了区间lo-hi，所以还要判断该节点是否超过了结束键hi</span></span><br><span class="line"><span class="comment">     * 如果fromStart为true，说明已经指定了起始键，直接获取第一个节点即可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> null或大于或等于起始键的节点，为null说明要么节点不存在，要么该节点超过了结束键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">absLowest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeMap.Entry&lt;K,V&gt; e = (fromStart ?  m.getFirstEntry() : (loInclusive ? m.getCeilingEntry(lo) : m.getHigherEntry(lo)));</span><br><span class="line">        <span class="keyword">return</span> (e == <span class="keyword">null</span> || tooHigh(e.key)) ? <span class="keyword">null</span> : e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前对象中小于或等于结束键的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> null或小于或等于结束键的节点，为null说明要么节点不存在，要么该节点小于起始键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">absHighest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeMap.Entry&lt;K,V&gt; e = (toEnd ?  m.getLastEntry() : (hiInclusive ?  m.getFloorEntry(hi) : m.getLowerEntry(hi)));</span><br><span class="line">        <span class="keyword">return</span> (e == <span class="keyword">null</span> || tooLow(e.key)) ? <span class="keyword">null</span> : e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取大于或等于指定键的节点</span></span><br><span class="line"><span class="comment">     * 若指定键小于起始键，那么只需要获取起始键即可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> null或大于或等于指定键的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">absCeiling</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tooLow(key))</span><br><span class="line">            <span class="keyword">return</span> absLowest();</span><br><span class="line">        TreeMap.Entry&lt;K,V&gt; e = m.getCeilingEntry(key);</span><br><span class="line">        <span class="keyword">return</span> (e == <span class="keyword">null</span> || tooHigh(e.key)) ? <span class="keyword">null</span> : e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取大于指定键的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> null或大于指定键的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">absHigher</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tooLow(key))</span><br><span class="line">            <span class="keyword">return</span> absLowest();</span><br><span class="line">        TreeMap.Entry&lt;K,V&gt; e = m.getHigherEntry(key);</span><br><span class="line">        <span class="keyword">return</span> (e == <span class="keyword">null</span> || tooHigh(e.key)) ? <span class="keyword">null</span> : e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取小于或等于指定键的节点</span></span><br><span class="line"><span class="comment">     * 若指定键大于结束键，则直接获取结束键即可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> null或小于或等于指定键的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">absFloor</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tooHigh(key))</span><br><span class="line">            <span class="keyword">return</span> absHighest();</span><br><span class="line">        TreeMap.Entry&lt;K,V&gt; e = m.getFloorEntry(key);</span><br><span class="line">        <span class="keyword">return</span> (e == <span class="keyword">null</span> || tooLow(e.key)) ? <span class="keyword">null</span> : e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取小于指定键的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> null或小于指定键的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">absLower</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tooHigh(key))</span><br><span class="line">            <span class="keyword">return</span> absHighest();</span><br><span class="line">        TreeMap.Entry&lt;K,V&gt; e = m.getLowerEntry(key);</span><br><span class="line">        <span class="keyword">return</span> (e == <span class="keyword">null</span> || tooLow(e.key)) ? <span class="keyword">null</span> : e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取子集的尾节点（结果不包含尾节点）</span></span><br><span class="line"><span class="comment">     * 当hiInclusive为true时，说明结果要包含指定的结束键，所以它就取了比指定结束键还要大的节点作为尾节点</span></span><br><span class="line"><span class="comment">     * 当hiInclusive为false时，说明结果不包含指定的结束键，所以它就取了等于结束键的节点作为尾节点</span></span><br><span class="line"><span class="comment">     * 不管是哪一种，反正它是不包含尾节点，可以在迭代器的hasNext中看到：next != null &amp;&amp; next.key != fenceKey;  说明不包含尾节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 尾节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">absHighFence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (toEnd ? <span class="keyword">null</span> : (hiInclusive ? m.getHigherEntry(hi) : m.getCeilingEntry(hi)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取子集的头节点（不包含头节点）</span></span><br><span class="line"><span class="comment">     * 分析同上</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 头节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">absLowFence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (fromStart ? <span class="keyword">null</span> : (loInclusive ? m.getLowerEntry(lo) : m.getFloorEntry(lo)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//剩下的方法就不一一分析了，大多数都是类似的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        compare(key, key); <span class="comment">//校验指定键至是否实现Comparable或Comparator</span></span><br><span class="line"></span><br><span class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>); <span class="comment">//设置红黑树的根节点</span></span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="comment">// split comparator and comparable paths</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123; <span class="comment">//采用Comparator的方式进行比较，查找新增节点应该放在哪个位置上</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value); <span class="comment">//新增节点已经存在则进行替换值</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">//采用Comparable的方式进行比较，查找新增节点应该放在哪个位置上</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = k.compareTo(t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent); <span class="comment">//构建节点并关联关系</span></span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="移除节点"><a href="#移除节点" class="headerlink" title="移除节点"></a>移除节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除指定键对应的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 移除节点的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    V oldValue = p.value;</span><br><span class="line">    deleteEntry(p); <span class="comment">//移除节点并调整红黑树的平衡</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取排序后的第一个节点并移除</span></span><br><span class="line"><span class="comment"> * 获取最左边的节点并移除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最左边的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">pollFirstEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getFirstEntry();</span><br><span class="line">    Map.Entry&lt;K,V&gt; result = exportEntry(p);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>)</span><br><span class="line">        deleteEntry(p);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取排序后的最后一个节点并移除</span></span><br><span class="line"><span class="comment"> * 获取最右边的节点并移除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最右边的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">pollLastEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getLastEntry();</span><br><span class="line">    Map.Entry&lt;K,V&gt; result = exportEntry(p);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>)</span><br><span class="line">        deleteEntry(p);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取排序后的第一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 排序后的第一个节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">firstEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exportEntry(getFirstEntry());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取最左边的节点，实际上就是在获取排序后的第一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最左边的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getFirstEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取排序后的最后一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 排序后的最后一个节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">lastEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exportEntry(getLastEntry());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取最右边的节点，实际上就是在获取排序后的最后一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最右边的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getLastEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">while</span> (p.right != <span class="keyword">null</span>)</span><br><span class="line">            p = p.right;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取小于指定键的最大节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 小于指定键的最大节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">lowerEntry</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exportEntry(getLowerEntry(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取小于指定键的最大节点的键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 小于指定键的最大节点的键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> K <span class="title">lowerKey</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> keyOrNull(getLowerEntry(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取等于或小于指定键的最大节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 等于或小于指定键的最大节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">floorEntry</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exportEntry(getFloorEntry(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取小于指定键的最大节点的键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 小于指定键的最大节点的键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> K <span class="title">floorKey</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> keyOrNull(getFloorEntry(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取等于或大于指定键的最小节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 等于或大于指定键的最小节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">ceilingEntry</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exportEntry(getCeilingEntry(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取等于或大于指定键的最小节点的键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 等于或大于指定键的最小节点的键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> K <span class="title">ceilingKey</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> keyOrNull(getCeilingEntry(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取大于指定键的最小节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 大于指定键的最小节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">higherEntry</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exportEntry(getHigherEntry(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取大于指定键的最小节点的键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 大于指定键的最小节点的键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> K <span class="title">higherKey</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> keyOrNull(getHigherEntry(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>若要按自然顺序排列则键必须实现Comparable，此时TreeMap中键不可以为null；若要自定义排列顺序则键必须实现Comparator，此时TreeMap中键可以为null</p></li><li><p>TreeMap中的很多算法跟红黑树中的中序有很大的关联，所以最好提前了解</p></li><li><p>TreeMap有序不可重复，非线程安全</p></li><li><p>TreeMap的数据结构是<code>红黑树</code></p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>红黑树</code> <code>Comparable与Comparator</code> <code>有序不可重复</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;探索&lt;code&gt;TreeMap&lt;/code&gt;底层实现是基于&lt;code&gt;JDK1.8&lt;/code&gt;，通过该类的注释可以了解它的数据结构是&lt;code&gt;红黑树&lt;/code&gt;，默认是按照&lt;code&gt;自然顺序&lt;/code&gt;进行排序（所有的键都必须去实现&lt;code&gt;Comparable&lt;/code&gt;），当然也可以通过&lt;code&gt;指定比较器&lt;/code&gt;进行排序（所有的键都必须实现&lt;code&gt;Comparator&lt;/code&gt;）。至于什么是红黑树，读者最好有一定的了解，那看懂它的源码也就是分分钟的事了。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索LinkedHashMap底层实现</title>
    <link href="http://zlia.tech/2019/10/25/explain-linkedhashmap-sourcecode/"/>
    <id>http://zlia.tech/2019/10/25/explain-linkedhashmap-sourcecode/</id>
    <published>2019-10-25T06:59:27.000Z</published>
    <updated>2019-10-31T03:29:19.477Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>印象中对LinkedHashMap的使用次数好像也不多，参考了几篇文章发现它依赖于<code>HashMap</code>而存在，也就是说它在HashMap的基础上又增加了某些特性，比如说<code>有序</code>。既然是基于HashMap，那么它内部的数据结构也应该有数组 + 链表 + 红黑树，而刚才说它又加上了自己的有序特性，那么应该还有<code>一条链表来维护该顺序</code>，如下图所示：</p><p class="customize-img"><img src="/assets/blogImg/java/linkedhashmap/data-structure.png" alt="LinkedHashMap数据结构"></p><p>该图侧重于它是如何保持有序的，就像上面说的是一条链表，画的有点丑，不过应该不难理解。另外一方面，由于它是基于HashMap，所以在看这篇文章之前最好能对HashMap有个了解，加上接下来并不会过多的解释它的数据结构，更多的关注还是在有序及其他特性上，毕竟它的数据结构是偷来的，探索LinkedHashMap底层实现是基于<code>JDK1.8</code>。</p><a id="more"></a><h3 id="阅读注释"><a href="#阅读注释" class="headerlink" title="阅读注释"></a><div><span>阅读注释</span></div></h3><p class="customize-img"><img src="/assets/blogImg/java/linkedhashmap/linkedhashmap-comment-1.png" alt="LinkedHashMap注释-1"></p><p>提供了一条链表来维护有序性，默认顺序是节点的插入顺序。</p><p class="customize-img"><img src="/assets/blogImg/java/linkedhashmap/linkedhashmap-comment-2.png" alt="LinkedHashMap注释-2"></p><p>还提供了按照访问顺序进行排序，该排序方式适合左LRU缓存。</p><p class="customize-img"><img src="/assets/blogImg/java/linkedhashmap/linkedhashmap-comment-3.png" alt="LinkedHashMap注释-3"></p><p>LinkedHashMap的迭代性能比HashMap高，因为HashMap会迭代所有容量，包括某些索引上并没有节点，而LinkedHashMap按照链表来迭代，并不会理会空节点。</p><p class="customize-img"><img src="/assets/blogImg/java/linkedhashmap/linkedhashmap-comment-4.png" alt="LinkedHashMap注释-4"></p><p>非线程安全，与HashMap相比，结构修改的概念不太一样。</p><p class="customize-img"><img src="/assets/blogImg/java/linkedhashmap/linkedhashmap-comment-5.png" alt="LinkedHashMap注释-5"></p><p>迭代器会发生快速失败倒是每个集合的共有特点。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//继承了HashMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//唯一序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3801124242820219131L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//双向链表的头节点，也代表着最少访问</span></span><br><span class="line">    <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//双向链表的尾节点，也代表着最多访问</span></span><br><span class="line">    <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置排序方式，也是迭代时的顺序</span></span><br><span class="line"><span class="comment">     * true：按照访问顺序，最多访问的节点会更新到尾节点</span></span><br><span class="line"><span class="comment">     * false：按照插入顺序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量与加载因子来初始化，按照插入顺序排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor 指定加载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量来初始，按照插入顺序排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 采用默认的初始容量与加载因子来初始化，按照插入顺序排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定结集合添加到表中，按照插入顺序排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定容量与加载因子、排序方式来初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor 指定加载因子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> accessOrder 指定排序方式-按照插入顺序、访问顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h4><p>以下的方法将不会详细介绍HashMap中的相关方法，只可能会略微提到，读者最好能够对HashMap有一定的了解。</p><h5 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定节点添加到尾部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 指定节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">//添加到尾部后要进行关联关系，以便通过上下节点维护顺序</span></span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 复制节点的关联关系以保持有序</span></span><br><span class="line"><span class="comment"> * HashMap中可能出现链表转换成红黑树、也有可能出现红黑树转换为链表，所以相应的在转换过程中对象的结构也应该发生变化，为了保持有序性，必须复制原有结构的关联关系到新结构上</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src 原结构的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dst 现结构的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transferLinks</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; src, LinkedHashMap.Entry&lt;K,V&gt; dst)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; b = dst.before = src.before;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; a = dst.after = src.after;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = dst;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = dst;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = dst;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = dst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 恢复到初始状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reinitialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.reinitialize();</span><br><span class="line">    head = tail = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建普通结构的节点</span></span><br><span class="line"><span class="comment"> * 相当于在HashMap原有节点的基础上又维护了一层有序</span></span><br><span class="line"><span class="comment"> * 添加节点时会调用HashMap#putVal，紧着会调用该方法用来创建新节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 下一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p = <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将红黑树结构的节点的变成普通结构的节点，实际上只是对象变了，其成员属性拷贝原有节点上对应的值</span></span><br><span class="line"><span class="comment"> * HashMap#untreeify时会调用该方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 红黑树结构的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> next 下一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 普通结构的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; q = (LinkedHashMap.Entry&lt;K,V&gt;)p;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; t =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(q.hash, q.key, q.value, next);</span><br><span class="line">    transferLinks(q, t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建红黑树结构的节点</span></span><br><span class="line"><span class="comment"> * HashMap#putTreeVal时会调用该方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> next 下一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">newTreeNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(hash, key, value, next);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将普通结构的节点变成红黑树结构的节点，实际上只是对象变了，其成员属性拷贝原有节点上对应的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 普通结构的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> next 下一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 红黑树结构的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; q = (LinkedHashMap.Entry&lt;K,V&gt;)p;</span><br><span class="line">    TreeNode&lt;K,V&gt; t = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(q.hash, q.key, q.value, next);</span><br><span class="line">    transferLinks(q, t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除节点后的动作</span></span><br><span class="line"><span class="comment"> * HashMap#removeNode时会调用该方法</span></span><br><span class="line"><span class="comment"> * 将指定节点移除后应该维护其剩余节点的关联关系</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增节点后的动作</span></span><br><span class="line"><span class="comment"> * 默认情况下不会移除最少访问的节点</span></span><br><span class="line"><span class="comment"> * HashMap#putVal时会调用该方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict 模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123; <span class="comment">//可根据覆写removeEldestEntry方法来实现不同策略的缓存机制，默认是不会移除</span></span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>); <span class="comment">//移除最少访问的节点，即头部节点，默认情况下不会调用该方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问节点后的动作</span></span><br><span class="line"><span class="comment"> * 上面我们提到accessOrder = true时会按照访问顺序排序，最多访问的节点会被移动到尾部，即将当前节点移动到尾部，若是accessOrder = false则按照插入顺序排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 当前节点，即访问的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123; <span class="comment">//说明当前节点不是尾部节点，那就说明要移动到尾部</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; <span class="comment">//当前节点的上下节点</span></span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>) <span class="comment">//说明当前节点是头部节点</span></span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//当前节点是中间节点</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//a = null 说明当前节点是尾部，可是我们在一开始就判断了当前节点不是尾部节点，所以这里的else就不会走到</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>) <span class="comment">//last = tail也不可能为空，因为只有当前节点存在的情况才会调用该方法</span></span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p; <span class="comment">//将当前节点当作尾部节点</span></span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将键值对分别写入到流中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 输出流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">internalWriteEntries</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after) &#123;</span><br><span class="line">        s.writeObject(e.key);</span><br><span class="line">        s.writeObject(e.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否包含指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after) &#123;</span><br><span class="line">        V v = e.value;</span><br><span class="line">        <span class="keyword">if</span> (v == value || (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键获取值</span></span><br><span class="line"><span class="comment"> * 若accessOrder = true 调用该方法时认为是访问节点，同时也认为是结构修改，所以会去调用afterNodeAccess</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键获取值，若不存在指定节点则返回默认值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> defaultValue 默认值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 值或默认值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">   Node&lt;K,V&gt; e;</span><br><span class="line">   <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">       <span class="keyword">return</span> defaultValue;</span><br><span class="line">   <span class="keyword">if</span> (accessOrder)</span><br><span class="line">       afterNodeAccess(e);</span><br><span class="line">   <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.clear();</span><br><span class="line">    head = tail = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否移除最少访问的节点</span></span><br><span class="line"><span class="comment"> * 可通过覆写该方法来实现不同的策略，比如当缓存达到指定瓶颈时，每添加新节点时就删除掉最少访问的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> eldest 最少访问的节点，即头节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有键的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有键的Set集合 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Set&lt;K&gt; ks = keySet;</span><br><span class="line">    <span class="keyword">if</span> (ks == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ks = <span class="keyword">new</span> LinkedKeySet();</span><br><span class="line">        keySet = ks;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含所有键的集合</span></span><br><span class="line"><span class="comment"> * 跟HashMap中的代码类似，就不做解释了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedKeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; LinkedHashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedKeyIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsKey(o); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;K&gt; <span class="title">spliterator</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, Spliterator.SIZED |</span><br><span class="line">                                        Spliterator.ORDERED |</span><br><span class="line">                                        Spliterator.DISTINCT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> mc = modCount;</span><br><span class="line">        <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after)</span><br><span class="line">            action.accept(e.key);</span><br><span class="line">        <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有值的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有值的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Collection&lt;V&gt; vs = values;</span><br><span class="line">    <span class="keyword">if</span> (vs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        vs = <span class="keyword">new</span> LinkedValues();</span><br><span class="line">        values = vs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含所有值的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedValues</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; LinkedHashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedValueIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsValue(o); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;V&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, Spliterator.SIZED |</span><br><span class="line">                                        Spliterator.ORDERED);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> mc = modCount;</span><br><span class="line">        <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after)</span><br><span class="line">            action.accept(e.value);</span><br><span class="line">        <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有键值对的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有键值对的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> LinkedEntrySet()) : es;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含所有键值对的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedEntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; LinkedHashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedEntryIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">        Object key = e.getKey();</span><br><span class="line">        Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class="line">        <span class="keyword">return</span> candidate != <span class="keyword">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">            Object key = e.getKey();</span><br><span class="line">            Object value = e.getValue();</span><br><span class="line">            <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, Spliterator.SIZED |</span><br><span class="line">                                        Spliterator.ORDERED |</span><br><span class="line">                                        Spliterator.DISTINCT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> mc = modCount;</span><br><span class="line">        <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after)</span><br><span class="line">            action.accept(e);</span><br><span class="line">        <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历表并执行指定动作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action 指定动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> mc = modCount;</span><br><span class="line">    <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after)</span><br><span class="line">        action.accept(e.key, e.value);</span><br><span class="line">    <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历表并执行指定动作后获取新值，利用新值替换所有节点的旧值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> function 指定动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; function)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (function == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> mc = modCount;</span><br><span class="line">    <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after)</span><br><span class="line">        e.value = function.apply(e.key, e.value);</span><br><span class="line">    <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代器基类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashIterator</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; next;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; current;</span><br><span class="line">    <span class="keyword">int</span> expectedModCount;</span><br><span class="line"></span><br><span class="line">    LinkedHashIterator() &#123;</span><br><span class="line">        next = head;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        current = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> LinkedHashMap.<span class="function">Entry&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        current = e;</span><br><span class="line">        next = e.after;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; p = current;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        current = <span class="keyword">null</span>;</span><br><span class="line">        K key = p.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含所有键的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedKeyIterator</span> <span class="keyword">extends</span> <span class="title">LinkedHashIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().getKey(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含所有值的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedValueIterator</span> <span class="keyword">extends</span> <span class="title">LinkedHashIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含所有键值对的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedEntryIterator</span> <span class="keyword">extends</span> <span class="title">LinkedHashIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>有序、不可重复、非线程安全：内部通过维护一条双向链表来保证有序性</p></li><li><p>排序方式有两种：按插入顺序；按访问顺序，最近访问的节点会被移动到尾部，相当于头节点是最少访问的节点</p></li><li><p>removeEldestEntry：是否移除最少访问的节点，可覆写该方法来实现不同策略的缓存机制</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>双向链表保证有序性</code> <code>可按插入顺序或按访问顺序</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;印象中对LinkedHashMap的使用次数好像也不多，参考了几篇文章发现它依赖于&lt;code&gt;HashMap&lt;/code&gt;而存在，也就是说它在HashMap的基础上又增加了某些特性，比如说&lt;code&gt;有序&lt;/code&gt;。既然是基于HashMap，那么它内部的数据结构也应该有数组 + 链表 + 红黑树，而刚才说它又加上了自己的有序特性，那么应该还有&lt;code&gt;一条链表来维护该顺序&lt;/code&gt;，如下图所示：&lt;/p&gt;
&lt;p class=&quot;customize-img&quot;&gt;&lt;img src=&quot;/assets/blogImg/java/linkedhashmap/data-structure.png&quot; alt=&quot;LinkedHashMap数据结构&quot;&gt;&lt;/p&gt;
&lt;p&gt;该图侧重于它是如何保持有序的，就像上面说的是一条链表，画的有点丑，不过应该不难理解。另外一方面，由于它是基于HashMap，所以在看这篇文章之前最好能对HashMap有个了解，加上接下来并不会过多的解释它的数据结构，更多的关注还是在有序及其他特性上，毕竟它的数据结构是偷来的，探索LinkedHashMap底层实现是基于&lt;code&gt;JDK1.8&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索IdentityHashMap底层实现</title>
    <link href="http://zlia.tech/2019/10/23/explain-identityhashmap-sourcecode/"/>
    <id>http://zlia.tech/2019/10/23/explain-identityhashmap-sourcecode/</id>
    <published>2019-10-23T09:11:08.000Z</published>
    <updated>2019-11-04T08:05:22.859Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a><div><span>前沿</span></div></h3><p>我也是第一次认识IdentityHashMap，在工作中从未使用过它，所以对它的使用场景可能并不是很了解，本文也仅仅针对基于<code>JDK1.8</code>的源码进行探索。<code>IdentityHashMap</code>的数据结构应该是如图所示：</p><p class="customize-img"><img src="/assets/blogImg/java/identityhashmap/data-structure.png" alt="IdentityHashMap数据结构"></p><p>这个数据结构是我在看源码之前看了几篇别人写的文章所了解到的，个人喜欢在看源码对目标有所了解的习惯，紧接着才去深入它。</p><a id="more"></a><h3 id="阅读注释"><a href="#阅读注释" class="headerlink" title="阅读注释"></a><div><span>阅读注释</span></div></h3><p class="customize-img"><img src="/assets/blogImg/java/identityhashmap/identityhashmap-comment-1.png" alt="IdentityHashMap注释-1"></p><p>在IdentityHashMap中，对于两个键只有在k1 == k2成立时才认为是相等的，而在HashMap中确实k1.equals(k2)成立是才被认为相等，<code>前者是引用相等，而后者是对象相等</code>。</p><p class="customize-img"><img src="/assets/blogImg/java/identityhashmap/identityhashmap-comment-2.png" alt="IdentityHashMap注释-2"></p><p class="customize-img"><img src="/assets/blogImg/java/identityhashmap/identityhashmap-comment-3.png" alt="IdentityHashMap注释-3"></p><p>Identity可用于序列化或深拷贝或对象代理。</p><p class="customize-img"><img src="/assets/blogImg/java/identityhashmap/identityhashmap-comment-4.png" alt="IdentityHashMap注释-4"></p><p>键值对允许存放null，同样也是无序的。</p><p class="customize-img"><img src="/assets/blogImg/java/identityhashmap/identityhashmap-comment-5.png" alt="IdentityHashMap注释-5"></p><p>IdentityHashMap属于非线程安全，和集合中的其他类一样迭代器都可能发生快速失败。</p><p class="customize-img"><img src="/assets/blogImg/java/identityhashmap/identityhashmap-comment-6.png" alt="IdentityHashMap注释-6"></p><p>线性探针哈希表，这是对其数据结构的称呼。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//可序列化、克隆</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdentityHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认键值对个数</span></span><br><span class="line"><span class="comment">     * 虽然注释上写着是默认初始容量，但当你发现有这样子的一段代码时：table = new Object[2 * initCapacity]，你就会明白默认初始容量应该是64</span></span><br><span class="line"><span class="comment">     * 容量大小必须是2的幂次方，在添加节点时会先判断当前节点的个数是否超过了容量的1/3，所以我认为1/3是加载因子</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 为什么必须是2的幂次方?</span></span><br><span class="line"><span class="comment">     * 在计算索引时用&amp;代码了%，提升了效率，不过这导致了一个前提，就是必须是2的幂次方，为了是能够取到容量区间中的每个索引，有人将这种做法称为均匀分布</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最小键值对个数</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 为什么最小是4?</span></span><br><span class="line"><span class="comment">     * 假设手动指定容量大小是1，则初始容量应该是2，在添加第一个节点时会先判断当前节点的个数是否超过了容量的1/3，很显然，2 * 1/3的结果都不足1，所以它会先扩容，扩容后再添加节点，由于扩容是需要消耗一定的成本，为何不在初始化时就设定较 * 高的值来避免此次扩容；那么如果指定容量大小是2呢? 4 * 1/3 不足2，因为它的数据结构是同时存储key与value，所以在存储value时也必定会扩容，故也不行；那3就更不行了，毕竟要是2的幂次方，所以4属于最小指定容量值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MINIMUM_CAPACITY = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大键值对个数</span></span><br><span class="line"><span class="comment">     * 虽然注释上写着是最大容量，但实际上并不是，此数值用于当构造函数中指定的容量过高时会直接该数值，而当你发现有这样子一句代码时：table = new Object[2 * initCapacity]; 你就会发现实际上最大的容量应该是 1&lt;&lt;30才对</span></span><br><span class="line"><span class="comment">     * 实际上，线性探针表中能存储的节点个数不能超过 1&lt;&lt;&lt;30 - 1 个，因为它至少有一个位置是存储了null，用来避免死循环</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">29</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线性探针表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线性探针表中存储的节点个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 结构被修改的次数</span></span><br><span class="line"><span class="comment">     * 该成员属性是用于检测迭代器的快速失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代表键为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object NULL_KEY = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存entrySet方法的返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 采用默认键值对个数初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdentityHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init(DEFAULT_CAPACITY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键值对个数来初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expectedMaxSize 指定键值对个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdentityHashMap</span><span class="params">(<span class="keyword">int</span> expectedMaxSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (expectedMaxSize &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"expectedMaxSize is negative: "</span></span><br><span class="line">                                           + expectedMaxSize);</span><br><span class="line">    init(capacity(expectedMaxSize));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键值对个数进行初始化，并将指定集合添加到线性探针表中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdentityHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Allow for a bit of growth</span></span><br><span class="line">    <span class="keyword">this</span>((<span class="keyword">int</span>) ((<span class="number">1</span> + m.size()) * <span class="number">1.1</span>));</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 倘若键为null则采用NULL_KEY作为键</span></span><br><span class="line"><span class="comment">  * 正如方法名一样，隐藏Null</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> NULL_KEY或指定键</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">maskNull</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span> ? NULL_KEY : key);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 倘若键为NULL_KEY则返回null</span></span><br><span class="line"><span class="comment">  * 正如方法名一样，揭露Null</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key 线性探针表中的键</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> null或指定键</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title">unmaskNull</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (key == NULL_KEY ? <span class="keyword">null</span> : key);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 调整指定键值对个数</span></span><br><span class="line"><span class="comment">  * Integer.highestOneBit 返回只含有二进制中最高位（从左到右第一个数字为1）的十进制，如15对应的二进制是1111，结果是1000，也就是数字8</span></span><br><span class="line"><span class="comment">  * 这里有一点我觉得代码写的不够完美，假设expectedMaxSize = 3，意思我可能要存储3个键值对，而它最终的容量是16，那么在我添加最后一对键值对时，它仍然会进行扩容，个人觉得设计的不够完美</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> expectedMaxSize 指定键值对个数</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 调整后的键值对个数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">(<span class="keyword">int</span> expectedMaxSize)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line">         (expectedMaxSize &gt; MAXIMUM_CAPACITY / <span class="number">3</span>) ? MAXIMUM_CAPACITY :</span><br><span class="line">         (expectedMaxSize &lt;= <span class="number">2</span> * MINIMUM_CAPACITY / <span class="number">3</span>) ? MINIMUM_CAPACITY :</span><br><span class="line">         Integer.highestOneBit(expectedMaxSize + (expectedMaxSize &lt;&lt; <span class="number">1</span>));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 指定键值对个数来初始化哈希探针表</span></span><br><span class="line"><span class="comment">  * 由于参数代表着键值对个数，相当于是2倍的节点个数，故在初始化时 * 2</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> initCapacity 指定键值对个数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> initCapacity)</span> </span>&#123;</span><br><span class="line">     table = <span class="keyword">new</span> Object[<span class="number">2</span> * initCapacity];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取哈希探针表中节点的个数</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 节点的个数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> size;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 判断哈希探针表是否为空</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 哈希探针表是否为空</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 在指定区间内获取偶数索引位置</span></span><br><span class="line"><span class="comment">  * 为什么是偶数位置?</span></span><br><span class="line"><span class="comment">  * 因为它的数据结构是按照 | key | value | key1 | value1 | 的形式进行存储，导致了键是存储在偶数位置上，而值是存储在奇数位置上</span></span><br><span class="line"><span class="comment">  * 它采用的System.identityHashCode，该方法的结果与Object#hashCode的结果是一样的，只不过这样子就调不到开发人员自己覆写的hashCode方法</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> x 指定键</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> length 指定容量大小</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 偶数索引位置</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object x, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> h = System.identityHashCode(x);</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * (h &lt;&lt; 1) - (h &lt;&lt;8) </span></span><br><span class="line"><span class="comment">      * h * Math.pow(2,1) - h * Math.pow(2,8) -&gt; -h * (Math.pow(2,8) - Math.pow(2,1)) -&gt; -h * 2 * (Math.pow(2,7) - 1) -&gt; -h * 2 * 127 -&gt; -h * 127 * 2</span></span><br><span class="line"><span class="comment">      * 简化后的结果正好跟注释对应上，不过它始终没解释为啥是乘以-127，目前只知道 * 2是一定会得到偶数，因为它相当于进行了左移，去掉了最右边的一位，即1</span></span><br><span class="line"><span class="comment">      * 然后偶数 &amp; (length - 1) 最终是确定索引只可能是该区间内上的某一个偶数位置</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">return</span> ((h &lt;&lt; <span class="number">1</span>) - (h &lt;&lt; <span class="number">8</span>)) &amp; (length - <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取下一个偶数索引位置</span></span><br><span class="line"><span class="comment">  * 若下一个偶数索引位置超过了哈希探针表的容量大小，则从头开始，相当于在循环遍历哈希探针表</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> i 当前索引位置</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> len 表的容量大小</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 下一个偶数索引位置</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextKeyIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (i + <span class="number">2</span> &lt; len ? i + <span class="number">2</span> : <span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 对哈希探针表进行扩容</span></span><br><span class="line"><span class="comment">  * 新表是旧表的2倍，原来在旧表中节点重新散列到新表上</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> newCapacity 指定容量大小</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 是否扩容成功</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> newLength = newCapacity * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">     Object[] oldTable = table;</span><br><span class="line">     <span class="keyword">int</span> oldLength = oldTable.length;</span><br><span class="line">     <span class="keyword">if</span> (oldLength == <span class="number">2</span> * MAXIMUM_CAPACITY) &#123;</span><br><span class="line">         <span class="keyword">if</span> (size == MAXIMUM_CAPACITY - <span class="number">1</span>) <span class="comment">//最大节点的个数不能超过 MAXIMUM_CAPACITY - 1，因为有一个位置要存储Null，避免死循环</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Capacity exhausted."</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (oldLength &gt;= newLength)</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">     Object[] newTable = <span class="keyword">new</span> Object[newLength];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLength; j += <span class="number">2</span>) &#123; <span class="comment">//查找偶数位置上的键</span></span><br><span class="line">         <span class="comment">//扩容后将键值对重新散列到新表上</span></span><br><span class="line">         Object key = oldTable[j];</span><br><span class="line">         <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">             Object value = oldTable[j+<span class="number">1</span>];</span><br><span class="line">             oldTable[j] = <span class="keyword">null</span>;</span><br><span class="line">             oldTable[j+<span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">             <span class="keyword">int</span> i = hash(key, newLength);</span><br><span class="line">             <span class="keyword">while</span> (newTable[i] != <span class="keyword">null</span>)</span><br><span class="line">                 i = nextKeyIndex(i, newLength);</span><br><span class="line">             newTable[i] = key;</span><br><span class="line">             newTable[i + <span class="number">1</span>] = value;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     table = newTable;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 哈希探针表中是否包含指定键</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 是否包含指定键</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     Object k = maskNull(key);</span><br><span class="line">     Object[] tab = table;</span><br><span class="line">     <span class="keyword">int</span> len = tab.length;</span><br><span class="line">     <span class="keyword">int</span> i = hash(k, len);</span><br><span class="line">     <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">         Object item = tab[i];</span><br><span class="line">         <span class="keyword">if</span> (item == k)</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         <span class="keyword">if</span> (item == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         i = nextKeyIndex(i, len);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 哈希探针表中是否包含指定值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 是否包含指定值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">     Object[] tab = table;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tab.length; i += <span class="number">2</span>)</span><br><span class="line">         <span class="keyword">if</span> (tab[i] == value &amp;&amp; tab[i - <span class="number">1</span>] != <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 哈希探针表中是否包含指定键值对</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 是否包含指定键值对</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">containsMapping</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">     Object k = maskNull(key);</span><br><span class="line">     Object[] tab = table;</span><br><span class="line">     <span class="keyword">int</span> len = tab.length;</span><br><span class="line">     <span class="keyword">int</span> i = hash(k, len);</span><br><span class="line">     <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">         Object item = tab[i];</span><br><span class="line">         <span class="keyword">if</span> (item == k)</span><br><span class="line">             <span class="keyword">return</span> tab[i + <span class="number">1</span>] == value;</span><br><span class="line">         <span class="keyword">if</span> (item == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         i = nextKeyIndex(i, len);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 删除节点后重新散列所有可能冲突的节点</span></span><br><span class="line"><span class="comment">  * | key | value | key1 | value1 | key2 | value2 | -&gt; | key1 | value1 | key2 | value2 | null | null |</span></span><br><span class="line"><span class="comment">  * 该方法的实现较为混乱</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> d 指定索引位置</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeDeletion</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// Adapted from Knuth Section 6.4 Algorithm R</span></span><br><span class="line">     Object[] tab = table;</span><br><span class="line">     <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Look for items to swap into newly vacated slot</span></span><br><span class="line">     <span class="comment">// starting at index immediately following deletion,</span></span><br><span class="line">     <span class="comment">// and continuing until a null slot is seen, indicating</span></span><br><span class="line">     <span class="comment">// the end of a run of possibly-colliding keys.</span></span><br><span class="line">     Object item;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = nextKeyIndex(d, len); (item = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">          i = nextKeyIndex(i, len) ) &#123;</span><br><span class="line">         <span class="keyword">int</span> r = hash(item, len);</span><br><span class="line">         <span class="keyword">if</span> ((i &lt; r &amp;&amp; (r &lt;= d || d &lt;= i)) || (r &lt;= d &amp;&amp; d &lt;= i)) &#123;</span><br><span class="line">             tab[d] = item;</span><br><span class="line">             tab[d + <span class="number">1</span>] = tab[i + <span class="number">1</span>];</span><br><span class="line">             tab[i] = <span class="keyword">null</span>;</span><br><span class="line">             tab[i + <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">             d = i;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 清空</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     modCount++;</span><br><span class="line">     Object[] tab = table;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; i++)</span><br><span class="line">         tab[i] = <span class="keyword">null</span>;</span><br><span class="line">     size = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 比较当前对象与指定对象是否相等</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> o 指定对象</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 是否相等</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (o == <span class="keyword">this</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> IdentityHashMap) &#123;</span><br><span class="line">         IdentityHashMap&lt;?,?&gt; m = (IdentityHashMap&lt;?,?&gt;) o;</span><br><span class="line">         <span class="keyword">if</span> (m.size() != size)</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">         Object[] tab = m.table;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; i+=<span class="number">2</span>) &#123;</span><br><span class="line">             Object k = tab[i];</span><br><span class="line">             <span class="keyword">if</span> (k != <span class="keyword">null</span> &amp;&amp; !containsMapping(k, tab[i + <span class="number">1</span>]))</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">         Map&lt;?,?&gt; m = (Map&lt;?,?&gt;)o;</span><br><span class="line">         <span class="keyword">return</span> entrySet().equals(m.entrySet());</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">// o is not a Map</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取哈希值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 哈希值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">     Object[] tab = table;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; i +=<span class="number">2</span>) &#123;</span><br><span class="line">         Object key = tab[i];</span><br><span class="line">         <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">             Object k = unmaskNull(key);</span><br><span class="line">             result += System.identityHashCode(k) ^</span><br><span class="line">                       System.identityHashCode(tab[i + <span class="number">1</span>]);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 浅拷贝</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 克隆后的对象</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         IdentityHashMap&lt;?,?&gt; m = (IdentityHashMap&lt;?,?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">         m.entrySet = <span class="keyword">null</span>;</span><br><span class="line">         m.table = table.clone();</span><br><span class="line">         <span class="keyword">return</span> m;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 迭代器</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IdentityHashMapIterator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">     <span class="comment">//当前索引位置</span></span><br><span class="line">     <span class="keyword">int</span> index = (size != <span class="number">0</span> ? <span class="number">0</span> : table.length);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//结构修改次数</span></span><br><span class="line">     <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//移除节点前需要先获取当前索引位置，即先调用nextIndex后才能移除，下一次移除仍然需要先调用该方法</span></span><br><span class="line">     <span class="keyword">int</span> lastReturnedIndex = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//是否是有效索引</span></span><br><span class="line">     <span class="keyword">boolean</span> indexValid; <span class="comment">// To avoid unnecessary next computation</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//哈希探针表</span></span><br><span class="line">     Object[] traversalTable = table; <span class="comment">// reference to main table or copy</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 从当前索引位置开始后续是否有下一个键</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span> 是否有下一个键</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         Object[] tab = traversalTable;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; tab.length; i+=<span class="number">2</span>) &#123;</span><br><span class="line">             Object key = tab[i];</span><br><span class="line">             <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 index = i;</span><br><span class="line">                 <span class="keyword">return</span> indexValid = <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         index = tab.length;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 获取下一个索引</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span> 下一个索引</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">         <span class="keyword">if</span> (!indexValid &amp;&amp; !hasNext())</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">         indexValid = <span class="keyword">false</span>;</span><br><span class="line">         lastReturnedIndex = index;</span><br><span class="line">         index += <span class="number">2</span>;</span><br><span class="line">         <span class="keyword">return</span> lastReturnedIndex;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 移除当前节点</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (lastReturnedIndex == -<span class="number">1</span>)</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">         <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line"></span><br><span class="line">         expectedModCount = ++modCount;</span><br><span class="line">         <span class="keyword">int</span> deletedSlot = lastReturnedIndex;</span><br><span class="line">         lastReturnedIndex = -<span class="number">1</span>;</span><br><span class="line">         <span class="comment">// back up index to revisit new contents after deletion</span></span><br><span class="line">         index = deletedSlot;</span><br><span class="line">         indexValid = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">         Object[] tab = traversalTable;</span><br><span class="line">         <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">int</span> d = deletedSlot;</span><br><span class="line">         Object key = tab[d];</span><br><span class="line">         tab[d] = <span class="keyword">null</span>;        <span class="comment">// vacate the slot</span></span><br><span class="line">         tab[d + <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// If traversing a copy, remove in real table.</span></span><br><span class="line">         <span class="comment">// We can skip gap-closure on copy.</span></span><br><span class="line">         <span class="keyword">if</span> (tab != IdentityHashMap.<span class="keyword">this</span>.table) &#123;</span><br><span class="line">             IdentityHashMap.<span class="keyword">this</span>.remove(key);</span><br><span class="line">             expectedModCount = modCount;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         size--;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//在删除节点后所有可能冲突的节点会被重新散列，但是遍历的索引确实不变的，这也就是导致了移动后的某些节点可能会遍历不到，所以它在变化前做了数组的拷贝以便能够正常访问</span></span><br><span class="line">         Object item;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = nextKeyIndex(d, len); (item = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">              i = nextKeyIndex(i, len)) &#123;</span><br><span class="line">             <span class="keyword">int</span> r = hash(item, len);</span><br><span class="line">             <span class="comment">// See closeDeletion for explanation of this conditional</span></span><br><span class="line">             <span class="keyword">if</span> ((i &lt; r &amp;&amp; (r &lt;= d || d &lt;= i)) ||</span><br><span class="line">                 (r &lt;= d &amp;&amp; d &lt;= i)) &#123;</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">if</span> (i &lt; deletedSlot &amp;&amp; d &gt;= deletedSlot &amp;&amp;</span><br><span class="line">                     traversalTable == IdentityHashMap.<span class="keyword">this</span>.table) &#123;</span><br><span class="line">                     <span class="keyword">int</span> remaining = len - deletedSlot;</span><br><span class="line">                     Object[] newTable = <span class="keyword">new</span> Object[remaining];</span><br><span class="line">                     System.arraycopy(tab, deletedSlot,</span><br><span class="line">                                      newTable, <span class="number">0</span>, remaining);</span><br><span class="line">                     traversalTable = newTable;</span><br><span class="line">                     index = <span class="number">0</span>;</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 tab[d] = item;</span><br><span class="line">                 tab[d + <span class="number">1</span>] = tab[i + <span class="number">1</span>];</span><br><span class="line">                 tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                 tab[i + <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">                 d = i;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 包含所有键的迭代器</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">IdentityHashMapIterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">     <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">     <span class="function"><span class="keyword">public</span> K <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> (K) unmaskNull(traversalTable[nextIndex()]);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 包含所有值的迭代器</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">IdentityHashMapIterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">     <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">     <span class="function"><span class="keyword">public</span> V <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> (V) traversalTable[nextIndex() + <span class="number">1</span>];</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 包含所有键值对的迭代器，都是类似的代码就不做解释了</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">IdentityHashMapIterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> Entry lastReturnedEntry;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         lastReturnedEntry = <span class="keyword">new</span> Entry(nextIndex());</span><br><span class="line">         <span class="keyword">return</span> lastReturnedEntry;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         lastReturnedIndex =</span><br><span class="line">             ((<span class="keyword">null</span> == lastReturnedEntry) ? -<span class="number">1</span> : lastReturnedEntry.index);</span><br><span class="line">         <span class="keyword">super</span>.remove();</span><br><span class="line">         lastReturnedEntry.index = lastReturnedIndex;</span><br><span class="line">         lastReturnedEntry = <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">         <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">private</span> <span class="title">Entry</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">this</span>.index = index;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">         <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             checkIndexForEntryUse();</span><br><span class="line">             <span class="keyword">return</span> (K) unmaskNull(traversalTable[index]);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">         <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             checkIndexForEntryUse();</span><br><span class="line">             <span class="keyword">return</span> (V) traversalTable[index+<span class="number">1</span>];</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">         <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">             checkIndexForEntryUse();</span><br><span class="line">             V oldValue = (V) traversalTable[index+<span class="number">1</span>];</span><br><span class="line">             traversalTable[index+<span class="number">1</span>] = value;</span><br><span class="line">             <span class="comment">// if shadowing, force into main table</span></span><br><span class="line">             <span class="keyword">if</span> (traversalTable != IdentityHashMap.<span class="keyword">this</span>.table)</span><br><span class="line">                 put((K) traversalTable[index], value);</span><br><span class="line">             <span class="keyword">return</span> oldValue;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">super</span>.equals(o);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">             <span class="keyword">return</span> (e.getKey() == unmaskNull(traversalTable[index]) &amp;&amp;</span><br><span class="line">                    e.getValue() == traversalTable[index+<span class="number">1</span>]);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">if</span> (lastReturnedIndex &lt; <span class="number">0</span>)</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">super</span>.hashCode();</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span> (System.identityHashCode(unmaskNull(traversalTable[index])) ^</span><br><span class="line">                    System.identityHashCode(traversalTable[index+<span class="number">1</span>]));</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span> (unmaskNull(traversalTable[index]) + <span class="string">"="</span></span><br><span class="line">                     + traversalTable[index+<span class="number">1</span>]);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkIndexForEntryUse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Entry was removed"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取包含所有键的集合</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 包含所有键的Set集合 </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Set&lt;K&gt; ks = keySet;</span><br><span class="line">     <span class="keyword">if</span> (ks == <span class="keyword">null</span>) &#123;</span><br><span class="line">         ks = <span class="keyword">new</span> KeySet();</span><br><span class="line">         keySet = ks;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ks;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 包含哈希探针表中所有键的集合</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> size;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> containsKey(o);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> oldSize = size;</span><br><span class="line">         IdentityHashMap.<span class="keyword">this</span>.remove(o);</span><br><span class="line">         <span class="keyword">return</span> size != oldSize;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">         Objects.requireNonNull(c);</span><br><span class="line">         <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">for</span> (Iterator&lt;K&gt; i = iterator(); i.hasNext(); ) &#123;</span><br><span class="line">             <span class="keyword">if</span> (c.contains(i.next())) &#123;</span><br><span class="line">                 i.remove();</span><br><span class="line">                 modified = <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> modified;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         IdentityHashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (K key : <span class="keyword">this</span>)</span><br><span class="line">             result += System.identityHashCode(key);</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">         <span class="keyword">return</span> toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">     <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">         <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">         <span class="keyword">int</span> size = size();</span><br><span class="line">         <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">             a = (T[]) Array.newInstance(a.getClass().getComponentType(), size);</span><br><span class="line">         Object[] tab = table;</span><br><span class="line">         <span class="keyword">int</span> ti = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> si = <span class="number">0</span>; si &lt; tab.length; si += <span class="number">2</span>) &#123;</span><br><span class="line">             Object key;</span><br><span class="line">             <span class="keyword">if</span> ((key = tab[si]) != <span class="keyword">null</span>) &#123; <span class="comment">// key present ?</span></span><br><span class="line">                 <span class="comment">// more elements than expected -&gt; concurrent modification from other thread</span></span><br><span class="line">                 <span class="keyword">if</span> (ti &gt;= size) &#123;</span><br><span class="line">                     <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                 &#125;</span><br><span class="line">                 a[ti++] = (T) unmaskNull(key); <span class="comment">// unmask key</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// fewer elements than expected or concurrent modification from other thread detected</span></span><br><span class="line">         <span class="keyword">if</span> (ti &lt; size || expectedModCount != modCount) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// final null marker as per spec</span></span><br><span class="line">         <span class="keyword">if</span> (ti &lt; a.length) &#123;</span><br><span class="line">             a[ti] = <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> a;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Spliterator&lt;K&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> KeySpliterator&lt;&gt;(IdentityHashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取包含所有值的对象</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 包含所有值的对象</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Collection&lt;V&gt; vs = values;</span><br><span class="line">     <span class="keyword">if</span> (vs == <span class="keyword">null</span>) &#123;</span><br><span class="line">         vs = <span class="keyword">new</span> Values();</span><br><span class="line">         values = vs;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> vs;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 包含所有值的对象</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Values</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> ValueIterator();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> size;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> containsValue(o);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">for</span> (Iterator&lt;V&gt; i = iterator(); i.hasNext(); ) &#123;</span><br><span class="line">             <span class="keyword">if</span> (i.next() == o) &#123;</span><br><span class="line">                 i.remove();</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         IdentityHashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">         <span class="keyword">return</span> toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">     <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">         <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">         <span class="keyword">int</span> size = size();</span><br><span class="line">         <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">             a = (T[]) Array.newInstance(a.getClass().getComponentType(), size);</span><br><span class="line">         Object[] tab = table;</span><br><span class="line">         <span class="keyword">int</span> ti = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> si = <span class="number">0</span>; si &lt; tab.length; si += <span class="number">2</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (tab[si] != <span class="keyword">null</span>) &#123; <span class="comment">// key present ?</span></span><br><span class="line">                 <span class="comment">// more elements than expected -&gt; concurrent modification from other thread</span></span><br><span class="line">                 <span class="keyword">if</span> (ti &gt;= size) &#123;</span><br><span class="line">                     <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                 &#125;</span><br><span class="line">                 a[ti++] = (T) tab[si+<span class="number">1</span>]; <span class="comment">// copy value</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// fewer elements than expected or concurrent modification from other thread detected</span></span><br><span class="line">         <span class="keyword">if</span> (ti &lt; size || expectedModCount != modCount) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// final null marker as per spec</span></span><br><span class="line">         <span class="keyword">if</span> (ti &lt; a.length) &#123;</span><br><span class="line">             a[ti] = <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> a;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Spliterator&lt;V&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> ValueSpliterator&lt;&gt;(IdentityHashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取包含所有键值对的集合</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 包含所有键值对的集合</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">     Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet;</span><br><span class="line">     <span class="keyword">if</span> (es != <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">return</span> es;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">return</span> entrySet = <span class="keyword">new</span> EntrySet();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 包含所有键值对的集合</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">         <span class="keyword">return</span> containsMapping(entry.getKey(), entry.getValue());</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">         <span class="keyword">return</span> removeMapping(entry.getKey(), entry.getValue());</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> size;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         IdentityHashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">         Objects.requireNonNull(c);</span><br><span class="line">         <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = iterator(); i.hasNext(); ) &#123;</span><br><span class="line">             <span class="keyword">if</span> (c.contains(i.next())) &#123;</span><br><span class="line">                 i.remove();</span><br><span class="line">                 modified = <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> modified;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">         <span class="keyword">return</span> toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">     <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">         <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">         <span class="keyword">int</span> size = size();</span><br><span class="line">         <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">             a = (T[]) Array.newInstance(a.getClass().getComponentType(), size);</span><br><span class="line">         Object[] tab = table;</span><br><span class="line">         <span class="keyword">int</span> ti = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> si = <span class="number">0</span>; si &lt; tab.length; si += <span class="number">2</span>) &#123;</span><br><span class="line">             Object key;</span><br><span class="line">             <span class="keyword">if</span> ((key = tab[si]) != <span class="keyword">null</span>) &#123; <span class="comment">// key present ?</span></span><br><span class="line">                 <span class="comment">// more elements than expected -&gt; concurrent modification from other thread</span></span><br><span class="line">                 <span class="keyword">if</span> (ti &gt;= size) &#123;</span><br><span class="line">                     <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                 &#125;</span><br><span class="line">                 a[ti++] = (T) <span class="keyword">new</span> AbstractMap.SimpleEntry&lt;&gt;(unmaskNull(key), tab[si + <span class="number">1</span>]);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// fewer elements than expected or concurrent modification from other thread detected</span></span><br><span class="line">         <span class="keyword">if</span> (ti &lt; size || expectedModCount != modCount) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// final null marker as per spec</span></span><br><span class="line">         <span class="keyword">if</span> (ti &lt; a.length) &#123;</span><br><span class="line">             a[ti] = <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> a;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> EntrySpliterator&lt;&gt;(IdentityHashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 自定义序列化</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> s 输出流</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> java.io.IOException  </span>&#123;</span><br><span class="line">     <span class="comment">// Write out and any hidden stuff</span></span><br><span class="line">     s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Write out size (number of Mappings)</span></span><br><span class="line">     s.writeInt(size);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Write out keys and values (alternating)</span></span><br><span class="line">     Object[] tab = table;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">         Object key = tab[i];</span><br><span class="line">         <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">             s.writeObject(unmaskNull(key));</span><br><span class="line">             s.writeObject(tab[i + <span class="number">1</span>]);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 自定义反序列化</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> s 输入流</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException  </span>&#123;</span><br><span class="line">     <span class="comment">// Read in any hidden stuff</span></span><br><span class="line">     s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Read in size (number of Mappings)</span></span><br><span class="line">     <span class="keyword">int</span> size = s.readInt();</span><br><span class="line">     <span class="keyword">if</span> (size &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> java.io.StreamCorruptedException</span><br><span class="line">             (<span class="string">"Illegal mappings count: "</span> + size);</span><br><span class="line">     <span class="keyword">int</span> cap = capacity(size);</span><br><span class="line">     SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, cap);</span><br><span class="line">     init(cap);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Read the keys and values, and put the mappings in the table</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">         <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">             K key = (K) s.readObject();</span><br><span class="line">         <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">             V value = (V) s.readObject();</span><br><span class="line">         putForCreate(key, value);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 反序列化时将键值对存储到哈希探针表上</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putForCreate</span><span class="params">(K key, V value)</span> <span class="keyword">throws</span> java.io.StreamCorruptedException </span>&#123;</span><br><span class="line">     Object k = maskNull(key);</span><br><span class="line">     Object[] tab = table;</span><br><span class="line">     <span class="keyword">int</span> len = tab.length;</span><br><span class="line">     <span class="keyword">int</span> i = hash(k, len);</span><br><span class="line"></span><br><span class="line">     Object item;</span><br><span class="line">     <span class="keyword">while</span> ( (item = tab[i]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (item == k)</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> java.io.StreamCorruptedException();</span><br><span class="line">         i = nextKeyIndex(i, len);</span><br><span class="line">     &#125;</span><br><span class="line">     tab[i] = k;</span><br><span class="line">     tab[i + <span class="number">1</span>] = value;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 遍历哈希探针表并执行指定动作</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> action 指定动作</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">     Objects.requireNonNull(action);</span><br><span class="line">     <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">     Object[] t = table;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; t.length; index += <span class="number">2</span>) &#123;</span><br><span class="line">         Object k = t[index];</span><br><span class="line">         <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">             action.accept((K) unmaskNull(k), (V) t[index + <span class="number">1</span>]);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 遍历哈希探针表并执行指定动作后获取新值，利用新值替换所有节点的旧值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> function 指定动作</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; function)</span> </span>&#123;</span><br><span class="line">     Objects.requireNonNull(function);</span><br><span class="line">     <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">     Object[] t = table;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; t.length; index += <span class="number">2</span>) &#123;</span><br><span class="line">         Object k = t[index];</span><br><span class="line">         <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">             t[index + <span class="number">1</span>] = function.apply((K) unmaskNull(k), (V) t[index + <span class="number">1</span>]);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加节点</span></span><br><span class="line"><span class="comment"> * 先获取偶数索引位置，若该位置上已经存在节点且两者的节点相等，则进行替换，若两者的节点不相等则继续往下查找偶数索引位置，直到偶数位置上不存在节点时才跳出循环</span></span><br><span class="line"><span class="comment"> * 在上面我们提到，在最大键值对中必须有一个地方存在null，否则会陷入死循环，而这里正好也是说明了这一点，要是在最大键值对中所有的偶数位置上都已经填充了节点，那么它会一直查找，陷入了一个环形的查找中，反正就是死循环了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object k = maskNull(key);</span><br><span class="line"></span><br><span class="line">    retryAfterResize: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">final</span> Object[] tab = table;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> len = tab.length;</span><br><span class="line">        <span class="keyword">int</span> i = hash(k, len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object item; (item = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">             i = nextKeyIndex(i, len)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item == k) &#123; <span class="comment">//若新增的节点与当前偶数索引位置上的节点相等，将新值替换旧值</span></span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    V oldValue = (V) tab[i + <span class="number">1</span>];</span><br><span class="line">                tab[i + <span class="number">1</span>] = value;</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> s = size + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * s + (s &lt;&lt; 1) -&gt; 3 * s</span></span><br><span class="line"><span class="comment">         * 添加节点后是否超过容量的1/3，若超过则进行扩容，扩容成功后要在新表中重新查找偶数索引位置，若扩容失败或不需要扩容则直接存储节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (s + (s &lt;&lt; <span class="number">1</span>) &gt; len &amp;&amp; resize(len))</span><br><span class="line">            <span class="keyword">continue</span> retryAfterResize; <span class="comment">//代码又回到for循环上</span></span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        tab[i] = k;</span><br><span class="line">        tab[i + <span class="number">1</span>] = value;</span><br><span class="line">        size = s;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定集合到线性探针表中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = m.size();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; size)</span><br><span class="line">        resize(capacity(n)); <span class="comment">//保守扩容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</span><br><span class="line">        put(e.getKey(), e.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过指定键获取值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    Object[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = hash(k, len);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        Object item = tab[i];</span><br><span class="line">        <span class="keyword">if</span> (item == k)</span><br><span class="line">            <span class="keyword">return</span> (V) tab[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        i = nextKeyIndex(i, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="移除节点"><a href="#移除节点" class="headerlink" title="移除节点"></a>移除节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过指定键移除节点</span></span><br><span class="line"><span class="comment"> * 移除节点后会重新散列所有可能冲突的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    Object[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = hash(k, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        Object item = tab[i];</span><br><span class="line">        <span class="keyword">if</span> (item == k) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                V oldValue = (V) tab[i + <span class="number">1</span>];</span><br><span class="line">            tab[i + <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            closeDeletion(i); <span class="comment">//删除节点后重新散列所有可能冲突的节点</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        i = nextKeyIndex(i, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过键值对移除节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">removeMapping</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    Object[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = hash(k, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        Object item = tab[i];</span><br><span class="line">        <span class="keyword">if</span> (item == k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tab[i + <span class="number">1</span>] != value)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            modCount++;</span><br><span class="line">            size--;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            tab[i + <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">            closeDeletion(i);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        i = nextKeyIndex(i, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>IdentityHashMap的数据结构是<code>线性探针表</code></p></li><li><p>IdentityHashMap采用的是<code>引用相等</code>，而HashMap采用的是<code>对象相等</code></p></li><li><p>IdentityHashMap默认容量大小是64，个人认为加载因子是1/3</p></li><li><p>IdentityHashMap的容量大小必须是2的幂次方</p></li><li><p>IdentityHashMap用于序列化或深拷贝、代理场景中，不过即使这么说，我还是没能感受到它的用处</p></li><li><p>IdentityHashMap无序、不可重复、非线程安全</p></li><li><p>IdentityHashMap的键值对允许存放null</p></li><li><p><code>添加节点流程</code>：首先获取索引位置，接着若发现当前位置上不存在节点则直接添加皆可，若发现当前位置上已经存在节点了则比较两者是否相等（采用 k1 == k2的方式），若相等则说明重复进行替换值即可，若不相等说明发生冲突，它会往后查抄偶数索引位置，直到发现偶数索引位置上不存在节点时才进行存储</p></li><li><p><code>扩容机制</code>：在添加元素时判断当前节点个数是否超过了容量的1/3，若超过则以<code>2倍大小</code>进行扩容，扩容时对哈希探针表中的所有节点进行重新散列，扩容结束后从重新走上面的添加节点流程，因为节点的索引位置已经发生变化；最大键值对是 1 &lt;&lt; 29，最小键值对是 4，虽说最大键值对是1 &lt;&lt; 29，但实际上能存储的最大键值对是 1 &lt;&lt; 29 -1，因为它要保留一个null来防止死循环，在程序中它采用的是不断遍历哈希探针表来获取偶数位置上不存在节点的索引，若所有位置上都填充了节点，就会陷入死循环中，所以至少要有这样子的一个null</p></li><li><p><code>删除节点流程</code>：在删除节点后，它会重新散列所有可能冲突的节点。按照上面的添加节点流程中我们知道，两个节点即使发生冲突了也只是找其他的位置进行存储，这和不冲突的情况下进行存储并没有什么区别，所以在删除节点后，它会重新散列所有节点</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>resize</code> <code>put</code> <code>remove</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前沿&quot;&gt;&lt;a href=&quot;#前沿&quot; class=&quot;headerlink&quot; title=&quot;前沿&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前沿&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;我也是第一次认识IdentityHashMap，在工作中从未使用过它，所以对它的使用场景可能并不是很了解，本文也仅仅针对基于&lt;code&gt;JDK1.8&lt;/code&gt;的源码进行探索。&lt;code&gt;IdentityHashMap&lt;/code&gt;的数据结构应该是如图所示：&lt;/p&gt;
&lt;p class=&quot;customize-img&quot;&gt;&lt;img src=&quot;/assets/blogImg/java/identityhashmap/data-structure.png&quot; alt=&quot;IdentityHashMap数据结构&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个数据结构是我在看源码之前看了几篇别人写的文章所了解到的，个人喜欢在看源码对目标有所了解的习惯，紧接着才去深入它。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索HashMap底层实现</title>
    <link href="http://zlia.tech/2019/10/21/explain-hashmap-sourcecode/"/>
    <id>http://zlia.tech/2019/10/21/explain-hashmap-sourcecode/</id>
    <published>2019-10-21T02:32:13.000Z</published>
    <updated>2020-01-16T15:41:19.543Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>探索<code>HashMap</code>底层实现是基于<code>JDK1.8</code>，看代码之前翻了一下别人写的博客我才知道<code>JDK1.7</code>版本的HashMap是由<code>数组 + 链表</code>的数据结构组成，而对于JDK1.8是由<code>数组 + 链表 + 红黑树</code>的数据结构组成，所以我又去了解了什么是二叉树、平衡二叉树、红黑树，为的就是能做个铺垫。既然是由数组、链表、红黑树组成，加上平时我们了解过的一些细节，可以猜到它的数据结构应该是这样子的，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/java/hashmap/hashmap-data-structure.png" alt="HashMap数据结构"></p><p>长的虽然有点丑。下面我们就开始探索它吧，还是先从注释开始看！</p><a id="more"></a><h3 id="阅读注释"><a href="#阅读注释" class="headerlink" title="阅读注释"></a><div><span>阅读注释</span></div></h3><p class="customize-img"><img src="/assets/blogImg/java/hashmap/hashmap-comment-1.png" alt="HashMap注释-1"></p><p>HashMap的每个节点都由一个键值对组成，也就是一个Key对应着一个Value，相当于绑定关系了，这两者都可以为Null。Hashtable的代码我还没有看过，不过这个结论不用质疑。HashMap是<code>无序</code>的，这跟它的实现机制有关。</p><p class="customize-img"><img src="/assets/blogImg/java/hashmap/hashmap-comment-2.png" alt="HashMap注释-2"></p><p>简单来说，迭代所需的时间与遍历数组、链表、红黑树的大小成比例，因为数据有可能存放在链表、红黑树中，它要把所有的数据都遍历出来。</p><p class="customize-img"><img src="/assets/blogImg/java/hashmap/hashmap-comment-3.png" alt="HashMap注释-3"></p><p>当哈希表中元素的填充数量超过加载因子与当前容量的乘积时，就会发生扩容！</p><p class="customize-img"><img src="/assets/blogImg/java/hashmap/hashmap-comment-4.png" alt="HashMap注释-4"></p><p>为什么较高的加载因子会减少空间开销，增加了查找的成本呢？加载因子表示元素填满的程度，在容量不变的情况下，随着加载因子越大，填满的元素就越多，空间利用率变大了。假设容量固定值为16，有以下情况：</p><ul><li><p>A. 加载因子0.75，该数组在不扩容的情况下最多可填充0.75 * 16 = 12。</p></li><li><p>B. 加载因子1，该数组在不扩容的情况下最多可填充1* 16 = 16。</p></li></ul><p>所以我们说空间利用率变大了，同样的，元素多了，查找的成本也就自然增加了。</p><p class="customize-img"><img src="/assets/blogImg/java/hashmap/hashmap-comment-5.png" alt="HashMap注释-5"></p><p>若是知道键值对的数量，可创建具有指定容量大小的HashMap。</p><p class="customize-img"><img src="/assets/blogImg/java/hashmap/hashmap-comment-6.png" alt="HashMap注释-6"></p><p>HashMap属于非线程安全，需要在外部进行控制。</p><p class="customize-img"><img src="/assets/blogImg/java/hashmap/hashmap-comment-7.png" alt="HashMap注释-7"></p><p>Java提供了方法来保证HashMap的线程安全。</p><p class="customize-img"><img src="/assets/blogImg/java/hashmap/hashmap-comment-8.png" alt="HashMap注释-8"></p><p>该说法很ArrayList很像。</p><p class="customize-img"><img src="/assets/blogImg/java/hashmap/hashmap-comment-9.png" alt="HashMap注释-9"></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唯一序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的初始容量，必须是2的幂次方！！！</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 1 &lt;&lt; 4 = 16，为什么不直接写16呢?</span></span><br><span class="line"><span class="comment">     * 我们都知道计算机底层都是用二进制操作的，而如果直接写16的话最终还是要转换成二进制，对于位运算来说，就是直接用二进制进行计算的，所以效率会更高一些</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 为什么是2的幂次方?</span></span><br><span class="line"><span class="comment">     * HashMap的底层是由数组 + 链表 + 红黑树组成的，那么先从数组开始存起，先不管规则如何，想要往数组中存入元素，必须要先知道指定索引</span></span><br><span class="line"><span class="comment">     * 虽然和ArrayList一样都是数组，但对于HashMap添加一个元素来说，并不是按照顺序存入，那将和ArrayList没什么区别了</span></span><br><span class="line"><span class="comment">     * 既然不是按顺序存入，那就是按照一定的规则去计算索引了，当然了，这个规则不能是死的，所以只能拿着传入的值进行一定的规则运算</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 因为HashMap可以存入任意类型的元素，不管是Key还是Value，所以对于任意类型来说都应该可以使用这个规则，也就是说它必须存在于任意类型中，不管是方法还是成员变量，那我们能想到的</span></span><br><span class="line"><span class="comment">     * 也只有Object了，它是所有类型的父类，加上索引的值应该是int类型的，所以它最终采用了hashCode方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 不过你会发现hashCode方法返回的数值是不可预测的，而对于HashMap中的数组来说，索引的取值必须要在0~15之间，所以这个规则还没有结束，必须把hashCode的结果控制在0-15之间</span></span><br><span class="line"><span class="comment">     * 第一个反应想到的对容量大小采用取余运算，没错，是可以的，但是有更好的方法，就像上面一样，为了提高效率采用了位运算，这里我们采用的位运算是&amp;</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 那为什么不用 | 呢？只能说在A | B计算中（A相当于是hashCode，B相当于是容量大小），B没办法对结果产生范围性的控制，比如下面：</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * A:    1000</span></span><br><span class="line"><span class="comment">     *    | </span></span><br><span class="line"><span class="comment">     * B：   0111</span></span><br><span class="line"><span class="comment">     * ----------</span></span><br><span class="line"><span class="comment">     *       1111</span></span><br><span class="line"><span class="comment">     * B的最大值只能取到7，而结果确实15，肯定不行，所以最终采用了&amp;。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 因为索引的最大值只能取到15，所以是 &amp; 15，如果是16，那么就能取到16造成索引越界了，不过它有一些要求（重点来了），细心的同学会发现在构造HashMap时是可以指定其他值，比如13、17，这* 些都不是2的幂次方，我们假设采用13</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   1000         0010</span></span><br><span class="line"><span class="comment">     * &amp;            &amp;</span></span><br><span class="line"><span class="comment">     *   1101         1101</span></span><br><span class="line"><span class="comment">     * -------      -------</span></span><br><span class="line"><span class="comment">     *   0000         0000</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 你可以都计算几个，我们发现，有些索引它没办法取到，就上面的索引为2它取不到，关键就是因为1101（13）中的第三位是0，不管上面的取值（hashCode）如何，它的结果都是0，所以它的值必须要* 是1才可以，才能取到所有的值，所以应该是1111这样子的一种格式，就是最后几位都是1，不能是0和1发生间隔，而我们刚才说了最多只能取到1111（15），这个值是由容量大小 -1 决定的，所以应* 该是capacity -1的结果要是1111的这种格式才可以，我们发现：</span></span><br><span class="line"><span class="comment">     * capacity = 111 + 1 = 1000 = 8</span></span><br><span class="line"><span class="comment">     * capacity = 1111 + 1 = 10000 = 16</span></span><br><span class="line"><span class="comment">     * capacity = 11111 + 1 = 100000 = 32</span></span><br><span class="line"><span class="comment">     * capacity = 111111 + 1 = 1000000 = 64</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 多的就不计算了，这些结果都是2的幂次方，不知道我讲明白了没有...</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * ===========================================================分割线=========================================================================================</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 既然已经解释那么多，还差一个，反正后面还是要解释的，就一起得了...</span></span><br><span class="line"><span class="comment">     * 到目前为止我们得到的结论是：hashCode &amp; (capacity - 1) ，还没有结束...</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 为了更好的说明接下来的问题，我们随便取值一个hashCode来做运算</span></span><br><span class="line"><span class="comment">     * 情况A：</span></span><br><span class="line"><span class="comment">     *      0000 0010 0100 0110 0000 0110 0000 0011</span></span><br><span class="line"><span class="comment">     *   &amp;</span></span><br><span class="line"><span class="comment">     *      0000 0000 0000 0000 0000 0000 0000 1111</span></span><br><span class="line"><span class="comment">     *  ---------------------------------------------</span></span><br><span class="line"><span class="comment">     *      0000 0000 0000 0000 0000 0000 0000 0011</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 看情况A我们可以看出对于hashCode来说，它的后面好几位（从右向左看）基本上没啥用，反正不管是1还是0，结果都是0，排面都是靠低位撑着呢...也就是说索引的结果基本上由低位说了算的，所以* 这样子造成了一个现象，有可能出现高位不同低位相同的两个数计算出的索引结果是一致的！看情况B：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 情况B：</span></span><br><span class="line"><span class="comment">     *      1111 0000 0000 0000 0000 0000 0000 0011</span></span><br><span class="line"><span class="comment">     *   &amp;</span></span><br><span class="line"><span class="comment">     *      0000 0000 0000 0000 0000 0000 0000 1111</span></span><br><span class="line"><span class="comment">     * ----------------------------------------------</span></span><br><span class="line"><span class="comment">     *      0000 0000 0000 0000 0000 0000 0000 0011</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 情况A与情况B的结果是一致的，可是它们的hashCode是不一样的啊，说明了这是两个不同的数，有点问题啊！所以我们必须对这个hashCode在做一次计算，因为要使得高位不同得出的结果应该也要不* 同，故而要拿这个高位来做文章才能做区分，最简单的方式是拿hashCode的高位与hashCode自身在做一次计算，在HashMap中16位我们称之位高位（从左向右开始数），所以是拿这个16位在做一次运* 算，同样是采用位运算，有可能是&amp;、|、^（异或）</span></span><br><span class="line"><span class="comment">     * 上面我们说，有可能出现高位不同低位相同的两个数，针对不同的位运算我们采用假设：</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 若是采用位运算&amp;，AB两个数的低位都为0，A的高位为1，B的高位为0，即使在做一次运算，得到的结果还是一样的</span></span><br><span class="line"><span class="comment">     * 若是采用位运算|，AB两个数的低位都为1，A的高位为0，B的高位为1，即使在做一次运算，得到的结果也是一样的</span></span><br><span class="line"><span class="comment">     * 若是采用位运算^，AB两个数的低位都为1，A的高位为0，B的高位为1，结果就不一样了，A的结果为0，B的结果为1，是不是巧合呢</span></span><br><span class="line"><span class="comment">     * 若是采用位运算^，AB两个数的低位都为1，A的高位为1，B的高位为0，结果也是不一样的</span></span><br><span class="line"><span class="comment">     * 若是采用位运算^，AB两个数的低位都为0，A的高位为0，B的高位为1，结果也是不一样的</span></span><br><span class="line"><span class="comment">     * 若是采用位运算^，AB两个数的低位都为0，A的高位为1，B的高位为0，结果也是不一样的</span></span><br><span class="line"><span class="comment">     * 已经很明显了，最终采用的位运算是^，所以会经过如下计算：hashCode ^ (hashCode &gt;&gt;&gt; 16)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ==============================================================分割线====================================================================================  </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 上面说的有点多来总结下吧：</span></span><br><span class="line"><span class="comment">     * 1. 为什么HashMap的容量大小必须是2的幂次方：因为在HashMap中采用了位运算&amp;代替了取余运算%，这样做是为了提升效率，不过在替换运算符号的同时也有一个要求，为了能取到区间中的每个数，</span></span><br><span class="line"><span class="comment">     * 比如0-15中的每个数都能取到，也就是说最后几位要是连续的1（01111，从左向右看），不能是0与1发生间隔，而把这个数去 + 1就等于容量大小，你会发现它正是2的幂次方，所以按照我个人的理解来说，就是在将&amp;替换了%后，为了能取到区间中的每* 个索引，必须是2的幂次方，有人将这种做法叫做均匀分布</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. 为什么采用hashCode方法：HashMap能存放任意类型的数据，要想按照HashMap的规则进行运算，在任意类型的数据当中一定存在着这些规则，那就只有Object#hashCode</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. result = hasCode ^ (hashCode &gt;&gt;&gt; 16)目的是什么：为了降低不同的数导致同样的结果（索引），简单来说就是为了降低碰撞，但还是有可能发生碰撞</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 4. result &amp; (capacity - 1)：计算索引的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大容量值，必须是2的幂次方</span></span><br><span class="line"><span class="comment">     * 当通过构造函数传入更高的值时会使用最大容量指来代替</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的加载因子</span></span><br><span class="line"><span class="comment">     * 设置成0.75是对空间与时间的一个权衡（折中），加载因子过大会减少空间开销，增加查找成本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当添加节点后链表的长度超过该数值时会将链表转换为红黑树，提升查询速度，但同时内存使用会增大，因为树节点的大小约是常规节点的两倍</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 为什么是8?</span></span><br><span class="line"><span class="comment">     * 在节点良好分布的情况下，基本不会用到红黑树。而在理想情况下的随机哈希，节点分布遵循泊松分布，链表下的长度达到8已经是非常小的概率，超过8的概率我们认为是几乎不可能发生的事情</span></span><br><span class="line"><span class="comment">     * 不过HashMap还是做了预防措施，当链表的长度达到8时会被转换成红黑树，至于为什么不是7，个人认为8更合适，应该尽可能的提升性能.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当红黑树的节点个数小于该数值时，红黑树将转换回链表</span></span><br><span class="line"><span class="comment">     * 这里有个点很重要，当初我以为红黑树在删除节点后长度就会变小，那应该会按照这个指标来将其变成单向链表结构，可惜不是，红黑树在删除节点前会判断是否次树过小，若过小则转换为链表，若不是则删除节点并进行自我平衡，所以只有在重新散列时* 才会判断该数值！！！！</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 为什么不是7?</span></span><br><span class="line"><span class="comment">     * 若是频繁地添加删除添加删除元素，那么HashMap将在转换中消耗很大的性能，而7的空隙让它有一个很好的缓冲</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当链表的长度大于8时：</span></span><br><span class="line"><span class="comment">     * 若哈希表的容量大于64，则将链表转换成红黑树</span></span><br><span class="line"><span class="comment">     * 若哈希表的容量小于64，数据结构保持不变，对哈希表进行扩容，扩容时原来的节点可能在旧的索引上，有可能在新的索引上（原来的索引 + 旧的容量大小）</span></span><br><span class="line"><span class="comment">     * 至少应该是4 * TREEIFY_THRESHOLD，防止重新散列和树化阈值(TREEIFY_THRESHOLD)产生冲突</span></span><br><span class="line"><span class="comment">     * 在哈希表容量很小的情况下，随着不断的添加节点，链表的长度会越来越大，也会有越来越多的链表，当长度超过一定的阈值之后便需要转换成红黑树，而在扩容时又需要拆解成链表，这些都是需要一定的成本，所以在容量较小的情况下直接选择* 扩容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义加载因子</span></span><br><span class="line"><span class="comment">     * 容量大小不变的情况下，加载因子过大减少空间开销，增加查询成本</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 注意：该属性是可以指定大于1，但是会造成一定的成本，具体可看threshold属性说明，最终是建议不应该超过1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希表</span></span><br><span class="line"><span class="comment">     * 数组结构中包括链表、红黑树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存entrySet方法的返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 键值对的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashMap中结构修改的次数</span></span><br><span class="line"><span class="comment">     * 在上面的翻译中我们已经解释了什么是结构修改</span></span><br><span class="line"><span class="comment">     * 该成员属性是用于检测迭代器的快速失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩容前需要判断的阈值</span></span><br><span class="line"><span class="comment">     * 若超过该值则扩容，若没超过则不需要</span></span><br><span class="line"><span class="comment">     * 该值的计算方式：capacity * load factor</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 注意：该属性是可以超过指定容量大小（capacity），准备来说，应该是加载因子（load factor）可以指定大于1，下面假设是2</span></span><br><span class="line"><span class="comment">     * 相当于指定了容量大小是10，但是会到大于20时才会扩充容量</span></span><br><span class="line"><span class="comment">     * 当填充的元素个数超过10个而小于20个后，那么后续的元素必定会造成碰撞从而形成链表或红黑树，这就为后续的增加/查找造成了一定的成本</span></span><br><span class="line"><span class="comment">     * 所以建议加载因子（load factor）不应该超过1</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 我为什么会想到这个注意点呢，是因为putMapEntries方法中有一段代码：float ft = ((float)s / loadFactor) + 1.0F，这段代码很有意思，可以看具体方法中的说明</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储Key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;K&gt; keySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储Value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Collection&lt;V&gt; values;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap的大部分知识点，包括一些细节方面，其实都在上面的注释中提到了，应该尽可能的去理解它！</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量与加载因子构造哈希表</span></span><br><span class="line"><span class="comment"> * 在上面中我们提到了容量必须是2的幂次方，所以调用tableSizeFor方法来进行调整</span></span><br><span class="line"><span class="comment"> * Float.isNaN：检测是否是数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor 指定加载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量与默认加载因子（0.75）构造哈希表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始容量（16）与默认加载因子（0.75）构造哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定集合添加到哈希表中，采用默认加载因子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h4><h5 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br><span class="line">1319</span><br><span class="line">1320</span><br><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br><span class="line">1345</span><br><span class="line">1346</span><br><span class="line">1347</span><br><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br><span class="line">1366</span><br><span class="line">1367</span><br><span class="line">1368</span><br><span class="line">1369</span><br><span class="line">1370</span><br><span class="line">1371</span><br><span class="line">1372</span><br><span class="line">1373</span><br><span class="line">1374</span><br><span class="line">1375</span><br><span class="line">1376</span><br><span class="line">1377</span><br><span class="line">1378</span><br><span class="line">1379</span><br><span class="line">1380</span><br><span class="line">1381</span><br><span class="line">1382</span><br><span class="line">1383</span><br><span class="line">1384</span><br><span class="line">1385</span><br><span class="line">1386</span><br><span class="line">1387</span><br><span class="line">1388</span><br><span class="line">1389</span><br><span class="line">1390</span><br><span class="line">1391</span><br><span class="line">1392</span><br><span class="line">1393</span><br><span class="line">1394</span><br><span class="line">1395</span><br><span class="line">1396</span><br><span class="line">1397</span><br><span class="line">1398</span><br><span class="line">1399</span><br><span class="line">1400</span><br><span class="line">1401</span><br><span class="line">1402</span><br><span class="line">1403</span><br><span class="line">1404</span><br><span class="line">1405</span><br><span class="line">1406</span><br><span class="line">1407</span><br><span class="line">1408</span><br><span class="line">1409</span><br><span class="line">1410</span><br><span class="line">1411</span><br><span class="line">1412</span><br><span class="line">1413</span><br><span class="line">1414</span><br><span class="line">1415</span><br><span class="line">1416</span><br><span class="line">1417</span><br><span class="line">1418</span><br><span class="line">1419</span><br><span class="line">1420</span><br><span class="line">1421</span><br><span class="line">1422</span><br><span class="line">1423</span><br><span class="line">1424</span><br><span class="line">1425</span><br><span class="line">1426</span><br><span class="line">1427</span><br><span class="line">1428</span><br><span class="line">1429</span><br><span class="line">1430</span><br><span class="line">1431</span><br><span class="line">1432</span><br><span class="line">1433</span><br><span class="line">1434</span><br><span class="line">1435</span><br><span class="line">1436</span><br><span class="line">1437</span><br><span class="line">1438</span><br><span class="line">1439</span><br><span class="line">1440</span><br><span class="line">1441</span><br><span class="line">1442</span><br><span class="line">1443</span><br><span class="line">1444</span><br><span class="line">1445</span><br><span class="line">1446</span><br><span class="line">1447</span><br><span class="line">1448</span><br><span class="line">1449</span><br><span class="line">1450</span><br><span class="line">1451</span><br><span class="line">1452</span><br><span class="line">1453</span><br><span class="line">1454</span><br><span class="line">1455</span><br><span class="line">1456</span><br><span class="line">1457</span><br><span class="line">1458</span><br><span class="line">1459</span><br><span class="line">1460</span><br><span class="line">1461</span><br><span class="line">1462</span><br><span class="line">1463</span><br><span class="line">1464</span><br><span class="line">1465</span><br><span class="line">1466</span><br><span class="line">1467</span><br><span class="line">1468</span><br><span class="line">1469</span><br><span class="line">1470</span><br><span class="line">1471</span><br><span class="line">1472</span><br><span class="line">1473</span><br><span class="line">1474</span><br><span class="line">1475</span><br><span class="line">1476</span><br><span class="line">1477</span><br><span class="line">1478</span><br><span class="line">1479</span><br><span class="line">1480</span><br><span class="line">1481</span><br><span class="line">1482</span><br><span class="line">1483</span><br><span class="line">1484</span><br><span class="line">1485</span><br><span class="line">1486</span><br><span class="line">1487</span><br><span class="line">1488</span><br><span class="line">1489</span><br><span class="line">1490</span><br><span class="line">1491</span><br><span class="line">1492</span><br><span class="line">1493</span><br><span class="line">1494</span><br><span class="line">1495</span><br><span class="line">1496</span><br><span class="line">1497</span><br><span class="line">1498</span><br><span class="line">1499</span><br><span class="line">1500</span><br><span class="line">1501</span><br><span class="line">1502</span><br><span class="line">1503</span><br><span class="line">1504</span><br><span class="line">1505</span><br><span class="line">1506</span><br><span class="line">1507</span><br><span class="line">1508</span><br><span class="line">1509</span><br><span class="line">1510</span><br><span class="line">1511</span><br><span class="line">1512</span><br><span class="line">1513</span><br><span class="line">1514</span><br><span class="line">1515</span><br><span class="line">1516</span><br><span class="line">1517</span><br><span class="line">1518</span><br><span class="line">1519</span><br><span class="line">1520</span><br><span class="line">1521</span><br><span class="line">1522</span><br><span class="line">1523</span><br><span class="line">1524</span><br><span class="line">1525</span><br><span class="line">1526</span><br><span class="line">1527</span><br><span class="line">1528</span><br><span class="line">1529</span><br><span class="line">1530</span><br><span class="line">1531</span><br><span class="line">1532</span><br><span class="line">1533</span><br><span class="line">1534</span><br><span class="line">1535</span><br><span class="line">1536</span><br><span class="line">1537</span><br><span class="line">1538</span><br><span class="line">1539</span><br><span class="line">1540</span><br><span class="line">1541</span><br><span class="line">1542</span><br><span class="line">1543</span><br><span class="line">1544</span><br><span class="line">1545</span><br><span class="line">1546</span><br><span class="line">1547</span><br><span class="line">1548</span><br><span class="line">1549</span><br><span class="line">1550</span><br><span class="line">1551</span><br><span class="line">1552</span><br><span class="line">1553</span><br><span class="line">1554</span><br><span class="line">1555</span><br><span class="line">1556</span><br><span class="line">1557</span><br><span class="line">1558</span><br><span class="line">1559</span><br><span class="line">1560</span><br><span class="line">1561</span><br><span class="line">1562</span><br><span class="line">1563</span><br><span class="line">1564</span><br><span class="line">1565</span><br><span class="line">1566</span><br><span class="line">1567</span><br><span class="line">1568</span><br><span class="line">1569</span><br><span class="line">1570</span><br><span class="line">1571</span><br><span class="line">1572</span><br><span class="line">1573</span><br><span class="line">1574</span><br><span class="line">1575</span><br><span class="line">1576</span><br><span class="line">1577</span><br><span class="line">1578</span><br><span class="line">1579</span><br><span class="line">1580</span><br><span class="line">1581</span><br><span class="line">1582</span><br><span class="line">1583</span><br><span class="line">1584</span><br><span class="line">1585</span><br><span class="line">1586</span><br><span class="line">1587</span><br><span class="line">1588</span><br><span class="line">1589</span><br><span class="line">1590</span><br><span class="line">1591</span><br><span class="line">1592</span><br><span class="line">1593</span><br><span class="line">1594</span><br><span class="line">1595</span><br><span class="line">1596</span><br><span class="line">1597</span><br><span class="line">1598</span><br><span class="line">1599</span><br><span class="line">1600</span><br><span class="line">1601</span><br><span class="line">1602</span><br><span class="line">1603</span><br><span class="line">1604</span><br><span class="line">1605</span><br><span class="line">1606</span><br><span class="line">1607</span><br><span class="line">1608</span><br><span class="line">1609</span><br><span class="line">1610</span><br><span class="line">1611</span><br><span class="line">1612</span><br><span class="line">1613</span><br><span class="line">1614</span><br><span class="line">1615</span><br><span class="line">1616</span><br><span class="line">1617</span><br><span class="line">1618</span><br><span class="line">1619</span><br><span class="line">1620</span><br><span class="line">1621</span><br><span class="line">1622</span><br><span class="line">1623</span><br><span class="line">1624</span><br><span class="line">1625</span><br><span class="line">1626</span><br><span class="line">1627</span><br><span class="line">1628</span><br><span class="line">1629</span><br><span class="line">1630</span><br><span class="line">1631</span><br><span class="line">1632</span><br><span class="line">1633</span><br><span class="line">1634</span><br><span class="line">1635</span><br><span class="line">1636</span><br><span class="line">1637</span><br><span class="line">1638</span><br><span class="line">1639</span><br><span class="line">1640</span><br><span class="line">1641</span><br><span class="line">1642</span><br><span class="line">1643</span><br><span class="line">1644</span><br><span class="line">1645</span><br><span class="line">1646</span><br><span class="line">1647</span><br><span class="line">1648</span><br><span class="line">1649</span><br><span class="line">1650</span><br><span class="line">1651</span><br><span class="line">1652</span><br><span class="line">1653</span><br><span class="line">1654</span><br><span class="line">1655</span><br><span class="line">1656</span><br><span class="line">1657</span><br><span class="line">1658</span><br><span class="line">1659</span><br><span class="line">1660</span><br><span class="line">1661</span><br><span class="line">1662</span><br><span class="line">1663</span><br><span class="line">1664</span><br><span class="line">1665</span><br><span class="line">1666</span><br><span class="line">1667</span><br><span class="line">1668</span><br><span class="line">1669</span><br><span class="line">1670</span><br><span class="line">1671</span><br><span class="line">1672</span><br><span class="line">1673</span><br><span class="line">1674</span><br><span class="line">1675</span><br><span class="line">1676</span><br><span class="line">1677</span><br><span class="line">1678</span><br><span class="line">1679</span><br><span class="line">1680</span><br><span class="line">1681</span><br><span class="line">1682</span><br><span class="line">1683</span><br><span class="line">1684</span><br><span class="line">1685</span><br><span class="line">1686</span><br><span class="line">1687</span><br><span class="line">1688</span><br><span class="line">1689</span><br><span class="line">1690</span><br><span class="line">1691</span><br><span class="line">1692</span><br><span class="line">1693</span><br><span class="line">1694</span><br><span class="line">1695</span><br><span class="line">1696</span><br><span class="line">1697</span><br><span class="line">1698</span><br><span class="line">1699</span><br><span class="line">1700</span><br><span class="line">1701</span><br><span class="line">1702</span><br><span class="line">1703</span><br><span class="line">1704</span><br><span class="line">1705</span><br><span class="line">1706</span><br><span class="line">1707</span><br><span class="line">1708</span><br><span class="line">1709</span><br><span class="line">1710</span><br><span class="line">1711</span><br><span class="line">1712</span><br><span class="line">1713</span><br><span class="line">1714</span><br><span class="line">1715</span><br><span class="line">1716</span><br><span class="line">1717</span><br><span class="line">1718</span><br><span class="line">1719</span><br><span class="line">1720</span><br><span class="line">1721</span><br><span class="line">1722</span><br><span class="line">1723</span><br><span class="line">1724</span><br><span class="line">1725</span><br><span class="line">1726</span><br><span class="line">1727</span><br><span class="line">1728</span><br><span class="line">1729</span><br><span class="line">1730</span><br><span class="line">1731</span><br><span class="line">1732</span><br><span class="line">1733</span><br><span class="line">1734</span><br><span class="line">1735</span><br><span class="line">1736</span><br><span class="line">1737</span><br><span class="line">1738</span><br><span class="line">1739</span><br><span class="line">1740</span><br><span class="line">1741</span><br><span class="line">1742</span><br><span class="line">1743</span><br><span class="line">1744</span><br><span class="line">1745</span><br><span class="line">1746</span><br><span class="line">1747</span><br><span class="line">1748</span><br><span class="line">1749</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定容量大小调整到2的幂次方</span></span><br><span class="line"><span class="comment"> * 具体是调整到比该容量还大的最近2的幂次方</span></span><br><span class="line"><span class="comment"> * cap = 21 最终调整到 32</span></span><br><span class="line"><span class="comment"> * cap = 15 最终调整到 16</span></span><br><span class="line"><span class="comment"> * 若是2的幂次方则结果是原来的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cap 指定容量大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 2的幂次方</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定集合中的元素添加到哈希表中</span></span><br><span class="line"><span class="comment"> * 若哈希表为空，表达式s/loadFactor有可能出现带有小数的情况，比如1.6、1.4这样子的一种格式</span></span><br><span class="line"><span class="comment"> * 而后续的 + 1.0F 和 (int)ft 相当于是对小数点做一个向上取整，以尽可能的保证更大容量</span></span><br><span class="line"><span class="comment"> * 若哈希表不为空，则预先进行扩容一次，若没有预先进行扩容，而是等到后续添加元素达到阈值后才开始扩容，那个时候随着元素的增加扩容所消耗的时间也会增加，简单来说，减少了一定的时间成本</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 总结：</span></span><br><span class="line"><span class="comment"> * 若哈希表已初始化，则采用它自身的容量进行扩容</span></span><br><span class="line"><span class="comment"> * 若哈希表未初始化，则采用集合的容量作为哈希表的容量大小，前提是大于哈希表的容量大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取哈希表中的元素个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希表中的元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断哈希表是否为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希表是否为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定键查找节点</span></span><br><span class="line"><span class="comment"> * HashMap在插入节点时先通过hashCode进行比较，若两者相同在通过equals进行比较，若也相同则认为是重复，会进行相应的覆盖，若不相等则用链表或红黑树进行存储</span></span><br><span class="line"><span class="comment"> * 按照如此的思路，要查找某个节点，则hashCode与equals必须都相等，若有其中一个不相等则继续查找下一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 键的哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定键对应的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定键计算哈希值</span></span><br><span class="line"><span class="comment"> * 至于为什么是这么计算的可参考一开始提到的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断指定类是否实现了Comparable，同时Comparable的泛型是它自身</span></span><br><span class="line"><span class="comment"> * 简单来说就是判断指定类C是否满足`class C implements Comparable&lt;C&gt;`这样子的一种格式，若满足则返回该类的class，否则返回null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 指定类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> x.getClass or null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">        Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;</span><br><span class="line">        <span class="keyword">if</span> ((c = x.getClass()) == String.class) <span class="comment">// bypass checks</span></span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        <span class="keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ts.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((t = ts[i]) <span class="keyword">instanceof</span> ParameterizedType) &amp;&amp;</span><br><span class="line">                    ((p = (ParameterizedType)t).getRawType() ==</span><br><span class="line">                     Comparable.class) &amp;&amp;</span><br><span class="line">                    (as = p.getActualTypeArguments()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    as.length == <span class="number">1</span> &amp;&amp; as[<span class="number">0</span>] == c) <span class="comment">// type arg is c</span></span><br><span class="line">                    <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 若x与kc的类型相同则比较x与k的大小，实际上k与kc的类类型是同一个，简单来说就是在比较k与x的大小，既然是比较，类类型是一样的才有意义</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> kc k的类类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 比较值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 另一个比较值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 比较结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareComparables</span><span class="params">(Class&lt;?&gt; kc, Object k, Object x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x == <span class="keyword">null</span> || x.getClass() != kc ? <span class="number">0</span> :</span><br><span class="line">            ((Comparable)k).compareTo(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否包含指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化哈希表或以两倍的大小进行扩容，扩容后进行重新散列-rehash</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * rehash机制：</span></span><br><span class="line"><span class="comment"> * 若指定索引上存在元素且没有链表或红黑树结构，则在新数组上重新计算索引并填充即可</span></span><br><span class="line"><span class="comment"> * 若指定索引上存在元素且结构是链表，将链表分成高低位两条链表并往新数组中填充，高位链表会存储在新索引上（原索引 + 旧容量大小），低位链表存储在原索引上</span></span><br><span class="line"><span class="comment"> * 若指定索引上存在元素且结构是红黑树，将红黑树分成高低位两棵树，低位这棵树中的长度若超过8，在判断高位那棵树是否存在，若不存在说明低位已经树形化过，若存在说明结构已经修改，低位需要重新树形化，若低位这棵树的长度不超过8则将这棵树转换* 成单向链表的结构，同理对于处理高位这棵树也是如此判断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length; <span class="comment">//旧容量</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold; <span class="comment">//旧阈值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>; <span class="comment">//新容量与新阈值</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123; <span class="comment">//旧容量超过最大容量时</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY) <span class="comment">//新容量是旧容量的两倍大小</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">//新阈值是旧阈值的两倍大小</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">//threshold大于0说明采用了自定义的初始容量大小，而一开始threshold存放了初始容量的大小</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">//threshold小于0说明采用默认初始容量大小与加载因子</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123; <span class="comment">//只有在采用自定义初始容量大小的情况下才会进入到该语句中</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap]; <span class="comment">//使用新容量创建新数组以便进行扩容</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>) <span class="comment">//哈希表指定索引上只有一个元素，也就是说该位置上不存在链表或者红黑树之类的数据结构</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e; <span class="comment">//将该位置上的元素按照新容量重新散列，也就是在新数组中重新计算索引并填充，至于为什么是这么计算的，最上面应该提到了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) <span class="comment">//哈希表指定索引上是红黑树，红黑树将自身拆解成高低位两棵树，具体可参见split方法</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; </span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 哈希表指定索引上是一条链表，根据哈希值将一条链表上的节点分成高位、低位两部分组成的两条链表（分组），将高低位两条链条填充到新数组中，高位填充到新索引（原索引 + 旧容量大小）处，而低位的索引保持不变</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * 首先应该明白oldCap是2的幂次方，它的二进制应该是0000 0000 0000 0000 0000 0000 0000 1000 这样子的一种格式</span></span><br><span class="line"><span class="comment">                         * e.hash &amp; oldCap：将结果大于0的节点构成一组链表，既然是链表就有头部节点与尾部节点，所以这就对应了上面的hiHead、hiTail，我们称作高位；同样的将结果小于0</span></span><br><span class="line"><span class="comment">                         * 的节点构成另外一组链表，对应着loHead、loTail，我们称作低位</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 为什么在新的哈希表中索引只可能出现在旧索引处或旧索引 + 旧容量大小处</span></span><br><span class="line"><span class="comment">                     * 首先索引的计算方式是：e.hash &amp; (capacity-1)，方便理解我们直接举例</span></span><br><span class="line"><span class="comment">                     * oldCapacity：16  newCapacity：32   node1：0000 0000 0000 0000 0000 1111 0000 1010  node2：0000 0000 0000 0000 0000 1111 0001 1010</span></span><br><span class="line"><span class="comment">                     *         node1 &amp; (oldCapacity -1)                                           node2 &amp; (oldCapacity -1)</span></span><br><span class="line"><span class="comment">                     * </span></span><br><span class="line"><span class="comment">                     *    0000 0000 0000 0000 0000 1111 0000 1010                        0000 0000 0000 0000 0000 1111 0001 1010     </span></span><br><span class="line"><span class="comment">                     * &amp;  0000 0000 0000 0000 0000 0000 0000 1111                   &amp;    0000 0000 0000 0000 0000 0000 0000 1111</span></span><br><span class="line"><span class="comment">                     * --------------------------------------------                    ------------------------------------------</span></span><br><span class="line"><span class="comment">                     *    0000 0000 0000 0000 0000 0000 0000 1010                        0000 0000 0000 0000 0000 0000 0000 1010</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     *         node1 &amp; (newCapacity -1)                                           node2 &amp; (newCapacity -1)</span></span><br><span class="line"><span class="comment">                     * </span></span><br><span class="line"><span class="comment">                     *    0000 0000 0000 0000 0000 1111 0000 1010                        0000 0000 0000 0000 0000 1111 0001 1010     </span></span><br><span class="line"><span class="comment">                     * &amp;  0000 0000 0000 0000 0000 0000 0001 1111                   &amp;    0000 0000 0000 0000 0000 0000 0001 1111</span></span><br><span class="line"><span class="comment">                     * --------------------------------------------                    ------------------------------------------</span></span><br><span class="line"><span class="comment">                     *    0000 0000 0000 0000 0000 0000 0000 1010                        0000 0000 0000 0000 0000 0000 0001 1010</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * 在旧容量当中索引取决于最后的4位，而在新容量当中索引取决于最后的5位，旧容量与新容量相比最大的差别在于倒数第5位上，而能造成它们索引不同的情况就要看hash值的倒数第5位上是否是1</span></span><br><span class="line"><span class="comment">                     * 若不是1，&amp;完之后结果自然为0，此时的新容量下的索引与旧容量下的索引是一致的；若是1，&amp;完之后结果自然是1，而正好该位置上是旧容量的大小（倒数第5位），如果转换成十进制的话，此时新容量下的索引是旧容量下的索引 +  * 旧容量大小，所以我们可以得出在新容量下的索引只可能出现在这两种情况下。而在计算当中采用 e.hash &amp; oldCap就是在判断倒数第5位是否是1，若是1则索引是旧容量下的索引 + 旧容量大小，若不是1，则还是原来的索引</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定索引上的单向链表结构转成红黑树 + 双向链表</span></span><br><span class="line"><span class="comment"> * 链表长度不仅要超过8，同时哈希表的长度要超过64，否则直接进行扩容</span></span><br><span class="line"><span class="comment"> * 为什么还要采用双向链表呢?</span></span><br><span class="line"><span class="comment"> * 因为在转成红黑树后需要将根节点移动到链表的头部，这就需要更改链表节点之间的关系，而单向链表中是不知道上一个节点是谁，若想知道的话就还需要从头遍历，所以采用双向链表</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tab 新数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 哈希值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123; <span class="comment">//将链表转成双向链表</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>); <span class="comment">//将节点信息变成红黑树节点</span></span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab); <span class="comment">//将双向链表转成红黑树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将节点信息转换成红黑树节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> next 下一个节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 红黑树节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 转换成普通的节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> next 下一个节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 普通节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表树形化</span></span><br><span class="line"><span class="comment"> * 单向链表 -&gt; 双向链表 + 红黑树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tab 哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="comment">//若根节点不存在则进行设置</span></span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            root = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123; <span class="comment">//存在根节点则要进行左右子树的比较来选择最终的存储点</span></span><br><span class="line">                <span class="keyword">int</span> dir, ph;</span><br><span class="line">                K pk = p.key;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h) <span class="comment">//通过比较hash值，此时说明x节点小于根节点，故应该在左子树</span></span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h) <span class="comment">//右子树上</span></span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp; <span class="comment">//若当前节点与另外一个节点的hash相等的话，就比较键值，若键值也相同的话就比较类名</span></span><br><span class="line">                            (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                            (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p; <span class="comment">//xp是p节点的父节点</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123; <span class="comment">//查找到叶子节点后说明后续已经没有节点了，可以进行插入了</span></span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    root = balanceInsertion(root, x); <span class="comment">//插入后仍然需要维持红黑树的平衡，通过左右旋转的方式来维持平衡</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    moveRootToFront(tab, root); <span class="comment">//将根节点移动到链表头部</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先比较两个对象的类名是否相等，若相等则比较两个对象的哈希值大小并返回结果，若不相等则返回结果</span></span><br><span class="line"><span class="comment"> * 若对象为空，则哈希值等于0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> b 另一个对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 比较结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tieBreakOrder</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span> ||</span><br><span class="line">        (d = a.getClass().getName().</span><br><span class="line">            compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">        d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span><br><span class="line">                -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树中插入节点后维持平衡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 插入节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * xp = x.parent    x的父节点</span></span><br><span class="line"><span class="comment">        * xpp = x.parent.parent x的爷爷节点</span></span><br><span class="line"><span class="comment">        * xppl = x.parent.parent.left  x的爷爷节点的左子树</span></span><br><span class="line"><span class="comment">        * xppr = x.parent.parent.right  x的爷爷节点的右子树</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    x.red = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123; <span class="comment">//1 x.parent == null 说明是根节点，将其变成黑色即可</span></span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>) <span class="comment">//2 xp = x.parent 说明x的父节点是黑色，不需要任何的操作</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123; <span class="comment">//3 x的父节点在x的爷爷节点的左子树上</span></span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123; <span class="comment">//4 x的父节点是红色，叔叔节点也是红色</span></span><br><span class="line">                xppr.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == xp.right) &#123; <span class="comment">//5 X的父节点在X的爷爷节点的左子树上，X在X的父节点的右子树上</span></span><br><span class="line">                    root = rotateLeft(root, x = xp);<span class="comment">//注意此时的x变成了原来x的父节点</span></span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123; <span class="comment">//6 X的父节点在X的爷爷节点的左子树上，X在X的父节点的左子树上</span></span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateRight(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//7 X的父节点在X的爷爷节点的右子树上</span></span><br><span class="line">            <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123; <span class="comment">//8 x的父节点是红色，叔叔节点也是红色</span></span><br><span class="line">                xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123; <span class="comment">//9 x的父节点在X的爷爷节点的右子树上，X在X的父节点的左子树上</span></span><br><span class="line">                    root = rotateRight(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123; <span class="comment">//10 x的父节点在X的爷爷节点的右子树上，X在X的父节点的右子树上</span></span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树中指定节点进行左旋</span></span><br><span class="line"><span class="comment"> * 过多的算法就不讨论了，可以参考红黑树、AVL树的文章</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 指定节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * r = p.right 当前节点的右子树</span></span><br><span class="line"><span class="comment">     * rl = r.left 当前节点的右子树的左子树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>)</span><br><span class="line">            rl.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">            (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">            pp.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = r;</span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树中指定节点进行右旋</span></span><br><span class="line"><span class="comment"> * 过多的算法就不讨论了，可以参考红黑树、AVL树的文章</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 指定节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (l = p.left) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="keyword">null</span>)</span><br><span class="line">            lr.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">            (root = l).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)</span><br><span class="line">            pp.right = l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.left = l;</span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将根节点移动到链表的头部</span></span><br><span class="line"><span class="comment"> * 看到这里我发现，它不仅保留了双向链表同时增加了红黑树，所以在查找的时候应该是使用的红黑树结构</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tab 哈希表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; tab != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; root.hash;</span><br><span class="line">        TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">        <span class="keyword">if</span> (root != first) &#123;</span><br><span class="line">            Node&lt;K,V&gt; rn;</span><br><span class="line">            tab[index] = root;</span><br><span class="line">            TreeNode&lt;K,V&gt; rp = root.prev;</span><br><span class="line">            <span class="keyword">if</span> ((rn = root.next) != <span class="keyword">null</span>)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)rn).prev = rp;</span><br><span class="line">            <span class="keyword">if</span> (rp != <span class="keyword">null</span>)</span><br><span class="line">                rp.next = rn;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                first.prev = root;</span><br><span class="line">            root.next = first;</span><br><span class="line">            root.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前节点作为查找的起始节点，查找其所有子节点中是否有匹配到指定节点，匹配必须是hash相同、equals相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h 哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 指定节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> kc 比较器的泛型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">        TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h) <span class="comment">//当前节点的hash大于指定节点的hash，后续应该从左子树进行下一轮比较</span></span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h) <span class="comment">//当前节点的hash小于指定节点的hash，后续应该从右子树进行下一轮比较</span></span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk))) <span class="comment">//当前节点的hash与指定节点的hash相同，同时equals也相等</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//执行到这里说明当前节点的hash与指定节点的hash相同，但是equals不相等，因为接下来不知道该从左子树还是右子树开始查找，所以要先判断是否存在左右子树</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>) <span class="comment">//若左子树为空，那只能从右子树开始进行下一轮比较</span></span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>) <span class="comment">// 若右子树为空，那只能从左子树开始进行下一轮比较</span></span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                    (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                    (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>) </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                * 若左右子树都不为空，那就必须定义一种规则了，通过comparable方法来比较key的大小</span></span><br><span class="line"><span class="comment">                * 首先得先检测是否实现了comparable才可以进行比较-comparableClassFor</span></span><br><span class="line"><span class="comment">                * 接着还得检测是否类型相同，否则也不具备可比性</span></span><br><span class="line"><span class="comment">                * 若满足以上两点则返回比较结果</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>) <span class="comment">//执行到这里说明无法通过comparable进行比较或者key在比较之后还是相等，只能先尝试从右子树开始查找</span></span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">//若右子树递归后还是未找到，那么就从左子树开始查找</span></span><br><span class="line">            p = pl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//最后未匹配的话就返回null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 将红黑树拆解成高低的两棵树，并根据判断来选择是转换成单向链表还是重新树形化</span></span><br><span class="line"><span class="comment"> * 若低位这棵树的长度不超过6，则将其转换成单向链表，同理高位这棵树也是这么判断的</span></span><br><span class="line"><span class="comment"> * 若低位这棵树的长度超过6，且另外一棵树高位不存在，说明红黑树并未将其拆解成两棵树，低位这棵树的结构仍是不变，故而不需要进行重新树形化，而若高位这棵树存在，则需要重新树形化，因为结构已经发生变化</span></span><br><span class="line"><span class="comment"> * 同理，高位也是如此判断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tab 新的哈希表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bit 旧的哈希表长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123; <span class="comment">//尝试将红黑树拆解成高低位的两棵树，至少何为高低位可参考上面的解释</span></span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">        e.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)  <span class="comment">//低位这棵树的长度小于链表的阈值则转换成链表结构</span></span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">//若hiHead为空，说明红黑树并未拆解成高低位两棵树，低位已经被树形化过了不需要重新树形化，若hiHead不为空，说明红黑树已经拆解成高低位两棵树，结构已经发生变化，低位需要重新树形化</span></span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树转换单向链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 链表的头部节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">        Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">            hd = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tl.next = p;</span><br><span class="line">        tl = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在哈希表中通过指定键移除节点</span></span><br><span class="line"><span class="comment"> * 返回值是null表示不存在移除的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定value，通过hash与equals找到节点后还要根据matchValue来判断是否需要判断value值相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> matchValue 标识是否需要判断value是否相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> movable 标识移除节点后是否需要移动其他节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 移除的节点或null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value, <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">//当前节点刚好是要移除的节点，链表的头部或红黑树的根节点</span></span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123; <span class="comment">//走到这里说明头部节点/根节点为匹配上，获取它的下一个节点，若有说明它的结构可能是红黑树或链表，若没有说明不存在移除的节点</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">//判断当前节点是否是红黑树结构</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);  <span class="comment">//从红黑树中查找节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123; <span class="comment">//从链表中查找节点</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e; <span class="comment">// 把当前节点p指向e，这一步是让p存储的永远下一次循环里e的父节点，如果下一次e匹配上了，那么p就是node的父节点</span></span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value || <span class="comment">//matchValue标识在找到节点后是否需要判断value值是否相等</span></span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode) <span class="comment">//从红黑树中移除节点</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p) <span class="comment">//说明头部节点刚好是要移除的节点，直接将它的下一个节点填充到哈希表中</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 说明链表中找到移除的节点，p是node的父节点，由于要删除node，所有只需要把p的下一个节点指向到node的下一个节点即可把node从链表中删除了</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在红黑树中通过指定键查找节点</span></span><br><span class="line"><span class="comment"> * 从根节点开始查找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h 哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树中移除当前节点</span></span><br><span class="line"><span class="comment"> * 调用该方法前当前节点必须存在</span></span><br><span class="line"><span class="comment"> * 作者说该方法的代码比典型的红黑删除代码更为混乱，因为红黑树在删除中会通过交换值的方式来删除，而在红黑树中还维护了一个双向链表，若是直接通过交换值会对双向链表中节点之间的关系造成错误，因此它采用了另外一种方式-交换树链接</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 交换树链接：当前节点与当前节点的右子树的最左节点进行交换，包括parent、left、right节点的关系都发生交换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tab 新的哈希表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> movable 标识移除节点后是否需要移动其他节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始处理链表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">    TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl; <span class="comment">//first、root：根节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev; <span class="comment">//succ：当前节点的下一个节点   pred：当前节点的上一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>) <span class="comment">//说明当前节点是根节点，直接将它的下一个节点作为根节点</span></span><br><span class="line">        tab[index] = first = succ;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//说明当前节点是某一个节点，移除当前节点时更改当前节点的上下节点的关系</span></span><br><span class="line">        pred.next = succ;</span><br><span class="line">    <span class="keyword">if</span> (succ != <span class="keyword">null</span>)</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span>) <span class="comment">//走到这里说明当前节点的下一个节点为空，即表明已经没有节点了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.parent != <span class="keyword">null</span>) </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * moveRootToFront是用来维持红黑树的根节点即为链表的头部，但是在该方法在调用moveRootToFront时会进行判断，也就是它可能不会被调用到，那么会造成红黑的根节点与链表的头部节点不一致</span></span><br><span class="line"><span class="comment">     * 这里获取的root指向的是链表的头部节点，并不是红黑树的根节点，故而还要往上查找根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        root = root.root();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.right == <span class="keyword">null</span> ||</span><br><span class="line">        (rl = root.left) == <span class="keyword">null</span> || rl.left == <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 通过root节点来判断此红黑树是否太小, 如果是则调用untreeify方法转为链表节点并返回，转链表后就无需再进行下面的红黑树处理，这比维持红黑树的平衡来说简单多了</span></span><br><span class="line"><span class="comment">         * 因为在删除节点后红黑树需要维持平衡，有可能根节点会发生变化，也有可能被置空（根节点与删除节点之间是父子节点的关系导致），而又由于没有调用moveRootToFront来更新根节点，导致下次在获取根节点时可能获取到的为空</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结束处理链表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开始处理红黑树</span></span><br><span class="line"></span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>, pl = left, pr = right, replacement; <span class="comment">//p：当前节点  pl：当前节点的左子树    pr：当前节点的右子树</span></span><br><span class="line">    <span class="comment">//1. 当前节点有两个子节点的情况下</span></span><br><span class="line">    <span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">        <span class="keyword">while</span> ((sl = s.left) != <span class="keyword">null</span>) <span class="comment">//找到当前节点的右子树的最左节点，即为s</span></span><br><span class="line">            s = sl;</span><br><span class="line">        <span class="keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="comment">//交换s与p的颜色，也就是交换当前节点与最左节点的颜色</span></span><br><span class="line">        TreeNode&lt;K,V&gt; sr = s.right;  <span class="comment">//最左节点的右子树，即为sr</span></span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;  <span class="comment">//当前节点的父节点，即为pp</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一次调整和第二次调整：将当前节点和最左节点进行了位置调换</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一次调整</span></span><br><span class="line">        <span class="keyword">if</span> (s == pr) &#123;  <span class="comment">//如果当前节点的右节点即为最左节点，则将当前节点的父节点赋值为最左节点，将最左节点的右节点赋值为当前节点</span></span><br><span class="line">            p.parent = s;</span><br><span class="line">            s.right = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; sp = s.parent; <span class="comment">//最左节点的父节点，即为sp</span></span><br><span class="line">            <span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123; <span class="comment">//将当前节点的父节点变成最左节点的父节点</span></span><br><span class="line">                <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                    sp.left = p; <span class="comment">//最左节点应该是在左子树上，这边的代码应该是会走进去，而不会走到else中；将最左节点的父节点的左子树变成当前节点</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sp.right = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>) <span class="comment">//最左节点的左子树必定为null，但有可能还有右子树，故而将它的右子树变成当前节点的右子树</span></span><br><span class="line">                pr.parent = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二次调整</span></span><br><span class="line">        p.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>)</span><br><span class="line">            sr.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>)</span><br><span class="line">            pl.parent = s;</span><br><span class="line">        <span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>)</span><br><span class="line">            root = s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = s;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = s;</span><br><span class="line">        <span class="keyword">if</span> (sr != <span class="keyword">null</span>) <span class="comment">//若最左节点的右子树不为空，则赋值replacement为最左节点的右子树</span></span><br><span class="line">            replacement = sr;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            replacement = p; <span class="comment">//若最左节点的右子树为空，则赋值replacement为当前节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 当前节点只有一个子节点且是左子树，replacement赋值当前节点的左子树</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)</span><br><span class="line">        replacement = pl;</span><br><span class="line">    <span class="comment">//3. 当前节点只有一个子节点且是右子树，replacement赋值为当前节点的右子树</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)</span><br><span class="line">        replacement = pr;</span><br><span class="line">    <span class="comment">//4. 当前节点无子节点，即本身是个叶子节点，replacement赋值为当前节点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        replacement = p;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第三次调整：使用replacement节点替换掉p节点的位置，将p节点移除</span></span><br><span class="line">    <span class="keyword">if</span> (replacement != p) &#123; <span class="comment">//这里说明当前节点不是叶子节点，直接用replacement代替当前节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent; <span class="comment">//获取当前节点的父节点</span></span><br><span class="line">        <span class="keyword">if</span> (pp == <span class="keyword">null</span>) <span class="comment">//说明当前节点是根节点</span></span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left) <span class="comment">//说明当前节点在父节点的左子树上</span></span><br><span class="line">            pp.left = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = replacement; <span class="comment">//说明当前节点在父节点的右子树上</span></span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>; <span class="comment">//当前节点已经被完整的替换为replacement, 将当前节点清空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若当前节点的颜色是红色，可以直接删除，因为删除一个红色并不会影响红黑树的平衡，否则需要进行红黑树的平衡调整，因为删除黑色会导致黑色数目不一致</span></span><br><span class="line">    TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">//说明当前节点是叶子节点，也就是说replacement是需要删除的节点，直接将replacement的关系清空即可</span></span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        p.parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                pp.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                pp.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (movable) <span class="comment">//判断是否将红黑树的根节点移动到链表的头部</span></span><br><span class="line">        moveRootToFront(tab, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调整红黑树的平衡</span></span><br><span class="line"><span class="comment"> * 该方法可以说是HashMap中最复杂的部分了，不过我认为它是跟算法有些关系，对于源码中的算法个人认为只要你清楚它在做什么即可，毕竟你的算法基本并不怎样，所以这里就不做深入研究了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 当前节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceDeletion</span><span class="params">(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * x：当前节点</span></span><br><span class="line"><span class="comment">     * xp：当前节点的父节点</span></span><br><span class="line"><span class="comment">     * xpl：当前节点的父节点的左子树</span></span><br><span class="line"><span class="comment">     * xpr：当前节点的父节点的右子树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpl, xpr;;)  &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span> || x == root)  <span class="comment">//当前节点是根节点的情况</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123; <span class="comment">//当前节点是根节点，染成黑色，直接返回，因为调整过后，root并不一定指向删除操作过后的根节点，如果之前删除的是root节点，则x将成为新的根节点）</span></span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x.red) &#123; <span class="comment">//如果x为红色，则无需调整</span></span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((xpl = xp.left) == x) &#123; <span class="comment">//当前节点为其父节点的左孩子</span></span><br><span class="line">            <span class="keyword">if</span> ((xpr = xp.right) != <span class="keyword">null</span> &amp;&amp; xpr.red) &#123; <span class="comment">//如果它有红色的兄弟节点xpr，那么它的父亲节点xp一定是黑色节点</span></span><br><span class="line">                xpr.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">true</span>;</span><br><span class="line">                root = rotateLeft(root, xp);</span><br><span class="line">                xpr = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果xpr为空，则向上继续调整，将x的父节点xp作为新的x继续循环</span></span><br><span class="line">            <span class="keyword">if</span> (xpr == <span class="keyword">null</span>)</span><br><span class="line">                x = xp;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</span><br><span class="line">                <span class="keyword">if</span> ((sr == <span class="keyword">null</span> || !sr.red) &amp;&amp;</span><br><span class="line">                    (sl == <span class="keyword">null</span> || !sl.red)) &#123; <span class="comment">//若sl和sr都为黑色或者不存在，即xpr没有红色孩子，则将xpr染红</span></span><br><span class="line">                    xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                    x = xp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sr == <span class="keyword">null</span> || !sr.red) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (sl != <span class="keyword">null</span>)</span><br><span class="line">                            sl.red = <span class="keyword">false</span>;</span><br><span class="line">                        xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateRight(root, xpr);</span><br><span class="line">                        xpr = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                            <span class="keyword">null</span> : xp.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpr.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                        <span class="keyword">if</span> ((sr = xpr.right) != <span class="keyword">null</span>)</span><br><span class="line">                            sr.red = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xp.red = <span class="keyword">false</span>;</span><br><span class="line">                        root = rotateLeft(root, xp);</span><br><span class="line">                    &#125;</span><br><span class="line">                    x = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// symmetric</span></span><br><span class="line">            <span class="keyword">if</span> (xpl != <span class="keyword">null</span> &amp;&amp; xpl.red) &#123;</span><br><span class="line">                xpl.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">true</span>;</span><br><span class="line">                root = rotateRight(root, xp);</span><br><span class="line">                xpl = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (xpl == <span class="keyword">null</span>)</span><br><span class="line">                x = xp;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;</span><br><span class="line">                <span class="keyword">if</span> ((sl == <span class="keyword">null</span> || !sl.red) &amp;&amp;</span><br><span class="line">                    (sr == <span class="keyword">null</span> || !sr.red)) &#123;</span><br><span class="line">                    xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                    x = xp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sl == <span class="keyword">null</span> || !sl.red) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                            sr.red = <span class="keyword">false</span>;</span><br><span class="line">                        xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpl);</span><br><span class="line">                        xpl = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                            <span class="keyword">null</span> : xp.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xpl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpl.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                        <span class="keyword">if</span> ((sl = xpl.left) != <span class="keyword">null</span>)</span><br><span class="line">                            sl.red = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xp.red = <span class="keyword">false</span>;</span><br><span class="line">                        root = rotateRight(root, xp);</span><br><span class="line">                    &#125;</span><br><span class="line">                    x = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表中是否包含指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                    (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有键的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有键的Set集合 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Set&lt;K&gt; ks = keySet;</span><br><span class="line">    <span class="keyword">if</span> (ks == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ks = <span class="keyword">new</span> KeySet();</span><br><span class="line">        keySet = ks;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含哈希表中所有键的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取哈希表的大小，共存储了多少节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 哈希表的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空哈希表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取包含所有键的迭代器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 包含所有键的迭代器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希表中是否包含指定键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 指定键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否包含指定键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsKey(o); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据指定键移除节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取分割迭代器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;K&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KeySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历所有键并执行指定动作</span></span><br><span class="line"><span class="comment">     * 遍历过程中不允许HashMap调用任何会修改结构的方法，否则最后会抛出异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> action 指定动作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有值的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有值的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Collection&lt;V&gt; vs = values;</span><br><span class="line">    <span class="keyword">if</span> (vs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        vs = <span class="keyword">new</span> Values();</span><br><span class="line">        values = vs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含所有值的对象</span></span><br><span class="line"><span class="comment"> * 和上面的集合类似，就不做介绍了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Values</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ValueIterator(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsValue(o); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;V&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ValueSpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e.value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有键值对的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有键值对的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> EntrySet()) : es;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含所有键值对的集合</span></span><br><span class="line"><span class="comment"> * 和上面的代码大同小异，不讲解了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">        Object key = e.getKey();</span><br><span class="line">        Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class="line">        <span class="keyword">return</span> candidate != <span class="keyword">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">            Object key = e.getKey();</span><br><span class="line">            Object value = e.getValue();</span><br><span class="line">            <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>; <span class="comment">//注意这里，倒数第二个参数matchValue为true，说明删除的时候还要比较value值是否相同</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EntrySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过指定键获取节点并替换值</span></span><br><span class="line"><span class="comment"> * 该方法会比较旧值是否与获取到的节点的值相同，只有相同的情况下才会替换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> oldValue 旧值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newValue 新值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否替换成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e; V v;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        ((v = e.value) == oldValue || (v != <span class="keyword">null</span> &amp;&amp; v.equals(oldValue)))) &#123;</span><br><span class="line">        e.value = newValue;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过指定键获取节点并替换值</span></span><br><span class="line"><span class="comment"> * 该方法不会比较值是否相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 新值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧值或null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        V oldValue = e.value;</span><br><span class="line">        e.value = value;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过指定键获取节点并执行指定动作</span></span><br><span class="line"><span class="comment"> * 获取到的节点若不为空同时值不为空，则不会执行指定动作</span></span><br><span class="line"><span class="comment"> * 否则执行指定动作获取新值，若新值为空直接返回，若新值不为空则继续</span></span><br><span class="line"><span class="comment"> * 若是节点不为空，说明是值为空，则用新值代替</span></span><br><span class="line"><span class="comment"> * 若是节点为空，则判断当前位置是否是红黑树结构，若是则采用红黑树的方式新增节点，若不是则采用头插法（将新增的节点插入到链表的头部），同时还要判断链表的长度是否超过8，超过则转换成红黑树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键值、</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mappingFunction 指定动作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧值或执行指定动作后的新值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">computeIfAbsent</span><span class="params">(K key, Function&lt;? <span class="keyword">super</span> K, ? extends V&gt; mappingFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mappingFunction == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; t = <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;K,V&gt; old = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="keyword">null</span> ||</span><br><span class="line">        (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length; <span class="comment">//初始化容量大小或扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                    old = e;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++binCount;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        V oldValue;</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span> &amp;&amp; (oldValue = old.value) != <span class="keyword">null</span>) &#123; <span class="comment">//通过键获取到的节点若不为空同时值不为空，则不会执行指定动作</span></span><br><span class="line">            afterNodeAccess(old);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    V v = mappingFunction.apply(key);</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123; <span class="comment">//走到这里说明节点的值为空，替换成新值</span></span><br><span class="line">        old.value = v;</span><br><span class="line">        afterNodeAccess(old);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t != <span class="keyword">null</span>) <span class="comment">//当前位置的结构是红黑树</span></span><br><span class="line">        t.putTreeVal(<span class="keyword">this</span>, tab, hash, key, v);</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">//采用头插法</span></span><br><span class="line">        tab[i] = newNode(hash, key, v, first);</span><br><span class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    ++size;</span><br><span class="line">    afterNodeInsertion(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过指定键获取节点并执行指定动作</span></span><br><span class="line"><span class="comment"> * 若是节点为空或节点的值为空，则直接返回</span></span><br><span class="line"><span class="comment"> * 若是节点不为空同时值不为空，执行指定动作获取新值，若新值为空则删除当前节点，否则替换当前节点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mappingFunction 指定动作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或执行指定动作后的新值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">computeIfPresent</span><span class="params">(K key, BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (remappingFunction == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Node&lt;K,V&gt; e; V oldValue;</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash, key)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (oldValue = e.value) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        V v = remappingFunction.apply(key, oldValue);</span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = v;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            removeNode(hash, key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过指定键获取节点并执行指定动作</span></span><br><span class="line"><span class="comment"> * 不管节点是否为空，都会执行指定动作获取新址</span></span><br><span class="line"><span class="comment"> * 若节点不为空且新值不为空，则进行替换</span></span><br><span class="line"><span class="comment"> * 若节点不为空且新值为空，则移除当前节点</span></span><br><span class="line"><span class="comment"> * 若节点为空且新值不为空，则新增节点，当前位置是红黑树结构则采用红黑树的新增方式，否则采用头插法来新增节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> remappingFunction 指定动作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 执行指定动作后的新值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(K key, BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (remappingFunction == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; t = <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;K,V&gt; old = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="keyword">null</span> ||</span><br><span class="line">        (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode) <span class="comment">//在红黑树中查找</span></span><br><span class="line">            old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                    old = e;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++binCount;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    V oldValue = (old == <span class="keyword">null</span>) ? <span class="keyword">null</span> : old.value;</span><br><span class="line">    V v = remappingFunction.apply(key, oldValue);</span><br><span class="line">    <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">            old.value = v;</span><br><span class="line">            afterNodeAccess(old);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            removeNode(hash, key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) <span class="comment">//当前位置是红黑树结构</span></span><br><span class="line">            t.putTreeVal(<span class="keyword">this</span>, tab, hash, key, v);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//采用头插法</span></span><br><span class="line">            tab[i] = newNode(hash, key, v, first);</span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        ++size;</span><br><span class="line">        afterNodeInsertion(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过指定键获取节点并执行指定动作</span></span><br><span class="line"><span class="comment"> * 若节点不为空且值不为空，则执行指定动作获取新值</span></span><br><span class="line"><span class="comment"> * 若节点不为空且值为空，则采用默认值（value）作为新值</span></span><br><span class="line"><span class="comment"> * 若新值为空则移除节点，若移除不为空则替换</span></span><br><span class="line"><span class="comment"> * 若节点为空且新值不为空，则新增节点，当前位置是红黑树结构则采用红黑树的新增方式，否则采用头插法来新增节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 默认值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> remappingFunction 指定动作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 执行指定动作后的新值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">merge</span><span class="params">(K key, V value, BiFunction&lt;? <span class="keyword">super</span> V, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (remappingFunction == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; t = <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;K,V&gt; old = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="keyword">null</span> ||</span><br><span class="line">        (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                    old = e;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++binCount;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">        V v;</span><br><span class="line">        <span class="keyword">if</span> (old.value != <span class="keyword">null</span>)</span><br><span class="line">            v = remappingFunction.apply(old.value, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            v = value;</span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">            old.value = v;</span><br><span class="line">            afterNodeAccess(old);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            removeNode(hash, key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">            t.putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[i] = newNode(hash, key, value, first);</span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        ++size;</span><br><span class="line">        afterNodeInsertion(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历哈希表并执行指定动作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action 指定动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> mc = modCount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                action.accept(e.key, e.value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历哈希表并执行指定动作后获取新值，利用新值替换所有节点的旧值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> function 指定动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; function)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">if</span> (function == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> mc = modCount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                e.value = function.apply(e.key, e.value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 浅拷贝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 克隆后的新对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HashMap&lt;K,V&gt; result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = (HashMap&lt;K,V&gt;)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">    result.reinitialize(); <span class="comment">//恢复到初始化</span></span><br><span class="line">    <span class="comment">//恢复到初始化后需要重新设置节点，明明一开始已经设置节点了为什么还要恢复初始化后再设置呢?个人认为是因为某些成员属性需要被恢复到初始化，克隆后的对象有可能会被使用到，不能在与克隆前的对象有所关联，初始化便需要重新设置</span></span><br><span class="line">    result.putMapEntries(<span class="keyword">this</span>, <span class="keyword">false</span>); </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取加载因子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 加载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">float</span> <span class="title">loadFactor</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> loadFactor; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取容量大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (table != <span class="keyword">null</span>) ? table.length :</span><br><span class="line">        (threshold &gt; <span class="number">0</span>) ? threshold :</span><br><span class="line">        DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义序列化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 输出流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> buckets = capacity();</span><br><span class="line">    <span class="comment">// Write out the threshold, loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    s.writeInt(buckets);</span><br><span class="line">    s.writeInt(size);</span><br><span class="line">    internalWriteEntries(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将键值对存储到流中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 输出流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">internalWriteEntries</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                s.writeObject(e.key);</span><br><span class="line">                s.writeObject(e.value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义反序列化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 输入流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    reinitialize();</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                         loadFactor);</span><br><span class="line">    s.readInt();                <span class="comment">// 读取buckets</span></span><br><span class="line">    <span class="keyword">int</span> mappings = s.readInt(); <span class="comment">// 读取size</span></span><br><span class="line">    <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Illegal mappings count: "</span> +</span><br><span class="line">                                         mappings);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123; <span class="comment">// (if zero, use defaults)</span></span><br><span class="line">        <span class="comment">// Size the table using given load factor only if within</span></span><br><span class="line">        <span class="comment">// range of 0.25...4.0</span></span><br><span class="line">        <span class="keyword">float</span> lf = Math.min(Math.max(<span class="number">0.25f</span>, loadFactor), <span class="number">4.0f</span>);</span><br><span class="line">        <span class="keyword">float</span> fc = (<span class="keyword">float</span>)mappings / lf + <span class="number">1.0f</span>; <span class="comment">//向上取整获取初始容量，尽可能的获取到更大的容量以便减少resize的调用</span></span><br><span class="line">        <span class="keyword">int</span> cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                   DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                   (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor((<span class="keyword">int</span>)fc));</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)cap * lf;</span><br><span class="line">        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check Map.Entry[].class since it's the nearest public type to</span></span><br><span class="line">        <span class="comment">// what we're actually creating.</span></span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap);</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[cap];</span><br><span class="line">        table = tab;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                K key = (K) s.readObject();</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                V value = (V) s.readObject();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代器基类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">    <span class="comment">//下一个节点</span></span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">    <span class="comment">//当前节点        </span></span><br><span class="line">    Node&lt;K,V&gt; current;</span><br><span class="line">    <span class="comment">//记录修改次数</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount;</span><br><span class="line">    <span class="comment">//当前位置</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     * 提前准备好第一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HashIterator() &#123;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        Node&lt;K,V&gt;[] t = table;</span><br><span class="line">        current = next = <span class="keyword">null</span>;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否存在下一个节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否存在下一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] t;</span><br><span class="line">        Node&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除当前节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; p = current;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        current = <span class="keyword">null</span>;</span><br><span class="line">        K key = p.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含所有键的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().key; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含所有值的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含所有键值对的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建普通节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将红黑树节点转换成普通节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建红黑树节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">newTreeNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将普通节点节点转换成红黑树节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 恢复到初始状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reinitialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    table = <span class="keyword">null</span>;</span><br><span class="line">    entrySet = <span class="keyword">null</span>;</span><br><span class="line">    keySet = <span class="keyword">null</span>;</span><br><span class="line">    values = <span class="keyword">null</span>;</span><br><span class="line">    modCount = <span class="number">0</span>;</span><br><span class="line">    threshold = <span class="number">0</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问节点后的动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入节点后的动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除节点后的动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        r = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 校验红黑树的基本特性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否是红黑树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">checkInvariants</span><span class="params">(TreeNode&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right,</span><br><span class="line">        tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next;</span><br><span class="line">    <span class="keyword">if</span> (tb != <span class="keyword">null</span> &amp;&amp; tb.next != t)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tn != <span class="keyword">null</span> &amp;&amp; tn.prev != t)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tp != <span class="keyword">null</span> &amp;&amp; t != tp.left &amp;&amp; t != tp.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tl != <span class="keyword">null</span> &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tr != <span class="keyword">null</span> &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (t.red &amp;&amp; tl != <span class="keyword">null</span> &amp;&amp; tl.red &amp;&amp; tr != <span class="keyword">null</span> &amp;&amp; tr.red)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tl != <span class="keyword">null</span> &amp;&amp; !checkInvariants(tl))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tr != <span class="keyword">null</span> &amp;&amp; !checkInvariants(tr))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过键获取对应的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 键对应的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过键获取对应的值</span></span><br><span class="line"><span class="comment"> * 因为哈希表允许存放null,若获取的值为null则采用默认值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> defaultValue 默认值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 键对应的值或默认值 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? defaultValue : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定键值对</span></span><br><span class="line"><span class="comment"> * 与putIfAbsent相比该方法的修改一定会生效，不管值是否为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧值或null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定节点到哈希表中</span></span><br><span class="line"><span class="comment"> * 有可能会发生重复添加节点，若发生重复的话会更新指定节点的最新值，若不重复则添加即可，以下的添加方式大同小异，区别在于红黑树可能要做一些调整来维持红黑树的特性</span></span><br><span class="line"><span class="comment"> * 若索引上不存在任何节点直接添加即可</span></span><br><span class="line"><span class="comment"> * 若索引上已经存在节点且结构是链表，若链表长度不超过8则往链表上添加即可，若超过8则执行树形化操作</span></span><br><span class="line"><span class="comment"> * 若索引上已经存在节点且结构是红黑树，调用红黑树的添加节点方法</span></span><br><span class="line"><span class="comment"> * 返回值是null表示没有重复添加，返回具体值表示发生重复添加</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 旧值或null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent 在键值对存在的情况下发生重复添加是否不允许修改值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict 模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧值或null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length; <span class="comment">//初始化容量大小</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">//指定索引上未存放元素，直接存放即可</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p; <span class="comment">//通过hash与equals来判断是否是重复的节点，若是则先记录下当前节点以便后续替换值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value); <span class="comment">//以红黑树的方式进行添加节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//不重复的节点但在同一个索引处下有两种可能：hash不同、hash相同但equals不相同</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// 当链表长度超过8</span></span><br><span class="line">                        treeifyBin(tab, hash); <span class="comment">//树形化操作</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// 新增节点时存在重复的节点，将该节点更新成最新的值</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold) <span class="comment">//超过阈值时就需要进行扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树中插入节点</span></span><br><span class="line"><span class="comment"> * 插入过程中会判断是否重复插入，从根节点开始查找</span></span><br><span class="line"><span class="comment"> * 若是返回null表示新增了一个节点，若是返回重复的节点则后续会将这个节点的值修改成最新的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map map对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tab 哈希表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h 指定节点的哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 指定节点的键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> v 指定节点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或重复的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h) <span class="comment">//当前节点的hash值大于指定节点的hash，后续应该从左子树开始查找</span></span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h) <span class="comment">//当前节点的hash值小于指定节点的hash，后续应该从右子树开始查找</span></span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk))) <span class="comment">//当前节点的hash值与指定节点的hash值相同、equals也相等，此时的节点就是重复的节点，直接返回即可</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//走到这里说明当前节点的hash值与指定节点的hash值相同，但是equals不相等，而后续不知道该从左子树还是右子树开始查找，故而要指定具体规则，通过comparable来比较当前节点的键与指定节点的键</span></span><br><span class="line">        <span class="comment">//但前提是要先检测是否实现了comparable才能比较</span></span><br><span class="line">        <span class="comment">//继而还要检测两个键值的类型是否相同，否则也不具备可比性</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                    (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                * 走到这里的话说明不具备比较器或者比较之后还是相等或者两个键值的类型不同，那么还是无法决定是要从左子树还是右子树开始查找，所以没办法只能先尝试查抄左子树在查找右子树，个个去尝试下</span></span><br><span class="line"><span class="comment">                * searched：标识已经遍历过当前节点的所有子节点，包括子孙节点，为false说明还没有过，那么就递归遍历对比，看是否能够查找到equals相等的节点，如果查找到了，也就是查找到了重复节点，直接返回即可</span></span><br><span class="line"><span class="comment">                * 如果查找不到，说明应该新增一个节点</span></span><br><span class="line"><span class="comment">                * 在查找过后就修改此值，标识已经遍历过了后续就不用再遍历了</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 不知道查找左子树还是右子树的情况下，只能一个一个去尝试了</span></span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//走到这里说明遍历了整个红黑树都没有找到键值相等的节点，说明该新增一个节点了，那就要思考要新增到左子树上还是右子树上呢?</span></span><br><span class="line">            <span class="comment">//而该方法就是决定胜负的那个方法，必须要抉择出是左子树还是右子树</span></span><br><span class="line">            <span class="comment">//先比较键的类名是否相等，若相等则比较哈希值并返回结果，若不相等则返回结果，这样子就能决定是新增到左子树还是右子树上</span></span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//走到这里说明要新增一个节点，而新增一个节点应该先找到叶子节点才能实现最后的插入，找到叶子节点并插入后就是调整节点之间的关系，比较容易理解</span></span><br><span class="line">        <span class="comment">//若dir小于或等于0且当前节点的左子树是否为空，若不为空则继续查找，若为空则说明新增的节点可以作为当前节点的左子树</span></span><br><span class="line">        <span class="comment">//若dir大于0且当前节点的右子树是否为空，若不为空则继续查找，若为空则说明新增的节点可以作为当前节点的右子树</span></span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">            TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);<span class="comment">//创建一个新的红黑树节点</span></span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x;</span><br><span class="line">            xp.next = x;</span><br><span class="line">            x.parent = x.prev = xp;</span><br><span class="line">            <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">            moveRootToFront(tab, balanceInsertion(root, x));<span class="comment">//新增节点后有可能会导致红黑树失去平衡、根节点的变化，故要做调整以及更新根节点到链表的头部</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量添加节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    putMapEntries(m, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定键值对</span></span><br><span class="line"><span class="comment"> * 与put相比该方法的修改只有在值为空的情况下才会生效</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧值或null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="移除节点"><a href="#移除节点" class="headerlink" title="移除节点"></a>移除节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过指定键移除节点</span></span><br><span class="line"><span class="comment"> * matchVaue = false，故移除过程中不会比较值是否相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 移除节点的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过指定键移除节点</span></span><br><span class="line"><span class="comment"> * matchVaue = true，故移除过程中还会比较值是否相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>e.hash &amp; oldCap：其结果不为0个人称之为高位，等于0个人称之为低位。实际上它是在判断新容量下节点的索引位置应该是保持不变还是变成原先的索引（旧容量下的索引位置） + 旧容量大小，至于为什么是这两种可以看上面具体方法的解释。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p><code>当前位置不存在节点时新增节点</code>：直接添加</p></li><li><p><code>当前位置存在节点且是红黑树结构下新增节点</code>：直接添加，添加后可能需要旋转并移动根节点</p></li><li><p><code>当前位置存在节点且是链表结构下新增节点</code>：直接添加，添加后检测是否超过红黑树的阈值（8）和当前哈希表的长度是否超过一定容量大小（64），若这两者都满足则先将其单向链表转换成双向链表，遍历双向链表后变成红黑树，此时红黑树中的节点具有prev、next、lef、right、parent信息</p></li><li><p><code>当前位置只有一个节点且不存在链表或红黑树结构下进行扩容</code>：在新的哈希表中重新计算位置并填充即可</p></li><li><p><code>当前位置有多个节点且是红黑树结构下进行扩容</code>：将红黑树尝试分成高低位两棵树（何为高低位可参考上面的解释），低位这棵树先检测长度是否超过链表的阈值（6），若超过说明要进行树形化，接着检测是否已经树形化过，实际上就是判断高位的那棵树是否为空即可知道低位是否已经树形化过，若是高位那棵树为空，说明红黑树并未分成高低位两棵树，所以最终是将红黑树填充到新的哈希表中；同样的，若是高位那棵树存在，说明红黑树确实分成了两棵树，结构已经发生了变化，低位需要重新树形化；若低位这棵树的长度不超过链表的阈值（6）则要将其转换成单向链表结构并填充到新的哈希表中。高位那棵树的做法和低位是类似的，只不过最终填充到新的哈希表中时索引不一致，低位的索引是原先的索引（保持不变），高位的索引是原来的索引 + 旧的哈希表的容量大小。</p></li><li><p><code>当前位置有多个节点且是链表结构下进行扩容</code>：将链表尝试分成高低位两条链表并填充到新的哈希表中，低位的索引是原先的索引（保持不变），高位的索引是原来的索引 + 旧的哈希表的容量大小</p></li><li><p><code>当前位置存在节点且是红黑树结构下删除节点</code>：查找到指定节点后先调整双向链表，若此时红黑树的长度过小则直接将其转换成单向链表，若不是则利用交换树链接的方式来移除并调整平衡。该内容涉及到比较多的算法，建议对于算法只要懂的它做什么即可，后续想研究算法的话可以在回过头来！</p></li><li><p>HashMap的键与值都允许存放Null</p></li><li><p>HashMap是无序不可重复、非线程安全</p></li><li><p>HashMap的容量大小必须是2的幂次方</p></li><li><p>HashMap默认初始容量16、默认加载因子0.75</p></li><li><p>HashMap中索引的计算方式：hash &amp; (capacity - 1)</p></li><li><p>HashMap扩容时会以<code>2倍大小</code>进行增长，旧数组中的节点重新散列到新数组中，而在新数组中索引可能出现在原索引位置或原索引位置 + 旧数组容量大小</p></li><li><p>红黑树的根节点不一定是链表的头节点</p></li><li><p>JDK1.7在扩容时会出现死循环，而JDK1.8不会</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>单向链表转成红黑树</code>  <code>红黑树转成单向链表</code> <code>rehash</code> <code>默认初始容量与加载因子</code> <code>hash值与索引的计算方式</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;探索&lt;code&gt;HashMap&lt;/code&gt;底层实现是基于&lt;code&gt;JDK1.8&lt;/code&gt;，看代码之前翻了一下别人写的博客我才知道&lt;code&gt;JDK1.7&lt;/code&gt;版本的HashMap是由&lt;code&gt;数组 + 链表&lt;/code&gt;的数据结构组成，而对于JDK1.8是由&lt;code&gt;数组 + 链表 + 红黑树&lt;/code&gt;的数据结构组成，所以我又去了解了什么是二叉树、平衡二叉树、红黑树，为的就是能做个铺垫。既然是由数组、链表、红黑树组成，加上平时我们了解过的一些细节，可以猜到它的数据结构应该是这样子的，如图所示：&lt;/p&gt;
&lt;p class=&quot;customize-img&quot;&gt;&lt;img src=&quot;/assets/blogImg/java/hashmap/hashmap-data-structure.png&quot; alt=&quot;HashMap数据结构&quot;&gt;&lt;/p&gt;
&lt;p&gt;长的虽然有点丑。下面我们就开始探索它吧，还是先从注释开始看！&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
</feed>
