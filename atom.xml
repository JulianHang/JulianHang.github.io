<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>奇思妙想</title>
  
  <subtitle>越努力越幸运！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zlia.tech/"/>
  <updated>2019-09-18T14:32:28.191Z</updated>
  <id>http://zlia.tech/</id>
  
  <author>
    <name>zlia</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初识红黑树</title>
    <link href="http://zlia.tech/2019/09/18/explain-binarytree-redblack/"/>
    <id>http://zlia.tech/2019/09/18/explain-binarytree-redblack/</id>
    <published>2019-09-18T14:19:58.000Z</published>
    <updated>2019-09-18T14:32:28.191Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>在认识红黑树之前，最好你已经认识并掌握了二叉树与平衡二叉树（AVL）。AVL树是高度平衡的二叉树，它的时间复杂度大约是O(log<sub>2</sub>n)，即使在最坏的情况下也是。其实AVL树最复杂的地方在于删除节点重新平衡时的处理，有可能需要多次旋转节点。而红黑树相对于AVL树<code>降低了平衡要求</code>，它使用<code>红黑两种颜色来标记节点</code>，并对颜色进行要求（限制），在插入删除操作后对不符合的情况进行调整以满足要求，从而实现自我平衡。这些所谓的要求即是红黑树的特性：</p><ul><li><p>每个节点要么是红色要么是黑色。</p></li><li><p>根节点是黑色。</p></li><li><p>叶节点（值为Nil或Null的节点）是黑色。</p></li><li><p>如果一个节点是红色，那么它的子节点是黑色，相当于父子节点之间不能出现连续的红色节点。</p></li><li><p>从任意节点出发到任意叶节点的所有路径上均包含相同数目的黑色节点。</p></li></ul><a id="more"></a><p>通过上面的要求保证了<code>任意节点到叶节点的所有路径中，没有一条路径会大于其他路径的两倍长（最大是两倍</code>）。可以想象某条路径上有3个连续的黑色节点，而另外一条路径上它能达到的最长也就是红黑相间，所以最长是6个节点，3个黑色3个红色。由于红黑树降低了平衡的要求，也就是说它在插入删除时可能不需要任何的操作，也可能只需要改变下颜色即可，最糟糕的情况下才是旋转，相比AVL树只能通过旋转去达到平衡，所以说<code>红黑树的插入删除效率比AVL树要高</code>，而AVL树对于平衡要求较高导致了<code>它的查询效率比红黑树高</code>，但实际上差别并不是很大！最终看一下红黑树的效果图：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-1.png" alt="红黑树结构"></p><h3 id="了解旋转"><a href="#了解旋转" class="headerlink" title="了解旋转"></a><div><span>了解旋转</span></div></h3><p>在继续讲解红黑树之前，<code>旋转</code>是必须要掌握的。在上一篇<a href="http://zlia.tech/2019/09/15/explain-binarytree-avl">AVL平衡二叉树</a>中我们详细说明了什么是旋转、旋转的几种情况，希望不懂的同学可以先去了解下，毕竟这是前提，这里只是简单帮助同学回忆下。</p><h4 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h4><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-2.png" alt="左旋"></p><p>节点8左旋之后，由一开始节点8的右子树为节点10变成了节点10的左子树为节点8，同时根节点变成了节点10。</p><h4 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h4><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-3.png" alt="右旋"></p><p>节点8右旋之后，由一开始节点8的左子树为节点6变成了节点6的右子树为节点8，同时根节点变成了节点6。</p><h3 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a><div><span>红黑树的插入</span></div></h3><p>上面说了节点要么是红色要么是黑色，对于新插入的节点来说也是如此。假设新插入的节点是黑色，那么某条路径上便会多出来一个黑色节点，除了将其改成红色之外其余的方式，包括左旋、右旋，都无法改变会多出来一个黑色节点，所以它完全满足不了红黑树的第五特性，那么留下来的只有红色了，故而<code>新插入的节点颜色是红色的</code>！在想想，若新插入的节点是红色的话，会造成哪里不平衡，也就是说会违背哪些特性：</p><ul><li><p>每个节点要么是红色要么是黑色。</p></li><li><p>根节点是黑色。</p></li><li><p>叶节点是黑色。</p></li><li><p>如果一个节点是红色，那么它的子节点是黑色，相当于父子节点之间不能出现连续的红色节点。</p></li><li><p>从任意节点出发到任意叶节点的所有路径上均包含相同数目的黑色节点。</p></li></ul><p>第一条显然没有违背；对于空树来说，新插入的红色节点违背了该条，不过调整起来很简单，并不是关键点；新插入的节点并未来影响到叶节点；新插入的红色节点有可能它的父节点也是红色，故违背了该条，接下来的内容是针对此情况进行重点分析；新插入的节点为红色正是为了不违背该条。</p><h4 id="插入情况分析"><a href="#插入情况分析" class="headerlink" title="插入情况分析"></a>插入情况分析</h4><p>现在来分析新插入的红色节点可能出现的情况，以及它们的处理措施，这里我们<code>假设新插入的红色节点为X</code>：</p><ul><li><p>若X是根节点，将其变成黑色皆可。</p></li><li><p>若X的父节点是黑色，则不需要任何黑色。</p></li><li><p>若X的父节点是红色，叔叔节点（隶属于同一个父节点）也是红色，解决方案如下：</p><ul><li><p>将X的父节点与叔叔节点变成黑色。</p></li><li><p>将X的爷爷节点变成红色。</p></li><li><p>X的爷爷节点变成红色后，有可能会出现连续红色节点的冲突，若有的话则将X的爷爷节点当作是新插入的节点，继续重复31、32操作，直到当前节点是根节点，最后将根节点变成黑色。</p></li></ul></li></ul><p>如图所示红黑树：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-insert-1.png" alt="红黑树插入-1"></p><p><code>新插入的红色节点X为125</code>，如图所示红黑树：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-insert-2.png" alt="红黑树插入-2"></p><p><code>节点125和其父节点130都是红色节点，违背了第四点要求</code>，所以将节点125的父节点130与叔叔节点150变成黑色，同时将节点125的爷爷节点140变成红色，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-insert-3.png" alt="红黑树插入-3"></p><p><code>节点140和其父节点120都是红色节点，也违背了第四点要求</code>，我们可以将节点140看成是新插入的节点。所以将节点140的父节点120与叔叔节点60变成黑色，同时将节点140的爷爷节点90变成红色，由于节点90是根节点，又将其节点90变成了黑色，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-insert-4.png" alt="红黑树插入-4"></p><p>到这里，新插入的红色节点125一开始不满足红黑树的特性到所作的一系列调整，最终变成了标准的红黑树！</p><ul><li><p>若X的父节点是红色，叔叔节点是黑色（空），解决方案如下：</p><ul><li><p>X和X的父节点在X的爷爷节点的左子树上（左左情况）。</p></li><li><p>X和X的父节点在X的爷爷节点的右子树上（右右情况）。</p></li><li><p>以上的两种情况（4142）都是同一个处理措施，只不过旋转的方向不一致。</p><ul><li><p>将X的父节点与X的爷爷节点进行颜色互换。</p></li><li><p>将X的爷爷节点进行左/右旋，左左情况是右旋，右右情况是左旋。</p></li></ul></li></ul></li></ul><p>如图所示红黑树（左左情况）：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-insert-5.png" alt="红黑树插入-5"></p><p><code>新插入的红色节点X为25</code>，如图所示红黑树：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-insert-6.png" alt="红黑树插入-6"></p><p>节点25的父节点30为红色，叔叔节点为黑色，且节点25与父节点30都是节点50的左子树，所以将节点30与节点50进行颜色互换，同时将节点50进行右旋，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-insert-7.png" alt="红黑树插入-7"></p><p>以上是左左情况下该如何处理，右右情况的话只需要左旋即可，很简单！这边提下为啥要进行旋转，单是颜色互换其实你会发现90-&gt;60-&gt;50-&gt;null这条路径上少了一个黑色节点数目，它并不满足第五点要求，所以旋转是必须的。</p><ul><li><p>若X的父节点是红色，叔叔节点是黑色（空），该情况与上面的第四点有些类似，解决方案如下：</p><ul><li><p>X的父节点在X的爷爷节点的左子树上，X在X的父节点的右子树上（左右情况）。</p></li><li><p>X的父节点在X的爷爷节点的右子树上，X在X的父节点的左子树上（右左情况）。</p></li><li><p>以上的两种情况（5152）都是同一个处理措施，只不过旋转的方式不一样。</p><ul><li><p>将X的父节点进行左/右旋，左右情况是左旋，右左情况是右旋。</p></li><li><p>注意旋转后，X将会变化，将X的父节点与X的爷爷节点进行颜色互换。</p></li><li><p>将X的爷爷节点进行左/右旋，左右情况是右，右左情况是左旋，因为前面已经旋转过一次了，故后面是另外一个旋转，就比如左右，先左旋在右旋。</p></li></ul></li></ul></li></ul><p>如图所示红黑树（左右情况）：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-insert-8.png" alt="红黑树插入-8"></p><p><code>新插入的红色节点X为126</code>，如图所示红黑树：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-insert-9.png" alt="红黑树插入-9"></p><p>节点126的父节点125为红色，叔叔节点为黑色，且节点125在节点130的左子树上，节点126在节点125的右子树上，所以将节点125进行左旋，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-insert-10.png" alt="红黑树插入-10"></p><p>不知道发现没有，旋转后的红黑树跟第四点提到的情景是一样的，故处理方式也是一直。此时的X应该是节点125，故将节点126与节点130进行颜色互换，同时将节点130进行右旋，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-insert-11.png" alt="红黑树插入-11"></p><p>最终也是一颗标准的红黑树！以上是左右情况下该如何处理，右左情况的话也是差不多，不过多介绍了！</p><h4 id="插入情况总结"><a href="#插入情况总结" class="headerlink" title="插入情况总结"></a>插入情况总结</h4><p>整理下插入节点的情况及措施，假设新插入的节点为X：</p><ul><li><p>X是根节点：将其变成黑色即可。</p></li><li><p>X的父节点为黑色：不需要任何操作。</p></li><li><p>X的父节点为红色：</p><ul><li><p>叔叔节点为红色：将X的父节点与叔叔节点变成黑色；将X的爷爷节点变成红色；X的爷爷节点变成红色后，有可能会出现连续红色节点的冲突，若有的话则将X的爷爷节点当作是新插入的节点，继续重复上面的操作，直到当前节点是根节点，最后将根节点变成黑色。</p></li><li><p>叔叔节点为黑色：</p><ul><li><p>X在左子树上，父节点也在左子树上（左左情况） || X在右子树上，父节点也在右子树上（右右情况）：将X的父节点与X的爷爷节点进行颜色互换，将X的爷爷节点进行左/右旋，左左情况是右旋，右右情况是左旋。</p></li><li><p>父节点在左子树上，X在右子树上（左右情况） || 父节点在右子树上，X在左子树上（右左情况）：将X的父节点进行左/右旋，左右情况是左旋，右左情况是右旋，旋转后会发现与321的情况一样，然后按照321的情况继续处理，因为已经旋转过一次了，所以左右情况是右旋，右左情况是左旋。</p></li></ul></li></ul></li></ul><p>了解完以上的所有情况后，不知道你们会不会觉得有点难。实际上每一种情况对应着一种处理方式，你只需对应上即可，不过关键还是要去理解它！</p><h3 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a><div><span>红黑树的删除</span></div></h3><p>删除节点很容易，复杂的是删除节点后如何调整平衡，请同学们一定要耐心的看，仔细看，加上自己的理解！参考了其他人的文章，将删除节点的子节点个数分为以下情况，这里我们<code>假设删除节点为X</code>：</p><ul><li><p>X没有子节点的情况：</p><ul><li><p>X为红色。</p></li><li><p>X为黑色，X的兄弟节点没有子节点。</p></li><li><p>X为黑色，X的兄弟节点只有一个子节点。</p><ul><li><p>X的兄弟节点与X的兄弟节点的子节点在左子树上（左左情况）。</p></li><li><p>X的兄弟节点与X的兄弟节点的子节点在右子树上（右右情况）。</p></li><li><p>X的兄弟节点在左子树上，X的兄弟节点的子节点在右子树上（左右情况）。</p></li><li><p>X的兄弟节点在右子树上，X的兄弟节点的子节点在左子树上（右左情况）。</p></li></ul></li><li><p>X为黑色，X的兄弟节点有两个子节点。</p></li></ul></li><li><p>X只有一个子节点的情况（左右无所谓）：</p><ul><li><p>X为红色，其子节点只能为黑色。</p></li><li><p>X为黑色，其子节点为红色。</p></li><li><p>X为黑色，其子节点为黑色。</p></li></ul></li><li><p>X有两个子节点的情况是将其简化成以上的两种情况后再处理，有以下两种简化方式（根据业务需求自行选择其中一种）：</p><ul><li><p>找到X的右子树中最左的节点，将两个节点的值进行交换，就变成了删除最左的节点，不过删除的值依然还是原来的值，相当于X换了个位置。由于是最左的节点，那么它肯定没有左子树，所以它要么是没有子节点要么是只有一个子节点。</p></li><li><p>找到X的左子树中最右的节点，将两个节点的值进行交换。由于是最右的节点，那么它肯定没有右子树，所以它要么是没有子节点要么是只有一个子节点。</p></li></ul></li></ul><p>情况有点多，接下来一一分析！</p><h4 id="删除节点没有子节点"><a href="#删除节点没有子节点" class="headerlink" title="删除节点没有子节点"></a>删除节点没有子节点</h4><ul><li>X为红色。</li></ul><p>如图所示红黑树：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-1.png" alt="红黑树删除-1"></p><p><code>删除节点X为126</code>，如图所示红黑树：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-2.png" alt="红黑树删除-2"></p><p>直接删除即可，因为删除的是红色节点，并不会影响黑色节点的数目。</p><ul><li>X为黑色，X的兄弟节点没有子节点，此时X的兄弟节点必定为黑色。</li></ul><p>如图所示红黑树：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-3.png" alt="红黑树删除-3"></p><p><code>删除节点X为110</code>，它为黑色，且兄弟节点140没有子节点。由于X为黑色，那么它的兄弟节点必定为黑色（否则就违背了黑色数目不一致），如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-4.png" alt="红黑树删除-4"></p><p>图中删除后的节点用虚线白字表示，方便讲解。在删除节点110后，90-&gt;120-&gt;110的路径上明显少了一个黑色数目，采取的措施是将删除节点X的兄弟节点变成红色，X的父节点变成黑色，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-5.png" alt="红黑树删除-5"></p><p>最终每条路径上的黑色数目一样。</p><ul><li><p>X为黑色，X的兄弟节点只有一个子节点</p><ul><li><p>X的兄弟节点与X的兄弟节点的子节点在左子树上（左左情况）</p></li><li><p>X的兄弟节点与X的兄弟节点的子节点在右子树上（右右情况）</p></li><li><p>以上的两种情况都是同一个处理措施，只不过旋转的方式不一样。</p></li></ul></li></ul><p>如图所示红黑树（左左情况）：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-6.png" alt="红黑树删除-6"></p><p><code>删除节点X为140</code>，它为黑色，且兄弟节点110（左子树上）只有一个子节点100（左子树上），如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-7.png" alt="红黑树删除-7"></p><p>在删除节点140后，90-&gt;120-&gt;140的路径上少了一个黑色数目，采取的措施是将X的父节点与X的兄弟节点进行颜色互换，将X的父节点变成黑色，将X的兄弟节点的子节点变成黑色，最后将X的父节点进行左/右旋，左左情况是右旋，右右情况是左旋，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-8.png" alt="红黑树删除-8"></p><p>最终每条路径上的黑色数目一样。</p><ul><li><p>X为黑色，X的兄弟节点只有一个子节点</p><ul><li><p>X的兄弟节点在左子树上，X的兄弟节点的子节点在右子树上（左右情况）</p></li><li><p>X的兄弟节点在右子树上，X的兄弟节点的子节点在左子树上（右左情况）</p></li><li><p>以上的两种情况都是同一个处理措施，只不过旋转的方式不一样。</p></li></ul></li></ul><p>如图所示红黑树（左右情况）：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-9.png" alt="红黑树删除-9"></p><p><code>删除节点X为140</code>，它为黑色，且兄弟节点110（左子树上）只有一个子节点115（右子树上），如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-10.png" alt="红黑树删除-10"></p><p>在删除节点140后，90-&gt;120-&gt;110-&gt;115的路径上少了一个黑色数目，采取的措施是将X的兄弟节点与X的兄弟节点的子节点进行颜色互换，将X的兄弟节点进行左/右旋，左右情况是左旋，右左情况是右旋，将X的父节点与X的兄弟节点进行颜色互换，将X的父节点变成黑色，将X的兄弟节点的子节点变成黑色，将X的父节点进行左/右旋，左右情况是右，右左情况是左旋，因为前面已经旋转过一次了，后面是另外一个旋转，就比如左右，先左旋在右旋（不知道你们发现没有，后半段的处理跟前面的左左/右右情况的处理是一样的），如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-11.png" alt="红黑树删除-11"></p><p>最终每条路径上的黑色数目一样。</p><ul><li><p>X为黑色，X的兄弟节点有两个子节点（若是叶节点则和上面的第2点没啥区别，所以这里不是叶节点）</p><ul><li>X的兄弟节点为黑色，那么它的两个子节点必定是红色（因为X没有子节点，这种情况不用考虑兄弟节点的子节点，因为即使旋转了红色的节点并不会影响黑色数目），这样子才能保证黑色数目一致</li></ul></li></ul><p>如图所示红黑树：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-12.png" alt="红黑树删除-12"></p><p><code>删除节点X为140</code>，它为黑色，且兄弟节点110也为黑色，有两个子节点，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-13.png" alt="红黑树删除-13"></p><p>在删除节点140后，90-&gt;120-&gt;140的路径上少了一个黑色数目，采取的措施是将X的父节点进行左/右旋，X在左子树是左旋，X在右子树是右旋，将X的父节点与X的兄弟节点的左/右子节点变成黑色，X在左子树上就将右子节点变成黑色，X在右子树上就将左子节点变成黑色，将X的兄弟节点变成红色，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-14.png" alt="红黑树删除-14"></p><p>最终每条路径上的黑色数目一样。</p><ul><li><p>X为黑色，X的兄弟节点有两个子节点</p><ul><li><p>X的兄弟节点为红色，那么它的两个子节点只能为黑色，这样子才能保证黑色数目一样</p><ul><li>X的兄弟节点的子节点都无子节点</li></ul></li></ul></li></ul><p>如图所示红黑树：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-15.png" alt="红黑树删除-15"></p><p><code>删除节点X为30</code>，它为黑色，兄弟节点85为红色，有两个子节点（在无子节点），如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-16.png" alt="红黑树删除-16"></p><p>在删除节点30后，60-&gt;30的路径上少了一个黑色数目，由于该情况比较复杂，我们以X的父节点为目标（即使在移动后我们仍称为X的父节点）采取的措施是：</p><ul><li><p>删除X</p></li><li><p>X的父节点与X的兄弟节点颜色互换</p></li><li><p>X的父节点左/右旋，X在左子树是左旋，X在右子树是右旋</p></li><li><p>X的父节点与X的父节点的子节点（旋转过后的子节点）颜色互换</p></li></ul><p>如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-17.png" alt="红黑树删除-17"></p><p>最终每条路径上的黑色数目一样。</p><ul><li><p>X为黑色，X的兄弟节点有两个子节点</p><ul><li><p>X的兄弟节点为红色，那么它的两个子节点只能为黑色（只考虑X的兄弟节点的子节点与X同边，就比如X在左子树，那么只考虑X的兄弟节点的左子树，因为只有左子树才会在旋转之后移动到了X的那一侧，影响到了黑色数目，而右子树始终没有变动）</p><ul><li>X的兄弟节点的子节点的子节点只有一个，那么X的兄弟节点的子节点为黑色，那么X的兄弟节点的子节点的子节点必为红色（因为X无子节点）</li></ul></li></ul></li></ul><p>如图所示红黑树：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-18.png" alt="红黑树删除-18"></p><p><code>删除节点X为30</code>，它为黑色，兄弟节点85为红色，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-19.png" alt="红黑树删除-19"></p><p>在删除节点30后，60-&gt;30的路径上少了一个黑色数目，由于该情况比较复杂，我们以X的父节点为目标（即使在移动后我们仍称为X的父节点）采取的措施是：</p><ul><li><p>删除X</p></li><li><p>X的父节点左/右旋，X在左子树是左旋，X在右子树右旋</p></li><li><p>X的父节点与X的兄弟节点颜色互换</p></li><li><p>若X的父节点的左/右子树（旋转过后）的左/右子树与X同边，简单来说，若X在左/右子树，那么只考虑X的父节点的右/左子树的左/右子树，从14225开始执行，若是没对应上则从14227开始执行，同理X在右子树上</p></li><li><p>X在左/右子树，X的父节点的右/左子树进行右/左旋（14225）</p></li><li><p>X在左/右子树，X的父节点的右/左子树与X的父节点的右/左子树的右/左子树进行颜色互换（14226）</p></li><li><p>X的父节点左/右旋，x在左子树是左旋，x在右子树右旋（14227）</p></li><li><p>X的父节点与X的父节点的兄弟节点变成黑色，X的父节点的父节点变成红色（旋转过后）</p></li></ul><p>最终每条路径上的黑色数目一样。该情况很是复杂，希望同学们能耐心的理解并尝试动手，否则很难从中发现规律！</p><ul><li><p>X为黑色，X的兄弟节点有两个子节点</p><ul><li><p>X的兄弟节点为红色，那么它的两个子节点只能为黑色（和上面一样，只需考虑一侧）</p><ul><li>X的兄弟节点的子节点的子节点有两个，那么X的兄弟节点的子节点为黑色，那么X的兄弟节点的子节点的两个子节点都为红色</li></ul></li></ul></li></ul><p>如图所示红黑树：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-20.png" alt="红黑树删除-20"></p><p><code>删除节点X为30</code>，它为黑色，兄弟节点85为红色，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-21.png" alt="红黑树删除-21"></p><p>在删除节点30后，60-&gt;30的路径上少了一个黑色数目，由于该情况比较复杂，我们以X的父节点为目标（即使在移动后我们仍称为X的父节点）采取的措施是：</p><ul><li><p>删除X</p></li><li><p>X的父节点左/右旋，X在左子树是左旋，X在右子树右旋</p></li><li><p>X的父节点与X的兄弟节点颜色互换</p></li><li><p>X的父节点左/右旋，X在左子树是左旋，X在右子树右旋</p></li><li><p>X的父节点与X的父节点的兄弟节点变成黑色，X的父节点的父节点变成红色（旋转过后）</p></li></ul><p>删除节点中最复杂的部分差不多都在这里了。说实话，我整理起来都耗费了很多精力与时间，同学们看不懂或者不理解的地方尝试多看几遍，多动手几次，说不定，当然了，也不排除我写错了，所以还是要自己动手比较好，加油吧！</p><h4 id="删除节点只有一个子节点"><a href="#删除节点只有一个子节点" class="headerlink" title="删除节点只有一个子节点"></a>删除节点只有一个子节点</h4><ul><li><p>X为红色，其子节点为黑色，不存在这样子的情况，要不然黑色数目就不一样了</p></li><li><p>X为黑色，其子节点为黑色，同样的道理，黑色数目还是不一样（X-&gt;Null路径上少了一个）</p></li><li><p>X为黑色，其子节点为红色（左右无所谓），这里就不上图片了，直接说处理措施：</p><ul><li><p>删除X</p></li><li><p>将X的子节点变成黑色，并作为X的父节点的子节点</p></li></ul></li></ul><h4 id="删除节点有两个子节点"><a href="#删除节点有两个子节点" class="headerlink" title="删除节点有两个子节点"></a>删除节点有两个子节点</h4><ul><li><p>找到X的右子树中最左的节点，将两个节点的值进行交换，就变成了删除最左的节点，不过删除的值依然还是原来的值，所以最左的节点要么没有子节点，要么只有一个子节点，是不是又回到上面的情况了，那处理情况自然也就是上面的内容了</p></li><li><p>找到X的左子树中最右的节点，将两个节点的值进行交换，所以最右的节点要么没有子节点，要么只有一个子节点，同理！</p></li></ul><h4 id="删除情况总结"><a href="#删除情况总结" class="headerlink" title="删除情况总结"></a>删除情况总结</h4><ul><li><p>X没有子节点的情况</p><ul><li><p>X为红色，不需要任何处理</p></li><li><p>X为黑色，X的兄弟节点没有子节点</p><ul><li><p>那么X的兄弟节点肯定也为黑色</p></li><li><p>删除X</p></li><li><p>将X的兄弟节点变成红色，X的父节点变成黑色</p></li></ul></li><li><p>X为黑色，X的兄弟节点只有一个子节点</p><ul><li><p>X的兄弟节点与X的兄弟节点的子节点在左子树上（左左情况） || X的兄弟节点与X的兄弟节点的子节点在右子树上（右右情况）</p><ul><li><p>删除X</p></li><li><p>将X的父节点与X的兄弟节点进行颜色互换</p></li><li><p>将X的父节点变成黑色</p></li><li><p>将X的兄弟节点的子节点变成黑色</p></li><li><p>将X的父节点进行左/右旋，左左情况是右旋，右右情况是左旋</p></li></ul></li><li><p>X的兄弟节点在左子树上，X的兄弟节点的子节点在右子树上（左右情况） || X的兄弟节点在右子树上，X的兄弟节点的子节点在左子树上（右左情况）</p><ul><li><p>删除X</p></li><li><p>将X的兄弟节点与X的兄弟节点的子节点进行颜色互换</p></li><li><p>将X的兄弟节点进行左/右旋，左右情况是左旋，右左情况是右旋</p></li><li><p>将X的父节点与X的兄弟节点进行颜色互换</p></li><li><p>将X的父节点变成黑色</p></li><li><p>将X的兄弟节点的子节点变成黑色</p></li><li><p>将X的父节点进行左/右旋，左右情况是右，右左情况是左旋，因为前面已经旋转过一次了，后面是另外一个旋转，就比如左右，先左旋在右旋</p></li></ul></li></ul></li><li><p>X为黑色，X的兄弟节点有两个子节点（若是叶子节点则和上面的12没什么区别，所以这里不是叶子节点）</p><ul><li><p>X的兄弟节点为黑色，那么它的两个子节点必定都是红色（因为X没有子节点，这种情况不用考虑子节点，因为即使旋转了红色的节点并不会影响黑色数目）</p><ul><li><p>删除X</p></li><li><p>X的父节点进行左/右旋，X在左子树是左旋，X在右子树是右旋</p></li><li><p>将X的父节点与X的兄弟节点的左/右子节点变成黑色，X在左子树上就将右子节点变成黑色，X在右子树上就将左子节点变成黑色</p></li><li><p>将X的兄弟节点变成红色</p></li></ul></li><li><p>X的兄弟节点为红色，那么它的两个子节点必定是黑色（只考虑X的兄弟节点的子节点与X同边，就比如X在左子树，那么只考虑X的兄弟节点的左子树，因为只有左子树才会在旋转之后移动到了X的那一侧，影响到了黑色数目，而右子树始终没有变动）</p><ul><li><p>X的兄弟节点的子节点都无子节点</p><ul><li><p>删除X</p></li><li><p>X的父节点与X的兄弟节点颜色互换</p></li><li><p>X的父节点左/右旋，X在左子树是左旋，X在右子树是右旋</p></li><li><p>X的父节点与X的父节点的子节点（旋转过后的子节点）颜色互换</p></li></ul></li><li><p>X的兄弟节点的子节点只有一个子节点，X的兄弟节点的子节点为黑色，那么X的兄弟节点的子节点的子节点必为红色</p><ul><li><p>删除X</p></li><li><p>x的父节点左/右旋，x在左子树是左旋，x在右子树右旋</p></li><li><p>x的父节点与X的兄弟节点颜色互换</p></li><li><p>若X的父节点的左/右子树（旋转过后）的左/右子树与X同边，简单来说，若X在左/右子树，那么只考虑X的父节点的右/左子树的左/右子树，先从14225开始执行，若是没对应上则先从14227开始执行，同理X在右子树上</p></li><li><p>X在左/右子树，X的父节点的右/左子树进行右/左旋</p></li><li><p>X在左/右子树，X的父节点的右/左子树与X的父节点的右/左子树的右/左子树进行颜色互换</p></li><li><p>X的父节点左/右旋，x在左子树是左旋，x在右子树右旋</p></li><li><p>X的父节点与X的父节点的兄弟节点变成黑色，X的父节点的父节点变成红色（旋转过后）</p></li></ul></li><li><p>X的兄弟节点的子节点有两个子节点，X的兄弟节点的子节点为黑色，那么X的兄弟节点的子节点的两个子节点都为红色</p><ul><li><p>删除X</p></li><li><p>x的父节点左/右旋，x在左子树是左旋，x在右子树右旋</p></li><li><p>x的父节点与X的兄弟节点颜色互换</p></li><li><p>x的父节点左/右旋，x在左子树是左旋，x在右子树右旋</p></li><li><p>X的父节点与X的父节点的兄弟节点变成黑色，X的父节点的父节点变成红色（旋转过后）</p></li></ul></li></ul></li></ul></li></ul></li><li><p>X只有一个子节点的情况</p><ul><li><p>X为黑色，其子节点只能为红色（左右都无所谓）</p><ul><li><p>删除X</p></li><li><p>将X的子节点变成黑色，并作为X的父节点的子节点</p></li></ul></li><li><p>X为红色，其子节点为黑色 || X为黑色，其子节点为黑色</p><ul><li>不存在这两种情况，黑叔数目不一样</li></ul></li></ul></li><li><p>X有两个子节点的情况</p><ul><li><p>找到X的右子树中最左的节点，将两个节点的值进行交换，就变成了删除最左的节点，不过删除的值依然还是原来的值，相当于X换了个位置。由于是最左的节点，那么它肯定没有左子树，所以它要么是没有子节点要么是只有一个子节点（右子树），最终变成了上面的处理情况。</p></li><li><p>找到X的左子树中最右的节点，将两个节点的值进行交换。由于是最右的节点，那么它肯定没有右子树，所以它要么是没有子节点要么是只有一个子节点（左子树），最终变成了上面的情况。</p></li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><div><span>总结</span></div></h3><p>红黑树的插入与删除较为复杂，过一段时间后容易忘记，特意整理了一份流程说明，有兴趣的同学可以去观摩-<a href="">红黑树插入与删除流程说明</a>，至于代码的设计实现上可能没有那么快给出，我也是个菜鸟啊，到时候要是不小心写出来了我就在新写一篇文章告知天下！这篇算是纯理论的红黑树，想学东西就要多去实践。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;在认识红黑树之前，最好你已经认识并掌握了二叉树与平衡二叉树（AVL）。AVL树是高度平衡的二叉树，它的时间复杂度大约是O(log&lt;sub&gt;2&lt;/sub&gt;n)，即使在最坏的情况下也是。其实AVL树最复杂的地方在于删除节点重新平衡时的处理，有可能需要多次旋转节点。而红黑树相对于AVL树&lt;code&gt;降低了平衡要求&lt;/code&gt;，它使用&lt;code&gt;红黑两种颜色来标记节点&lt;/code&gt;，并对颜色进行要求（限制），在插入删除操作后对不符合的情况进行调整以满足要求，从而实现自我平衡。这些所谓的要求即是红黑树的特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;每个节点要么是红色要么是黑色。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;根节点是黑色。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;叶节点（值为Nil或Null的节点）是黑色。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果一个节点是红色，那么它的子节点是黑色，相当于父子节点之间不能出现连续的红色节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从任意节点出发到任意叶节点的所有路径上均包含相同数目的黑色节点。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="algorithm" scheme="http://zlia.tech/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>初识平衡二叉树-AVL</title>
    <link href="http://zlia.tech/2019/09/15/explain-binarytree-avl/"/>
    <id>http://zlia.tech/2019/09/15/explain-binarytree-avl/</id>
    <published>2019-09-15T11:23:55.000Z</published>
    <updated>2019-09-16T02:35:27.539Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>上一篇文章只是简单地认识下<code>二叉树</code>，并未提到它的<code>缺陷</code>。数据结构的好坏取决于<code>时间复杂度</code>，由于每次操作（插入、删除、查找）需要与节点比较来选择进入到左子树还是右子树，也就是说每次比较都会排除一些可能（选择左右其中一侧），当然了这是对于随机均匀分布的二叉树来说，它的时间复杂度是O（log<sub>2</sub>n），但是对于只有单向的左子树或右子树来说，它的时间复杂度就变成了O(n)，每次操作都会从头到尾所有节点比较一遍。总的来说，二叉树的时间复杂度区间是在O(log<sub>2</sub>n) ~ O(n)之间，这完全取决于二叉树的结构！如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/avl/single-binarytree.png" alt="单向二叉树结构"></p><p>随着单向二叉树越来越长，所消耗的时间也会越来越多，这已经跟单链表没有什么区别了。因此，为了解决单链表的情况，将时间复杂度降低至O（log<sub>2</sub>n），衍生出了<code>平衡二叉树</code>。</p><a id="more"></a><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><div><span>平衡二叉树</span></div></h3><p>通过上面的分析看出，只要将节点均匀分布在两侧即可完成目的，而这也正是平衡二叉树所要做的事，因此它要求<code>任何节点的左右子树的高度相差不超过1</code>，实际上就是计算同一层中<code>最大的高度值与最小的高度值相差不超过1</code>，解释下高度的含义：从叶子节点开始自底向上到指定节点的最长距离，叶子节点的高度为0，<code>空树的高度为-1</code>。对于AVL树来说，它只是平衡二叉树的其中一种，节点的左右子树高度差被称为<code>平衡因子</code>，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/avl/balance-binarytree-1.png" alt="平衡二叉树结构"></p><p>图中左侧为平衡二叉树，每一层的高度差值都不会超过1，图中右侧中出现高度差值超过1，故非平衡二叉树。仔细观察下，图中左右两个的二叉树无非就差了一个节点6，可以将这个多余的节点看成是新插入的节点，是该操作导致了二叉树失去平衡，更严格来说，只要是修改了树的结构，都有可能导致平衡失调，而能修改树结构的操作只有删除与插入。那么该如何才能让它继续保持平衡呢？很容易想到，只要稍微移动下树的结构就能使之平衡，这样子的操作被称为<code>旋转</code>，分为<code>单旋转</code>和<code>双旋转</code>。在想一想，图中右侧中左子树相对偏高，若是旋转的话应该将左子树的高度降低，相应的右子树也会增高，这样子就达到平衡了。</p><h3 id="AVL树旋转"><a href="#AVL树旋转" class="headerlink" title="AVL树旋转"></a><div><span>AVL树旋转</span></div></h3><p>上面提到只有删除与插入会导致二叉树不平衡，这里就举插入来介绍平衡二叉树的几种<code>旋转方式</code>。插入的话无非就以下几种方式：</p><h4 id="左左型"><a href="#左左型" class="headerlink" title="左左型"></a>左左型</h4><ul><li>插入到根节点的左子树的左子树上，称作<code>左左型LL（右旋转）</code>。该方式导致的不平衡是因为左子树上的节点增加了，所以旋转的话就应当将左子树的高度降低，而旋转的节点是插入的节点到根节点的路径上的节点都有可能旋转（这个很在编写代码中很关键），也就是说有可能旋转多次才能达到平衡，如图所示操作：</li></ul><p class="customize-img"><img src="/assets/blogImg/algorithm/avl/avl-binarytree-1.png" alt="avl平衡二叉树结构-1"></p><p>图中可见是节点7，我们知道向右旋转会导致左子树的高度降低，没错，旋转正确的话是使二叉树达到平衡。我们将节点7移动到根节点位置上，节点5、6紧随其后，而节点8变成了节点的右子树，节点9还是节点8的右子树，简单来说，随着某个节点的移动，其他节点也会相应的移动，这样子才能达到平衡。不知道你们发现没有，旋转过后，不仅符合二叉树的规则，同时也达到平衡，只不过根节点变化了，不过这丝毫不影响！这是比较简单的<code>左左型LL</code>，在来看另外一种情况：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/avl/avl-binarytree-2.png" alt="avl平衡二叉树结构-2"></p><p>此种情况比上面多了一个节点，不过这不是关键。我们发现节点X应该是比节点7大，而比节点8小，也就是说它可以当作节点7的右子树，也可以当作节点8的左子树，而随着节点7移动到根节点上，它已经有了节点5与节点8两个子节点，容不下第三个节点了，也就是说它已经做不了节点7的右子树了，那么这个时候节点X只能考虑去走另外一套方案了，让我称为节点8的左子树，所以最终旋转的结果如上图所示。理解了右旋转，左旋转也是一样的道理。</p><h4 id="右右型"><a href="#右右型" class="headerlink" title="右右型"></a>右右型</h4><ul><li>插入到根节点的右子树的右子树上，称作<code>右右型RR（左旋转）</code>。该方式导致的不平衡是因为右子树上的节点增加了，所以旋转的话就应当将右子树的高度降低，如图所示：</li></ul><p class="customize-img"><img src="/assets/blogImg/algorithm/avl/avl-binarytree-3.png" alt="avl平衡二叉树结构-3"></p><p>图中可见是节点9导致了二叉树的不平衡，那么应该左旋转来降低右子树的高度。将节点9移动到根节点位置上，节点10、11紧随其后，而节点8变成了节点9的左子树，重点在于节点X，发现节点X比节点8大，而比节点9小，随着节点9的移动，它已经做不了节点9的左子树了，所以结果它成了节点8的右子树。跟上面的右旋转有点类似！</p><h4 id="左右型"><a href="#左右型" class="headerlink" title="左右型"></a>左右型</h4><ul><li>插入到根节点的左子树的右子树上，称作<code>左右型LR（左右旋转）</code>。该方式的结构与上面的左左型稍微有点区别，因为最终插入的节点是落在了右子树上，所以首先应该先降低右子树的高度，应该左旋转，不过你会发现，随着右子树的移动，左子树的高度最终增加了，二叉树还是不平衡，不过不用担心，事情是往好的方向发展，你发现没有，左旋转后的结构与上面的左左型是一样的！也就是说只需要在向右旋转一次就能达到平衡，总共旋转了两次，所以称为左右旋转！如图所示：</li></ul><p class="customize-img"><img src="/assets/blogImg/algorithm/avl/avl-binarytree-4.png" alt="avl平衡二叉树结构-4"></p><p>我们知道若是直接移动节点7，最终还是不平衡，而咱们说从节点插入的地方到根节点的路径上都有可能需要旋转，那只有节点X了，那么应该通过左旋转来降低高度，不过随着节点X的移动，最终发现二叉树还是不平衡，不过你也应该发现了，这结构和左左型很像，所以最终还需要右旋转来达到平衡！</p><h4 id="右左型"><a href="#右左型" class="headerlink" title="右左型"></a>右左型</h4><ul><li>插入到根节点的右子树的左子树上，称作<code>右左型RL（右左旋转）</code>。该方式的结构与上面的右右型有些区别，最终插入的节点是落在了左子树上，所以首先应该先降低左子树的高度，那么应该右旋转，同理，随着旋转一次后发现还是不平衡，不过结构倒是很像右右型，接下来的操作就跟右右型一样了，就不做多阐述了！如图所示：</li></ul><p class="customize-img"><img src="/assets/blogImg/algorithm/avl/avl-binarytree-5.png" alt="avl平衡二叉树结构-5"></p><p>这几种类型不难理解，只要记住哪边高度多大就旋转哪边，需要注意的事可能要旋转多次，这也很简单，发现旋转后还是不平衡在继续旋转即可。</p><h3 id="平衡二叉树的设计与实现"><a href="#平衡二叉树的设计与实现" class="headerlink" title="平衡二叉树的设计与实现"></a><div><span>平衡二叉树的设计与实现</span></div></h3><p>掌握概念后，最重要的就是实战，我已经把代码写了一遍，不过中途是参考了别人的文章，这边也只是放出了代码图片，有兴趣的同学可以去github上观摩-<a href="https://github.com/JulianHang/little-java-project/blob/master/src/tech/zlia/interest/algorithm/tree/avl/AvlBalanceTree.java" target="_blank" rel="noopener">avl平衡二叉树代码设计与实现</a></p><p class="customize-img"><img src="/assets/blogImg/algorithm/avl/avl-binarytree-code.png" alt="avl平衡二叉树结构代码设计"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><div><span>总结</span></div></h3><p>平衡二叉树中的旋转较为复杂，最好能够结合场景去分析推敲，加油吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;上一篇文章只是简单地认识下&lt;code&gt;二叉树&lt;/code&gt;，并未提到它的&lt;code&gt;缺陷&lt;/code&gt;。数据结构的好坏取决于&lt;code&gt;时间复杂度&lt;/code&gt;，由于每次操作（插入、删除、查找）需要与节点比较来选择进入到左子树还是右子树，也就是说每次比较都会排除一些可能（选择左右其中一侧），当然了这是对于随机均匀分布的二叉树来说，它的时间复杂度是O（log&lt;sub&gt;2&lt;/sub&gt;n），但是对于只有单向的左子树或右子树来说，它的时间复杂度就变成了O(n)，每次操作都会从头到尾所有节点比较一遍。总的来说，二叉树的时间复杂度区间是在O(log&lt;sub&gt;2&lt;/sub&gt;n) ~ O(n)之间，这完全取决于二叉树的结构！如图所示：&lt;/p&gt;
&lt;p class=&quot;customize-img&quot;&gt;&lt;img src=&quot;/assets/blogImg/algorithm/avl/single-binarytree.png&quot; alt=&quot;单向二叉树结构&quot;&gt;&lt;/p&gt;
&lt;p&gt;随着单向二叉树越来越长，所消耗的时间也会越来越多，这已经跟单链表没有什么区别了。因此，为了解决单链表的情况，将时间复杂度降低至O（log&lt;sub&gt;2&lt;/sub&gt;n），衍生出了&lt;code&gt;平衡二叉树&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="algorithm" scheme="http://zlia.tech/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>初识二叉树</title>
    <link href="http://zlia.tech/2019/09/11/explain-binarytree/"/>
    <id>http://zlia.tech/2019/09/11/explain-binarytree/</id>
    <published>2019-09-11T08:27:44.000Z</published>
    <updated>2019-09-17T08:27:46.801Z</updated>
    
    <content type="html"><![CDATA[<h3 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a><div><span>树的概念</span></div></h3><p>探索二叉树前，先来认识下什么是树？用官方一点的话来说，<code>树是数据元素之间具有层次关系的非线性结构，是由n（n&gt;=0）个节点组成的有限集合</code>，n=0时称为空树。在任意一颗非空树中，它具有了以下特性：</p><ul><li><p>每棵树至多只有一个根节点。</p></li><li><p>由根节点构造出多个孩子节点，每个孩子节点只有一个父节点，而孩子节点又构造出多个节点。</p></li></ul><p>先看张图，方便了解下树的一些专业术语。</p><p class="customize-img"><img src="/assets/blogImg/algorithm/binarytree/tree-structure-1.png" alt="树结构"></p><ul><li><p><code>根节点</code>：根节点是没有父节点，图中的A节点。</p></li><li><p><code>孩子节点/子节点</code>：某个节点的孩子称为孩子节点，孩子节点/子节点是相对的，图中A的孩子节点有B、C、D，而B的孩子节点有E、F。</p></li><li><p><code>叶子节点</code>：某个节点没有孩子，图中的E、F、G、D。</p></li><li><p><code>节点的度</code>：某个节点的孩子节点个数，图中A有BCD（3）个孩子节点，B有EF（2）个孩子节点。</p></li><li><p><code>树的层次</code>：某个节点处于树中的层次，图中的A处于第1层。</p></li><li><p><code>树的高/深度</code>：树的最大层次，图中的高/深度为3。</p></li></ul><p>接下来聊正题吧！</p><a id="more"></a><h3 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a><div><span>二叉树的概念</span></div></h3><p><code>二叉树是由n（n&gt;=0）个节点组成的有限集合</code>，n=0时称为空树。在任意一颗非空树中，由一个根节点和两颗互不相交、分别称为根节点的左子树、右子树组成。简单来说，二叉树是一种特殊的树，每个节点最多只能有<code>两个</code>子节点，也就是左子树、右子树。比某个节点小的值放在该节点的左侧，称为左子树，该节点左侧的所有节点，包括子孙节点，都小于该节点，同理，比某个节点大的值放在该节点的右侧，称为右子树，右侧的所有节点都大于该节点的值，这是二叉树的特点！除了上面提到的特性，二叉树还有另外一些性质，提供一张图，方便理解与解释：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/binarytree/binarytree-structure-1.png" alt="二叉树结构"></p><ul><li><p>在二叉树的第K层上，<code>最多</code>有2<sup>k-1</sup>个节点，假设k=3，即在第三层，最多有4个节点。</p></li><li><p>高/深为m的二叉树中，<code>最多</code>有2<sup>m</sup>-1个节点，图中高/深度为3，那么最多7个节点，只差C节点的左子树。</p></li><li><p>在任意一颗二叉树中，度为0的节点总是比度为2的节点多1个，图中度为0的节点有DEF（3），而度为2的节点有AB（2）个。</p></li><li><p>具有n个节点的二叉树，其高/深度<code>至少</code>为log<sub>2</sub>n + 1，图中共有6个节点，log<sub>2</sub>6不会算的话，可以想想6是不是介于2<sup>2</sup>与2<sup>3</sup>之间，它应该无限接近于2次方，最后在加上1，所以高/深至少为3层。</p></li></ul><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p><code>在一颗二叉树中，每一层的节点数都达到最大个数</code>，以下是它的特性：</p><ul><li><p>在满二叉树的第K层上，有2<sup>k-1</sup>个节点。</p></li><li><p>高/深为m的二叉树中，有2<sup>m</sup>-1个节点。</p></li></ul><p>如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/binarytree/binarytree-full-structure-1.png" alt="满二叉树结构"></p><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p><code>在一颗二叉树中，除了最后一层外，其他各层的节点数都达到最大个数，且最后一层从左向右的节点连续存在，只缺右侧若干节点</code>。该含义和满二叉树很相似，所以说满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树，以下是它的特性：</p><ul><li>具有n个节点的二叉树，其高/深为log<sub>2</sub>n + 1</li></ul><p>如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/binarytree/binarytree-complete-structure-1.png" alt="完全二叉树结构"></p><p class="customize-img"><img src="/assets/blogImg/algorithm/binarytree/binarytree-complete-structure-2.png" alt="普通二叉树结构"></p><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a><div><span>二叉树的存储结构</span></div></h3><h4 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h4><p>二叉树的顺序结构是使用一维数组存储二叉树中的节点，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/binarytree/binarytree-order-1.png" alt="二叉树顺序存储结构"></p><p>上图中所采用的顺序存储结构如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/binarytree/binarytree-order-2.png" alt="二叉树顺序存储结构"></p><p>仔细观察这是一颗完全二叉树，数组能够刚好填充数组，但对于不是完全二叉树又该是如何存储的？接着看图：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/binarytree/binarytree-order-3.png" alt="二叉树顺序存储结构"></p><p>上图中所采用的顺序存储结构如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/binarytree/binarytree-order-4.png" alt="二叉树顺序存储结构"></p><p>存储位置没有发生变化，只是在索引为4的位置上存储了空元素（^代表为空），表示此位置上是没有节点的？为什么要这么做呢？简单来说就是为了节点能够很容易地找到父节点或孩子节点，若没有按照一定的规则存储，压根不知道每个节点之间的关系，也就失去了二叉树的意义了。具体的规则如下：一棵树有n个节点，假设i（0 &lt;= i &lt; n）为某个节点的索引，那么该节点的左子树对应的数组索引是2i + 1，右子树对应的数组索引是2i + 2，而该节点的父节点对应的数组索引是(i - 1) / 2。通过以上的规则在数组中维护了每个节点之间的关系，但同时也会造成一定空间的浪费，就好比当它是空元素时，也只有在完全二叉树的情况下才不会造成空间的浪费，严格上来说，该存储方式一般适用于完全二叉树。</p><h4 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h4><p>二叉树还有另外一种存储结构，<code>链式存储结构</code>，该结构可分为：二叉链表、三叉链表，下面将会分别说明。<code>二叉链表结构</code>主要由一个<code>数据域</code>和两个分别指向<code>左右子树的节点</code>组成，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/binarytree/binarytree-link-1.png" alt="二叉树链表存储结构"></p><p>这很像单向链表，每个节点只存储了孩子节点的关系，若要找到其父节点需要重新遍历链表，那效率将被大大的降低了！因此为了提高效率，在原有的基础上新增了父节点的地址，称为<code>三叉链表结构</code>，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/binarytree/binarytree-link-2.png" alt="二叉树链表存储结构"></p><p>两者的区别仅在于多了一个父节点的地址。</p><h3 id="二叉树的设计与实现"><a href="#二叉树的设计与实现" class="headerlink" title="二叉树的设计与实现"></a><div><span>二叉树的设计与实现</span></div></h3><p>尝试手写下二叉树，将采用二叉链表结构实现。由于作者对算法技术并不是很了解，该设计也是参考了别个文章的代码，不得不说，别人写的算法文章还是很专业，对于算法内容讲的很明白、清晰，但是对于代码上的设计并不是很友好，所以最终作者是自己设计了实现代码，只是放出了代码相关的图片，有兴趣的同学可以去github上观摩-<a href="https://github.com/JulianHang/little-java-project/blob/master/src/tech/zlia/interest/algorithm/tree/binary/BinarySearchTree.java" target="_blank" rel="noopener">二叉树设计</a>，也顺便提一下别人的文章<a href="https://blog.csdn.net/javazejian/article/details/53727333" target="_blank" rel="noopener">二叉树算法</a>。</p><p class="customize-img"><img src="/assets/blogImg/algorithm/binarytree/binarytree-code.png" alt="二叉树设计"></p><p><code>若只是想了解算法的话，可以看提供的别人的文章，想看设计代码的话，可以看我的设计代码，良心推荐！</code></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><div><span>总结</span></div></h3><p>二叉树的知识点还是挺复杂、多样的。作者也是入门级别水平，要学的内容还是挺多的，尽可能的将自己理解的内容通过博客的方式写出来，帮助自己也拉别人一把。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;树的概念&quot;&gt;&lt;a href=&quot;#树的概念&quot; class=&quot;headerlink&quot; title=&quot;树的概念&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;树的概念&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;探索二叉树前，先来认识下什么是树？用官方一点的话来说，&lt;code&gt;树是数据元素之间具有层次关系的非线性结构，是由n（n&amp;gt;=0）个节点组成的有限集合&lt;/code&gt;，n=0时称为空树。在任意一颗非空树中，它具有了以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;每棵树至多只有一个根节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;由根节点构造出多个孩子节点，每个孩子节点只有一个父节点，而孩子节点又构造出多个节点。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先看张图，方便了解下树的一些专业术语。&lt;/p&gt;
&lt;p class=&quot;customize-img&quot;&gt;&lt;img src=&quot;/assets/blogImg/algorithm/binarytree/tree-structure-1.png&quot; alt=&quot;树结构&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;根节点&lt;/code&gt;：根节点是没有父节点，图中的A节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;孩子节点/子节点&lt;/code&gt;：某个节点的孩子称为孩子节点，孩子节点/子节点是相对的，图中A的孩子节点有B、C、D，而B的孩子节点有E、F。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;叶子节点&lt;/code&gt;：某个节点没有孩子，图中的E、F、G、D。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;节点的度&lt;/code&gt;：某个节点的孩子节点个数，图中A有BCD（3）个孩子节点，B有EF（2）个孩子节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;树的层次&lt;/code&gt;：某个节点处于树中的层次，图中的A处于第1层。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;树的高/深度&lt;/code&gt;：树的最大层次，图中的高/深度为3。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来聊正题吧！&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="algorithm" scheme="http://zlia.tech/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>探索Stack底层实现</title>
    <link href="http://zlia.tech/2019/09/06/explain-stack-sourcecode/"/>
    <id>http://zlia.tech/2019/09/06/explain-stack-sourcecode/</id>
    <published>2019-09-06T06:10:06.000Z</published>
    <updated>2019-09-16T06:56:43.294Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a><div><span>简单介绍</span></div></h3><p><code>Stack</code>类就一百多行代码，简单说明下。它的特性是<code>后进先出（LIFO）</code>，继承了Vector类，大部分的操作都是使用Vector中的方法。在注释中，作者提醒我们若要使用后进先出的栈操作，应该优先使用<code>Deque</code>，这么说来，该类已经被放弃了，早在JDK1.0的时候它就出现了，是有点老了！我们说过Vector属于相对线程安全，所以Stack也是相对线程安全！探索<code>Stack</code>源代码是基于<code>JDK1.8</code>的。</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a><div><span>源码</span></div></h3><p>该类的代码不多，就不做分类了，不过为了方便理解，提供了它的数据结构图。</p><p class="customize-img"><img src="/assets/blogImg/java/stack/stack-data-structure.png" alt="Stack数据结构图"></p><p>说是后进先出，实际上它还是能通过调用Vector中的方法来破除该原则！该图只是告诉大家什么是<code>后进先出</code>。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 添加指定元素到栈的顶层</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 指定元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 指定元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">push</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">        addElement(item);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除栈的顶层元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 被移除的顶层元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        E obj;</span><br><span class="line">        <span class="keyword">int</span> len = size();</span><br><span class="line"></span><br><span class="line">        obj = peek();</span><br><span class="line">        removeElementAt(len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取栈的顶层元素</span></span><br><span class="line"><span class="comment">     * 若为空数组，则抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        <span class="keyword">return</span> elementAt(len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断数组是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 数组是否为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反向遍历获取指定元素的索引，返回指定元素的索引与顶层元素的索引之间的差值</span></span><br><span class="line"><span class="comment">     * 若未找到指定元素则返回-1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 差值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = lastIndexOf(o);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> size() - i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a><div><span>重点</span></div></h3><p><code>使用Deque代替Stack</code> <code>严格上说并不满足后进先出原则</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简单介绍&quot;&gt;&lt;a href=&quot;#简单介绍&quot; class=&quot;headerlink&quot; title=&quot;简单介绍&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;简单介绍&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Stack&lt;/code&gt;类就一百多行代码，简单说明下。它的特性是&lt;code&gt;后进先出（LIFO）&lt;/code&gt;，继承了Vector类，大部分的操作都是使用Vector中的方法。在注释中，作者提醒我们若要使用后进先出的栈操作，应该优先使用&lt;code&gt;Deque&lt;/code&gt;，这么说来，该类已经被放弃了，早在JDK1.0的时候它就出现了，是有点老了！我们说过Vector属于相对线程安全，所以Stack也是相对线程安全！探索&lt;code&gt;Stack&lt;/code&gt;源代码是基于&lt;code&gt;JDK1.8&lt;/code&gt;的。&lt;/p&gt;
&lt;h3 id=&quot;源码&quot;&gt;&lt;a href=&quot;#源码&quot; class=&quot;headerlink&quot; title=&quot;源码&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;源码&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;该类的代码不多，就不做分类了，不过为了方便理解，提供了它的数据结构图。&lt;/p&gt;
&lt;p class=&quot;customize-img&quot;&gt;&lt;img src=&quot;/assets/blogImg/java/stack/stack-data-structure.png&quot; alt=&quot;Stack数据结构图&quot;&gt;&lt;/p&gt;
&lt;p&gt;说是后进先出，实际上它还是能通过调用Vector中的方法来破除该原则！该图只是告诉大家什么是&lt;code&gt;后进先出&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索CopyOnWriteArrayList底层实现</title>
    <link href="http://zlia.tech/2019/09/05/explain-copyonwritearraylist-sourcecode/"/>
    <id>http://zlia.tech/2019/09/05/explain-copyonwritearraylist-sourcecode/</id>
    <published>2019-09-05T10:21:39.000Z</published>
    <updated>2019-09-06T06:08:32.916Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a><div><span>简单介绍</span></div></h3><p>由于<code>CopyOnWriteArrayList</code>的<code>注释</code>并不是很多，所以在这里简单的说明下，它属于线程安全，底层是通过<code>生成数组的新副本</code>来实现的，也就是在修改列表元素/结构的情况会生成新副本。简单地说，它是ArrayList的一个变体！探索<code>CopyOnWriteArrayList</code>源代码是基于<code>JDK1.8</code>版本的。</p><h3 id="开干"><a href="#开干" class="headerlink" title="开干"></a><div><span>开干</span></div></h3><p>开始进入到看源码的时间吧！</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//支持随机访问，可克隆，可序列化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8673264195747942595L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//目前先知道是锁就行了，后续会有新文章来进行详细说明</span></span><br><span class="line">    <span class="comment">//保证同一个时间内只有一个线程能访问，</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保证变量的可见性，但无法保证原子性</span></span><br><span class="line">    <span class="comment">//至于什么是可见性、原子性，较为难理解，况且也不是本章的重点，加上作者对其的理解还不够，所以后续才会出文章去做详细说明</span></span><br><span class="line">    <span class="comment">//该数组用于存放元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相比于ArrayList，为什么没有了size、modCount成员属性呢？</span></span><br><span class="line">    <span class="comment">//因为每次添加/删除元素时，都会生成数组的新副本，也就是说新副本代替了size的作用</span></span><br><span class="line">    <span class="comment">//modCount在ArrayList中主要用于在迭代器的结构修改判断中，而CopyOnWriteArrayList的迭代器中不支持结构修改，为什么不支持呢？</span></span><br><span class="line">    <span class="comment">//源码中并未提到为什么不支持，以下主要是自我的理解</span></span><br><span class="line">    <span class="comment">//结构修改中必然涉及到加锁，若对迭代器加锁了，要是对它进行遍历上千条数据，那其他线程就不用执行了，所以迭代器万不可加锁！</span></span><br><span class="line">    <span class="comment">//不能加锁，那对于结构的修改势必会造成并发访问的问题，所以目前是没有提供支持，纯属个人理解！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//JDK1.8并未有该类的相关注释，偏向底层，目前作者只知道它是跟锁有关联的，若想知道可自行百度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> lockOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = CopyOnWriteArrayList.class;</span><br><span class="line">            lockOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"lock"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建空数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建一个包含指定collection集合的对象，CopyOnWriteArrayList容量大小和该集合大小一致，指定集合中的元素按照迭代器的顺序排列</span></span><br><span class="line"><span class="comment"> * collection集合类型有Map、set、List等子类，所以入参可以是多种类型</span></span><br><span class="line"><span class="comment"> * CopyOnWriteArrayList保证数组中元素类型是Object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] elements;</span><br><span class="line">    <span class="keyword">if</span> (c.getClass() == CopyOnWriteArrayList.class)</span><br><span class="line">        elements = ((CopyOnWriteArrayList&lt;?&gt;)c).getArray();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        elements = c.toArray();</span><br><span class="line">        <span class="comment">//c.toArray 可能不会返回正确的Object[]类型，这边可能会利用多态的性质，如 A a = new B()</span></span><br><span class="line">        <span class="keyword">if</span> (elements.getClass() != Object[].class)</span><br><span class="line">            elements = Arrays.copyOf(elements, elements.length, Object[].class);</span><br><span class="line">    &#125;</span><br><span class="line">    setArray(elements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建一个包含指定数组的对象</span></span><br><span class="line"><span class="comment"> * 生成数组的新副本，并让该对象中的数组指向它</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toCopyIn 指定数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(E[] toCopyIn)</span> </span>&#123;</span><br><span class="line">    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h4><p>接下来按照类的声明顺序介绍<code>方法</code>，有必要的情况下结合例子进行说明。</p><h5 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组</span></span><br><span class="line"><span class="comment"> * 之所以没有加上private访问修饰符，是因为在CopyOnWriteArraySet类中使用了该方法</span></span><br><span class="line"><span class="comment"> * 加上final防止继承类去覆写该方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 新数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组元素的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组元素的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getArray().length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断数组是否为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组是否为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断两个对象是否相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o1 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o2 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 两个对象是否相等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">eq</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (o1 == <span class="keyword">null</span>) ? o2 == <span class="keyword">null</span> : o1.equals(o2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正向遍历，获取从指定起始索引到指定结束索引之间搜索指定元素的索引</span></span><br><span class="line"><span class="comment"> * 若指定区间不存在指定元素的话则返回-1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> elements 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fence 指定结束索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o, Object[] elements,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> index, <span class="keyword">int</span> fence)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; fence; i++)</span><br><span class="line">            <span class="keyword">if</span> (elements[i] == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; fence; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elements[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反向遍历，获取从指定起始索引到索引为0之间搜索指定元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> elements 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o, Object[] elements, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elements[i] == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elements[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断数组中是否包含指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组是否包含指定元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">return</span> indexOf(o, elements, <span class="number">0</span>, elements.length) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正向遍历，获取指定元素的索引</span></span><br><span class="line"><span class="comment"> * 若未发现指定元素则返回-1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">return</span> indexOf(o, elements, <span class="number">0</span>, elements.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正向遍历，获取从指定起始索引处开始搜索指定元素的索引</span></span><br><span class="line"><span class="comment"> * 若未发现指定元素则返回-1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(E e, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">return</span> indexOf(e, elements, index, elements.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反向遍历，获取指定元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">return</span> lastIndexOf(o, elements, elements.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反向遍历，获取从指定起始索引处开始搜索指定元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(E e, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">return</span> lastIndexOf(e, elements, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拷贝新的CopyOnWriteArrayList对象，没有拷贝对象中的数组，属于浅拷贝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        CopyOnWriteArrayList&lt;E&gt; clone =</span><br><span class="line">            (CopyOnWriteArrayList&lt;E&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        clone.resetLock();</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个包含所有列表元素的有序（按照添加顺序）数组</span></span><br><span class="line"><span class="comment"> * 此方法是创建一个新数组，方便使用者能够随便操作新数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elements, elements.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将列表的所有元素放入到指定数组中并返回</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：T类型要么是数组中数据的相同类型，要么是数组中数据的父类型，运用多态性质</span></span><br><span class="line"><span class="comment"> * 若传入的新数组容量 &lt; 列表容量，则取它的类类型来创建一个包含列表元素的新数组，并返回</span></span><br><span class="line"><span class="comment"> * 若传入的新数组容量 &gt; 列表容量，则将列表中的元素按照顺序拷贝到新数组中，同时将新数组中索引为size的值设置成null</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 一开始我也好奇为啥要在索引为size上设置个null呢？</span></span><br><span class="line"><span class="comment"> * 看了注释加上自我的理解，若传入的新数组是个空数组的话，那么除了拷贝列表元素后剩余的所有空间的值都为null，此时在给索引为size的值设置成null似乎没有多大</span></span><br><span class="line"><span class="comment"> * 意思；另外一种情况是若传入的新数组不是个空数组，那这个设置就有意义了，传入的新数组的某些元素会被列表元素覆盖，同时有个null，剩下的才是自己本身的数据，呈现这样子一种效果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment"> * list.add(11);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Integer[] str = new Integer[]&#123;1,2,3,4,5,6,7,8,9,10&#125;;</span></span><br><span class="line"><span class="comment"> * Integer[] s1 = list.toArray(str);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * for (Integer s : s1) &#123;</span></span><br><span class="line"><span class="comment"> *     System.out.println(s + ",");</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输出结果：11,null,3,4,5,6,7,8,9,10,</span></span><br><span class="line"><span class="comment"> * 那么设置这个null的意义就在于能够确定列表中元素个数（长度），但有个前提就是调用者知道链表中的所有节点信息不存在null才有意义，目前我只有想到这一种情况下有用！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 指定数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 填充完列表元素的指定数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T a[]) &#123;</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">int</span> len = elements.length;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; len)</span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elements, len, a.getClass());</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        System.arraycopy(elements, <span class="number">0</span>, a, <span class="number">0</span>, len);</span><br><span class="line">        <span class="keyword">if</span> (a.length &gt; len)</span><br><span class="line">            a[len] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断数组中是否包含指定集合中的所有元素</span></span><br><span class="line"><span class="comment"> * 集合中的元素但凡在数组中未包含则返回false</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组中是否包含指定集合中的所有元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">int</span> len = elements.length;</span><br><span class="line">    <span class="keyword">for</span> (Object e : c) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indexOf(e, elements, <span class="number">0</span>, len) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集合与数组取交集</span></span><br><span class="line"><span class="comment"> * 最终数组中只包含与集合共有的元素，相当于在修改数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组元素是否被修改成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="keyword">if</span> (len != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// temp array holds those elements we know we want to keep</span></span><br><span class="line">            <span class="keyword">int</span> newlen = <span class="number">0</span>;</span><br><span class="line">            Object[] temp = <span class="keyword">new</span> Object[len];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                Object element = elements[i];</span><br><span class="line">                <span class="keyword">if</span> (c.contains(element))</span><br><span class="line">                    temp[newlen++] = element;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newlen != len) &#123;</span><br><span class="line">                setArray(Arrays.copyOf(temp, newlen));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空数组中的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        setArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历数组，并对数组中的元素进行指定处理</span></span><br><span class="line"><span class="comment"> * 读取时不会发生冲突，因为添加、删除、替换等操作都是使用新副本，只不过会出现实时数据不一致，但最终是一致的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action 函数式接口，对数组中的元素指定处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">int</span> len = elements.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) elements[i];</span><br><span class="line">        action.accept(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定条件移除元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filter 使用指定条件来过滤元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> E&gt; filter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (filter == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="keyword">if</span> (len != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> newlen = <span class="number">0</span>;</span><br><span class="line">            Object[] temp = <span class="keyword">new</span> Object[len];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) elements[i];</span><br><span class="line">                <span class="keyword">if</span> (!filter.test(e))</span><br><span class="line">                    temp[newlen++] = e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newlen != len) &#123;</span><br><span class="line">                setArray(Arrays.copyOf(temp, newlen));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定规则替换所有旧元素</span></span><br><span class="line"><span class="comment"> * operator.apply方法：旧元素作为入参传入，根据规则返回新元素，然后进行替换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> operator 指定规则，函数式接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (operator == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) elements[i];</span><br><span class="line">            newElements[i] = operator.apply(e);</span><br><span class="line">        &#125;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定规则对数组中的元素进行排序</span></span><br><span class="line"><span class="comment"> * 若没有指定规则则使用默认的升序进行排序</span></span><br><span class="line"><span class="comment"> * 指定规则后会调用自定义比较器中的compare方法进行比较排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 自定义比较器，覆写compare方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, elements.length);</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E[] es = (E[])newElements;</span><br><span class="line">        Arrays.sort(es, c);</span><br><span class="line">        setArray(newElements);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义序列化</span></span><br><span class="line"><span class="comment"> * 写入数组的长度及数组的元素方便构建</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 输出流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="comment">// Write out array length</span></span><br><span class="line">    s.writeInt(elements.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (Object element : elements)</span><br><span class="line">        s.writeObject(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义反序列化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 输入流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成新的锁对象</span></span><br><span class="line">    resetLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = s.readInt();</span><br><span class="line">    SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, len);</span><br><span class="line">    Object[] elements = <span class="keyword">new</span> Object[len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        elements[i] = s.readObject();</span><br><span class="line">    setArray(elements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组元素的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组元素的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.toString(getArray());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先判断当前对象与指定对象是否指向同一个对象，就是在判断地址</span></span><br><span class="line"><span class="comment"> * 紧接着判断指定对象属于List的子类</span></span><br><span class="line"><span class="comment"> * 紧接着获取该对象的迭代器</span></span><br><span class="line"><span class="comment"> * 若两个迭代器的元素个数不相等，则返回false</span></span><br><span class="line"><span class="comment"> * 若两个迭代器的元素个数相等，则将两个迭代器的元素进行对应的比较，但凡出现对应的元素不相等则返回false</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 当前对象与指定对象是否相等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> List))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;?&gt; list = (List&lt;?&gt;)(o);</span><br><span class="line">    Iterator&lt;?&gt; it = list.iterator();</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">int</span> len = elements.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!it.hasNext() || !eq(elements[i], it.next()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (it.hasNext())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hashCode = <span class="number">1</span>;</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">int</span> len = elements.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        Object obj = elements[i];</span><br><span class="line">        hashCode = <span class="number">31</span>*hashCode + (obj==<span class="keyword">null</span> ? <span class="number">0</span> : obj.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取分割迭代器</span></span><br><span class="line"><span class="comment"> * 由于该方法涉及到另外一个接口，会另外新起一篇文章来讲解该内容，这里就不做阐述</span></span><br><span class="line"><span class="comment"> * 附上文章地址：http://zlia.tech/2019/08/28/explain-arraylist-spliterator-sourcecode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Spliterators.spliterator</span><br><span class="line">        (getArray(), Spliterator.IMMUTABLE | Spliterator.ORDERED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取指定起始索引到指定结束索引之间的元素，简称获取指定子集</span></span><br><span class="line"><span class="comment"> * 指定区间中的元素包括起始索引，不包括结束索引</span></span><br><span class="line"><span class="comment"> * 若起始索引与结束索引相等，则返回空元素</span></span><br><span class="line"><span class="comment"> * 对子集的操作，即调用set、add、remove等方法将会影响到整个数组</span></span><br><span class="line"><span class="comment"> * 但在先获取子集后，又对整个数组的结构进行修改，这时在遍历子集则会导致报错，而对于整体的非结构性修改则不会报错，不过依然会影响到子集</span></span><br><span class="line"><span class="comment"> * 所以在获取子集后最好不要修改数组的结构</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 代码片段与ArrayList是类似的，可参考ArrayList文章：http://zlia.tech/2019/08/16/explain-arraylist-sourcecode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromIndex 起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toIndex 结束索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定区间中的所有元素，称为子集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span> || toIndex &gt; len || fromIndex &gt; toIndex)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> COWSubList&lt;E&gt;(<span class="keyword">this</span>, fromIndex, toIndex);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重置锁，生成新的锁对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resetLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UNSAFE.putObjectVolatile(<span class="keyword">this</span>, lockOffset, <span class="keyword">new</span> ReentrantLock());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取指定索引的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定索引的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取指定索引的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定索引的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定索引处的元素修改成指定元素</span></span><br><span class="line"><span class="comment"> * 在执行操作之前，先加上锁，接着生成数组的新副本，在新副本中替换元素，最后将数组指向新副本并释放锁</span></span><br><span class="line"><span class="comment"> * 在未释放锁之前，其他线程无法进入，这样子就保证了线程安全</span></span><br><span class="line"><span class="comment"> * 每次调用该方法都会造成新副本数组的生成，导致内存飙升</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 新元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oldValue != element) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setArray(elements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定元素到列表尾部</span></span><br><span class="line"><span class="comment"> * 在执行操作之前，先加上锁，接着生成数组的新副本，并扩充其容量，最后将数组指向新副本并释放锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定元素到指定索引处</span></span><br><span class="line"><span class="comment"> * 由于每次都会生成新副本，原先数组的前index元素列表会拷贝到新副本中，再者原先数据的后index元素列表会拷贝到新副本中</span></span><br><span class="line"><span class="comment"> * 原先数组中的所有元素都拷贝到了新副本中，最终在新副本中的index位置为null，最后在设置指定元素即可</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 指定元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; len || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index+</span><br><span class="line">                                                <span class="string">", Size: "</span>+len);</span><br><span class="line">        Object[] newElements;</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            newElements = <span class="keyword">new</span> Object[len + <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            System.arraycopy(elements, index, newElements, index + <span class="number">1</span>,</span><br><span class="line">                             numMoved);</span><br><span class="line">        &#125;</span><br><span class="line">        newElements[index] = element;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 若数组中未包含指定元素则进行添加到尾部</span></span><br><span class="line"><span class="comment"> * 若数组中已经存在指定元素则返回false</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addIfAbsent</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    Object[] snapshot = getArray();</span><br><span class="line">    <span class="keyword">return</span> indexOf(e, snapshot, <span class="number">0</span>, snapshot.length) &gt;= <span class="number">0</span> ? <span class="keyword">false</span> :</span><br><span class="line">        addIfAbsent(e, snapshot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 若新副本中未包含指定元素则进行添加到尾部</span></span><br><span class="line"><span class="comment"> * 若是新副本中已经存在指定元素则返回false</span></span><br><span class="line"><span class="comment"> * 至始至终snapshot都是用来做与新副本进行比较的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> snapshot 数组，有可能成为旧数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addIfAbsent</span><span class="params">(E e, Object[] snapshot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] current = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = current.length;</span><br><span class="line">        <span class="keyword">if</span> (snapshot != current) &#123;</span><br><span class="line">            <span class="comment">//生成了新的数组副本</span></span><br><span class="line">            <span class="keyword">int</span> common = Math.min(snapshot.length, len);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; common; i++)</span><br><span class="line">                <span class="keyword">if</span> (current[i] != snapshot[i] &amp;&amp; eq(e, current[i]))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (indexOf(e, current, common, len) &gt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(current, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加集合中未被数组包含的元素到数组尾部，相当于批量添加不存在的元素到尾部</span></span><br><span class="line"><span class="comment"> * 集合中重复的元素只会被添加一次</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 添加到数组中的元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addAllAbsent</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] cs = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> (cs.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="keyword">int</span> added = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// uniquify and compact elements in cs</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cs.length; ++i) &#123;</span><br><span class="line">            Object e = cs[i];</span><br><span class="line">            <span class="keyword">if</span> (indexOf(e, elements, <span class="number">0</span>, len) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                indexOf(e, cs, <span class="number">0</span>, added) &lt; <span class="number">0</span>)</span><br><span class="line">                cs[added++] = e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (added &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + added);</span><br><span class="line">            System.arraycopy(cs, <span class="number">0</span>, newElements, len, added);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> added;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定集合添加到数组尾部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] cs = (c.getClass() == CopyOnWriteArrayList.class) ?</span><br><span class="line">        ((CopyOnWriteArrayList&lt;?&gt;)c).getArray() : c.toArray();</span><br><span class="line">    <span class="keyword">if</span> (cs.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span> &amp;&amp; cs.getClass() == Object[].class)</span><br><span class="line">            setArray(cs);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + cs.length);</span><br><span class="line">            System.arraycopy(cs, <span class="number">0</span>, newElements, len, cs.length);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定集合添加到数组的指定索引处</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] cs = c.toArray();</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; len || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index+</span><br><span class="line">                                                <span class="string">", Size: "</span>+len);</span><br><span class="line">        <span class="keyword">if</span> (cs.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index;</span><br><span class="line">        Object[] newElements;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            newElements = Arrays.copyOf(elements, len + cs.length);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            newElements = <span class="keyword">new</span> Object[len + cs.length];</span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            System.arraycopy(elements, index,</span><br><span class="line">                             newElements, index + cs.length,</span><br><span class="line">                             numMoved);</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(cs, <span class="number">0</span>, newElements, index, cs.length);</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除数组中指定索引处的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除数组中的指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    Object[] snapshot = getArray();</span><br><span class="line">    <span class="keyword">int</span> index = indexOf(o, snapshot, <span class="number">0</span>, snapshot.length);</span><br><span class="line">    <span class="keyword">return</span> (index &lt; <span class="number">0</span>) ? <span class="keyword">false</span> : remove(o, snapshot, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除数组中的指定索引处的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> snapshot 数组，有可能是旧数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o, Object[] snapshot, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] current = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = current.length;</span><br><span class="line">        <span class="keyword">if</span> (snapshot != current) findIndex: &#123;</span><br><span class="line">            <span class="comment">//这部分代码是获取新副本中指定元素的索引，也就是获取最新的索引，看看新副本中有没有存在等于指定元素的更小索引</span></span><br><span class="line">            <span class="keyword">int</span> prefix = Math.min(index, len);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (current[i] != snapshot[i] &amp;&amp; eq(o, current[i])) &#123;</span><br><span class="line">                    index = i;</span><br><span class="line">                    <span class="keyword">break</span> findIndex; <span class="comment">//表示跳出指定代码块</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若在新副本中未找到指定元素的索引则index不会被改变，此时的情况应该是：旧数组的长度大于新副本数组的长度，那么最终会返回false</span></span><br><span class="line">            <span class="keyword">if</span> (index &gt;= len)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//判断新副本的指定索引处的元素是否与指定元素相等，若相等则说明该位置的元素并未发生改变</span></span><br><span class="line">            <span class="keyword">if</span> (current[index] == o)</span><br><span class="line">                <span class="keyword">break</span> findIndex;</span><br><span class="line">            <span class="comment">//此时的情况是：新副本数组的长度大于旧数组的长度，获取新副本中指定元素的索引</span></span><br><span class="line">            index = indexOf(o, current, index, len);</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">        System.arraycopy(current, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">        System.arraycopy(current, index + <span class="number">1</span>,</span><br><span class="line">                         newElements, index,</span><br><span class="line">                         len - index - <span class="number">1</span>);</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除指定起始索引到结束索引之间的所有元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromIndex 指定起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toIndex 指定结束索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span> || toIndex &gt; len || toIndex &lt; fromIndex)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        <span class="keyword">int</span> newlen = len - (toIndex - fromIndex);</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - toIndex;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            setArray(Arrays.copyOf(elements, newlen));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> Object[newlen];</span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, fromIndex);</span><br><span class="line">            System.arraycopy(elements, toIndex, newElements,</span><br><span class="line">                             fromIndex, numMoved);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组中移除指定集合的所有元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="keyword">if</span> (len != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// temp array holds those elements we know we want to keep</span></span><br><span class="line">            <span class="keyword">int</span> newlen = <span class="number">0</span>;</span><br><span class="line">            Object[] temp = <span class="keyword">new</span> Object[len];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                Object element = elements[i];</span><br><span class="line">                <span class="keyword">if</span> (!c.contains(element))</span><br><span class="line">                    temp[newlen++] = element;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newlen != len) &#123;</span><br><span class="line">                setArray(Arrays.copyOf(temp, newlen));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 迭代器 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> COWIterator&lt;E&gt;(getArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> COWIterator&lt;E&gt;(getArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取从指定起始索引开始的列表迭代器</span></span><br><span class="line"><span class="comment"> * 列表迭代器中的元素是从指定索引开始到结束索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 列表迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">int</span> len = elements.length;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; len)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> COWIterator&lt;E&gt;(elements, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 列表迭代器，正向迭代</span></span><br><span class="line"><span class="comment"> * 可获取上一个元素、下一个元素及索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">COWIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当迭代器被创建后，只拿到当前数组的引用，也就是说只拥有当前数组的元素</span></span><br><span class="line">    <span class="comment">//而随着后面列表的add、remove、repalce都是在操作新副本，这些变动并不会反映到当前的引用，相当于是两个引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下一个元素的索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> elements 当前数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCursor 下一个元素的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">COWIterator</span><span class="params">(Object[] elements, <span class="keyword">int</span> initialCursor)</span> </span>&#123;</span><br><span class="line">        cursor = initialCursor;</span><br><span class="line">        snapshot = elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 判断是否有下一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否有下一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &lt; snapshot.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否有前一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否有前一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个元素的值</span></span><br><span class="line"><span class="comment">     * 若不存在则抛出异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个元素的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasNext())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取上一个元素</span></span><br><span class="line"><span class="comment">     * 若不存在则抛出异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 上一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasPrevious())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> (E) snapshot[--cursor];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个元素的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个元素的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取上一个元素的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 上一个元素的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不支持，为什么不支持在数据结构那一栏中有提到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不支持，为什么不支持在数据结构那一栏中有提到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不支持，为什么不支持在数据结构那一栏中有提到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历元素，只能遍历一次</span></span><br><span class="line"><span class="comment">     * 与forEach的区别在于：可以遍历多次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> consumer 函数式接口，声明如何处理元素的函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        Object[] elements = snapshot;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = elements.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cursor; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) elements[i];</span><br><span class="line">            action.accept(e);</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>CopyOnWriteArrayList允许存放Null。</p></li><li><p>底层通过生成数组的新副本实现，故内存占用是个明显的问题。</p></li><li><p>多线程情况下，可能读取旧数据，只能保证数据的最终一致性。</p></li><li><p>CopyOnWriteArrayList适用于读多写少的场景。</p></li><li><p>CopyOnWriteArrayList在性能上没有ArrayList、LinkedList好，毕竟加了锁！</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>线程安全</code> <code>底层是通过生成数组的新副本实现</code> <code>由于每次都生成新副本，故内存占用会相对更大</code> <code>多线程情况下，可能读取到旧数据（读取在添加之前执行）</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简单介绍&quot;&gt;&lt;a href=&quot;#简单介绍&quot; class=&quot;headerlink&quot; title=&quot;简单介绍&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;简单介绍&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;由于&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;的&lt;code&gt;注释&lt;/code&gt;并不是很多，所以在这里简单的说明下，它属于线程安全，底层是通过&lt;code&gt;生成数组的新副本&lt;/code&gt;来实现的，也就是在修改列表元素/结构的情况会生成新副本。简单地说，它是ArrayList的一个变体！探索&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;源代码是基于&lt;code&gt;JDK1.8&lt;/code&gt;版本的。&lt;/p&gt;
&lt;h3 id=&quot;开干&quot;&gt;&lt;a href=&quot;#开干&quot; class=&quot;headerlink&quot; title=&quot;开干&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;开干&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;开始进入到看源码的时间吧！&lt;/p&gt;
&lt;h4 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//支持随机访问，可克隆，可序列化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CopyOnWriteArrayList&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;List&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt;, &lt;span class=&quot;title&quot;&gt;RandomAccess&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Cloneable&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;java&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;io&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Serializable&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//序列号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; serialVersionUID = &lt;span class=&quot;number&quot;&gt;8673264195747942595L&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//目前先知道是锁就行了，后续会有新文章来进行详细说明&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//保证同一个时间内只有一个线程能访问，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;transient&lt;/span&gt; ReentrantLock lock = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ReentrantLock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//保证变量的可见性，但无法保证原子性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//至于什么是可见性、原子性，较为难理解，况且也不是本章的重点，加上作者对其的理解还不够，所以后续才会出文章去做详细说明&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//该数组用于存放元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;transient&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;volatile&lt;/span&gt; Object[] array;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//相比于ArrayList，为什么没有了size、modCount成员属性呢？&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//因为每次添加/删除元素时，都会生成数组的新副本，也就是说新副本代替了size的作用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//modCount在ArrayList中主要用于在迭代器的结构修改判断中，而CopyOnWriteArrayList的迭代器中不支持结构修改，为什么不支持呢？&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//源码中并未提到为什么不支持，以下主要是自我的理解&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//结构修改中必然涉及到加锁，若对迭代器加锁了，要是对它进行遍历上千条数据，那其他线程就不用执行了，所以迭代器万不可加锁！&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//不能加锁，那对于结构的修改势必会造成并发访问的问题，所以目前是没有提供支持，纯属个人理解！&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//JDK1.8并未有该类的相关注释，偏向底层，目前作者只知道它是跟锁有关联的，若想知道可自行百度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; sun.misc.Unsafe UNSAFE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; lockOffset;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            UNSAFE = sun.misc.Unsafe.getUnsafe();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Class&amp;lt;?&amp;gt; k = CopyOnWriteArrayList.class;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            lockOffset = UNSAFE.objectFieldOffset&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                (k.getDeclaredField(&lt;span class=&quot;string&quot;&gt;&quot;lock&quot;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Error(e);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList与LinkedList的性能比较</title>
    <link href="http://zlia.tech/2019/09/02/arraylist-linkedlist-perfermance-compare/"/>
    <id>http://zlia.tech/2019/09/02/arraylist-linkedlist-perfermance-compare/</id>
    <published>2019-09-02T15:44:31.000Z</published>
    <updated>2019-09-02T15:51:13.322Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>我们都知道<code>ArrayList适合查询/替换</code>、<code>LinkedList适合添加/删除</code>，造成这样子的原因也在于它们底层的实现。光说这些理论似乎大家都会，所以准备用更加具体的例子来证明它，也能更好地比较这两者之间的性能关系。在测试具体场景前，简单说明下环境配置，window环境下：内存8个G；JDK8；i7处理器。</p><h3 id="测试场景"><a href="#测试场景" class="headerlink" title="测试场景"></a><div><span>测试场景</span></div></h3><p>分别准备1w、5w、10w、50w、100w条数据，也就是说数据类别有上面这几种，将它们分别按照下列场景测试。</p><ul><li><p>在首部、尾部添加元素/节点的效率。</p></li><li><p>随机位置/索引插入元素/节点的效率。</p></li><li><p>在首部、尾部删除元素/节点的效率。</p></li><li><p>随机位置/索引删除元素/节点的效率。</p></li><li><p>随机位置/索引获取元素/节点的效率。</p></li><li><p>随机位置/索引修改元素/节点的效率。</p></li></ul><a id="more"></a><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a><div><span>测试结果</span></div></h3><p>测试结果将以表格的方式展示。</p><ul><li>在首部、尾部添加元素/节点。</li></ul><p>A首：ArrayList首部添加元素，L首：LinkedList首部添加元素，A尾：ArrayList尾部添加元素，L尾：LinkedList尾部添加元素。</p><p class="customize-img"><img src="/assets/blogImg/java/arraylist-compare-linkedlist/arraylist-compare-linkedlist-1.png" alt="ArrayList注释-1"></p><ul><li>随机位置/索引插入元素/节点。</li></ul><p>A随：ArrayList随机位置添加元素，L随：LinkedList随机位置添加元素。</p><p class="customize-img"><img src="/assets/blogImg/java/arraylist-compare-linkedlist/arraylist-compare-linkedlist-2.png" alt="ArrayList注释-2"></p><p>由于50w、100w执行时间过长故并未给出具体时间，不过已经足以说明结果了。</p><ul><li>在首部、尾部删除元素/节点。</li></ul><p>A首：ArrayList首部删除元素，L首：LinkedList首部删除元素，A尾：ArrayList尾部删除元素，L尾：LinkedList尾部删除元素。</p><p class="customize-img"><img src="/assets/blogImg/java/arraylist-compare-linkedlist/arraylist-compare-linkedlist-3.png" alt="ArrayList注释-3"></p><ul><li>随机位置/索引删除元素/节点。</li></ul><p class="customize-img"><img src="/assets/blogImg/java/arraylist-compare-linkedlist/arraylist-compare-linkedlist-4.png" alt="ArrayList注释-4"></p><p>同上。</p><ul><li>随机位置/索引获取元素/节点。</li></ul><p class="customize-img"><img src="/assets/blogImg/java/arraylist-compare-linkedlist/arraylist-compare-linkedlist-5.png" alt="ArrayList注释-5"></p><p>同上。</p><ul><li>随机位置/索引替换元素/节点。</li></ul><p class="customize-img"><img src="/assets/blogImg/java/arraylist-compare-linkedlist/arraylist-compare-linkedlist-6.png" alt="ArrayList注释-6"></p><p>同上。</p><h3 id="测试结果分析"><a href="#测试结果分析" class="headerlink" title="测试结果分析"></a><div><span>测试结果分析</span></div></h3><p>以上的测试方式较为简单，没有考虑其他太多的因素，所以不要纠结于具体的时间，而是要了解它们的性能趋势。从测试结果来看，可以得到更为具体的结论：</p><ul><li><p><code>在首部添加/删除元素/节点过程中</code>，随着数据量的不断增大，<code>LinkedList明显要比ArrayList优秀很多</code>，<code>而对于尾部添加/删除</code>，<code>两者则差别不大</code>。</p></li><li><p>在随机插入/删除/获取/替换元素/节点过程中，随着数据量的不断增大，ArrayList明显要比LinkedList优秀很多！</p></li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a><div><span>结论</span></div></h3><ul><li><p><code>ArrayList比LinkedList更能适应大多数情况</code>。</p></li><li><p>频繁在首部添加/删除元素/节点，不需要过多的访问，可能更适合LinkedList。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;我们都知道&lt;code&gt;ArrayList适合查询/替换&lt;/code&gt;、&lt;code&gt;LinkedList适合添加/删除&lt;/code&gt;，造成这样子的原因也在于它们底层的实现。光说这些理论似乎大家都会，所以准备用更加具体的例子来证明它，也能更好地比较这两者之间的性能关系。在测试具体场景前，简单说明下环境配置，window环境下：内存8个G；JDK8；i7处理器。&lt;/p&gt;
&lt;h3 id=&quot;测试场景&quot;&gt;&lt;a href=&quot;#测试场景&quot; class=&quot;headerlink&quot; title=&quot;测试场景&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;测试场景&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;分别准备1w、5w、10w、50w、100w条数据，也就是说数据类别有上面这几种，将它们分别按照下列场景测试。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在首部、尾部添加元素/节点的效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;随机位置/索引插入元素/节点的效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在首部、尾部删除元素/节点的效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;随机位置/索引删除元素/节点的效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;随机位置/索引获取元素/节点的效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;随机位置/索引修改元素/节点的效率。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索LinkedList底层实现</title>
    <link href="http://zlia.tech/2019/09/02/explain-linkedlist-sourcecode/"/>
    <id>http://zlia.tech/2019/09/02/explain-linkedlist-sourcecode/</id>
    <published>2019-09-02T06:59:49.000Z</published>
    <updated>2019-09-02T07:04:07.272Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>老样子，还是先看注释！本来以为能收获点什么干货，结果注释与<code>ArrayList</code>的注释基本相同，有点尴尬…LinkedList的源码是基于<code>JDK1.8</code>。</p><h3 id="开干"><a href="#开干" class="headerlink" title="开干"></a><div><span>开干</span></div></h3><p>先上LinkedList类的注释，在深入到类中详细说明属性与方法。</p><a id="more"></a><h4 id="阅读注释"><a href="#阅读注释" class="headerlink" title="阅读注释"></a>阅读注释</h4><p class="customize-img"><img src="/assets/blogImg/java/linkedlist/linkedlist-comment-1.png" alt="LinkedList注释-1"></p><p class="customize-img"><img src="/assets/blogImg/java/linkedlist/linkedlist-comment-2.png" alt="LinkedList注释-2"></p><p>它的意思是：通过索引来操作LinkedList的话，每次都需要从头或从尾开始一个一个遍历，直到遇到指定的索引。</p><p class="customize-img"><img src="/assets/blogImg/java/linkedlist/linkedlist-comment-3.png" alt="LinkedList注释-3"></p><p>也是非线程安全，所以在多线程环境下要在外部控制同步防止数据紊乱。</p><p class="customize-img"><img src="/assets/blogImg/java/linkedlist/linkedlist-comment-4.png" alt="LinkedList注释-4"></p><p>不多说了。</p><p class="customize-img"><img src="/assets/blogImg/java/linkedlist/linkedlist-comment-5.png" alt="LinkedList注释-5"></p><p>有一个点要注意下，获取迭代器后，不能在直接通过对象调用方法去修改结构，只能通过迭代器去调用，否则将会抛出异常。</p><p class="customize-img"><img src="/assets/blogImg/java/linkedlist/linkedlist-comment-6.png" alt="LinkedList注释-6"></p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>接下来将详细说明LinkedList类的属性与方法，在这之前，先通过一张图简单了解下它的数据结构。</p><p class="customize-img"><img src="/assets/blogImg/java/linkedlist/linkedlist-data-structure.png" alt="LinkedList注释-6"></p><p>很简单的一张图，每一个节点都保存了当前节点的信息，同时又关联了下一个节点与上一个节点。若要获取指定节点信息，那么只能通过这种关联关系来找到具体节点，这也奠定了它<code>查找</code>的速度相对于<code>ArrayList</code>来说要慢很多，但也是由于有这层关系，<code>添加/删除</code>的速度相对于<code>ArrayList</code>来说要更快，<code>毕竟它只需要更改当前节点关联的上下节点关系即可，而ArrayList需要移动一波元素</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//支持克隆、序列化、双端队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//链表的容量大小，意指包含多少个节点</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//链表的第一个节点，也就是首部节点</span></span><br><span class="line">    <span class="comment">//链表中的每一个节点都保存着当前节点的信息、上一个节点的地址、下一个节点的地址</span></span><br><span class="line">    <span class="comment">//首部节点的上一个节点指向null</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//链表的最后一个节点，也就是尾部节点</span></span><br><span class="line">    <span class="comment">//尾部节点的下一个节点指向null</span></span><br><span class="line">    <span class="comment">//有了首部节点为什么还要有个尾部节点呢，个人理解是为了方便遍历计算</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinkedList的底层是通过链表实现的，并不需要提供成员属性来预先开辟内存空间以便后续的存储节点，所以<code>它充分利用了内存空间，实现灵活的内存管理</code>，不存在什么扩容机制。也正因为此，它并未提供有入参initCapacity的构造函数，在实现上看起来比ArrayList更简单。</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空参数构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个包含指定集合的链表</span></span><br><span class="line"><span class="comment"> * 指定集合中的节点按照迭代器的顺序依次添加到链表的尾部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉上确实比ArrayList简单多了，不用考虑那么多，直接new一个对象即可。</p><h4 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h4><p>接下来按照类的声明顺序介绍<code>方法</code>，有必要的情况下结合例子进行说明。</p><h5 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定节点到首部</span></span><br><span class="line"><span class="comment"> * 指定节点作为首部节点，它的上一个节点指向null</span></span><br><span class="line"><span class="comment"> * 若是空链表，当添加指定节点时首部节点与尾部节点指向同一个节点，即指定节点</span></span><br><span class="line"><span class="comment"> * 若不是空链表，则将原先的首部节点的上一个节点指向指定节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定节点到尾部</span></span><br><span class="line"><span class="comment"> * 指定节点作为尾部节点，它的下一个节点指向null</span></span><br><span class="line"><span class="comment"> * 若是空链表，当添加指定节点时首部节点与尾部节点指向同一个节点，即指定节点</span></span><br><span class="line"><span class="comment"> * 若不是空链表，则将原先的尾部节点的下一个节点指向指定节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定节点到指定节点succ前</span></span><br><span class="line"><span class="comment"> * 在添加节点时，更换对应上下节点的指向地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 添加的指定节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> succ 指定节点处</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除首部节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> f 首部节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除尾部节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> l 尾部节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> E element = l.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除指定节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 指定节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定节点的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否包含指定信息</span></span><br><span class="line"><span class="comment"> * 一个节点一个节点的判断是否与指定信息相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正向遍历的方式获取指定信息的位置</span></span><br><span class="line"><span class="comment"> * 由于是链表的数据结构，每个节点只知道自己的信息与上下两个节点，所以每次查找时都只能从头/尾开始遍历</span></span><br><span class="line"><span class="comment"> * 相当于是一个人一个人的问，直到问到自己想要的人</span></span><br><span class="line"><span class="comment"> * 若未找到指定节点则返回-1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> 0 指定信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定信息的位置或-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取节点个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空所有节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">        Node&lt;E&gt; next = x.next;</span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">    first = last = <span class="keyword">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断指定位置是否越界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否越界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断指定位置是否合法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否合法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取指定位置越界或不合法的信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">outOfBoundsMsg</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Index: "</span>+index+<span class="string">", Size: "</span>+size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 校验指定位置是否越界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isElementIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 校验指定位置是否合法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取指定位置的节点</span></span><br><span class="line"><span class="comment"> * 先判断指定位置处于0-mid-size的哪个区间，避免从头遍历消耗不必要的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反向遍历的方式获取指定信息的位置</span></span><br><span class="line"><span class="comment"> * 由于是链表的数据结构，每个节点只知道自己的信息与上下两个节点，所以每次查找时都只能从头/尾开始遍历</span></span><br><span class="line"><span class="comment"> * 相当于是一个人一个人的问，直到问到自己想要的人</span></span><br><span class="line"><span class="comment"> * 若未找到指定节点则返回-1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> 0 指定信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定信息的位置或-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = size;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储每个节点的信息及指向上下节点的地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当前节点的信息</span></span><br><span class="line">    E item;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前节点的下一个节点</span></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前节点的上一个节点</span></span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prev 当前节点的上一个节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element 当前节点的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> next 当前节点的下一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用该clone之前，该类要实现Cloneable，不然会抛出异常</span></span><br><span class="line"><span class="comment"> * 浅拷贝与深拷贝，举个例子吧</span></span><br><span class="line"><span class="comment"> * 比如A类中包含基本类型与B类，当调用A类clone方法后，两个A对象肯定是不一致，不然就不叫做拷贝了，不过这不是关键</span></span><br><span class="line"><span class="comment"> * 若A1对象中的B对象与A2对象中的B对象指向同一个对象，则认为它是浅拷贝，认为B没有被拷贝新的一份</span></span><br><span class="line"><span class="comment"> * 若两者指向不相等的话，则认为深拷贝，认为B重新拷贝了一份，不过这通常需要我们自定义代码，就像下面的方法一样</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 克隆后的新对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> LinkedList&lt;E&gt; <span class="title">superClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (LinkedList&lt;E&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;E&gt; clone = superClone();</span><br><span class="line"></span><br><span class="line">    clone.first = clone.last = <span class="keyword">null</span>;</span><br><span class="line">    clone.size = <span class="number">0</span>;</span><br><span class="line">    clone.modCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        clone.add(x.item);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造新数组，存放链表中的所有节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有节点信息的新数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    Object[] result = <span class="keyword">new</span> Object[size];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        result[i++] = x.item;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将链表中的所有节点信息放入到指定数组中并返回</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 一开始我也好奇为啥要在索引为size上设置个null呢？</span></span><br><span class="line"><span class="comment"> * 看了注释加上自我的理解，若传入的新数组是个空数组的话，那么除了拷贝列表元素后剩余的所有空间的值都为null，此时在给索引为size的值设置成null似乎没有多大</span></span><br><span class="line"><span class="comment"> * 意思；另外一种情况是若传入的新数组不是个空数组，那这个设置就有意义了，传入的新数组的某些元素会被列表元素覆盖，同时有个null，剩下的才是自己本身的数据，呈现这样子一种效果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment"> * list.add(11);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Integer[] str = new Integer[]&#123;1,2,3,4,5,6,7,8,9,10&#125;;</span></span><br><span class="line"><span class="comment"> * Integer[] s1 = list.toArray(str);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * for (Integer s : s1) &#123;</span></span><br><span class="line"><span class="comment"> *     System.out.println(s + ",");</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输出结果：11,null,3,4,5,6,7,8,9,10,</span></span><br><span class="line"><span class="comment"> * 那么设置这个null的意义就在于能够确定列表中元素个数（长度），但有个前提就是调用者知道链表中的所有节点信息不存在null才有意义，目前我只有想到这一种情况下有用！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 指定数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 填充完链表所有节点信息的指定数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        a = (T[])java.lang.reflect.Array.newInstance(</span><br><span class="line">                            a.getClass().getComponentType(), size);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    Object[] result = a;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        result[i++] = x.item;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义序列化</span></span><br><span class="line"><span class="comment"> * 每个节点当中保存的上下节点的关联关系对于序列化来说可有可无，只要你按次序保存好每个节点的信息，反序列化后依然可以构造出这些关联关系</span></span><br><span class="line"><span class="comment"> * 默认的序列化机制会将非静态与非瞬时（非transient修饰）写入流中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 输出流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        s.writeObject(x.item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义反序列化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 输入流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = s.readInt();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        linkLast((E)s.readObject());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取分割迭代器</span></span><br><span class="line"><span class="comment"> * 分割迭代器的方法作用都是类似的，不同的地方在于算法的实现上，所以不在做重复的分析，可参考另外一篇文章的详细介绍</span></span><br><span class="line"><span class="comment"> * 附上文章地址：http://zlia.tech/2019/08/28/explain-arraylist-spliterator-sourcecode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LLSpliterator&lt;E&gt;(<span class="keyword">this</span>, -<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很多方法都没有过多的说明，是因为可能涉及到算法或者只要简单画一画就能理解了！</p><h5 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取首部节点信息</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 首部节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取尾部节点信息</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 尾部节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取指定位置的信息</span></span><br><span class="line"><span class="comment"> * 校验位置是否越界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定位置的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取首部节点信息</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会返回null</span></span><br><span class="line"><span class="comment"> * 该方法比getFirst更友好</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 首部节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取首部节点信息</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 首部节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取首部节点信息</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会返回null</span></span><br><span class="line"><span class="comment"> * 该方法比getFirst更友好</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 首部节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取尾部节点信息</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会返回null</span></span><br><span class="line"><span class="comment"> * 该方法比getLast更友好</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 首部节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="移除节点"><a href="#移除节点" class="headerlink" title="移除节点"></a>移除节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除首部节点</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 首部节点的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除尾部节点</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 尾部节点的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除指定信息</span></span><br><span class="line"><span class="comment"> * 由于是链表的数据结构，每个节点只知道自己的信息与上下两个节点，所以每次查找时都只能从头开始遍历</span></span><br><span class="line"><span class="comment"> * 相当于是一个人一个人的问，直到问到自己想要的人</span></span><br><span class="line"><span class="comment"> * 若未找到指定节点则返回false</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除指定位置的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除首部节点，相当于队列取出元素</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会返回null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除首部节点</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 首部节点的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除首部节点，相当于队列取出元素</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会返回null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除尾部节点，相当于队列取出元素</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会返回null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正向遍历，删除指定节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否删除指定节点信息成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeFirstOccurrence</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remove(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反向遍历，删除指定节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否删除指定节点信息成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeLastOccurrence</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定信息到首部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定信息到尾部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定信息到尾部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定集合信息到尾部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在指定位置添加指定集合信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        succ = <span class="keyword">null</span>;</span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size += numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定节点信息到指定位置上</span></span><br><span class="line"><span class="comment"> * 在添加过程中只需要修改旧节点的上下节点关联关系即可，可以说效率提升了很多</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 指定节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定节点信息到尾部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定节点信息到首部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定节点信息到尾部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="修改节点"><a href="#修改节点" class="headerlink" title="修改节点"></a>修改节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改指定位置的节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 指定节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含指定位置开始到结尾之间的节点的正向迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含指定位置到结尾之间的节点的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 列表迭代器，正向迭代</span></span><br><span class="line"><span class="comment"> * 可获取上一个元素、下一个元素及位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指向当前节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; lastReturned;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指向上/下一个节点，随着调用方法的不同指向便不同</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上/下一个节点的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nextIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每次调用迭代器中的方法时，都会判断是否调用了LinkedList的外部方法去修改结构列表，如此的操作通常会造成快速失败</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化参数，设置下一个节点及下一个节点的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 当前位置，调用迭代器中的方法时该位置对应的节点信息是第一个获取到的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="comment">// assert isPositionIndex(index);</span></span><br><span class="line">        next = (index == size) ? <span class="keyword">null</span> : node(index);</span><br><span class="line">        nextIndex = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否有下一个节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否有下一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex &lt; size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个节点的信息</span></span><br><span class="line"><span class="comment">     * 初始化时的入参index对应的节点作为开始</span></span><br><span class="line"><span class="comment">     * 在获取下一个节点信息前，会判断是否造成了快速失败</span></span><br><span class="line"><span class="comment">     * 在获取完下一个节点后，将其指向赋值給lastReturned，同时修改next指向下一个节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个节点的信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">if</span> (!hasNext())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">        lastReturned = next;</span><br><span class="line">        next = next.next;</span><br><span class="line">        nextIndex++;</span><br><span class="line">        <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否有上一个节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否有上一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取上一个节点的信息</span></span><br><span class="line"><span class="comment">     * 初始化时的入参index对应的节点的上一个节点作为开始</span></span><br><span class="line"><span class="comment">     * 在获取下一个节点信息前，会判断是否造成了快速失败</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 上一个节点的信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">if</span> (!hasPrevious())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">        lastReturned = next = (next == <span class="keyword">null</span>) ? last : next.prev;</span><br><span class="line">        nextIndex--;</span><br><span class="line">        <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个节点的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个节点的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取上一个节点的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 上一个节点的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除当前节点，也就是lastReturned指向的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line"></span><br><span class="line">        Node&lt;E&gt; lastNext = lastReturned.next;</span><br><span class="line">        unlink(lastReturned);</span><br><span class="line">        <span class="keyword">if</span> (next == lastReturned)</span><br><span class="line">            next = lastNext;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nextIndex--;</span><br><span class="line">        lastReturned = <span class="keyword">null</span>;</span><br><span class="line">        expectedModCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将当前节点的信息修改成指定信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 指定信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line">        lastReturned.item = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在下一个节点前添加指定节点</span></span><br><span class="line"><span class="comment">     * 若下一个节点指向null，也就是说当前节点已经是尾部节点了，在将指定节点添加到尾部</span></span><br><span class="line"><span class="comment">     * 若下一个节点指向不为null，则在下一个节点前添加指定节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 指定节点信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        lastReturned = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">            linkLast(e);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            linkBefore(e, next);</span><br><span class="line">        nextIndex++;</span><br><span class="line">        expectedModCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正向遍历链表的剩余节点，对每一个节点执行指定的动作</span></span><br><span class="line"><span class="comment">     * 对于每个迭代器，除非剩余节点未遍历完毕，否则该方法只能执行一次，因为随着遍历nextIndex的次数在增加</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> action 对每一个节点执行指定的动作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">while</span> (modCount == expectedModCount &amp;&amp; nextIndex &lt; size) &#123;</span><br><span class="line">            action.accept(next.item);</span><br><span class="line">            lastReturned = next;</span><br><span class="line">            next = next.next;</span><br><span class="line">            nextIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        checkForComodification();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化时 modCount 与 expectedModCount 是相等的</span></span><br><span class="line"><span class="comment">     * 但如果在遍历的过程修改数组结构的话，此时 modCount 会有所变化，导致两者不相等，故而抛出异常，也就是我们上面提到的fast-failed异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取反向迭代器，尾部节点作为开始</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 以尾部节点作为开始的反向迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DescendingIterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 列表迭代器，反向迭代</span></span><br><span class="line"><span class="comment"> * 实际上都是采用ListItr类中的方法，只不过包装了一层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DescendingIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ListItr itr = <span class="keyword">new</span> ListItr(size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从反向的角度来看，判断是否有下一个节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否有下一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> itr.hasPrevious();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从反向的角度来看，获取下一个节点信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个节点信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> itr.previous();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从反向的角度来看，移除当前节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        itr.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>队列中的方法简单说明下：</li></ul><p>peek、peekFirst、elements方法都是<code>获取首部节点</code>，但若是空链表的话，前两者不会抛出异常（返回null），最后一个会。</p><p>peekLast方法是<code>获取尾部节点</code>。</p><p>poll、pollFirst、remove、pop方法都是<code>删除并首部节点</code>，但若是空链表的话，前两者不会抛出异常（返回null），后两者会。</p><p>pollLast方法是<code>删除并获取尾部节点</code>。</p><p>offer与offerLast方法都是<code>添加指定节点到尾部</code>，没啥区别。</p><p>offerFirst、push方法是<code>添加指定节点到首部</code>，两者的区别在于有无返回值。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>LinkedList允许存放Null。</p></li><li><p>LinkedList内部通过链表实现，属于非线程安全。</p></li><li><p>LinkedList充分利用了内存空间，不存在扩容机制。</p></li><li><p>ArrayList具有<code>iterator</code>与<code>listIterator</code>，虽然LinkedList也有这两个方法，但实际上这两个方法的内部实现都是调用的<code>listIterator</code>。</p></li><li><p>在遍历过程中不允许修改结构，否则会抛出错误。</p></li><li><p>LinkedList实现了队列。</p></li></ul><h4 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a>重点关注</h4><p><code>底层是通过链表实现，有序可重复</code> <code>充分利用内存空间</code> </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;老样子，还是先看注释！本来以为能收获点什么干货，结果注释与&lt;code&gt;ArrayList&lt;/code&gt;的注释基本相同，有点尴尬…LinkedList的源码是基于&lt;code&gt;JDK1.8&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;开干&quot;&gt;&lt;a href=&quot;#开干&quot; class=&quot;headerlink&quot; title=&quot;开干&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;开干&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;先上LinkedList类的注释，在深入到类中详细说明属性与方法。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索ArrayListSpliterator底层实现</title>
    <link href="http://zlia.tech/2019/08/28/explain-arraylist-spliterator-sourcecode/"/>
    <id>http://zlia.tech/2019/08/28/explain-arraylist-spliterator-sourcecode/</id>
    <published>2019-08-28T09:53:49.000Z</published>
    <updated>2019-08-28T09:57:06.629Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>上次看ArrayList底层机制时把<code>ArrayListSpliterator</code>放了放，现在回过头来具体看看实现。</p><h3 id="简单粗暴"><a href="#简单粗暴" class="headerlink" title="简单粗暴"></a><div><span>简单粗暴</span></div></h3><p>直接上代码吧！</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListSpliterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指向当前集合对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;E&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前索引，可能被trySplit和tryAdvance操作修改</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结束索引，未使用前为-1，使用后为list的size</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> fence;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过与modCount比较来判断集合是否被修改，初始值与modCount相等</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expectedModCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list 当前集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> origin 起始索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fence 结束索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expectedModCount </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ArrayListSpliterator(ArrayList&lt;E&gt; list, <span class="keyword">int</span> origin, <span class="keyword">int</span> fence,</span><br><span class="line">                         <span class="keyword">int</span> expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list; <span class="comment">// OK if null unless traversed</span></span><br><span class="line">        <span class="keyword">this</span>.index = origin;</span><br><span class="line">        <span class="keyword">this</span>.fence = fence;</span><br><span class="line">        <span class="keyword">this</span>.expectedModCount = expectedModCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取结束索引</span></span><br><span class="line"><span class="comment">     * 初始化expectedModCount与fence参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 结束索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getFence</span><span class="params">()</span> </span>&#123; <span class="comment">// initialize fence to size on first use</span></span><br><span class="line">        <span class="keyword">int</span> hi; <span class="comment">// (a specialized variant appears in method forEach)</span></span><br><span class="line">        ArrayList&lt;E&gt; lst;</span><br><span class="line">        <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((lst = list) == <span class="keyword">null</span>)</span><br><span class="line">                hi = fence = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                expectedModCount = lst.modCount;</span><br><span class="line">                hi = fence = lst.size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在当前切割迭代器的基础上再次拆分一个新的迭代器</span></span><br><span class="line"><span class="comment">     * 若切割迭代器是可以拆分的，会返回新的一个切割迭代器，两个迭代器平分原先迭代器中的元素</span></span><br><span class="line"><span class="comment">     * 若切割迭代器无法拆分的话，则返回null</span></span><br><span class="line"><span class="comment">     * 拆分后原先迭代器必须修改起始索引，因为它的元素被拆分了（index = mid）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新的切割迭代器或null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayListSpliterator&lt;E&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (lo &gt;= mid) ? <span class="keyword">null</span> : <span class="comment">// divide range in half unless too small</span></span><br><span class="line">            <span class="keyword">new</span> ArrayListSpliterator&lt;E&gt;(list, lo, index = mid,</span><br><span class="line">                                        expectedModCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 若存在剩余元素，则对其下一个元素执行指定动作，并返回true</span></span><br><span class="line"><span class="comment">     * 若不存在剩余元素，则返回false</span></span><br><span class="line"><span class="comment">     * 该方法是对单独元素进行操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> action 若存在剩余元素，执行指定动作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否存在剩余元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hi = getFence(), i = index;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; hi) &#123;</span><br><span class="line">            index = i + <span class="number">1</span>;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E)list.elementData[i];</span><br><span class="line">            action.accept(e);</span><br><span class="line">            <span class="keyword">if</span> (list.modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历剩余元素，并执行指定动作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> action 若存在剩余元素，执行指定动作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, hi, mc; <span class="comment">// hoist accesses and checks from loop</span></span><br><span class="line">        ArrayList&lt;E&gt; lst; Object[] a;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> ((lst = list) != <span class="keyword">null</span> &amp;&amp; (a = lst.elementData) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                mc = lst.modCount;</span><br><span class="line">                hi = lst.size;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mc = expectedModCount;</span><br><span class="line">            <span class="keyword">if</span> ((i = index) &gt;= <span class="number">0</span> &amp;&amp; (index = hi) &lt;= a.length) &#123;</span><br><span class="line">                <span class="keyword">for</span> (; i &lt; hi; ++i) &#123;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) a[i];</span><br><span class="line">                    action.accept(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (lst.modCount == mc)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取切割迭代器的元素个数</span></span><br><span class="line"><span class="comment">     * 计算结束索引与起始索引之间的元素个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 切割迭代器的元素个数 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">estimateSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">long</span>) (getFence() - index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取切割迭代器的特征值</span></span><br><span class="line"><span class="comment">     * ArrayList底层实现是数组，故是有序、有实际大小、可重复、可存入null、属于非线程安全、在遍历时可添加修改替换元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>分割迭代器可以单个(tryAdvance)或顺序（多个）遍历元素.</p></li><li><p>分割迭代器可拆分成若干个小型的分割迭代器来并行操作元素.</p></li><li><p>分割迭代器属于非线程安全.</p></li><li><p>ArrayListSpliterator属于后期绑定与快速失败的分割迭代器.</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;上次看ArrayList底层机制时把&lt;code&gt;ArrayListSpliterator&lt;/code&gt;放了放，现在回过头来具体看看实现。&lt;/p&gt;
&lt;h3 id=&quot;简单粗暴&quot;&gt;&lt;a href=&quot;#简单粗暴&quot; class=&quot;headerlink&quot; title=&quot;简单粗暴&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;简单粗暴&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;直接上代码吧！&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索Vector的底层实现</title>
    <link href="http://zlia.tech/2019/08/21/explain-vector-sourcecode/"/>
    <id>http://zlia.tech/2019/08/21/explain-vector-sourcecode/</id>
    <published>2019-08-21T10:06:56.000Z</published>
    <updated>2019-09-06T06:09:18.565Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a><div><span>背景</span></div></h3><p>上周发布了<a href="http://zlia.tech/2019/08/16/explain-arraylist-sourcecode/">探索ArrayList的底层实现</a>，趁热打铁！实际上<code>ArrayList</code>与<code>Vector</code>的实现上非常相似，代码基本上都是一样的，还是老样子，先看注释，我能说注释都差不多一样吗。探索<code>Vector</code>源代码是基于<code>JDK1.8</code>的。</p><h4 id="阅读注释"><a href="#阅读注释" class="headerlink" title="阅读注释"></a>阅读注释</h4><p class="customize-img"><img src="/assets/blogImg/java/vector/vector-comment-1.png" alt="Vector注释-1"></p><p>Vector内部是通过动态数组实现的。</p><a id="more"></a><p class="customize-img"><img src="/assets/blogImg/java/vector/vector-comment-2.png" alt="Vector注释-2"></p><p>Vector可自定义扩容的大小，<code>若没有指定则默认翻倍，即2倍关系（100%），ArrayList默认是1.5倍关系（50%）</code></p><p class="customize-img"><img src="/assets/blogImg/java/vector/vector-comment-3.png" alt="Vector注释-3"></p><p>截图中应该讲的挺明白了！</p><p class="customize-img"><img src="/assets/blogImg/java/vector/vector-comment-4.png" alt="Vector注释-4"></p><p>又是快速失败！</p><p class="customize-img"><img src="/assets/blogImg/java/vector/vector-comment-5.png" alt="Vector注释-5"></p><p>需要线程安全的情况下使用Vector，不需要则推荐使用ArrayList。</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//支持序列化、可克隆、随机访问</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储元素的数组缓冲区</span></span><br><span class="line">    <span class="comment">//Vector的容量大小就是数组缓冲区的长度大小</span></span><br><span class="line">    <span class="comment">//Vector中排在最后一个元素后面的元素内容都是null，实际上指的是数组长度过大，未存满内容</span></span><br><span class="line">    <span class="keyword">protected</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组中实际元素的个数，指的是包含多少元素，称作有效元素</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> elementCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当容量不足时，指定容量需要扩充的大小</span></span><br><span class="line">    <span class="comment">//若该值小于或等于0，则当容量不足时采用翻倍的方式扩充大小</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> capacityIncrement;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们都知道定义一个数组的大小是 int 类型，那么也就意味着最大的数组大小应该是Integer.MAX_VALUE，但是这里为啥要减去8呢？</span></span><br><span class="line">    <span class="comment">//查阅资源发现大部分的人都在说8个字节是用来存储数组的大小，半信半疑</span></span><br><span class="line">    <span class="comment">//分配最大数组，某些VM会在数组中存储header word，按照上面的说法指的应该是数组的大小</span></span><br><span class="line">    <span class="comment">//若尝试去分配更大的数组可能会造成 OutOfMemoryError: 定义的数组大小超过VM上限</span></span><br><span class="line">    <span class="comment">//不同的操作系统对于不同的JDK可能分配的内存会有所差异，所以8这个数字可能是为了保险起见</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Vector结构被修改的次数</span></span><br><span class="line">    <span class="comment">//该字段主要针对迭代器与子集使用，若该属性被出乎意料的改变了，调用迭代器的相关方法，如 next、 remove、previous、set、add</span></span><br><span class="line">    <span class="comment">//则会抛出 ConcurrentModificationException常，该情况其实就是上面提到的fail-fast</span></span><br><span class="line">    <span class="comment">//严格上来说，该字段并不算是结构被修改的次数，在判断是否需要扩容时，它是首先进行增加在判断，不过这不影响，该字段仅用来判断是否与其他字段相等</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个指定初始容量大小与指定容量增长速率的空数组</span></span><br><span class="line"><span class="comment"> * 若initialCapacity小于0，则抛出参数异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 初始容量大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacityIncrement 当容量不足时，容量扩充的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个指定初始容量大小的空数组</span></span><br><span class="line"><span class="comment"> * 由于未指定容量增长速率，故而采用翻倍的机制</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 初始容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个初始容量为10的空数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建一个包含指定collection集合的数组，这些元素按照迭代器的顺序排列</span></span><br><span class="line"><span class="comment"> * collection集合类型有Map、set、List等子类，所以入参可以是多种类型</span></span><br><span class="line"><span class="comment"> * collection集合转换成数组，elementData指向该数组，elementCount成员属性被赋值为collection集合长度</span></span><br><span class="line"><span class="comment"> * 判断数组类型是否是Ojbect[],若不是则创建一个新的数组，并拷贝elementData数组中的内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    elementCount = elementData.length;</span><br><span class="line">    <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">        elementData = Arrays.copyOf(elementData, elementCount, Object[].class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>若已经提前知道数组容量，则建议使用new Vector(initialCapacity)</p></li><li><p>若不知道数组容量的话，那就没办法了</p></li><li><p>Vector(Collection c)一般是在包含关系的情况下使用</p></li></ul><h4 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h4><p>接下来按照类的声明顺序介绍<code>方法</code>，有必要的情况下结合例子进行说明。</p><h5 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拷贝数组中的有效元素到指定数组中</span></span><br><span class="line"><span class="comment"> * 指定数组不能为null</span></span><br><span class="line"><span class="comment"> * 指定数组的容量大小不能小于Vector中数组的容量大小</span></span><br><span class="line"><span class="comment"> * 指定数组的类型必须能够存储Vector中数组的元素类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> anArray 指定数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">copyInto</span><span class="params">(Object[] anArray)</span> </span>&#123;</span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, anArray, <span class="number">0</span>, elementCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缩小Vector的容量到当前数组的大小，应用可以调用该方法来最小化Vector的存储空间，简单来说就是节约空间，去掉没有用到的剩余数组空间</span></span><br><span class="line"><span class="comment"> * elementCount 是指数组的有效元素，实实在在的大小，而 elementData.length 是数组的总容量大小，也就是说只有当填充/删除元素时elementCount的大小才会变化</span></span><br><span class="line"><span class="comment"> * 而当进行扩容时 elementData.length 才会变化，毕竟数组的长度变大了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">if</span> (elementCount &lt; oldCapacity) &#123;</span><br><span class="line">        elementData = Arrays.copyOf(elementData, elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定的容量增大或缩小Vector的容量大小</span></span><br><span class="line"><span class="comment"> * 若newSize大于有效元素个数，增大的容量会使用null填充</span></span><br><span class="line"><span class="comment"> * 若newSize小于有效元素个数，以newSize为起始索引到结尾的元素都被置为null导致元素丢失，容量保持不变</span></span><br><span class="line"><span class="comment"> * 最后将 elementCount = newSize，导致在增大容量的情况下会出现null</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 若 elementData.length &gt; newSize &gt; elementCount，</span></span><br><span class="line"><span class="comment"> * 若 newSize &gt; elementData.length，Vector容量扩大，多余空间置null</span></span><br><span class="line"><span class="comment"> * 若 elementData.length &gt; elementCount &gt; newSize，则缩小Vector容量，导致元素丢失，容量保持不变</span></span><br><span class="line"><span class="comment"> * 不管大小如何，Vector的有效元素个数都变成 newSize，可能出现null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newSize 指定容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> newSize)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (newSize &gt; elementCount) &#123;</span><br><span class="line">        ensureCapacityHelper(newSize);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize ; i &lt; elementCount ; i++) &#123;</span><br><span class="line">            elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    elementCount = newSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组的容量大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> elementData.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组的有效元素个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组有效元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> elementCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断数组是否为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组是否为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> elementCount == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断数组是否包含指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o, <span class="number">0</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 采用正向遍历的方式，获取与指定元素相等的元素的索引</span></span><br><span class="line"><span class="comment"> * 若存在多个元素，取第一次与指定元素相等的元素的索引</span></span><br><span class="line"><span class="comment"> * 若返回-1则说明不存在指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 与指定元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 采用正向遍历的方式，根据指定起始索引开始，获取与指定元素相等的元素的索引</span></span><br><span class="line"><span class="comment"> * 若存在多个元素，取第一次与指定元素相等的元素的索引</span></span><br><span class="line"><span class="comment"> * 若不存在则返回-1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 与指定元素相等的元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index ; i &lt; elementCount ; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index ; i &lt; elementCount ; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 采用反向遍历的方式，获取与指定元素相等的元素的索引</span></span><br><span class="line"><span class="comment"> * 若存在多个元素，取第一次与指定元素相等的元素的索引</span></span><br><span class="line"><span class="comment"> * 若不存在则返回-1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 与指定元素相等的元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lastIndexOf(o, elementCount-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 采用反向遍历的方式，根据指定起始索引开始，获取与指定元素相等的元素的索引</span></span><br><span class="line"><span class="comment"> * 若存在多个元素，取第一次与指定元素相等的元素的索引</span></span><br><span class="line"><span class="comment"> * 若不存在则返回-1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 与指定元素相等的元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(index + <span class="string">" &gt;= "</span>+ elementCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用该clone之前，该类要实现Cloneable，不然会抛出异常</span></span><br><span class="line"><span class="comment"> * 数组默认已经实现了Cloneable接口，直接调用方法即可，而且直接返回对应的类型，不需要向下转型，同时包含数组元素</span></span><br><span class="line"><span class="comment"> * 浅拷贝与深拷贝，举个例子吧</span></span><br><span class="line"><span class="comment"> * 比如A类中包含基本类型与B类，当调用A类clone方法后，两个A对象肯定是不一致，不然就不叫做拷贝了，不过这不是关键</span></span><br><span class="line"><span class="comment"> * 若A1对象中的B对象与A2对象中的B对象指向同一个对象，则认为它是浅拷贝，认为B没有被拷贝新的一份</span></span><br><span class="line"><span class="comment"> * 若两者指向不相等的话，则认为深拷贝，认为B重新拷贝了一份，不过这通常需要我们自定义代码，就像下面的方法一样</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Vector&lt;E&gt; v = (Vector&lt;E&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, elementCount);</span><br><span class="line">        v.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个包含所有列表元素的有序（按照添加顺序）数组</span></span><br><span class="line"><span class="comment"> * 此方法是创建一个新数组，方便使用者能够随便操作新数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, elementCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将列表的所有元素放入到指定数组中并返回</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：T类型要么是数组中数据的相同类型，要么是数组中数据的父类型，运用多态性质</span></span><br><span class="line"><span class="comment"> * 若传入的新数组容量 &lt; 列表容量，则取它的类类型来创建一个包含列表元素的新数组，并返回</span></span><br><span class="line"><span class="comment"> * 若传入的新数组容量 &gt; 列表容量，则将列表中的元素按照顺序拷贝到新数组中，同时将新数组中索引为size的值设置成null</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 一开始我也好奇为啥要在索引为size上设置个null呢？</span></span><br><span class="line"><span class="comment"> * 看了注释加上自我的理解，若传入的新数组是个空数组的话，那么除了拷贝列表元素后剩余的所有空间的值都为null，此时在给索引为size的值设置成null似乎没有多大</span></span><br><span class="line"><span class="comment"> * 意思；另外一种情况是若传入的新数组不是个空数组，那这个设置就有意义了，传入的新数组的某些元素会被列表元素覆盖，同时有个null，剩下的才是自己本身的数据，呈现这样子一种效果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment"> * list.add(11);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Integer[] str = new Integer[]&#123;1,2,3,4,5,6,7,8,9,10&#125;;</span></span><br><span class="line"><span class="comment"> * Integer[] s1 = list.toArray(str);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * for (Integer s : s1) &#123;</span></span><br><span class="line"><span class="comment"> *     System.out.println(s + ",");</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输出结果：11,null,3,4,5,6,7,8,9,10,</span></span><br><span class="line"><span class="comment"> * 那么设置这个null的意义就在于能够确定列表中元素个数（长度），目前我只有想到这一种情况下有用！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 指定数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 填充完列表元素的指定数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; elementCount)</span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, elementCount, a.getClass());</span><br><span class="line"></span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, elementCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; elementCount)</span><br><span class="line">        a[elementCount] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组中指定索引中的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定索引的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    removeAllElements();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断数组中是否包含指定集合中的所有元素</span></span><br><span class="line"><span class="comment"> * 但凡集合中有一个元素不存在数组中则返回false</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组中是否包含指定集合中的所有元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.containsAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集合与数组取交集</span></span><br><span class="line"><span class="comment"> * 最终数组中只包含与集合共有的元素，相当于在修改数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组元素是否被修改成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.retainAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先判断当前对象与指定对象是否指向同一个对象，就是在判断地址</span></span><br><span class="line"><span class="comment"> * 紧接着判断指定对象属于List的子类</span></span><br><span class="line"><span class="comment"> * 紧接着获取两个对象的迭代器</span></span><br><span class="line"><span class="comment"> * 若两个迭代器的元素个数不相等，则返回false</span></span><br><span class="line"><span class="comment"> * 若两个迭代器的元素个数相等，则将两个迭代器的元素进行对应的比较，但凡出现对应的元素不相等则返回false</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 当前对象与指定对象是否相等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> List))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    ListIterator&lt;E&gt; e1 = listIterator();</span><br><span class="line">    ListIterator&lt;?&gt; e2 = ((List&lt;?&gt;) o).listIterator();</span><br><span class="line">    <span class="keyword">while</span> (e1.hasNext() &amp;&amp; e2.hasNext()) &#123;</span><br><span class="line">        E o1 = e1.next();</span><br><span class="line">        Object o2 = e2.next();</span><br><span class="line">        <span class="keyword">if</span> (!(o1==<span class="keyword">null</span> ? o2==<span class="keyword">null</span> : o1.equals(o2)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !(e1.hasNext() || e2.hasNext());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.hashCode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组元素的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组元素的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取指定起始索引到指定结束索引之间的元素，简称获取指定子集</span></span><br><span class="line"><span class="comment"> * 指定区间中的元素包括起始索引，不包括结束索引</span></span><br><span class="line"><span class="comment"> * 若起始索引与结束索引相等，则返回空元素</span></span><br><span class="line"><span class="comment"> * 对子集的操作，即调用set、add、remove等方法将会影响到整个数组</span></span><br><span class="line"><span class="comment"> * 但在先获取子集后，又对整个数组的结构进行修改，这时在遍历子集则会导致报错，而对于整体的非结构性修改则不会报错，不过依然会影响到子集</span></span><br><span class="line"><span class="comment"> * 所以在获取子集后最好不要修改数组的结构</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 所有跟子集有关的方法和说明，可以参考ArrayList，基本上相似，除了在方法上加上Synchronized(this)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromIndex 起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toIndex 结束索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定区间中的所有元素，称为子集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.synchronizedList(<span class="keyword">super</span>.subList(fromIndex, toIndex), <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历数组，并对数组中的元素进行指定处理</span></span><br><span class="line"><span class="comment"> * 在遍历过程中不允许修改结构，否则会抛出错误</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action 函数式接口，对数组中的元素指定处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">final</span> E[] elementData = (E[]) <span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> elementCount = <span class="keyword">this</span>.elementCount;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; elementCount; i++) &#123;</span><br><span class="line">        action.accept(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定条件移除元素</span></span><br><span class="line"><span class="comment"> * 笔者对BitSet也是第一次接触，针对本文章它显的不是很重要，故而大概了解了一下</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 该方法中将满足条件的元素索引存放到BitSet中，同时记录移除元素的个数removeCount</span></span><br><span class="line"><span class="comment"> * 紧接着BitSet调用 nextClearBit方法，该方法根据指定的索引获取没有在BitSet中存放的下一个索引，直接上个例子吧</span></span><br><span class="line"><span class="comment"> * BitSet removeSet = new BitSet();</span></span><br><span class="line"><span class="comment"> * removeSet.set(1)</span></span><br><span class="line"><span class="comment"> * removeSet.set(2)</span></span><br><span class="line"><span class="comment"> * System.out.println(removeSet.nextClearBit(1))  --&gt; 3</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 一开始已经在BitSet中存放了要移除的元素的索引，当调用nextClearBit方法循环遍历获取到的索引就是要保留的元素的索引</span></span><br><span class="line"><span class="comment"> * 故而直接获取元素的值将其存放到数组中，最后的数组是按照保留元素的顺序进行存放的</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 函数式接口中不能调用修改结构的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filter 使用指定条件来过滤元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> E&gt; filter)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(filter);</span><br><span class="line">    <span class="keyword">int</span> removeCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = elementCount;</span><br><span class="line">    <span class="keyword">final</span> BitSet removeSet = <span class="keyword">new</span> BitSet(size);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="keyword">final</span> E element = (E) elementData[i];</span><br><span class="line">        <span class="keyword">if</span> (filter.test(element)) &#123;</span><br><span class="line">            removeSet.set(i);</span><br><span class="line">            removeCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> anyToRemove = removeCount &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (anyToRemove) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> newSize = size - removeCount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) &#123;</span><br><span class="line">            i = removeSet.nextClearBit(i);</span><br><span class="line">            elementData[j] = elementData[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=newSize; k &lt; size; k++) &#123;</span><br><span class="line">            elementData[k] = <span class="keyword">null</span>;  <span class="comment">// Let gc do its work</span></span><br><span class="line">        &#125;</span><br><span class="line">        elementCount = newSize;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> anyToRemove;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定规则替换所有旧元素</span></span><br><span class="line"><span class="comment"> * operator.apply方法：旧元素作为入参传入，根据规则返回新元素，然后进行替换</span></span><br><span class="line"><span class="comment"> * operator.apply方法中不能调用修改结构的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> operator 指定规则，函数式接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(operator);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = elementCount;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        elementData[i] = operator.apply((E) elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定规则对数组中的元素进行排序</span></span><br><span class="line"><span class="comment"> * 若没有指定规则则使用默认的升序进行排序</span></span><br><span class="line"><span class="comment"> * 指定规则后会调用自定义比较器中的compare方法进行比较排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 自定义比较器，覆写compare方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    Arrays.sort((E[]) elementData, <span class="number">0</span>, elementCount, c);</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取分割迭代器</span></span><br><span class="line"><span class="comment"> * 由于该方法涉及到另外一个接口，会另外新起一篇文章来讲解该内容，这里就不做阐述</span></span><br><span class="line"><span class="comment"> * 附上文章地址：http://zlia.tech/2019/08/28/explain-arraylist-spliterator-sourcecode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> VectorSpliterator&lt;&gt;(<span class="keyword">this</span>, <span class="keyword">null</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="自定义容量-扩容机制"><a href="#自定义容量-扩容机制" class="headerlink" title="自定义容量 + 扩容机制"></a>自定义容量 + 扩容机制</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加Vector的容量大小，在必要情况下，入参minCapacity至少要确保能容纳元素的数量</span></span><br><span class="line"><span class="comment"> * 若当前Vector的容量小于minCapacity，会通过替换内部数组来增加容量大小，换句话就是创建更大长度的数组，然后将elementData指向它</span></span><br><span class="line"><span class="comment"> * 若capacityIncrement大于0，则新数组的长度大小等于旧数组长度大小 + capacityIncrement</span></span><br><span class="line"><span class="comment"> * 若capacityIncrement小于或等于0，则新新数组的长度大小等于旧数组长度大小 * 2，也就是翻倍</span></span><br><span class="line"><span class="comment"> * 但若新数组的长度大小仍然小于minCapacity，则最终的数组大小会是minCapacity</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 综上所述:</span></span><br><span class="line"><span class="comment"> * 扩容时，先计算自动扩充的容量大小</span></span><br><span class="line"><span class="comment"> * 若capacityIncrement大于0，则自动扩容的容量大小是 旧数组长度 + capacityIncrement</span></span><br><span class="line"><span class="comment"> * 若capacityIncrement小于或等于0，则自动扩容的容量大小是 旧数组长度 * 2</span></span><br><span class="line"><span class="comment"> * 得到自动扩容的容量大小后，与minCapacity进行比较，取最大值作为新数组的最终长度大小</span></span><br><span class="line"><span class="comment"> * 最终将elementData指向新数组即可</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity 手动扩充的容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        ensureCapacityHelper(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否需要扩容</span></span><br><span class="line"><span class="comment"> * 注意该方法是没有加synchronized关键字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity 手动扩充的容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityHelper</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 首先获取自动扩充的容量大小</span></span><br><span class="line"><span class="comment"> * 若capacityIncrement大于0，则自动扩充的容量大小：旧数组容量大小 + capacityIncrement</span></span><br><span class="line"><span class="comment"> * 若capacityIncrement小于0，则自动扩充的容量大小：旧数组容量大小 * 2</span></span><br><span class="line"><span class="comment"> * 在不考虑capacityIncrement的前提下，两次自动扩容的关系是翻倍，即2倍</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 判断手动扩充的容量是否大于自动扩充的容量</span></span><br><span class="line"><span class="comment"> * 若大于，则自动扩容的容量修改为手动扩充的容量，即 newCapacity = minCapacity，否则newCapacity不变，即采用自动扩充的容量</span></span><br><span class="line"><span class="comment"> * 为了防止内存溢出，扩容并不是无止境的扩充，当大于一个临界点MAX_ARRAY_SIZE时，就不允许在采用自动扩容的容量大小，而是取最大值或临界点</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 参考hugeCapacity方法：</span></span><br><span class="line"><span class="comment"> * 当程序执行到①时，我们可以知道 newCapacity &gt;= minCapacity（指的是赋值之后的关系）</span></span><br><span class="line"><span class="comment"> * 若MAX_ARRAY_SIZE大于newCapacity，则就开始创建长度为newCapacity的新数组，三者的关系为 MAX_ARRAY_SIZE &gt; newCapacity &gt;= minCapacity</span></span><br><span class="line"><span class="comment"> * 若MAX_ARRAY_SIZE小于newCapacity，则进入到hugeCapacity方法，但此时我们不知道minCapacity 与 MAX_ARRAY_SIZE的大小关系</span></span><br><span class="line"><span class="comment"> * 若minCapacity大于MAX_ARRAY_SIZE，则采用最大值，不允许无限制的手动设置扩充容量，不过最大值有可能会出现内存溢出</span></span><br><span class="line"><span class="comment"> * 三者关系为：newCapacity &gt;= minCapacity &gt; MAX_ARRAY_SIZE</span></span><br><span class="line"><span class="comment"> * 若minCapacity小于MAX_ARRAY_SIZE，则采用临界值，该临界值是保证在不同的操作系统下不会发生内存溢出， 三者关系为：newCapacity &gt; MAX_ARRAY_SIZE &gt; minCapacity</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 得出结论：</span></span><br><span class="line"><span class="comment"> * 添加元素时会先到底临界值，此时不会发生内存溢出，若在往上增长则达到最大值，最大值有可能发生内存溢出</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  minCapacity 手动扩充的容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;    --------------------&gt; ① 手动添加</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断入参minCapacity 是否大于 MAX_ARRAY_SIZE</span></span><br><span class="line"><span class="comment"> * 若 minCapacity &gt; MAX_ARRAY_SIZE，则返回值是最大值</span></span><br><span class="line"><span class="comment"> * 若 minCapacity &lt;= MAX_ARRAY_SIZE，则返回值是临界值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  minCapacity 手动扩充的容量大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 容量大小结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>自动扩容机制</code></p><ul><li>先判断capacityIncrement属性，该属性可以在创建Vector时设置，也可以使用默认值0</li><li>若capacityIncrement大于0，则每次自动扩容都以<code>capacityIncrement</code>大小进行增长</li><li>若capacityIncrement小于0，则每次自动扩容都以<code>2倍</code>的关系进行增长</li><li>如果期间手动扩充容量，则会比较手动扩充的容量大小与自动扩充的容量大小，取较大值进行扩容。</li><li>扩容是比较耗时的，应该尽力去避免，所以在初始化时就应该提供一个容量参数。</li></ul><p><code>容量最大值</code></p><ul><li>最大值是Interger.MAX_VALUE，但容易造成内存溢出，保险起见在容量等于Integer.MAX_VALUE - 8 的时候就应该停止扩充容量。</li></ul><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><p>将枚举类也归到迭代器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有有效元素的枚举类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 枚举类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Enumeration&lt;E&gt; <span class="title">elements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Enumeration&lt;E&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下一个元素的索引</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断当前枚举类中是否有下一个元素</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 是否有下一个元素</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count &lt; elementCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取下一个元素</span></span><br><span class="line"><span class="comment">         * 当获取到下一个元素后，会发生count++ 以此来将索引进行移动，从而达到判断是否有下一个元素</span></span><br><span class="line"><span class="comment">         * 先调用hasMoreElements -&gt; nextElement，否则会抛出异常</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 下一个元素</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">nextElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count &lt; elementCount) &#123;</span><br><span class="line">                    <span class="keyword">return</span> elementData(count++);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Vector Enumeration"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个包含指定索引到结尾之间的元素的列表迭代器</span></span><br><span class="line"><span class="comment"> * 元素之间按照顺序排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含元素的列表迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个包含所有元素的列表迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含元素的列表迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代器，正向迭代</span></span><br><span class="line"><span class="comment"> * 通过判断是否存在下一个元素，若有则获取，若没有则说明迭代结束</span></span><br><span class="line"><span class="comment"> * 由于这块的代码与ArrayList中的代码是一模一样，可以参考ArrayList，不多说了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> E 元素类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;       </span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; </span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != elementCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> elementData(lastRet = i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            Vector.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> size = elementCount;</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            <span class="keyword">final</span> E[] elementData = (E[]) Vector.<span class="keyword">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">                action.accept(elementData[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// update once at end of iteration to reduce heap write traffic</span></span><br><span class="line">            cursor = i;</span><br><span class="line">            lastRet = i - <span class="number">1</span>;</span><br><span class="line">            checkForComodification();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 列表迭代器，正向迭代</span></span><br><span class="line"><span class="comment"> * 可获取上一个元素、下一个元素及索引</span></span><br><span class="line"><span class="comment"> * 与ArrayList一模一样的代码，不多做说明了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        cursor = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">int</span> i = cursor - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            cursor = i;</span><br><span class="line">            <span class="keyword">return</span> elementData(lastRet = i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            Vector.<span class="keyword">this</span>.set(lastRet, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            Vector.<span class="keyword">this</span>.add(i, e);</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组中指定索引的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定索引对应的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">elementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> + elementCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组第一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 第一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">firstElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elementData(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组最后一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最后一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">lastElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elementData(elementCount - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组中指定索引的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定索引对应的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改数组中指定索引的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 新元素，替换索引对应的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> +</span><br><span class="line">                                                 elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    elementData[index] = obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改数组中指定索引的值</span></span><br><span class="line"><span class="comment"> * 与上面的方法区别在于有无返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 新元素，替换索引对应的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧元素，索引对应的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除数组中指定索引的元素，移除元素之前会先进行角标越界判断</span></span><br><span class="line"><span class="comment"> * 移除过程中将index索引位置后续的所有元素都将向左移动一格</span></span><br><span class="line"><span class="comment"> * 为了能让GC尽可能地回收资源，主动将尾部位置设置成null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeElementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> +</span><br><span class="line">                                                 elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j = elementCount - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, j);</span><br><span class="line">    &#125;</span><br><span class="line">    elementCount--;</span><br><span class="line">    elementData[elementCount] = <span class="keyword">null</span>; <span class="comment">/* to let gc do its work */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除数组中第一次出现的指定元素</span></span><br><span class="line"><span class="comment"> * 若数组中不存在指定元素则返回-1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否删除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">removeElement</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> i = indexOf(obj);</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        removeElementAt(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除数组中的所有元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeAllElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// Let gc do its work</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elementCount; i++)</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    elementCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除数组中第一次出现的指定值</span></span><br><span class="line"><span class="comment"> * 与上面的方法区别在于有无返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否删除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeElement(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除数组中指定索引的值，移除元素之前会先进行角标越界判断</span></span><br><span class="line"><span class="comment"> * 移除过程中将index索引位置后续的所有元素都将向左移动一格</span></span><br><span class="line"><span class="comment"> * 为了能让GC尽可能地回收资源，主动将尾部位置设置成null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 移除的旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = elementCount - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--elementCount] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量移除数组中的指定数组的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定移除的元素集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.removeAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除从指定起始索引到指定结束索引之间的所有元素</span></span><br><span class="line"><span class="comment"> * 移除包含fromIndex索引对应的值，但不包括toIndex索引对应的值</span></span><br><span class="line"><span class="comment"> * 移除过程中将toIndex索引位置及其后续的所有元素往左移动 toIndex - fromIndex 格</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 看到这里的时候有些理解难题，在移除元素后索引位置上的元素主动设置成null，我明白这一点，不好理解的点在于算法</span></span><br><span class="line"><span class="comment"> * 假设如下：</span></span><br><span class="line"><span class="comment"> *             f           t</span></span><br><span class="line"><span class="comment"> * 1     2     3     4     5     6     7     8</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 移除3后的结果，注意4是不会被移除的：</span></span><br><span class="line"><span class="comment"> * 1     2     6     7     8     9     null  null</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 根据需求，我们知道要将8位置上的值设置成null，那么问题就在于我怎么才能知道7位置上的索引是多少呢？哦，是7，这个不算，算法应该怎么写呢？</span></span><br><span class="line"><span class="comment"> * 所以我很好奇怎么是这个答案：size - (toIndex-fromIndex)，后面着重理解了一下：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *             f           t</span></span><br><span class="line"><span class="comment"> * 1     2     6     7     8     9     null  null</span></span><br><span class="line"><span class="comment"> * &lt;=             size                         =&gt;</span></span><br><span class="line"><span class="comment"> *                                     &lt;= t-f =&gt;</span></span><br><span class="line"><span class="comment"> * &lt;=               ?                   =&gt;</span></span><br><span class="line"><span class="comment"> * 求?的值，也就是在求null的索引是多少，看上面的图就应该比较好理解了（不知道看的懂不），size - (toIndex-fromIndex)就刚好是索引的值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromIndex 起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toIndex 结束索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = elementCount - toIndex;</span><br><span class="line">    System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">                     numMoved);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let gc do its work</span></span><br><span class="line">    <span class="keyword">int</span> newElementCount = elementCount - (toIndex-fromIndex);</span><br><span class="line">    <span class="keyword">while</span> (elementCount != newElementCount)</span><br><span class="line">        elementData[--elementCount] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义反序列化</span></span><br><span class="line"><span class="comment"> * 直接获取指定键值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> in 输入流</span></span><br><span class="line"><span class="comment"> */</span>    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream in)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    ObjectInputStream.GetField gfields = in.readFields();</span><br><span class="line">    <span class="keyword">int</span> count = gfields.get(<span class="string">"elementCount"</span>, <span class="number">0</span>);</span><br><span class="line">    Object[] data = (Object[])gfields.get(<span class="string">"elementData"</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span> || data == <span class="keyword">null</span> || count &gt; data.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(<span class="string">"Inconsistent vector internals"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    elementCount = count;</span><br><span class="line">    elementData = data.clone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义序列化</span></span><br><span class="line"><span class="comment"> * 直接设置指定键值并写入流中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 输出流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> java.io.ObjectOutputStream.PutField fields = s.putFields();</span><br><span class="line">    <span class="keyword">final</span> Object[] data;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        fields.put(<span class="string">"capacityIncrement"</span>, capacityIncrement);</span><br><span class="line">        fields.put(<span class="string">"elementCount"</span>, elementCount);</span><br><span class="line">        data = elementData.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    fields.put(<span class="string">"elementData"</span>, data);</span><br><span class="line">    s.writeFields();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加-插入元素"><a href="#添加-插入元素" class="headerlink" title="添加/插入元素"></a>添加/插入元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素到数组中的指定位置，添加元素之前会先进行扩容和角标越界判断</span></span><br><span class="line"><span class="comment"> * 插入过程中将index索引位置及后续的所有元素都将向右移动一格，同时将当前索引位置的值修改成新值</span></span><br><span class="line"><span class="comment"> * 数组扩容跟size属性没有任何关系，size只负责数组中有多少个元素，插入元素后故而 + 1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj 新元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insertElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index</span><br><span class="line">                                                 + <span class="string">" &gt; "</span> + elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, elementCount - index);</span><br><span class="line">    elementData[index] = obj;</span><br><span class="line">    elementCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素到数组尾部，添加元素之前会先进行扩容判断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj 新元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addElement</span><span class="params">(E obj)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素到数组尾部，添加元素之前会先进行扩容判断</span></span><br><span class="line"><span class="comment"> * 与上面方法的区别在于是否有返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 新元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素到数组中的指定位置，添加元素之前会先进行扩容和角标越界判断</span></span><br><span class="line"><span class="comment"> * 插入过程中将index索引位置及后续的所有元素都将向右移动一格，同时将当前索引位置的值修改成新值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element  新元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    insertElementAt(element, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加数组到另外一个数组中，从尾部开始追加</span></span><br><span class="line"><span class="comment"> * 相当于合并两个数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组中的元素是否添加到另外一个数组中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityHelper(elementCount + numNew);</span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, elementCount, numNew);</span><br><span class="line">    elementCount += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加数组到另外一个数组中，从指定索引出开始添加</span></span><br><span class="line"><span class="comment"> * 插入过程中将index索引位置及后续的任何元素都将往右移动 numNew 格，相当于是批量插入</span></span><br><span class="line"><span class="comment"> * 相当于在插入前先将原有的元素都往右移动，预先留出空位来给后面要添加的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组中的元素是否添加到另外一个数组中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityHelper(elementCount + numNew);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = elementCount - index;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    elementCount += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>Vector内部通过数组实现，属于线程安全，更准确地来说应该是相对线程安全。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 假设有两个个线程分别调用下面的两个方法</span></span><br><span class="line"><span class="comment"> * 当线程1获取到size方法返回的值时正要去执行get方法，但是却被线程2抢先一步了，导致了remove方法先执行</span></span><br><span class="line"><span class="comment"> * 等到remove方法执行完毕后，也就是删除了最后一个元素，等到get方法执行时，最后一个元素实际上已经被删除了，现在获取的索引已经超出了范围</span></span><br><span class="line"><span class="comment"> * 故会抛出索引越界错误，所以严格来说Vector属于相对线程安全.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  Object <span class="title">getLast</span><span class="params">(Vector list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list.get(list.size() - <span class="number">1</span>);   <span class="comment">//线程1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">deleteLast</span><span class="params">(Vector list)</span> </span>&#123;</span><br><span class="line">    list.remove(list.size() - <span class="number">1</span>);      <span class="comment">//线程2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Vector每次自动扩充的容量大小支持自定义，通过传入capacityIncrement即可。</p></li><li><p>创建空参数的Vector对象时，默认的初始容量是10，当容量不足时，以2倍速度增长。</p></li><li><p>构建Vector对象时，最好能预先设置容量大小，以免减少后期扩容花费的时间。</p></li><li><p>与迭代器不同，elements方法返回的枚举对象不会发生快速失败。</p></li><li><p>Vector容量的临界值是最大值 - 8，这个数字8是因为在数组中除了存储元素之外还会存储数组的长度，而这些数据都在内存中，不同操作系统对内存的分配可能有所差异，减去8更多的是为了防止内存溢出。</p></li><li><p>在获取ArrayList的子集后不能在做结构上的修改。</p></li><li><p>获取迭代器后，不允许进行结构修改操作，因为会 expectedModCount 与 modCount 是否相等。</p></li><li><p>在遍历过程中不允许修改结构，否则会抛出错误。</p></li></ul><h4 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a>重点关注</h4><p><code>默认每次自动扩容的关系是2倍</code> <code>相对线程安全</code> <code>默认初始容量是10</code> <code>底层是通过数组存储元素，故是有序可重复集合</code> <code>自动扩充的容量大小支持自定义（capacityIncrement）</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;上周发布了&lt;a href=&quot;http://zlia.tech/2019/08/16/explain-arraylist-sourcecode/&quot;&gt;探索ArrayList的底层实现&lt;/a&gt;，趁热打铁！实际上&lt;code&gt;ArrayList&lt;/code&gt;与&lt;code&gt;Vector&lt;/code&gt;的实现上非常相似，代码基本上都是一样的，还是老样子，先看注释，我能说注释都差不多一样吗。探索&lt;code&gt;Vector&lt;/code&gt;源代码是基于&lt;code&gt;JDK1.8&lt;/code&gt;的。&lt;/p&gt;
&lt;h4 id=&quot;阅读注释&quot;&gt;&lt;a href=&quot;#阅读注释&quot; class=&quot;headerlink&quot; title=&quot;阅读注释&quot;&gt;&lt;/a&gt;阅读注释&lt;/h4&gt;&lt;p class=&quot;customize-img&quot;&gt;&lt;img src=&quot;/assets/blogImg/java/vector/vector-comment-1.png&quot; alt=&quot;Vector注释-1&quot;&gt;&lt;/p&gt;
&lt;p&gt;Vector内部是通过动态数组实现的。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索ArrayList底层实现</title>
    <link href="http://zlia.tech/2019/08/16/explain-arraylist-sourcecode/"/>
    <id>http://zlia.tech/2019/08/16/explain-arraylist-sourcecode/</id>
    <published>2019-08-16T08:08:04.000Z</published>
    <updated>2019-09-05T09:59:24.666Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a><div><span>背景</span></div></h3><p>想进步，想学习了，反正面试都要问的，还不如早点看了好。探索<code>ArrayList</code>源代码是基于<code>JDK1.8</code>版本的，相比以前的版本不知道有没有优化，毕竟没看过之前版本的底层代码。</p><h3 id="简单说明下"><a href="#简单说明下" class="headerlink" title="简单说明下"></a><div><span>简单说明下</span></div></h3><p>一般看底层代码前我都习惯先阅读下该类的<code>注释说明</code>，也不知道在哪里养成的习惯。相信大家都写过应用代码，既然写过，那也深知注释对于一个使用者来说是多么的重要，决定了它是否能够正确的使用，所以这是一个好习惯。</p><h4 id="阅读注释"><a href="#阅读注释" class="headerlink" title="阅读注释"></a>阅读注释</h4><p class="customize-img"><img src="/assets/blogImg/java/arraylist/arraylist-comment-1.png" alt="ArrayList注释-1"></p><p>看到这不知道你们有没有很惊讶，反正我倒是一惊，所以我说看注释很重要！！！如果是你写代码给别人看，除了看具体代码之外，看注释就是最好的理解方式了，一语道破很多原理，要求不高的我都觉得可以不用看代码实现了，所以接下来会继续阅读注释。</p><a id="more"></a><p class="customize-img"><img src="/assets/blogImg/java/arraylist/arraylist-comment-2.png" alt="ArrayList注释-2"></p><p>这就变相地在说，ArrayList中的get/set效率比LinkedList高，这不正好验证了我们常说的ArryList<code>存取快，插入删除慢</code>，我想它的时间复杂度说明了一切，虽然这里只是给出了结论。在这里顺便提供下<a href="https://blog.csdn.net/qq_41523096/article/details/82142747" target="_blank" rel="noopener">有趣的时间复杂度</a>的介绍文章，便于理解。</p><p class="customize-img"><img src="/assets/blogImg/java/arraylist/arraylist-comment-3.png" alt="ArrayList注释-3"></p><p>简单地说数组会<code>自动扩容</code>。</p><p class="customize-img"><img src="/assets/blogImg/java/arraylist/arraylist-comment-4.png" alt="ArrayList注释-4"></p><p>在这里我将<code>amount</code>翻译成次数，这个单词本意是数量的意思。基于我对ArrayList的了解，当容量不足时，它是需要扩充容量的，就上面咱们提到的自动扩容，每次容量不足时都需要自动扩容，若一开始就设置好这个容量，那么就减少了自动扩容的次数，所以我将它翻译成次数。它的意思就是让你<code>提前设置好容量大小</code>，以便容量不足时需要消耗时间去自动扩容。</p><p class="customize-img"><img src="/assets/blogImg/java/arraylist/arraylist-comment-5.png" alt="ArrayList注释-5"></p><p>大致意思是ArrayList不是线程安全，所以在多线程环境下要在外部控制同步防止数据紊乱。</p><p class="customize-img"><img src="/assets/blogImg/java/arraylist/arraylist-comment-6.png" alt="ArrayList注释-6"></p><p>截图中应该讲的挺明白了！</p><p class="customize-img"><img src="/assets/blogImg/java/arraylist/arraylist-comment-7.png" alt="ArrayList注释-7"></p><p>fail-fast：快速失败，我也是第一次听说该术语，它仅仅用于检测BUG，说明不了什么问题。</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>按照顺序先来看下ArrayList都具有哪些<code>成员属性</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//支持序列化、可克隆、随机访问</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//序列化标识</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认初始值容量大小10</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空数组实例，主要用来做赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[]  EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空数组实例，当采用默认的空构造函数时采用该实例作为默认值</span></span><br><span class="line">    <span class="comment">//该实例与 EMPTY_ELEMENTDATA 被区分开来以便知道当第一个元素被添加时数组该扩充多大，简单来说该属性会参与到计算当中，而 EMPTY_ELEMENTDATA只是用作简单的赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ArrayList中的元素被添加到该数组中</span></span><br><span class="line">    <span class="comment">//ArrayList的容量大小是该数组的长度大小</span></span><br><span class="line">    <span class="comment">//空构造函数的 elementData被赋值为 DEFAULTCAPACITY_EMPTY_ELEMENTDATA，当添加第一个元素时，elementData数组大小将会被扩充到默认容量大小10</span></span><br><span class="line">    <span class="comment">//该对象加上 transient 修饰符表示不对该属性进行序列化</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ArrayList容量大小，意指它包含元素的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们都知道定义一个数组的大小是 int 类型，那么也就意味着最大的数组大小应该是Integer.MAX_VALUE，但是这里为啥要减去8呢？</span></span><br><span class="line">    <span class="comment">//查阅资源发现大部分的人都在说8个字节是用来存储数组的大小，半信半疑</span></span><br><span class="line">    <span class="comment">//分配最大数组，某些VM会在数组中存储header word，按照上面的说法指的应该是数组的大小</span></span><br><span class="line">    <span class="comment">//若尝试去分配更大的数组可能会造成 OutOfMemoryError: 定义的数组大小超过VM上限</span></span><br><span class="line">    <span class="comment">//不同的操作系统对于不同的JDK可能分配的内存会有所差异，所以8这个数字可能是为了保险起见</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ArrayList结构被修改的次数</span></span><br><span class="line">    <span class="comment">//该字段主要针对迭代器与子集使用，若该属性被出乎意料的改变了，调用迭代器的相关方法，如 next、 remove、previous、set、add则会抛出 ConcurrentModificationException异常，该//情况其实就是上面提到的fail-fast</span></span><br><span class="line">    <span class="comment">//严格上来说，该字段并不算是结构被修改的次数，在判断是否需要扩容时，它是首先进行增加在判断，不过这不影响，该字段仅用来判断是否与其他字段相等</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些成员属性都很容易理解，加上提供了注释，所以这边就不做多的阐述！</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>接下来介绍ArrayList提供的<code>构造函数</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个指定初始容量大小的空数组，相当于 new Object[initialCapacity]</span></span><br><span class="line"><span class="comment"> * 若入参initialCapacity大于0，则创建具有指定大小的空数组，并让elementData指向该数组</span></span><br><span class="line"><span class="comment"> * 若入参initialCapacity等于0，则elementData指向已经创建好的空数组</span></span><br><span class="line"><span class="comment"> * 若入参initialCapacity小于0，则抛出参数异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 初始容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span> + initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个初始容量为10的空数组，并让elementData指向已经创建好的空数组</span></span><br><span class="line"><span class="comment"> * 初始容量并不是在这里设置，而是在添加第一个元素时进行初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayLlist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建一个包含指定collection集合的数组，ArrayList容量大小和该集合大小一致，指定集合中的元素按照迭代器的顺序排列</span></span><br><span class="line"><span class="comment"> * collection集合类型有Map、set、List等子类，所以入参可以是多种类型</span></span><br><span class="line"><span class="comment"> * collection集合转换成数组，elementData指向该数组，size成员属性被赋值为collection集合长度</span></span><br><span class="line"><span class="comment"> * 若该数组大小大于0，则判断数组类型是否是Ojbect[],若不是则创建一个新的数组，并拷贝elementData数组中的内容</span></span><br><span class="line"><span class="comment"> * 若该数组大小等于0，则elementData指向空数组</span></span><br><span class="line"><span class="comment"> * collection集合不可能创建长度为负数的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//c.toArray 可能不会返回正确的Object[]类型，这边可能会利用多态的性质，如 A a = new B()</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//空数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>若已经提前知道数组容量，则建议使用new ArrayList(initialCapacity)</p></li><li><p>若不知道数组容量的话，那就没办法了</p></li><li><p>ArrayList(Collection c)一般是在包含关系的情况下使用</p></li></ul><h4 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h4><p>接下来按照类的声明顺序介绍<code>方法</code>，有必要的情况下结合例子进行说明。</p><h5 id="缩小数组大小空间"><a href="#缩小数组大小空间" class="headerlink" title="缩小数组大小空间"></a>缩小数组大小空间</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缩小ArrayList对象的容量到当前数组的大小，应用可以调用该方法来最小化ArrayList对象的存储空间，简单来说就是节约空间，去掉没有用到的剩余数组空间</span></span><br><span class="line"><span class="comment"> * modCount 是记录ArrayList修改结构的次数，节约数组空间就是减少了数组的大小</span></span><br><span class="line"><span class="comment"> * size 是数组填充了元素的个数，实实在在的大小，而 elementData.length 是数组的总容量大小，也就是说只有当填充/删除元素时size的大小才会变化</span></span><br><span class="line"><span class="comment"> * 而当进行扩容时 elementData.length 才会变化，毕竟数组的长度变大了</span></span><br><span class="line"><span class="comment"> * 若size小于elementData.length，则判断 size是否等于0</span></span><br><span class="line"><span class="comment"> * 若size等于0，则将 elementData 指向空数组</span></span><br><span class="line"><span class="comment"> * 若size不等于0，则创建一个大小为size的数组，并将elementData中原有的元素拷贝到新数组中，同时更新elementData指向新数组，从而完成节约数据空间的作用</span></span><br><span class="line"><span class="comment"> * size的长度是不可能大于elementData.length</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        elementData = (size == <span class="number">0</span>) ? EMPTY_ELEMENTDATA</span><br><span class="line">          : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="自定义容量-扩容机制"><a href="#自定义容量-扩容机制" class="headerlink" title="自定义容量 + 扩容机制"></a>自定义容量 + 扩容机制</h5><p>自定义容量可以在创建ArrayList对象时设置，若后期发现容量不足总不能手动去改数值吧，故而提供了其他方法去自定义容量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加ArrayList对象的容量，在必要情况下，入参minCapacity至少要确保能容纳元素的数量</span></span><br><span class="line"><span class="comment"> * 若 elementData 不等于空数组，则minExpand = 0，否则minExpand = DEFAULT_CAPACITY = 10</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 假设去掉设置minExpand的值的语句会造成的影响：</span></span><br><span class="line"><span class="comment"> * 若采用new ArrayList的方式创建对象，则表示在第一次添加元素时，自动将容量扩充到10，而若在此之前先手动扩充容量，如果该值小于10，则会扩容一次，而当容量不足时，</span></span><br><span class="line"><span class="comment"> * 又会扩容一次，总的来说会频繁的进行扩容，而为什么一开始要设置成10呢，微软工程师做过调研，认为该数字比较常用，实际上设置成其它值也是没问题的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 扩容机制为了保证所有的元素都能被容纳，自定义容量与自动扩容的数值会进行比较，取较大值作为扩容的参数，故而有了minCapacity与minExpand的比较</span></span><br><span class="line"><span class="comment"> * 若minCapacity大于minExpand，则调用ensureExplicitCapacity方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  minCapacity 手动扩充的容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span> <span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) ? <span class="number">0</span> : DEFAULT_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * modCount指的是记录修改结构的次数，但若是minCapacity 小于 elementData.length，则结构并没有修改，在这点上不是很难理解</span></span><br><span class="line"><span class="comment"> * 判断完需要扩容的参数，接下来应该判断该参数是否大于预先定义好的总容量大小，还是取较大值</span></span><br><span class="line"><span class="comment"> * 若minCapacity大于elementData.length，则调用grow方法开始扩容</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  minCapacity 手动扩充的容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * oldCapacity &gt;&gt; n：oldCapacity除以2的n次方</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 首先获取当前数组的容量大小，获取自动扩容时的容量大小为 oldCapacity + oldCapacity/2 = 1.5 * oldCapacity，也就是说两次扩容之间是1.5倍的关系</span></span><br><span class="line"><span class="comment"> * 判断手动扩充的容量是否大于自动扩充的容量</span></span><br><span class="line"><span class="comment"> * 若大于，则自动扩容的容量修改为手动扩充的容量，即 newCapacity = minCapacity，否则newCapacity不变，即采用自动扩充的容量</span></span><br><span class="line"><span class="comment"> * 为了防止内存溢出，扩容并不是无止境的扩充，当大于一个临界点MAX_ARRAY_SIZE时，就不允许在采用自动扩容的容量大小，而是取最大值或临界点</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 参考hugeCapacity方法：</span></span><br><span class="line"><span class="comment"> * 当程序执行到①时，我们可以知道 newCapacity &gt;= minCapacity（指的是赋值之后的关系）</span></span><br><span class="line"><span class="comment"> * 若MAX_ARRAY_SIZE大于newCapacity，则就开始创建长度为newCapacity的新数组，三者的关系为 MAX_ARRAY_SIZE &gt; newCapacity &gt;= minCapacity</span></span><br><span class="line"><span class="comment"> * 若MAX_ARRAY_SIZE小于newCapacity，则进入到hugeCapacity方法，但此时我们不知道minCapacity 与 MAX_ARRAY_SIZE的大小关系</span></span><br><span class="line"><span class="comment"> * 若minCapacity大于MAX_ARRAY_SIZE，则采用最大值，不允许无限制的手动设置扩充容量，不过最大值有可能会出现内存溢出</span></span><br><span class="line"><span class="comment"> * 三者关系为：newCapacity &gt;= minCapacity &gt; MAX_ARRAY_SIZE</span></span><br><span class="line"><span class="comment"> * 若minCapacity小于MAX_ARRAY_SIZE，则采用临界值，该临界值是保证在不同的操作系统下不会发生内存溢出， 三者关系为：newCapacity &gt; MAX_ARRAY_SIZE &gt; minCapacity</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 得出结论：</span></span><br><span class="line"><span class="comment"> * 添加元素时会先到底临界值，此时不会发生内存溢出，若在往上增长则达到最大值，最大值有可能发生内存溢出</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  minCapacity 手动扩充的容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;      --------------------&gt; ① 手动添加</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断入参minCapacity 是否大于 MAX_ARRAY_SIZE</span></span><br><span class="line"><span class="comment"> * 若 minCapacity &gt; MAX_ARRAY_SIZE，则返回值是最大值</span></span><br><span class="line"><span class="comment"> * 若 minCapacity &lt;= MAX_ARRAY_SIZE，则返回值是临界值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  minCapacity 手动扩充的容量大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 容量大小结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算出要扩充的容量大小并扩容</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  minCapacity 手动扩充的容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只有在采用new ArrayList()的方式创建对象后，elementData才会等于DEFAULTCAPACITY_EMPTY_ELEMENTDATA，而以其他方式创建对象后都具有一定的容量大小</span></span><br><span class="line"><span class="comment"> * 若 elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA，比较手动扩容与自动扩容的容量大小，取较大值</span></span><br><span class="line"><span class="comment"> * 若不相等，则采用手动扩容容量大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> elementData 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity 手动扩充的容量大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 容量大小结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>什么情况下会扩容</code></p><ul><li>这个问题有点白问，当然了是数组不够用了才需要扩充容量了，不过它不是一个一个的扩充，而是采用一定的规则去扩充，回答的也有点傻！</li></ul><p><code>自动扩容机制</code></p><ul><li>每次自动扩容都以<code>1.5倍</code>的关系进行增长，如果期间手动扩充容量，则会比较手动扩充的容量大小与1.5倍的容量大小，取较大值进行扩容。</li><li>扩容是比较耗时的，应该尽力去避免，所以在初始化时就应该提供一个容量参数。</li></ul><p><code>容量最大值</code></p><ul><li>最大值是Interger.MAX_VALUE，但容易造成内存溢出，保险起见在容量等于Integer.MAX_VALUE - 8 的时候就应该停止扩充容量。</li></ul><h5 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组中指定索引的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定索引对应的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改数组中指定索引的值</span></span><br><span class="line"><span class="comment"> * rangCheck检查角标是否越界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 新元素，替换索引对应的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧元素，索引对应的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加-插入元素"><a href="#添加-插入元素" class="headerlink" title="添加/插入元素"></a>添加/插入元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素到数组尾部，添加元素之前会先进行扩容判断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 新元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素到数组中的指定位置，添加元素之前会先进行扩容和角标越界判断</span></span><br><span class="line"><span class="comment"> * 插入过程中将index索引位置及后续的所有元素都将向右移动一格，同时将当前索引位置的值修改成新值</span></span><br><span class="line"><span class="comment"> * 数组扩容跟size属性没有任何关系，size只负责数组中有多少个元素，插入元素后故而 + 1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element  新元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加数组到另外一个数组中，从尾部开始追加</span></span><br><span class="line"><span class="comment"> * 相当于合并两个数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组中的元素是否添加到另外一个数组中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加数组到另外一个数组中，从指定索引出开始添加</span></span><br><span class="line"><span class="comment"> * 插入过程中将index索引位置及后续的任何元素都将往右移动 numNew 格，相当于是批量插入</span></span><br><span class="line"><span class="comment"> * 相当于在插入前先将原有的元素都往右移动，预先留出空位来给后面要添加的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组中的元素是否添加到另外一个数组中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除数组中指定索引的值，移除元素之前会先进行角标越界判断</span></span><br><span class="line"><span class="comment"> * 移除过程中将index索引位置后续的所有元素都将向左移动一格</span></span><br><span class="line"><span class="comment"> * 为了能让GC尽可能地回收资源，主动将尾部位置设置成null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 移除的旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                            numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除数组中第一次出现的指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否删除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除从指定起始索引到指定结束索引之间的所有元素</span></span><br><span class="line"><span class="comment"> * 移除包含fromIndex索引对应的值，但不包括toIndex索引对应的值</span></span><br><span class="line"><span class="comment"> * 移除过程中将toIndex索引位置及其后续的所有元素往左移动 toIndex - fromIndex 格</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 看到这里的时候有些理解难题，在移除元素后索引位置上的元素主动设置成null，我明白这一点，不好理解的点在于算法</span></span><br><span class="line"><span class="comment"> * 假设如下：</span></span><br><span class="line"><span class="comment"> *             f           t</span></span><br><span class="line"><span class="comment"> * 1     2     3     4     5     6     7     8</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 移除3后的结果，注意4是不会被移除的：</span></span><br><span class="line"><span class="comment"> * 1     2     6     7     8     9     null  null</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 根据需求，我们知道要将8位置上的值设置成null，那么问题就在于我怎么才能知道7位置上的索引是多少呢？哦，是7，这个不算，算法应该怎么写呢？</span></span><br><span class="line"><span class="comment"> * 所以我很好奇怎么是这个答案：size - (toIndex-fromIndex)，后面着重理解了一下：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *             f           t</span></span><br><span class="line"><span class="comment"> * 1     2     6     7     8     9     null  null</span></span><br><span class="line"><span class="comment"> * &lt;=             size                         =&gt;</span></span><br><span class="line"><span class="comment"> *                                     &lt;= t-f =&gt;</span></span><br><span class="line"><span class="comment"> * &lt;=               ?                   =&gt;</span></span><br><span class="line"><span class="comment"> * 求?的值，也就是在求null的索引是多少，看上面的图就应该比较好理解了（不知道看的懂不），size - (toIndex-fromIndex)就刚好是索引的值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromIndex 起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toIndex 结束索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - toIndex;</span><br><span class="line">    System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">                     numMoved);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> newSize = size - (toIndex-fromIndex);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize; i &lt; size; i++) &#123;</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    size = newSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量移除数组中的指定数组的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定移除的元素集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移除元素让我想到一个问题，看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Object[] o = <span class="keyword">new</span> Object[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">System.arraycopy(o, <span class="number">2</span>, o , <span class="number">1</span>, o.length - <span class="number">1</span> - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (Object i :o) &#123;</span><br><span class="line">    System.out.print(i + <span class="string">","</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看下输出结果1,3,4,5,6,6, 前面几个元素应该都明白，但是有一个点：<code>元素你虽然移除了，但是数组的长度依然没变化</code>。当元素往左移动一格后，那最后的索引位置上应该是个什么值，按道理来说，6应该也是往前移动了，所以它的这个位置应该空出来的才对，但是输出结果告诉我们：最后一个位置应该是类似复制操作导致了最后两个元素一样的值，要是不信的话，你可以多试几个值，而在ArrayList中如果不主动设置null的话会造成元素紊乱，就莫名其妙多了一个元素。</p><h5 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组中的元素个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组中的元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否是空元素数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组是否为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 采用正向遍历的方式，获取数组中与指定元素相等的元素的索引</span></span><br><span class="line"><span class="comment"> * 若存在多个元素，取第一次与指定元素相等的元素的索引</span></span><br><span class="line"><span class="comment"> * 若找不到指定元素则返回 -1</span></span><br><span class="line"><span class="comment"> * 方法中通过equals判断两对象是否相等，若是调用Object#equals方法，是在判断两者的地址是否指向同一个</span></span><br><span class="line"><span class="comment"> * 若对象中已经覆写了Object#equals，则应该引起注意！</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 采用反向遍历的方式，获取数组中与指定元素相等的元素的索引</span></span><br><span class="line"><span class="comment"> * 若存在多个元素，取第一次与指定元素相等的元素的索引</span></span><br><span class="line"><span class="comment"> * 若找不到指定元素则返回 -1</span></span><br><span class="line"><span class="comment"> * 方法中通过equals判断两对象是否相等，若是调用Object#equals方法，是在判断两者的地址是否指向同一个</span></span><br><span class="line"><span class="comment"> * 若对象中已经覆写了Object#equals，则应该引起注意！</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用该clone之前，该类要实现Cloneable，不然会抛出异常</span></span><br><span class="line"><span class="comment"> * 数组默认已经实现了Cloneable接口，直接调用方法即可，而且直接返回对应的类型，不需要向下转型，同时包含数组元素</span></span><br><span class="line"><span class="comment"> * 浅拷贝与深拷贝，举个例子吧</span></span><br><span class="line"><span class="comment"> * 比如A类中包含基本类型与B类，当调用A类clone方法后，两个A对象肯定是不一致，不然就不叫做拷贝了，不过这不是关键</span></span><br><span class="line"><span class="comment"> * 若A1对象中的B对象与A2对象中的B对象指向同一个对象，则认为它是浅拷贝，认为B没有被拷贝新的一份</span></span><br><span class="line"><span class="comment"> * 若两者指向不相等的话，则认为深拷贝，认为B重新拷贝了一份，不过这通常需要我们自定义代码，就像下面的方法一样</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 克隆后的新对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">        v.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个包含所有列表元素的有序（按照添加顺序）数组</span></span><br><span class="line"><span class="comment"> * 此方法是创建一个新数组，方便使用者能够随便操作新数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将列表的所有元素放入到指定数组中并返回</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：T类型要么是数组中数据的相同类型，要么是数组中数据的父类型，运用多态性质</span></span><br><span class="line"><span class="comment"> * 若传入的新数组容量 &lt; 列表容量，则取它的类类型来创建一个包含列表元素的新数组，并返回</span></span><br><span class="line"><span class="comment"> * 若传入的新数组容量 &gt; 列表容量，则将列表中的元素按照顺序拷贝到新数组中，同时将新数组中索引为size的值设置成null</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 一开始我也好奇为啥要在索引为size上设置个null呢？</span></span><br><span class="line"><span class="comment"> * 看了注释加上自我的理解，若传入的新数组是个空数组的话，那么除了拷贝列表元素后剩余的所有空间的值都为null，此时在给索引为size的值设置成null似乎没有多大</span></span><br><span class="line"><span class="comment"> * 意思；另外一种情况是若传入的新数组不是个空数组，那这个设置就有意义了，传入的新数组的某些元素会被列表元素覆盖，同时有个null，剩下的才是自己本身的数据，呈现这样子一种效果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment"> * list.add(11);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Integer[] str = new Integer[]&#123;1,2,3,4,5,6,7,8,9,10&#125;;</span></span><br><span class="line"><span class="comment"> * Integer[] s1 = list.toArray(str);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * for (Integer s : s1) &#123;</span></span><br><span class="line"><span class="comment"> *     System.out.println(s + ",");</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输出结果：11,null,3,4,5,6,7,8,9,10,</span></span><br><span class="line"><span class="comment"> * 那么设置这个null的意义就在于能够确定列表中元素个数（长度），但有个前提就是调用者知道链表中的所有节点信息不存在null才有意义，目前我只有想到这一种情况下有用！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 指定数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 填充完列表元素的指定数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组中指定索引中的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定索引的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断索引是否越界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断角标是否越界，该方法专门针对add 和 addAll方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本质上该方法与移除元素没啥区别</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空元素，主动将数组中的元素设置为null方便GC回收垃圾</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集合与数组取交集</span></span><br><span class="line"><span class="comment"> * 最终数组中只包含与集合共有的元素，相当于在修改数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组元素是否被修改成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量删除元素</span></span><br><span class="line"><span class="comment"> * 若集合是否包含指定元素的结果与入参complement比较，</span></span><br><span class="line"><span class="comment"> * 若complement是false，移除数组与集合共有的元素</span></span><br><span class="line"><span class="comment"> * 若complement是true，保留数组与集合共有的元素，即交集</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> complement 比较值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组元素是否被修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">            <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                elementData[w++] = elementData[r];</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></span><br><span class="line">        <span class="comment">// even if c.contains() throws.</span></span><br><span class="line">        <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">            System.arraycopy(elementData, r,</span><br><span class="line">                             elementData, w,</span><br><span class="line">                             size - r);</span><br><span class="line">            w += size - r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">                elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">            modCount += size - w;</span><br><span class="line">            size = w;</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义序列化</span></span><br><span class="line"><span class="comment"> * 若写入过程中数组结构被修改则会抛出异常</span></span><br><span class="line"><span class="comment"> * 如果采用默认的序列化机制，空余的空间会作为null写入本地文件或者在网络中传输，耗费了不必要的资源</span></span><br><span class="line"><span class="comment"> * 故而使用自定义序列化机制，仅写入索引为(0，size）的有效元素以节省资源</span></span><br><span class="line"><span class="comment"> * 默认的序列化机制会将非静态与非瞬时（非transient修饰）写入流中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 输出流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="comment">//执行默认序列化过程</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入元素个数</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按顺序写入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义反序列化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 输入流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行默认的反序列化过程</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//要写读一个字节，因为是按顺序写入</span></span><br><span class="line">    <span class="comment">//因为已经执行了默认的反序列化过程，已经为size赋值了，故不用再次赋值</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> capacity = calculateCapacity(elementData, size);</span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);</span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将流中的元素写入到数组中</span></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历数组，并对数组中的元素进行指定处理</span></span><br><span class="line"><span class="comment"> * 在遍历过程中不允许修改结构，否则会抛出错误</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action 函数式接口，对数组中的元素指定处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">final</span> E[] elementData = (E[]) <span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        action.accept(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定条件移除元素</span></span><br><span class="line"><span class="comment"> * 笔者对BitSet也是第一次接触，针对本文章它显的不是很重要，故而大概了解了一下</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 该方法中将满足条件的元素索引存放到BitSet中，同时记录移除元素的个数removeCount</span></span><br><span class="line"><span class="comment"> * 紧接着BitSet调用 nextClearBit方法，该方法根据指定的索引获取没有在BitSet中存放的下一个索引，直接上个例子吧</span></span><br><span class="line"><span class="comment"> * BitSet removeSet = new BitSet();</span></span><br><span class="line"><span class="comment"> * removeSet.set(1)</span></span><br><span class="line"><span class="comment"> * removeSet.set(2)</span></span><br><span class="line"><span class="comment"> * System.out.println(removeSet.nextClearBit(1))  --&gt; 3</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 一开始已经在BitSet中存放了要移除的元素的索引，当调用nextClearBit方法循环遍历获取到的索引就是要保留的元素的索引</span></span><br><span class="line"><span class="comment"> * 故而直接获取元素的值将其存放到数组中，最后的数组是按照保留元素的顺序进行存放的</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 函数式接口中不能调用修改结构的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filter 使用指定条件来过滤元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> E&gt; filter)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(filter);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> removeCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> BitSet removeSet = <span class="keyword">new</span> BitSet(size);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="keyword">final</span> E element = (E) elementData[i];</span><br><span class="line">        <span class="keyword">if</span> (filter.test(element)) &#123;</span><br><span class="line">            removeSet.set(i);</span><br><span class="line">            removeCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// shift surviving elements left over the spaces left by removed elements</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> anyToRemove = removeCount &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (anyToRemove) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> newSize = size - removeCount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) &#123;</span><br><span class="line">            i = removeSet.nextClearBit(i);</span><br><span class="line">            elementData[j] = elementData[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=newSize; k &lt; size; k++) &#123;</span><br><span class="line">            elementData[k] = <span class="keyword">null</span>;  <span class="comment">// Let gc do its work</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.size = newSize;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> anyToRemove;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定规则替换所有旧元素</span></span><br><span class="line"><span class="comment"> * operator.apply方法：旧元素作为入参传入，根据规则返回新元素，然后进行替换</span></span><br><span class="line"><span class="comment"> * operator.apply方法中不能调用修改结构的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> operator 指定规则，函数式接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(operator);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        elementData[i] = operator.apply((E) elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定规则对数组中的元素进行排序</span></span><br><span class="line"><span class="comment"> * 若没有指定规则则使用默认的升序进行排序</span></span><br><span class="line"><span class="comment"> * 指定规则后会调用自定义比较器中的compare方法进行比较排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 自定义比较器，覆写compare方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    Arrays.sort((E[]) elementData, <span class="number">0</span>, size, c);</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断数组中是否包含指定集合中的所有元素</span></span><br><span class="line"><span class="comment"> * 但凡集合中有一个元素不存在数组中则返回false</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组中是否包含指定集合中的所有元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object e : c)</span><br><span class="line">        <span class="keyword">if</span> (!contains(e))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先判断当前对象与指定对象是否指向同一个对象，就是在判断地址</span></span><br><span class="line"><span class="comment"> * 紧接着判断指定对象属于List的子类</span></span><br><span class="line"><span class="comment"> * 紧接着获取两个对象的迭代器</span></span><br><span class="line"><span class="comment"> * 若两个迭代器的元素个数不相等，则返回false</span></span><br><span class="line"><span class="comment"> * 若两个迭代器的元素个数相等，则将两个迭代器的元素进行对应的比较，但凡出现对应的元素不相等则返回false</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 当前对象与指定对象是否相等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> List))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    ListIterator&lt;E&gt; e1 = listIterator();</span><br><span class="line">    ListIterator&lt;?&gt; e2 = ((List&lt;?&gt;) o).listIterator();</span><br><span class="line">    <span class="keyword">while</span> (e1.hasNext() &amp;&amp; e2.hasNext()) &#123;</span><br><span class="line">        E o1 = e1.next();</span><br><span class="line">        Object o2 = e2.next();</span><br><span class="line">        <span class="keyword">if</span> (!(o1==<span class="keyword">null</span> ? o2==<span class="keyword">null</span> : o1.equals(o2)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !(e1.hasNext() || e2.hasNext());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.hashCode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组元素的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组元素的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取分割迭代器</span></span><br><span class="line"><span class="comment"> * 由于该方法涉及到另外一个接口，会另外新起一篇文章来讲解该内容，这里就不做阐述</span></span><br><span class="line"><span class="comment"> * 附上文章地址：http://zlia.tech/2019/08/28/explain-arraylist-spliterator-sourcecode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayListSpliterator&lt;&gt;(<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">parallelStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个包含指定索引到结尾之间的元素的列表迭代器</span></span><br><span class="line"><span class="comment"> * 元素之间按照顺序排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含元素的列表迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个包含所有元素的列表迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含元素的列表迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代器，正向迭代</span></span><br><span class="line"><span class="comment"> * 通过判断是否存在下一个元素，若有则获取，若没有则说明迭代结束</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> E 元素类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//下一个元素的索引</span></span><br><span class="line">    <span class="keyword">int</span> cursor;</span><br><span class="line">    <span class="comment">//当前元素的索引</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否存在下一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否存在下一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个元素的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个元素的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除迭代过程中当前索引的元素</span></span><br><span class="line"><span class="comment">     * 初始化时当前索引为 -1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">            cursor = lastRet;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历元素，只能遍历一次</span></span><br><span class="line"><span class="comment">     * 在遍历过程中调用remove方法需要注意，可能会抛出IllegalStateException异常</span></span><br><span class="line"><span class="comment">     * 在移除过程中 lastRet 成员变量可能为是 -1，故而会抛出异常</span></span><br><span class="line"><span class="comment">     * 与forEach的区别在于：可以遍历多次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> consumer 函数式接口，声明如何处理元素的函数</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * List&lt;String&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">     * list.add("1");</span></span><br><span class="line"><span class="comment">     * list.add("2");</span></span><br><span class="line"><span class="comment">     * list.iterator().forEachRemaining(str -&gt; &#123;</span></span><br><span class="line"><span class="comment">     *   System.out.println("str:" + str);</span></span><br><span class="line"><span class="comment">     * &#125;);</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * List&lt;String&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">     * list.add("1");</span></span><br><span class="line"><span class="comment">     * list.add("2");</span></span><br><span class="line"><span class="comment">     * list.add("3");</span></span><br><span class="line"><span class="comment">     * list.add("4");</span></span><br><span class="line"><span class="comment">     * list.add("5");</span></span><br><span class="line"><span class="comment">     * Iterator&lt;String&gt; iterator = list.iterator();</span></span><br><span class="line"><span class="comment">     * while (iterator.hasNext()) &#123;</span></span><br><span class="line"><span class="comment">     *  String nextValue = iterator.next();</span></span><br><span class="line"><span class="comment">     *  if (nextValue.equals("3")) &#123;</span></span><br><span class="line"><span class="comment">     *      iterator.forEachRemaining(str -&gt; &#123;</span></span><br><span class="line"><span class="comment">     *          System.out.println("内层：" + str);</span></span><br><span class="line"><span class="comment">     *      &#125;);</span></span><br><span class="line"><span class="comment">     *  &#125;</span></span><br><span class="line"><span class="comment">     *  System.out.println("外层：" + nextValue);</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(consumer);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = ArrayList.<span class="keyword">this</span>.size;</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">            consumer.accept((E) elementData[i++]); <span class="comment">//迭代过程中依次传入元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        cursor = i;</span><br><span class="line">        lastRet = i - <span class="number">1</span>;</span><br><span class="line">        checkForComodification();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化时 modCount 与 expectedModCount 是相等的</span></span><br><span class="line"><span class="comment">     * 但如果在遍历的过程修改数组结构的话，此时 modCount 会有所变化，导致两者不相等，故而抛出异常，也就是我们上面提到的fast-failed异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 列表迭代器，正向迭代</span></span><br><span class="line"><span class="comment"> * 可获取上一个元素、下一个元素及索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        cursor = index;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否有前一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否有前一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个元素的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个元素的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取上一个元素的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 上一个元素的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取上一个元素</span></span><br><span class="line"><span class="comment">     * 在获取过程中会判断该数组结构是否被修改</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 上一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">int</span> i = cursor - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        cursor = i;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随着遍历，索引是会向前移动，用指定元素替换索引处的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 指定元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList.<span class="keyword">this</span>.set(lastRet, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随着遍历，索引是会向前移动，将指定元素添加到下一个索引位置上</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 指定元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            ArrayList.<span class="keyword">this</span>.add(i, e);</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要理解迭代器，很关键的一个点就是<code>cursor</code>，它的位置决定了你调用方法的结果！</p><h5 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取指定起始索引到指定结束索引之间的元素，简称获取指定子集</span></span><br><span class="line"><span class="comment"> * 指定区间中的元素包括起始索引，不包括结束索引</span></span><br><span class="line"><span class="comment"> * 若起始索引与结束索引相等，则返回空元素</span></span><br><span class="line"><span class="comment"> * 对子集的操作，即调用set、add、remove等方法将会影响到整个数组</span></span><br><span class="line"><span class="comment"> * 但在先获取子集后，又对整个数组的结构进行修改，这时在遍历子集则会导致报错，而对于整体的非结构性修改则不会报错，不过依然会影响到子集</span></span><br><span class="line"><span class="comment"> * 所以在获取子集后最好不要修改数组的结构</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromIndex 起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toIndex 结束索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定区间中的所有元素，称为子集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SubList(<span class="keyword">this</span>, <span class="number">0</span>, fromIndex, toIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断起始索引与结束索引</span></span><br><span class="line"><span class="comment"> * 该判断在子集中又获取子集时显得较为重要</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromIndex 起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toIndex 结束索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> size 数组大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">subListRangeCheck</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"fromIndex = "</span> + fromIndex);</span><br><span class="line">    <span class="keyword">if</span> (toIndex &gt; size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"toIndex = "</span> + toIndex);</span><br><span class="line">    <span class="keyword">if</span> (fromIndex &gt; toIndex)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"fromIndex("</span> + fromIndex +</span><br><span class="line">                                           <span class="string">") &gt; toIndex("</span> + toIndex + <span class="string">")"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子集对象，支持随机访问</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  List&lt;String&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment"> *  list.add("1"); //0</span></span><br><span class="line"><span class="comment"> *  list.add("2"); //1</span></span><br><span class="line"><span class="comment"> *  list.add("3"); //2</span></span><br><span class="line"><span class="comment"> *  list.add("4"); //3</span></span><br><span class="line"><span class="comment"> *  list.add("5"); //4</span></span><br><span class="line"><span class="comment"> *  list.add("6"); //5</span></span><br><span class="line"><span class="comment"> *  list.add("7"); //6</span></span><br><span class="line"><span class="comment"> *  list.add("8"); //7</span></span><br><span class="line"><span class="comment"> *  list.add("9"); //8</span></span><br><span class="line"><span class="comment"> *  list.add("10"); //9</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  List&lt;String&gt; sub = list.subList(1,9);</span></span><br><span class="line"><span class="comment"> *  0,1,2,3,4,5,6,7</span></span><br><span class="line"><span class="comment"> *  2,3,4,5,6,7,8,9</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  sub.subList(2,8);</span></span><br><span class="line"><span class="comment"> *  0,1,2,3,4,5</span></span><br><span class="line"><span class="comment"> *  4,5,6,7,8,9</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 以上提供的方法只要是帮助大家去理解子集又获取子集的例子，其中加入了索引（上）及索引对应的元素（下）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SubList</span> <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指向调用者的引用，该变量特别是在子集中又子集时很关键，决定了是否理解该功能的重要因素</span></span><br><span class="line"><span class="comment">     * ArrayList -&gt; subList -&gt; subList</span></span><br><span class="line"><span class="comment">     * 当第一次调用subList获取子集时，为了方便理解，称为子集1，这个时候子集1中的parent指向了ArrayList，这点比较好理解</span></span><br><span class="line"><span class="comment">     * 当子集1又获取子集时，称为子集2，这个时候子集2中的parent指向了子集1，依次类推</span></span><br><span class="line"><span class="comment">     * 如果你仔细看了下面的方法后，你会知道它是如何调用的？例如子集2中调用add方法</span></span><br><span class="line"><span class="comment">     * 子集2#add -&gt; parent#add = 子集1#add -&gt; parent#add = ArrayList#add，最终都会调用到最上层类</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 那么为什么要这么设计呢？何不子集2#add -&gt; ArrayList#add 这样子的调用呢？</span></span><br><span class="line"><span class="comment">     * 理由在于modCount，它是指数组结构被修改的次数，这边就不再阐述何为结构被修改，假设下若按照 子集2#add -&gt; ArrayList#add这样子的顺序调用的话</span></span><br><span class="line"><span class="comment">     * ArrayList#modCount会正常变化，子集2#modCount也会正常变化，可参考add方法中的 this.modCount = parent.modCount 代码片段，</span></span><br><span class="line"><span class="comment">     * 按照上面的假设，此时只有ArrayList与子集2的modCount正常变化，但是子集1却没有变化，那当你在遍历子集1时，它会首先判断子集1的modCount是否与ArrayList的modCount相等</span></span><br><span class="line"><span class="comment">     * 若不相等，则抛出异常，具体可看 checkForComodification 方法，所以子集2#add时，也必须同时修改子集1的modCount，故而如此设计</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 有一个点关键，我们说是因为modCount，而只有结构修改了modCount才会变化，才需要如此调用，那么如果modCount没有被修改呢？</span></span><br><span class="line"><span class="comment">     * 那就不需要那么麻烦了，调用流程就是我们所假设的如此了 子集2#add -&gt; ArrayList#add</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 所以两种设计就用到了两个变量：parentOffset、offset</span></span><br><span class="line"><span class="comment">     * 两个变量分别针对两种方式去调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AbstractList&lt;E&gt; parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前子集索引与父子集索引的偏移量，简单地说就是子集2与子集1的索引偏移量，有一个等式</span></span><br><span class="line"><span class="comment">     * index2：子集2的索引  parentOffset2：子集2的属性</span></span><br><span class="line"><span class="comment">     * index1：子集1的索引  parentOffset1：子集1的属性</span></span><br><span class="line"><span class="comment">     * index3:ArrayList的索引</span></span><br><span class="line"><span class="comment">     * parentOffset2 + index2 = index1 + parentOffset1 = index3</span></span><br><span class="line"><span class="comment">     * 做了那么多，无非就是把子集1与子集2与ArrayList三者关联起来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parentOffset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前子集索引与ArrayList索引的偏移量，简单地说就是子集2与ArrayList的索引偏移量</span></span><br><span class="line"><span class="comment">     * 在创建子集2时，会把子集1与ArrayList的索引偏移量传给子集2，接着在加上子集2与子集1的索引偏移量就可以得到子集2与ArrayList的索引偏移量</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * offset2：子集2与子集1的索引偏移量（fromIndex）</span></span><br><span class="line"><span class="comment">     * offset1：子集1与ArrayList的索引偏移量（offset）</span></span><br><span class="line"><span class="comment">     * offset：当前子集，也就是子集2与ArrayList的索引偏移量</span></span><br><span class="line"><span class="comment">     * offset2 + offset1 = offset</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子集的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent 调用者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> offset 当前子集与ArrayList的索引偏移量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fromIndex 子集的起始索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> toIndex 子集的结束索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SubList(AbstractList&lt;E&gt; parent,</span><br><span class="line">            <span class="keyword">int</span> offset, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex) &#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        <span class="keyword">this</span>.parentOffset = fromIndex;</span><br><span class="line">        <span class="keyword">this</span>.offset = offset + fromIndex;</span><br><span class="line">        <span class="keyword">this</span>.size = toIndex - fromIndex;</span><br><span class="line">        <span class="keyword">this</span>.modCount = ArrayList.<span class="keyword">this</span>.modCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定元素替换子集中的指定索引</span></span><br><span class="line"><span class="comment">     * 指定索引的大小是相对于子集，故而加上offset</span></span><br><span class="line"><span class="comment">     * 由于该方法并没有修改结构，故而直接调用ArrayList的对应方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 相对于子集的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 指定元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 旧元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        E oldValue = ArrayList.<span class="keyword">this</span>.elementData(offset + index);</span><br><span class="line">        ArrayList.<span class="keyword">this</span>.elementData[offset + index] = e;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取子集中指定索引对应的元素</span></span><br><span class="line"><span class="comment">     * 指定索引的大小是相对于子集，故而加上offset</span></span><br><span class="line"><span class="comment">     * 由于该方法并没有修改结构，故而直接调用ArrayList的对应方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 相对于子集的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 指定索引对应的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">return</span> ArrayList.<span class="keyword">this</span>.elementData(offset + index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取子集的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子集中指定索引上添加元素</span></span><br><span class="line"><span class="comment">     * 由于该方法修改了数组结构，故而先调用上层子集的add方法，若没有子集则直接是ArrayList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 相对于子集的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 添加的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        parent.add(parentOffset + index, e);</span><br><span class="line">        <span class="keyword">this</span>.modCount = parent.modCount;</span><br><span class="line">        <span class="keyword">this</span>.size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除子集中指定索引位置的元素</span></span><br><span class="line"><span class="comment">     * 由于该方法修改了数组结构，故而先调用上层子集的remove方法，若没有子集则直接是ArrayList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 相对于子集的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        E result = parent.remove(parentOffset + index);</span><br><span class="line">        <span class="keyword">this</span>.modCount = parent.modCount;</span><br><span class="line">        <span class="keyword">this</span>.size--;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除子集中指定索引范围的所有元素</span></span><br><span class="line"><span class="comment">     * 由于该方法修改了数组结构，故而先调用上层子集的removeRange方法，若没有子集则直接是ArrayList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fromIndex 相对于子集的起始索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> toIndex 相对于子集的结束索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        parent.removeRange(parentOffset + fromIndex,</span><br><span class="line">                           parentOffset + toIndex);</span><br><span class="line">        <span class="keyword">this</span>.modCount = parent.modCount;</span><br><span class="line">        <span class="keyword">this</span>.size -= toIndex - fromIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子集末尾上追加集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c 集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addAll(<span class="keyword">this</span>.size, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子集中指定索引上添加集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 相对于子集的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c 集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        <span class="keyword">int</span> cSize = c.size();</span><br><span class="line">        <span class="keyword">if</span> (cSize==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        checkForComodification();</span><br><span class="line">        parent.addAll(parentOffset + index, c);</span><br><span class="line">        <span class="keyword">this</span>.modCount = parent.modCount;</span><br><span class="line">        <span class="keyword">this</span>.size += cSize;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取子集迭代器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 子集迭代器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> listIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取子集列表迭代器</span></span><br><span class="line"><span class="comment">     * 列表迭代器中的元素是从指定索引开始到结束索引</span></span><br><span class="line"><span class="comment">     * 这里就不对子集列表迭代器中的方法做再次解释了，毕竟它跟ArrayList是类似的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 相对于子集的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表迭代器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="keyword">this</span>.offset;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListIterator&lt;E&gt;() &#123;</span><br><span class="line">            <span class="keyword">int</span> cursor = index;</span><br><span class="line">            <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> expectedModCount = ArrayList.<span class="keyword">this</span>.modCount;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cursor != SubList.<span class="keyword">this</span>.size;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                checkForComodification();</span><br><span class="line">                <span class="keyword">int</span> i = cursor;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= SubList.<span class="keyword">this</span>.size)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">                Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">                <span class="keyword">if</span> (offset + i &gt;= elementData.length)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                cursor = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> (E) elementData[offset + (lastRet = i)];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cursor != <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                checkForComodification();</span><br><span class="line">                <span class="keyword">int</span> i = cursor - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">                Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">                <span class="keyword">if</span> (offset + i &gt;= elementData.length)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                cursor = i;</span><br><span class="line">                <span class="keyword">return</span> (E) elementData[offset + (lastRet = i)];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span> </span>&#123;</span><br><span class="line">                Objects.requireNonNull(consumer);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> size = SubList.<span class="keyword">this</span>.size;</span><br><span class="line">                <span class="keyword">int</span> i = cursor;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">final</span> Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">                <span class="keyword">if</span> (offset + i &gt;= elementData.length) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">                    consumer.accept((E) elementData[offset + (i++)]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// update once at end of iteration to reduce heap write traffic</span></span><br><span class="line">                lastRet = cursor = i;</span><br><span class="line">                checkForComodification();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cursor;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cursor - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">                checkForComodification();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    SubList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">                    cursor = lastRet;</span><br><span class="line">                    lastRet = -<span class="number">1</span>;</span><br><span class="line">                    expectedModCount = ArrayList.<span class="keyword">this</span>.modCount;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">                checkForComodification();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ArrayList.<span class="keyword">this</span>.set(offset + lastRet, e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">                checkForComodification();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = cursor;</span><br><span class="line">                    SubList.<span class="keyword">this</span>.add(i, e);</span><br><span class="line">                    cursor = i + <span class="number">1</span>;</span><br><span class="line">                    lastRet = -<span class="number">1</span>;</span><br><span class="line">                    expectedModCount = ArrayList.<span class="keyword">this</span>.modCount;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (expectedModCount != ArrayList.<span class="keyword">this</span>.modCount)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取子集</span></span><br><span class="line"><span class="comment">     * 子集中又获取子集</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fromIndex 相对于子集的起始索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> toIndex 相对于子集的结束索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 子集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SubList(<span class="keyword">this</span>, offset, fromIndex, toIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验索引是否超出范围</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 相对于子集的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>.size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验索引是否超出范围</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 相对于子集的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="keyword">this</span>.size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 索引超出范围的错误信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 相对于子集的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 错误信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">outOfBoundsMsg</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Index: "</span>+index+<span class="string">", Size: "</span>+<span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验子集的结构修改次数是否与ArrayList一致</span></span><br><span class="line"><span class="comment">     * 若先获取子集后，接着在ArrayList上修改了结构，则会报错</span></span><br><span class="line"><span class="comment">     * 因为子集的modCount并没有随着ArrayList结构的修改而变化，导致了两个变量不一致</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ArrayList.<span class="keyword">this</span>.modCount != <span class="keyword">this</span>.modCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由于该方法涉及到另外一个接口，会另外新起一篇文章来讲解该内容，这里就不做阐述</span></span><br><span class="line"><span class="comment">     * 附上文章地址：http://zlia.tech/2019/07/19/explain-arraylist-spliterator-sourcecode/</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayListSpliterator&lt;E&gt;(ArrayList.<span class="keyword">this</span>, offset,</span><br><span class="line">                                           offset + <span class="keyword">this</span>.size, <span class="keyword">this</span>.modCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Arrays</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拷贝指定数组到新数组中，根据指定的长度缩短或使用null扩充新数组</span></span><br><span class="line"><span class="comment">     * 新数组与原始数组的数据类型是完全一样的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">        <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拷贝指定数组到新数组中，根据指定的长度缩短或使用null扩充新数组</span></span><br><span class="line"><span class="comment">     * 新数组的数据类型由入参newType决定</span></span><br><span class="line"><span class="comment">     * 判断入参newType是否是Ojbect[]类型</span></span><br><span class="line"><span class="comment">     * 若newType是Object[]类型，则创建一个长度为newLength的新数组，并向下转型为T[]类型</span></span><br><span class="line"><span class="comment">     * 若newType不是Object[]类型，则创建一个长度为newLength的新数组，但由于Array.newInstance返回值是Object，故而向下转型为T[]类型</span></span><br><span class="line"><span class="comment">     * Array.newInstance与System.arraycopy属于C底层代码，故而查看不了具体实现</span></span><br><span class="line"><span class="comment">     * System.arraycopye(param1, param2, param3, param4, param5)</span></span><br><span class="line"><span class="comment">     * param1：原始数组； param2：原始数组复制元素的起始角标； param3：新数组； param4：复制元素到新数组的起始角标处；param5：原始数组要从起始角标开始拷贝多少个元素到新数组</span></span><br><span class="line"><span class="comment">     * 从原始数组param1的角标为param2开始复制param5个元素，到新数组param3的角标为param4作为复制元素的起始点</span></span><br><span class="line"><span class="comment">     * 返回新数组，此时已经填充好数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * System.arraycopy性能趋势：当数组大小在百万到千万级别之间时所花费的时间差别不大，但是当达到亿级别后，所花费的时间就会差很多</span></span><br><span class="line"><span class="comment">     * 所以这也就导致了当数组容量达到亿级别后，手动调用ensureCapacity来预先设置容量大小所带来的效率比自动扩容的销量要低很多</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) <span class="keyword">new</span> Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">        System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>, Math.min(original.length, newLength));</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>写的内容有点过多，这里总结一下，方便获取<code>直接获取结果</code>！</p><ul><li><p>ArrayList允许存放Null。</p></li><li><p>ArrayList内部通过数组实现，大体上和Vector类似，除了是非线程安全。</p></li><li><p>ArrayList中的size、isEmpty、get、set、iterator、listIterator的时间复杂度是O(1)，而add操作的时间复杂度是O(n)。</p></li><li><p>由于ArrayList是非线程安全，所以多线程情况下要在外部控制线程安全或使用Collections.synchronizedList也行。</p></li><li><p>创建空参数的ArrayList对象时，默认的初始容量是10，当容量不足时，以1.5倍速度增长。</p></li><li><p>在构建ArrayList对象时，最好能预先设置容量大小，以免减少后期扩容花费的时间。</p></li><li><p>ArrayList容量的临界值是最大值 - 8，这个数字8是因为在数组中除了存储元素之外还会存储数组的长度，而这些数据都在内存中，不同操作系统对内存的分配可能有所差异，减去8更多的是为了防止内存溢出。</p></li><li><p>ArrayList的Iterator迭代器中的forEachRemaining方法只能调用一次，且在该方法中不能调用remove方法。</p></li><li><p>ArrayList的ListIterator迭代器可反向遍历列表。</p></li><li><p>在获取ArrayList的子集后不能在做结构上的修改。</p></li><li><p>获取迭代器后，不允许进行结构修改操作，因为会 expectedModCount 与 modCount 是否相等。</p></li><li><p>在遍历过程中不允许修改结构，否则会抛出错误。</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>默认每次自动扩容的关系是1.5倍</code> <code>非线程安全</code> <code>默认初始扩容值10</code> <code>get/set时间复杂度O(1)，add时间复杂度O(n)</code> <code>fail-fast</code> <code>底层是通过数组存储元素，故是有序可重复集合</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;想进步，想学习了，反正面试都要问的，还不如早点看了好。探索&lt;code&gt;ArrayList&lt;/code&gt;源代码是基于&lt;code&gt;JDK1.8&lt;/code&gt;版本的，相比以前的版本不知道有没有优化，毕竟没看过之前版本的底层代码。&lt;/p&gt;
&lt;h3 id=&quot;简单说明下&quot;&gt;&lt;a href=&quot;#简单说明下&quot; class=&quot;headerlink&quot; title=&quot;简单说明下&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;简单说明下&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;一般看底层代码前我都习惯先阅读下该类的&lt;code&gt;注释说明&lt;/code&gt;，也不知道在哪里养成的习惯。相信大家都写过应用代码，既然写过，那也深知注释对于一个使用者来说是多么的重要，决定了它是否能够正确的使用，所以这是一个好习惯。&lt;/p&gt;
&lt;h4 id=&quot;阅读注释&quot;&gt;&lt;a href=&quot;#阅读注释&quot; class=&quot;headerlink&quot; title=&quot;阅读注释&quot;&gt;&lt;/a&gt;阅读注释&lt;/h4&gt;&lt;p class=&quot;customize-img&quot;&gt;&lt;img src=&quot;/assets/blogImg/java/arraylist/arraylist-comment-1.png&quot; alt=&quot;ArrayList注释-1&quot;&gt;&lt;/p&gt;
&lt;p&gt;看到这不知道你们有没有很惊讶，反正我倒是一惊，所以我说看注释很重要！！！如果是你写代码给别人看，除了看具体代码之外，看注释就是最好的理解方式了，一语道破很多原理，要求不高的我都觉得可以不用看代码实现了，所以接下来会继续阅读注释。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Photoshop CC 2014 安装、破解、完全卸载</title>
    <link href="http://zlia.tech/2019/07/19/photoshop-knowledge-1/"/>
    <id>http://zlia.tech/2019/07/19/photoshop-knowledge-1/</id>
    <published>2019-07-19T14:43:22.000Z</published>
    <updated>2019-07-19T14:48:19.317Z</updated>
    
    <content type="html"><![CDATA[<h3 id="先下载在说"><a href="#先下载在说" class="headerlink" title="先下载在说"></a><div><span>先下载在说</span></div></h3><p>废话少说点，上个链接，先下载着在文章。<br><code>安装包下载地址</code>：<a href="https://pan.baidu.com/s/1jijJZpNanLOhZY_yNUJQww" target="_blank" rel="noopener">Photoshop CC 2014 64位安装包</a> 提取码：u3cm。<br><code>破解补丁</code>：<a href="https://pan.baidu.com/s/1r7AFcb32LrRrzWtJb9PD7A" target="_blank" rel="noopener">Photoshop CC 2014 补丁</a> 提取码：cz1c<br>现在都2019年了，为啥还是2014年的版本呢？好老啊！怪作者没有一点基础，有个版本先学着就不错了，莫怪莫怪！</p><a id="more"></a><h3 id="轻松卸载PS"><a href="#轻松卸载PS" class="headerlink" title="轻松卸载PS"></a><div><span>轻松卸载PS</span></div></h3><p>为什么写这个小主题呢？还是吃了没有经验的亏，还以为应该挺好破解的，没想到全程都不能联网，可惜我已经在装好的路上不能回头了，嗯…只好卸载了重新安装了。<br>我也是看了别人写的帖子，这边就不复制粘贴了，没啥意思，以下是<a href="http://www.sucaijishi.com/2016/articles_0318/135.html" target="_blank" rel="noopener">卸载方式</a>，亲测过，很好用，一次成功。<br>不知道该网站作者提供的卸载工具是不是永久有效的，反正我现在使用是可以的，以防万一我在提供个永久有效链接。<br><code>卸载工具地址</code>：<a href="https://pan.baidu.com/s/1mbBytXwsWTq2sUQnJKhpPw" target="_blank" rel="noopener">卸载工具</a> 提取码：19t5。<br>回头一想，万一我提供的网址保个500错误，那我这篇文章岂不是没用了，不行不行，要有它存在的价值，勉强复制下它的内容，哈哈哈。</p><ul><li><p>先像正常软件卸载方式一样卸载它。</p></li><li><p>在使用卸载工具前，先删除以下路径的文件夹：</p><ul><li>C:\Program Files (x86)\Common Files\Adobe</li><li>C:\Program Files\Common Files\Adobe</li><li>C:\ProgramData\Adobe 此目录默认为隐藏目录，先设置系统显示隐藏的文件</li></ul></li><li><p>接着下载卸载工具，这是解压后的目录结构，使用前请先关闭杀毒、卫士等软件。<br><img src="/assets/blogImg/essays/ps/ps-uninstall-tools.png" alt="卸载PS工具目录结构"></p></li></ul><p><code>注意：该卸载工具可以卸载photoshop多个版本，需要卸载哪个版本就选择哪个</code></p><ul><li>紧接着开始扣图了，就按照图片的顺序一一执行就OK了：</li></ul><p class="customize-img"><img src="/assets/blogImg/essays/ps/ps-uninstall-step-1.png" alt="卸载PS步骤-1"></p><p class="customize-img"><img src="/assets/blogImg/essays/ps/ps-uninstall-step-2.png" alt="卸载PS步骤-2"></p><p class="customize-img"><img src="/assets/blogImg/essays/ps/ps-uninstall-step-3.png" alt="卸载PS步骤-3"></p><p class="customize-img"><img src="/assets/blogImg/essays/ps/ps-uninstall-step-4.png" alt="卸载PS步骤-4"></p><p class="customize-img"><img src="/assets/blogImg/essays/ps/ps-uninstall-step-5.png" alt="卸载PS步骤-5"></p><p class="customize-img"><img src="/assets/blogImg/essays/ps/ps-uninstall-step-6.png" alt="卸载PS步骤-6"></p><p><code>清除成功后，别忘记了重启下电脑，这步是不可或缺的!</code>。</p><h3 id="安装与破解"><a href="#安装与破解" class="headerlink" title="安装与破解"></a><div><span>安装与破解</span></div></h3><p>不照搬别人的成果了，安装的文章有很多，这边提供一个<a href="https://ke.qq.com/course/60897?taid=151401892212193&amp;dialog=1" target="_blank" rel="noopener">安装视频链接</a>，该视频中提到的补丁工具我没找到，所以上面只能提供一个补丁，你把下载下来的<code>amtlib.dll</code>补丁放到你安装PS的目录，它会进行替换。</p><p class="customize-img"><img src="/assets/blogImg/essays/ps/ps-crack-patch.png" alt="替换文件"></p><p><code>怎么验证破解成功？当你重启PS时，不会在弹出30天试用期窗口时就代表成功了，恭喜你！</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;先下载在说&quot;&gt;&lt;a href=&quot;#先下载在说&quot; class=&quot;headerlink&quot; title=&quot;先下载在说&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;先下载在说&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;废话少说点，上个链接，先下载着在文章。&lt;br&gt;&lt;code&gt;安装包下载地址&lt;/code&gt;：&lt;a href=&quot;https://pan.baidu.com/s/1jijJZpNanLOhZY_yNUJQww&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Photoshop CC 2014 64位安装包&lt;/a&gt; 提取码：u3cm。&lt;br&gt;&lt;code&gt;破解补丁&lt;/code&gt;：&lt;a href=&quot;https://pan.baidu.com/s/1r7AFcb32LrRrzWtJb9PD7A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Photoshop CC 2014 补丁&lt;/a&gt; 提取码：cz1c&lt;br&gt;现在都2019年了，为啥还是2014年的版本呢？好老啊！怪作者没有一点基础，有个版本先学着就不错了，莫怪莫怪！&lt;/p&gt;
    
    </summary>
    
      <category term="essays" scheme="http://zlia.tech/categories/essays/"/>
    
    
      <category term="photoshop" scheme="http://zlia.tech/tags/photoshop/"/>
    
  </entry>
  
  <entry>
    <title>探索Integer.toBinaryString源码</title>
    <link href="http://zlia.tech/2019/06/25/explain-binary-code/"/>
    <id>http://zlia.tech/2019/06/25/explain-binary-code/</id>
    <published>2019-06-25T11:56:40.000Z</published>
    <updated>2019-06-25T12:02:55.531Z</updated>
    
    <content type="html"><![CDATA[<h3 id="不解驱动着你"><a href="#不解驱动着你" class="headerlink" title="不解驱动着你"></a><div><span>不解驱动着你</span></div></h3><p>一般情况下我是不会主动去看源码的，除非是写专门的主题或者是遇到不懂的难题。果然了，于是带着好奇心尝试理解下源码，一会我先抛出问题，要是有同学一下子就明白了那就可以不用往下看了！还有一个前提就是最好对原码、补码、反码有所了解，因为计算机操作的数据就是以二进制的形式存在的，准确的说是用补码的形式来计算的！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URShift</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(i));</span><br><span class="line"></span><br><span class="line">        i &gt;&gt;&gt;= <span class="number">10</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(i));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> l = -<span class="number">1</span>;</span><br><span class="line">        System.out.println(Long.toBinaryString(l));</span><br><span class="line"></span><br><span class="line">        l &gt;&gt;&gt;= <span class="number">10</span>;</span><br><span class="line">        System.out.println(Long.toBinaryString(l));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">short</span> s = -<span class="number">1</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(s));</span><br><span class="line"></span><br><span class="line">        s &gt;&gt;&gt;= <span class="number">10</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(s));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span> b = -<span class="number">1</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(b));</span><br><span class="line"></span><br><span class="line">        b &gt;&gt;&gt;= <span class="number">10</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11111111111111111111111111111111</span></span><br><span class="line"><span class="number">1111111111111111111111</span></span><br><span class="line"><span class="number">1111111111111111111111111111111111111111111111111111111111111111</span></span><br><span class="line"><span class="number">111111111111111111111111111111111111111111111111111111</span></span><br><span class="line"><span class="number">11111111111111111111111111111111</span></span><br><span class="line"><span class="number">11111111111111111111111111111111</span></span><br><span class="line"><span class="number">11111111111111111111111111111111</span></span><br><span class="line"><span class="number">11111111111111111111111111111111</span></span><br></pre></td></tr></table></figure><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a><div><span>源码</span></div></h3><p><code>Integer.toBinaryString</code>内部实现的方法主要有两个：<code>numberOfLeadingZeros</code> <code>formatUnsignedInt</code>，剩下的就无关紧要了，所以接下来的内容主要围绕着两个方法来讲。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberOfLeadingZeros</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;&gt;&gt; <span class="number">16</span> == <span class="number">0</span>) &#123; n += <span class="number">16</span>; i &lt;&lt;= <span class="number">16</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;&gt;&gt; <span class="number">24</span> == <span class="number">0</span>) &#123; n +=  <span class="number">8</span>; i &lt;&lt;=  <span class="number">8</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;&gt;&gt; <span class="number">28</span> == <span class="number">0</span>) &#123; n +=  <span class="number">4</span>; i &lt;&lt;=  <span class="number">4</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;&gt;&gt; <span class="number">30</span> == <span class="number">0</span>) &#123; n +=  <span class="number">2</span>; i &lt;&lt;=  <span class="number">2</span>; &#125;</span><br><span class="line">    n -= i &gt;&gt;&gt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始之前在复习下计算机的原码、补码、反码的相关计算，举个简单的例子。</p><table><thead><tr><th style="text-align:center">数值</th><th style="text-align:center">原码</th><th style="text-align:center">反码</th><th style="text-align:center">补码</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0000 0000 0000 0000 0000 0000 0000 0001</td><td style="text-align:center">0000 0000 0000 0000 0000 0000 0000 0001</td><td style="text-align:center">0000 0000 0000 0000 0000 0000 0000 0001</td></tr><tr><td style="text-align:center">-1</td><td style="text-align:center">1000 0000 0000 0000 0000 0000 0000 0001</td><td style="text-align:center">1111 1111 1111 1111 1111 1111 1111 1110</td><td style="text-align:center">1111 1111 1111 1111 1111 1111 1111 1111</td></tr></tbody></table><p>为了方便理解，我们采用假设的方式来引导读者。针对<code>numberOfLeadingZeros</code>方法假设入参<code>i = 1</code>，以下分多个步骤来分析该方法，在分析方法之前先跟读者说下该方法的主要作用是：<code>获取该二进制从左侧开始数连续0的个数</code>，有了这个个数就能构建数组的大小去存储有效的数据，二进制中前置位为0的话是不会存储的。</p><ul><li><p>① 判断i是否等于0，结果很明显，此时<code>i = 1，n = 1</code>；</p></li><li><p>② 判断i左移16位后是否等于0，计算如下：</p></li></ul><table><thead><tr><th style="text-align:center">数值</th><th style="text-align:center">计算前</th><th style="text-align:center">移位</th><th style="text-align:center">计算后</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0000 0000 0000 0000 0000 0000 0000 0001</td><td style="text-align:center">左移16</td><td style="text-align:center">0000 0000 0000 0000 0000 0000 0000 0000</td></tr></tbody></table><p>很显然，结果是等于0，故此时<code>n = 17</code>，而i又做了计算，如下：</p><table><thead><tr><th style="text-align:center">数值</th><th style="text-align:center">计算前</th><th style="text-align:center">移位</th><th style="text-align:center">计算后</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0000 0000 0000 0000 0000 0000 0000 0001</td><td style="text-align:center">右移16</td><td style="text-align:center">0000 0000 0000 0001 0000 0000 0000 0000</td></tr></tbody></table><ul><li><p>③ <code>不管是byte还是short类型，它们在移位之前都会被转换成int类型，再进行计算，所以它们的位数也是32位</code>。好奇的地方来了，为啥要左移16位呢，而相等后又要右移16位呢？一开始我也不太懂要这么做，后面看了一片文章觉得应该跟算法有关系，准确的说用的是<code>二分法</code>，就比如有10位数字，利用10位的一半5来做为开头，而后做完逻辑后又取剩下位数的一半来继续做逻辑运算，直接结束。有了以上的两个前提，所以先左移16位，若等于0的话，则说明该二进制左侧<code>至少有连续的16个0</code>，相当于32位中的前16位已经计算好了，接下来就应该计算剩下的16位，因为目前连续的0个数是至少有16位，还有剩下16位不知道情况，所以有可能有更多的0连续。那么问题来了，怎么才能知道后16位的情况呢？准确的来说应该是怎么知道后16位有多少个连续0，这就很明确了，直接计算后16位等于多少不就可以知道结果了吗？是的，就是这么回事，利用二分法，应该是后16位中取前8位来计算，也就是 0000 0000 0000 0000 <u>0000 0000</u> 0000 0001 计算下划线的数字中包含几位连续的0，一般想的话直接会把上面下划线中的数字直接右移8位即可得到结果，可以是可以，只不过写的代码会有很多重复，你要判断多个if-else，而if里头又有if-else，看着很恶心，所以还是算法吊，这边的右移16位是为了跟下一个判断做一个对应。</p></li><li><p>④ 判断i左移24位后是否等于0，相当于计算上面提到的下划线中的数据内容，计算如下：</p></li></ul><table><thead><tr><th style="text-align:center">数值</th><th style="text-align:center">计算前</th><th style="text-align:center">移位</th><th style="text-align:center">计算后</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0000 0000 0000 0001 0000 0000 0000 0001</td><td style="text-align:center">右移24</td><td style="text-align:center">0000 0000 0000 0000 0000 0000 0000 0000</td></tr></tbody></table><p>结果等于0，此时<code>n = 25</code>,而i又做了计算，如下：</p><table><thead><tr><th style="text-align:center">数值</th><th style="text-align:center">计算前</th><th style="text-align:center">移位</th><th style="text-align:center">计算后</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0000 0000 0000 0001 0000 0000 0000 0001</td><td style="text-align:center">右移24</td><td style="text-align:center">0000 0001 0000 0000 0000 0000 0000 0000</td></tr></tbody></table><p>相当于准备要计算最后的8位了，那么就看下一个判断语句了。</p><ul><li><p>⑤ 判断i左移28位，这边就不在一一做运算了，结果<code>n = 29</code>。</p></li><li><p>⑥ 判断i左移30，结果<code>n = 31</code>。</p></li></ul><table><thead><tr><th style="text-align:center">数值</th><th style="text-align:center">结果值</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0100 0000 0000 0000 0000 0000 0000 0000</td></tr></tbody></table><ul><li>⑦ 计算 n = n - i &gt;&gt;&gt; 31，i右移31位后等于0，所以n最终等于31位，刚好说明从左侧开始有连续的31个0。</li></ul><p>接下来讨论另外一个方法<code>formatUnsignedInt</code>，紧接着上面假设后得出的结果，所以<code>mag = 1</code>，表示该数值的有效位是1位，故将会构建长度为1的数组，对于任意数据，最小的长度就是1，而对于最大的长度就要看具体的数值了。好了，<code>formatUnsignedInt</code>方法中入参为<code>val = 1, shift = 1, buf = new char[1], offset = 0, len = 1</code>。在分析之前先说下该方法的主要作用，其实也没啥可说的，就是<code>将数组解析成二进制后并放入到数组中</code>。</p><ul><li><p>① <code>charPos = 1</code>表示有效位的个数，<code>radix = 2</code>表示要转换成二进制的基数，若是要转换后八进制，则radix=8,同理，十六进制radix=16，不过你们也知道二进制的数只有0、1，同理就不阐述其他进制了，<code>mask = 1</code>,一般我们要将十进制转换成其他进制的话，只需要&amp;(与)上对应的进制基数即可得到结果，就好比是八进制的话就&amp;7、十六进制的话就&amp;15，这是最快得到十六进制表示的数值。</p></li><li><p>② 由于要将数组转换成二进制，故&amp;1，根据得到的索引值查找数组当中对应的某个值，然后在数组的最高位上进行存储，相当于越低位应该放在越高位上，正好与二进制的格式相对应，相信不难理解。</p></li><li><p>③ 计算完上一个数后，开始右移动，对于八进制的话应该是右移3位，因为3位数表示1位八进制，同理，对于十六进制应该是右移4位，因为4位数表示1位十六进制，这边是二进制，故右移1位。</p></li><li><p>④ 判断移位后数值是否等于0，毕竟等于0的话咱们就没必要计算了，所以结果会依次循环计算该数值并移位，直到最后。</p></li><li><p>⑤ 每次计算都是把计算结果放到数组当中去，所以<code>buf</code>就是最后的结果，最后在将其转成字符串输出。</p></li></ul><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a><div><span>结束语</span></div></h3><p>源码在适当的情况下还是需要去看的，笔者正在一步一步往这里靠近，努力加强自己的硬实力！加油自己，加油每一个人！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;不解驱动着你&quot;&gt;&lt;a href=&quot;#不解驱动着你&quot; class=&quot;headerlink&quot; title=&quot;不解驱动着你&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;不解驱动着你&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;一般情况下我是不会主动去看源码的，除非是写专门的主题或者是遇到不懂的难题。果然了，于是带着好奇心尝试理解下源码，一会我先抛出问题，要是有同学一下子就明白了那就可以不用往下看了！还有一个前提就是最好对原码、补码、反码有所了解，因为计算机操作的数据就是以二进制的形式存在的，准确的说是用补码的形式来计算的！&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;URShift&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(Integer.toBinaryString(i));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        i &amp;gt;&amp;gt;&amp;gt;= &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(Integer.toBinaryString(i));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; l = -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(Long.toBinaryString(l));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        l &amp;gt;&amp;gt;&amp;gt;= &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(Long.toBinaryString(l));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;short&lt;/span&gt; s = -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(Integer.toBinaryString(s));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        s &amp;gt;&amp;gt;&amp;gt;= &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(Integer.toBinaryString(s));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt; b = -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(Integer.toBinaryString(b));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        b &amp;gt;&amp;gt;&amp;gt;= &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(Integer.toBinaryString(b));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>每日知识点20181212</title>
    <link href="http://zlia.tech/2019/06/25/thinking-in-java-knowledge-20190609/"/>
    <id>http://zlia.tech/2019/06/25/thinking-in-java-knowledge-20190609/</id>
    <published>2019-06-25T11:52:32.000Z</published>
    <updated>2019-09-02T16:07:18.078Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java"><a href="#java" class="headerlink" title="java"></a><div><span>java</span></div></h3><ul><li><p>javadoc只能为public和protected成员进行文档注释，private和默认权限的注释则会被忽略掉，不过可以用-private进行标记，以便把private成员的注释耶包括在内.</p></li><li><p>int x = Character.digit(‘c’, 16)：是把16进制的c转为10进制，结果是12，16进制中a、b、c、d、e、f分别代表10、11、12、13、14、15.</p></li><li><p>计算机中计算都是采用补码计算的。在计算机中的机器字长的最高位表示正负，0为正数，1为负数。正数的原码、反码和补码都一样，都等于原码。负数的反码就是在原码的基础上符号位不变其余位按位取反，负数的补码就是在反码的基础上+1.值得注意的是，计算机将数值10000000表示为最大负数-128.推荐大家看下为什么计算机中要采用补码来储存数据，这是我搜索当中觉得不错的一篇文章-<a href="https://blog.csdn.net/weixin_44734925/article/details/88432355" target="_blank" rel="noopener">为什么计算机采用补码形式进行数据的表示</a>.</p></li><li><p>对于byte或short值进行移位运算，得到的可能不是正确的结果。它们会被转换成int类型，在进行移位操作，然后被<code>截断</code>，赋值给原来的类型.如short i = -1; i &gt;&gt;&gt;= 10; 因为i是short类型，所以会被截断，最终的结果是-1.</p></li><li><p>Math.round：四舍五入.</p></li><li><p>如果在返回void的方法中没有return语句，那么在该方法的结尾处会有一个隐式的return.</p></li><li><p>对于一类中的成员最好使用private访问权限修饰符。若你直接让外部类去访问该属性，有一天如果想要改变获取该属性的方式，那外部类岂不是也要跟着修改，所以最好的方式是用private修改该属性，同时提供具有public修饰符的方法，该方法主要用来获取该属性，至于怎么获取就是你说了算，外部类只要调用该方法即可，即使哪一天获取属性的方式变化了，也只需要修改方法的内部代码即可，外部类的调用方法还是不变.</p></li></ul><a id="more"></a><ul><li><p>当实现某个接口时，并不需要实现嵌套在其内部的任何接口.</p></li><li><p>当某个外围类的对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用.</p></li><li><p>看到这个程序的时候一开始我是不能理解的，后面仔细想想好像很有道理！先不用管为什么要这么写，看就完事了！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> a;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> B b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name);<span class="comment">//compile ok</span></span><br><span class="line">        System.out.println(b.name);<span class="comment">//compile error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> b;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>一开始我想着没问题啊，怎么会报错呢？后面一想想，这是两个事情啊！不能混为一谈.<code>name</code>是在访问A类中的变量，按照<code>protected</code>权限来说是可以访问的，但是对于另外一个对象<code>b</code>自身来说，若是在该类里面去访问name是没问题的，但是借助其他类来访问b对象，让b对象去访问name是不可取的，因为A类与b对象没有任何的关系，<code>b.name</code>就是去访问b类中的name变量，不好意思，它只对子类或同包访问，而A类都不是，可以考虑下若b = new C()，而C类正好继承B，这种多态场景下是不是更好理解一些.</p><ul><li><code>高级for循环</code>，只要是<code>实现了Iterable</code>类都可以使用高级for循环，实际上它底层是调用的迭代器的<code>hasNext</code>与<code>next</code>方法，当然这些是编译器帮你做的，不用我们操心了，于是我又很好奇的尝试了数组，不知道它底层有没有实现Iterable，因为它也是可以使用高级for循环，结果不太一样，也是编译器帮你做的，只不过是假的高级for循环，最终被编译成了普通的for循环了.</li></ul><p class="customize-img"><img src="/assets/blogImg/daliy-konwledge-point/20190812/for-1.png" alt="高级for-1"></p><p>很简单，以上是源码.</p><p class="customize-img"><img src="/assets/blogImg/daliy-konwledge-point/20190812/for-2.png" alt="高级for-1"></p><p>以上是编译后的字节码文件，不信你编一个试试.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java&quot;&gt;&lt;a href=&quot;#java&quot; class=&quot;headerlink&quot; title=&quot;java&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;java&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;javadoc只能为public和protected成员进行文档注释，private和默认权限的注释则会被忽略掉，不过可以用-private进行标记，以便把private成员的注释耶包括在内.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;int x = Character.digit(‘c’, 16)：是把16进制的c转为10进制，结果是12，16进制中a、b、c、d、e、f分别代表10、11、12、13、14、15.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;计算机中计算都是采用补码计算的。在计算机中的机器字长的最高位表示正负，0为正数，1为负数。正数的原码、反码和补码都一样，都等于原码。负数的反码就是在原码的基础上符号位不变其余位按位取反，负数的补码就是在反码的基础上+1.值得注意的是，计算机将数值10000000表示为最大负数-128.推荐大家看下为什么计算机中要采用补码来储存数据，这是我搜索当中觉得不错的一篇文章-&lt;a href=&quot;https://blog.csdn.net/weixin_44734925/article/details/88432355&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;为什么计算机采用补码形式进行数据的表示&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于byte或short值进行移位运算，得到的可能不是正确的结果。它们会被转换成int类型，在进行移位操作，然后被&lt;code&gt;截断&lt;/code&gt;，赋值给原来的类型.如short i = -1; i &amp;gt;&amp;gt;&amp;gt;= 10; 因为i是short类型，所以会被截断，最终的结果是-1.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Math.round：四舍五入.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果在返回void的方法中没有return语句，那么在该方法的结尾处会有一个隐式的return.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于一类中的成员最好使用private访问权限修饰符。若你直接让外部类去访问该属性，有一天如果想要改变获取该属性的方式，那外部类岂不是也要跟着修改，所以最好的方式是用private修改该属性，同时提供具有public修饰符的方法，该方法主要用来获取该属性，至于怎么获取就是你说了算，外部类只要调用该方法即可，即使哪一天获取属性的方式变化了，也只需要修改方法的内部代码即可，外部类的调用方法还是不变.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="daily-konwledge-point-java" scheme="http://zlia.tech/tags/daily-konwledge-point-java/"/>
    
  </entry>
  
  <entry>
    <title>推荐初级程序员书单</title>
    <link href="http://zlia.tech/2019/06/08/primary-programmer-book-list/"/>
    <id>http://zlia.tech/2019/06/08/primary-programmer-book-list/</id>
    <published>2019-06-08T07:02:17.000Z</published>
    <updated>2019-06-25T11:50:50.142Z</updated>
    
    <content type="html"><![CDATA[<h3 id="有点菜"><a href="#有点菜" class="headerlink" title="有点菜"></a><div><span>有点菜</span></div></h3><p>嗯…怎么说好呢？由于笔者自我认为还是个初级程序员，所以以下的内容基本上是围绕着我个人的经历来写的。笔者毕业两年了，看过的书籍不是很多，因为刚出来的时候也像你们一样在百度上搜索着程序员书单之类的关键词，然后一一列举下来，做的好一点的呢会去看看书单中每一本书的目录都包含什么及收集一些看过这些书的人的观点，不适合自己的当然是果断排除点！如今自己也看了几本书，觉得都还可以，只不过是针对<code>初级程序员</code>，当然这只是目前情况，笔者还在学习，陆陆续续也会推荐更多的书单介绍。</p><a id="more"></a><h3 id="入门级别"><a href="#入门级别" class="headerlink" title="入门级别"></a><div><span>入门级别</span></div></h3><p>由于笔者对<code>java8</code>有很大的浓厚兴趣，所以我的第一本书籍就是<code>Java核心技术 卷1</code>，市面上有讲java8的书籍应该不是很多吧。这本书的大致内容都是围绕着基础知识来讲，同时涵盖了一些java8的知识内容，比较适合入门不久的同学，遗憾的是对于数据结构这方面的知识只是点到为止，简单介绍而已，这方面的知识不应该也是属于核心技术吗？这我就不懂了，还专门写了swing这块的知识，我直接跳过了，个人觉得知识点不是很重要的块最好可以跳过以免浪费时间，既然看完了卷1，那顺便把卷二也看了吧，哈哈。卷二说实话没有卷一写的好，前面的知识讲的倒一般般，java8 stream的各种使用，后面讲的内容很繁琐，连续跳过了好几个章节，而且给我的感觉是讲的内容很老，当然了，这毕竟是几年前的书了，也难怪！</p><h3 id="入门增强"><a href="#入门增强" class="headerlink" title="入门增强"></a><div><span>入门增强</span></div></h3><p>所谓的入门增强就是在你了解基础知识后进一步的巩固加强它，比如一些原理性的知识能够很大程度的帮助你理解，如果这方面你掌握的很好以后对于框架层源码方面的理解会更容易理解，并且很多公司都注重基础知识，程序员强不强不是看他懂了几个框架，而是你的基础知识，原理性的东西才是最牛逼的，所以笔者一直在各种巩固自己这方面的知识，目前正在看的书籍是<code>java编程思想</code>，具备了前面的基础知识，看这本书会比较容易，该书多数以理论知识来讲解，代码内容不多，更注重于原理方面的知识，非常建议同学去看，只不过可惜的是没有讲到java8，唉，毕竟java8不论是在效率上还是安全性上都增强了，但是具体的理论知识我是想知道的！</p><h3 id="未读书籍"><a href="#未读书籍" class="headerlink" title="未读书籍"></a><div><span>未读书籍</span></div></h3><p>上面提到的书最好能理解透了在过，不然效果没那么明显，或者可以选择看第二遍。以下介绍的书单虽然我还没有看过，但是都是做过功课筛选出来的，罪过罪过。</p><ol><li><code>大话设计模式</code>：重复代码敲多了难免会觉得没意思，来点高大上的代码设计才能冲击你的成就感。</li><li><code>重构改善既有代码的设计</code>：光看这本书的名字就觉得应该很吊，哈哈哈。</li><li><code>数据结构与算法</code>：数据结构这方面的知识一定要下功夫。</li><li><code>java并发编程实战</code>：一样，下功夫吧。</li><li>未完待续。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;有点菜&quot;&gt;&lt;a href=&quot;#有点菜&quot; class=&quot;headerlink&quot; title=&quot;有点菜&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;有点菜&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;嗯…怎么说好呢？由于笔者自我认为还是个初级程序员，所以以下的内容基本上是围绕着我个人的经历来写的。笔者毕业两年了，看过的书籍不是很多，因为刚出来的时候也像你们一样在百度上搜索着程序员书单之类的关键词，然后一一列举下来，做的好一点的呢会去看看书单中每一本书的目录都包含什么及收集一些看过这些书的人的观点，不适合自己的当然是果断排除点！如今自己也看了几本书，觉得都还可以，只不过是针对&lt;code&gt;初级程序员&lt;/code&gt;，当然这只是目前情况，笔者还在学习，陆陆续续也会推荐更多的书单介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="essays" scheme="http://zlia.tech/categories/essays/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>每日知识点20190415</title>
    <link href="http://zlia.tech/2019/05/30/core-java-knowledge-20190415/"/>
    <id>http://zlia.tech/2019/05/30/core-java-knowledge-20190415/</id>
    <published>2019-05-30T15:21:44.000Z</published>
    <updated>2019-08-29T00:26:29.038Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java"><a href="#java" class="headerlink" title="java"></a><div><span>java</span></div></h3><ul><li><p>String v = map.putIfAbsent(“a”, “1”)：若map中不存在指定的key值(a)，则使用指定的key(a)和指定的value(1)进行填充，但此时返回的数据是<code>旧值</code>，所以是null，即v=null，当你真正调用map.get(“a”)时才返回指定的value值，即1.</p></li><li><p>String v = map.computeIfAbsent(“a”, “1”)：若map中不存在指定的key值(a)，则使用指定的key(a)和指定的value(1)进行填充，但此时返回的数据是<code>新值</code>，即v=1.</p></li><li><p>DateTimeFormatter.parse()：可以解析LocalDate、LocalTime、LocalDateTime.</p></li><li><p>MessageFormat：消息格式化，如MessageFormat.format(“hi, my name is {0}”, “zhangsan”)，不仅如此，占位符后面还可以跟一个类型和一个风格，它们之间用逗号隔开.单独将choice拿出来先讲讲，{1,choice,0#no house| 1#one hose | 2#two houses}，一个选择格式是由一个序列对构成的，每一个对包括一个<code>下限</code>和一个<code>格式字符串</code>，下面的列表中是其他的类型.</p></li></ul><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">风格</th></tr></thead><tbody><tr><td style="text-align:center">number</td><td style="text-align:center">integer、currency、percent、$</td></tr><tr><td style="text-align:center">time/date</td><td style="text-align:center">short、medium、long、full、yyyy-MM-dd</td></tr></tbody></table><ul><li>注解中的所有元素值必须是编译期常量.</li></ul><a id="more"></a><ul><li><p>Cannot annotate class literal、Cannot annotate import.</p></li><li><p>注解类型有：基本类型、String、Class、enum类型、注解类型、有前面所述类型组成的数组.</p></li><li><p>引导类加载器负责加载系统类，通常是用C语言来实现的.</p></li><li><p>扩展类加载器用于加载jre/lib/ext目录，即使没有配置任何类路径，它也可以找到其中的各个类.</p></li><li><p>系统类加载器用于加载应用类，查找类路径中的目录或者jar/zip文件里查找这些类.</p></li><li><p>对泛型上下限的理解：<br>  先说个前提，在类型参数确定的情况是可以add具体的对象及子类，个人理解而已.<br>  假设： 苹果 extends 水果、香蕉 extends 水果、其他<br>  <code>? extends 水果</code>：可以指定类型参数为<code>水果或水果的子类</code>，所以<code>类型参数可能是水果也可能是苹果也可能是香蕉</code>，不能确定具体的类型参数，更别说要添加什么类型的对象了，所以是不允许add操作，但是不管类型参数是什么，总之它就是水果，水果是它的最大类型参数，得出结论<code>该语句不能add，但是可以确定返回值是水果</code>.<br>  <code>? super 水果</code>：可以指定类型参数为<code>水果或水果的父类或Object</code>，因为编译器不知道你传入的类型参数是什么，所以不能add水果的父类，否则很容易造成类型参数与值不匹配，但至少有一点是确定的，不管你传入的类型参数是什么，它的子类都有水果，所以不管你传入的类型参数是什么，它都可以添加水果及水果的子类，毕竟水果是确定的一个最小类型参数，但是对于返回值就要看最大类型参数，那就是Object，得出结论<code>该语句能add指定类型参数及子类，但是返回值是Object</code>.<br>  无意中想到的一个快速理解的语句：<code>能不能add看最小类型参数确定没，就能add，没确定就不能，返回值是什么看最大类型参数是什么那返回值就是什么</code>.</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java&quot;&gt;&lt;a href=&quot;#java&quot; class=&quot;headerlink&quot; title=&quot;java&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;java&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;String v = map.putIfAbsent(“a”, “1”)：若map中不存在指定的key值(a)，则使用指定的key(a)和指定的value(1)进行填充，但此时返回的数据是&lt;code&gt;旧值&lt;/code&gt;，所以是null，即v=null，当你真正调用map.get(“a”)时才返回指定的value值，即1.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;String v = map.computeIfAbsent(“a”, “1”)：若map中不存在指定的key值(a)，则使用指定的key(a)和指定的value(1)进行填充，但此时返回的数据是&lt;code&gt;新值&lt;/code&gt;，即v=1.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;DateTimeFormatter.parse()：可以解析LocalDate、LocalTime、LocalDateTime.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MessageFormat：消息格式化，如MessageFormat.format(“hi, my name is {0}”, “zhangsan”)，不仅如此，占位符后面还可以跟一个类型和一个风格，它们之间用逗号隔开.单独将choice拿出来先讲讲，{1,choice,0#no house| 1#one hose | 2#two houses}，一个选择格式是由一个序列对构成的，每一个对包括一个&lt;code&gt;下限&lt;/code&gt;和一个&lt;code&gt;格式字符串&lt;/code&gt;，下面的列表中是其他的类型.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;类型&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;风格&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;number&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;integer、currency、percent、$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;time/date&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;short、medium、long、full、yyyy-MM-dd&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;注解中的所有元素值必须是编译期常量.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="daily-konwledge-point-java" scheme="http://zlia.tech/tags/daily-konwledge-point-java/"/>
    
  </entry>
  
  <entry>
    <title>每日知识点20190226</title>
    <link href="http://zlia.tech/2019/04/14/core-java-knowledge-20190226/"/>
    <id>http://zlia.tech/2019/04/14/core-java-knowledge-20190226/</id>
    <published>2019-04-14T05:02:06.000Z</published>
    <updated>2019-04-15T02:58:41.968Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java"><a href="#java" class="headerlink" title="java"></a><div><span>java</span></div></h3><ul><li><p>java Test &lt; 1.txt表示将1.txt中的内容作为其前面命令的输入.</p></li><li><p>java Test &gt; 1.txt表示将Test的结果输出到1.txt中.</p></li><li><p>双端队列，可以在头部和尾部添加或删除元素，但不支持在队列中间添加元素.</p></li><li><p>coll1.retainAll(coll2)：会从coll1中删除所有未在coll2中出现的元素.</p></li><li><p>方法引用所引用的方法的参数列表必须要和函数式接口中抽象方法的参数列表相同（完全一致），构造引用也是如此.</p></li><li><p>方法引用所引用的方法的的返回值必须要和函数式接口中抽象方法的返回值相同（完全一致），构造引用也是如此.</p><a id="more"></a></li><li><p>Optional作用：它在值不存在的情况下会使用替代物，而只有值存在的情况下才会使用这个值.</p></li><li><p>大家都推荐看核心技术卷1和卷2，为啥我觉得写的不是很通俗易懂呢？很多知识点的内容并没有讲的很明确，比如泛型、通配符这块。</p></li><li><p>对象序列化时序列号的作用是为了标识之前保存过的对象。如一个带有序列号为1的对象之前就被序列化过，那么另外的对象引用了该对象，此时只要在其中保存该对象的序列号即可，就可以引用到该对象.</p></li><li><p>Path类中的normalize方法将移除所有冗余的.和..部件。例如：规范化后/home/cay/../fred/./myprog将产生/home/cay/fred/myprog.</p></li><li><p>通过cmd命令来打包java程序时，可通过jar cvfe TestDemo.jar TestDemo TestDemo.class的方式完成，加上<code>e</code>参数可以在MANIFEST.MF文件中加入<code>Main-Class</code>来指定执行jar包时运行的类，俗称启   动类，如运行java -jar TestDemo.jar时，则会自动去跑TestDemo这个类.</p></li><li><p>p.resolve(q)按照下列规则返回一个路径：</p><ul><li>如果q是绝对路径，则结果就是q.</li><li>否则，根据文件系统的规则，将p后面跟着q作为结果.</li></ul></li><li><p>p.resolveSibling(q)：通过解析指定路径的父路径产生其兄弟路径.</p></li><li><p>Files.createDirectory(path)：其中，路径中除最后一个部件外，其他部分都必须是已存在的。要创建路径中的中间目录，应该使用Files.createDirectories(path).</p></li><li><p>内存映射文件：将一个文件或文件的一部分映射到内存中，然后这个文件就可以当作是内存数组一样地访问，比传统的文件操作要快很多.</p></li><li><p>buffer.flip()是将写模式转成读模式.</p></li><li><p>channel.lock()、channel.tryLock()：第一个调用会阻塞直至可获得锁，而第二个调用将立即返回，要么返回锁，要么在锁不可获得的情况下返回null.</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java&quot;&gt;&lt;a href=&quot;#java&quot; class=&quot;headerlink&quot; title=&quot;java&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;java&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;java Test &amp;lt; 1.txt表示将1.txt中的内容作为其前面命令的输入.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;java Test &amp;gt; 1.txt表示将Test的结果输出到1.txt中.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;双端队列，可以在头部和尾部添加或删除元素，但不支持在队列中间添加元素.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;coll1.retainAll(coll2)：会从coll1中删除所有未在coll2中出现的元素.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;方法引用所引用的方法的参数列表必须要和函数式接口中抽象方法的参数列表相同（完全一致），构造引用也是如此.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;方法引用所引用的方法的的返回值必须要和函数式接口中抽象方法的返回值相同（完全一致），构造引用也是如此.&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="daily-konwledge-point-java" scheme="http://zlia.tech/tags/daily-konwledge-point-java/"/>
    
  </entry>
  
  <entry>
    <title>我叫Spi，新成员</title>
    <link href="http://zlia.tech/2019/04/14/explain-spi-knowledge/"/>
    <id>http://zlia.tech/2019/04/14/explain-spi-knowledge/</id>
    <published>2019-04-14T05:01:40.000Z</published>
    <updated>2019-06-08T06:12:29.709Z</updated>
    
    <content type="html"><![CDATA[<h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a><div><span>自我介绍</span></div></h3><p>Spi，Service Provider Interface，是java提供的一套用来被第三方实现或扩展的API，它可以用来启用框架扩展或替换相应的组件。简单来说就是我提供标准，你按照我的标准提供实现就可以了，当然了，这个实现可以是可以有多个，你想选择哪个都可以，不过前提是你要知道所有的实现才能选择，这操作属于java中的策略模式，而所有的实现都被放在一个配置文件中，所以Spi基本上就是一个<code>接口</code> + <code>策略模式</code> + <code>配置文件</code>组合而成的动态加载机制。在面向对象的设计里，模块之间基于接口编程，模块之间不对实现类硬编码，在不同的场景下需要动态的指明实现类，这就需要一个服务发现的机制，Spi提供这样子的一个机制，为某个接口寻找服务实现的机制，将硬编码移到程序之外，也就是配置文件中，Spi的核心思想就是<code>解耦</code>。<a id="more"></a></p><h3 id="模拟Spi"><a href="#模拟Spi" class="headerlink" title="模拟Spi"></a><div><span>模拟Spi</span></div></h3><p>既然是标准，那么肯定有一些必须要遵守的规范：</p><ol><li>定义服务接口与服务接口的实现类，若是jar包则要在jar包的META-INF/services目录下创建一个以<code>接口全限定名</code>为文件名的文本文件，该文本文件的内容即<code>服务接口实现类的全限定名</code>。</li><li>该jar包记得加入到classpath中。</li><li>服务接口的实现类必须有一个不带参数的构造方法，即默认的构造方法。</li></ol><p>接下来看几个截图，具体的代码实现已经上传到github上了，有兴趣的读者可以看看，菜鸟级别的水平不要见怪！</p><p class="customize-img"><img src="/assets/blogImg/essays/spi/example-spi-1.png" alt="Spi例子-1"></p><p><code>请注意</code>，创建META-INF/service目录后最好看一下目录结构，<code>META-INF是一个目录，而service是它的子目录，这不是只有一层目录</code>，当时就被自己给坑了。</p><p class="customize-img"><img src="/assets/blogImg/essays/spi/example-spi-2.png" alt="Spi例子-2"></p><p>看了以上的内容咱们顺便在说下Spi的优缺点，不对，优点就是一开始说的解耦，将业务代码分离，简单说下缺点吧。看到上面的截图中采用的是ServiceLoader类来加载实现类，源码当中采用的是懒加载的方式，只有当我们去遍历配置文件中的实现类时才会一一实例化，缺点很明显，<code>只能通过遍历的方式去获取每个实现类，若你不想用某个实现类，它最终还是会被实例化，这势必造成了资源的浪费</code>，没有提供通过传入某个参数来获取到指定的实现类，不够灵活。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><div><span>总结</span></div></h3><p>网上有人说很多框架当中使用了Spi机制，比如JDBC加载不同的类型数据库的驱动、不同的日志实现类、Dubbo，虽然这些我都没有看过，但解耦是每个程序都需要的，这也奠定了Spi的重要性。Spi的缺点很明显，<code>可以在它的基础上在包装一层，这部分例子我从其他地方拷贝了过来，挺实用的，而正好是后期完善的，所以上面的截图中并没有显示这些内容，不过我已经放到了github上了</code>，有兴趣可以看看。最后加油自己，加油每一个人。</p><p><a href="https://github.com/JulianHang/little-mvn-project.git" target="_blank" rel="noopener">源码下载</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;自我介绍&quot;&gt;&lt;a href=&quot;#自我介绍&quot; class=&quot;headerlink&quot; title=&quot;自我介绍&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;自我介绍&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;Spi，Service Provider Interface，是java提供的一套用来被第三方实现或扩展的API，它可以用来启用框架扩展或替换相应的组件。简单来说就是我提供标准，你按照我的标准提供实现就可以了，当然了，这个实现可以是可以有多个，你想选择哪个都可以，不过前提是你要知道所有的实现才能选择，这操作属于java中的策略模式，而所有的实现都被放在一个配置文件中，所以Spi基本上就是一个&lt;code&gt;接口&lt;/code&gt; + &lt;code&gt;策略模式&lt;/code&gt; + &lt;code&gt;配置文件&lt;/code&gt;组合而成的动态加载机制。在面向对象的设计里，模块之间基于接口编程，模块之间不对实现类硬编码，在不同的场景下需要动态的指明实现类，这就需要一个服务发现的机制，Spi提供这样子的一个机制，为某个接口寻找服务实现的机制，将硬编码移到程序之外，也就是配置文件中，Spi的核心思想就是&lt;code&gt;解耦&lt;/code&gt;。
    
    </summary>
    
      <category term="essays" scheme="http://zlia.tech/categories/essays/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>我叫QPS，初次见面</title>
    <link href="http://zlia.tech/2019/04/07/explain-qps-knowledge/"/>
    <id>http://zlia.tech/2019/04/07/explain-qps-knowledge/</id>
    <published>2019-04-07T05:33:52.000Z</published>
    <updated>2019-06-08T06:12:19.385Z</updated>
    
    <content type="html"><![CDATA[<h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a><div><span>自我介绍</span></div></h3><p>QPS，query per second，<code>每秒的请求数</code>。当我看到这里的时候很不明白，每秒？按照我的理解应该是计算开始的时间到1秒钟这中间的请求数，但是怎么算是开始的时间，是指服务启动的时间还是第一次请求开始的时间，至少对于我来说讲述的并不是很明确。在比如，有一个时间线，第二秒的后500ms到第三秒的前500ms这样子也算是一个每秒的区间，那这之间的请求数算是咋回事呢？在说说QPS的目的，有人说是为了防止恶意刷取，增加项目负载，既然是控制刷取，那么我觉得这个控制应该是从别人第一次请求的时间开始算起，当它在1秒内多次请求达到上限后被服务限制了，这才算是合理的，所以我觉得应该是<code>从第一次请求开始的时间经过1秒后的请求数</code>，纯属个人理解。最近接触的项目中有提到QPS，说是恶意刷取，更准确的讲应该是用来做<code>流量控制</code>，这个词语给人的感觉更专业！而它算的时间也是从第一次请求开始算起的。 <a id="more"></a></p><h3 id="模拟QPS"><a href="#模拟QPS" class="headerlink" title="模拟QPS"></a><div><span>模拟QPS</span></div></h3><p>方便理解，模拟了一个场景来实现QPS的流量控制效果。<br>假设控制在1秒内不多于Limit个请求，Limit代表请求上限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkQps</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; limit ) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        total++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (System.nanoTime() - start &gt; duration) &#123;</span><br><span class="line">        total++;</span><br><span class="line">        reset();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这只是其中的一部分代码，也是最主要的，要想看所有的可到该文章的底部点击源码下载即可跳转到相应的位置。</p><h3 id="再见朋友"><a href="#再见朋友" class="headerlink" title="再见朋友"></a><div><span>再见朋友</span></div></h3><p>QPS是很多网站来衡量<code>吞吐量</code>的其中一个因素，基本上都会有一个统计图或者曲线图之类的，和QPS有关系的是另外一个朋友-<code>并发数</code>，目前笔者还没有去了解它，对于并发这块的知识点还远远不够，所以还早呢。又到了说几句鸡汤的时候了，技术是永远也学不完的，慢慢来，有一点点的进步总比呆坐着好，加油自己，加油每一个人。</p><p><a href="https://github.com/JulianHang/little-java-project/blob/master/src/tech/zlia/interest/example/FlowControlQpsTest.java" target="_blank" rel="noopener">源码下载</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;自我介绍&quot;&gt;&lt;a href=&quot;#自我介绍&quot; class=&quot;headerlink&quot; title=&quot;自我介绍&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;自我介绍&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;QPS，query per second，&lt;code&gt;每秒的请求数&lt;/code&gt;。当我看到这里的时候很不明白，每秒？按照我的理解应该是计算开始的时间到1秒钟这中间的请求数，但是怎么算是开始的时间，是指服务启动的时间还是第一次请求开始的时间，至少对于我来说讲述的并不是很明确。在比如，有一个时间线，第二秒的后500ms到第三秒的前500ms这样子也算是一个每秒的区间，那这之间的请求数算是咋回事呢？在说说QPS的目的，有人说是为了防止恶意刷取，增加项目负载，既然是控制刷取，那么我觉得这个控制应该是从别人第一次请求的时间开始算起，当它在1秒内多次请求达到上限后被服务限制了，这才算是合理的，所以我觉得应该是&lt;code&gt;从第一次请求开始的时间经过1秒后的请求数&lt;/code&gt;，纯属个人理解。最近接触的项目中有提到QPS，说是恶意刷取，更准确的讲应该是用来做&lt;code&gt;流量控制&lt;/code&gt;，这个词语给人的感觉更专业！而它算的时间也是从第一次请求开始算起的。
    
    </summary>
    
      <category term="essays" scheme="http://zlia.tech/categories/essays/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>每日知识点20190211</title>
    <link href="http://zlia.tech/2019/02/24/core-java-knowledge-20190211/"/>
    <id>http://zlia.tech/2019/02/24/core-java-knowledge-20190211/</id>
    <published>2019-02-24T04:09:16.000Z</published>
    <updated>2019-02-24T04:13:32.696Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java"><a href="#java" class="headerlink" title="java"></a><div><span>java</span></div></h3><ul><li>在同一个catch语句中可以捕获多个<code>不存在子类关系</code>的异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(FileNotFoundException | UnknowHostException e)&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>java中原来有提供<code>断言</code>，学到了学到了.</p></li><li><p>泛型类、泛型方法</p></li><li><p>一个类型变量或通配符可以有多个限定.限定类型用&amp;分隔，而逗号用来分隔类型变量.</p></li></ul><a id="more"></a><ul><li>对于编译器来说，用方法名+参数列表来确定一个方法签名.而对于虚拟机来说，用参数类型+返回类型来确定一个方法，编译器不允许开发者编码出方法名一致，返回值却不同的方法，而它自己却可以自动生成这种操作（产生两个仅返回类型不同的方法字节码）并交给虚拟机来处理.这种操作在泛型中称为<code>桥方法</code>，它主要用来避免类型变量擦除所带来的多态灾难.</li></ul><p class="customize-img"><img src="/assets/blogImg/daliy-konwledge-point/20190217/generic-method.png" alt="桥方法"></p><ul><li>运行时类型查询只适用于原始类型.意思是泛型不支持类型检查.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该类型检查会得到一个编译器错误</span></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Test&lt;String&gt;)&#123;</span><br><span class="line">    <span class="comment">//something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>不能使用像new T()、new T[]、T.class这样子表达式中的类型变量.</p></li><li><p>泛型类的静态上下文中类型变量无效.</p></li><li><p>不能抛出或捕获泛型类的实例.</p></li><li><p>带有超类型限定的通配符可以向泛型对象写入，带有子类型限定的通配符可以从泛型对象读取.</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java&quot;&gt;&lt;a href=&quot;#java&quot; class=&quot;headerlink&quot; title=&quot;java&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;java&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在同一个catch语句中可以捕获多个&lt;code&gt;不存在子类关系&lt;/code&gt;的异常&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt;(FileNotFoundException | UnknowHostException e)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;java中原来有提供&lt;code&gt;断言&lt;/code&gt;，学到了学到了.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;泛型类、泛型方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个类型变量或通配符可以有多个限定.限定类型用&amp;amp;分隔，而逗号用来分隔类型变量.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="daily-konwledge-point-java" scheme="http://zlia.tech/tags/daily-konwledge-point-java/"/>
    
  </entry>
  
  <entry>
    <title>每日知识点20181216</title>
    <link href="http://zlia.tech/2019/02/24/core-java-knowledge-20181216/"/>
    <id>http://zlia.tech/2019/02/24/core-java-knowledge-20181216/</id>
    <published>2019-02-24T04:08:59.000Z</published>
    <updated>2019-02-24T04:08:59.355Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java"><a href="#java" class="headerlink" title="java"></a><div><span>java</span></div></h3><ul><li><p>Arrays.deepToString(a)：打印二维数组.</p></li><li><p>Java8开始时间使用Date类，日期使用<code>LocalDate</code>类.</p></li><li><p>包内的类不能引用默认包中的类.</p></li><li><p>内部类可以是私有类（private），而常规类只可以具有包可见性（default）或公有可见性（public）.</p></li><li><p>内部类不能有static方法.</p></li><li><p>局部类不能用public或private访问说明符进行声明.</p></li></ul><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> flag)</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">FatherInner</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    System.out.println(flag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该段代码编译后生成Father.class与Father$1FatherInner.class文件.反编译Father$1FatherInner.class后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>$1<span class="title">Inner</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Father$<span class="number">1</span>Inner(Father var1,<span class="keyword">boolean</span> var2)&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span> = var1;</span><br><span class="line">        <span class="keyword">this</span>.val$flag = var2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.val$flag)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.val$flag)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> val$flag;</span><br><span class="line">    <span class="keyword">final</span> Father <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>由于构造器的名字与类名相同，而匿名类没有类名，所以匿名类不能有构造器.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java&quot;&gt;&lt;a href=&quot;#java&quot; class=&quot;headerlink&quot; title=&quot;java&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;java&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Arrays.deepToString(a)：打印二维数组.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Java8开始时间使用Date类，日期使用&lt;code&gt;LocalDate&lt;/code&gt;类.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;包内的类不能引用默认包中的类.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内部类可以是私有类（private），而常规类只可以具有包可见性（default）或公有可见性（public）.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内部类不能有static方法.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;局部类不能用public或private访问说明符进行声明.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="daily-konwledge-point-java" scheme="http://zlia.tech/tags/daily-konwledge-point-java/"/>
    
  </entry>
  
</feed>
