<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>奇思妙想</title>
  
  <subtitle>越努力越幸运！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zlia.tech/"/>
  <updated>2019-09-02T15:51:13.322Z</updated>
  <id>http://zlia.tech/</id>
  
  <author>
    <name>zlia</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ArrayList与LinkedList的性能比较</title>
    <link href="http://zlia.tech/2019/09/02/arraylist-linkedlist-perfermance-compare/"/>
    <id>http://zlia.tech/2019/09/02/arraylist-linkedlist-perfermance-compare/</id>
    <published>2019-09-02T15:44:31.000Z</published>
    <updated>2019-09-02T15:51:13.322Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>我们都知道<code>ArrayList适合查询/替换</code>、<code>LinkedList适合添加/删除</code>，造成这样子的原因也在于它们底层的实现。光说这些理论似乎大家都会，所以准备用更加具体的例子来证明它，也能更好地比较这两者之间的性能关系。在测试具体场景前，简单说明下环境配置，window环境下：内存8个G；JDK8；i7处理器。</p><h3 id="测试场景"><a href="#测试场景" class="headerlink" title="测试场景"></a><div><span>测试场景</span></div></h3><p>分别准备1w、5w、10w、50w、100w条数据，也就是说数据类别有上面这几种，将它们分别按照下列场景测试。</p><ul><li><p>在首部、尾部添加元素/节点的效率。</p></li><li><p>随机位置/索引插入元素/节点的效率。</p></li><li><p>在首部、尾部删除元素/节点的效率。</p></li><li><p>随机位置/索引删除元素/节点的效率。</p></li><li><p>随机位置/索引获取元素/节点的效率。</p></li><li><p>随机位置/索引修改元素/节点的效率。</p></li></ul><a id="more"></a><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a><div><span>测试结果</span></div></h3><p>测试结果将以表格的方式展示。</p><ul><li>在首部、尾部添加元素/节点。</li></ul><p>A首：ArrayList首部添加元素，L首：LinkedList首部添加元素，A尾：ArrayList尾部添加元素，L尾：LinkedList尾部添加元素。</p><p class="customize-img"><img src="/assets/blogImg/java/arraylist-compare-linkedlist/arraylist-compare-linkedlist-1.png" alt="ArrayList注释-1"></p><ul><li>随机位置/索引插入元素/节点。</li></ul><p>A随：ArrayList随机位置添加元素，L随：LinkedList随机位置添加元素。</p><p class="customize-img"><img src="/assets/blogImg/java/arraylist-compare-linkedlist/arraylist-compare-linkedlist-2.png" alt="ArrayList注释-2"></p><p>由于50w、100w执行时间过长故并未给出具体时间，不过已经足以说明结果了。</p><ul><li>在首部、尾部删除元素/节点。</li></ul><p>A首：ArrayList首部删除元素，L首：LinkedList首部删除元素，A尾：ArrayList尾部删除元素，L尾：LinkedList尾部删除元素。</p><p class="customize-img"><img src="/assets/blogImg/java/arraylist-compare-linkedlist/arraylist-compare-linkedlist-3.png" alt="ArrayList注释-3"></p><ul><li>随机位置/索引删除元素/节点。</li></ul><p class="customize-img"><img src="/assets/blogImg/java/arraylist-compare-linkedlist/arraylist-compare-linkedlist-4.png" alt="ArrayList注释-4"></p><p>同上。</p><ul><li>随机位置/索引获取元素/节点。</li></ul><p class="customize-img"><img src="/assets/blogImg/java/arraylist-compare-linkedlist/arraylist-compare-linkedlist-5.png" alt="ArrayList注释-5"></p><p>同上。</p><ul><li>随机位置/索引替换元素/节点。</li></ul><p class="customize-img"><img src="/assets/blogImg/java/arraylist-compare-linkedlist/arraylist-compare-linkedlist-6.png" alt="ArrayList注释-6"></p><p>同上。</p><h3 id="测试结果分析"><a href="#测试结果分析" class="headerlink" title="测试结果分析"></a><div><span>测试结果分析</span></div></h3><p>以上的测试方式较为简单，没有考虑其他太多的因素，所以不要纠结于具体的时间，而是要了解它们的性能趋势。从测试结果来看，可以得到更为具体的结论：</p><ul><li><p><code>在首部添加/删除元素/节点过程中</code>，随着数据量的不断增大，<code>LinkedList明显要比ArrayList优秀很多</code>，<code>而对于尾部添加/删除</code>，<code>两者则差别不大</code>。</p></li><li><p>在随机插入/删除/获取/替换元素/节点过程中，随着数据量的不断增大，ArrayList明显要比LinkedList优秀很多！</p></li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a><div><span>结论</span></div></h3><ul><li><p><code>ArrayList比LinkedList更能适应大多数情况</code>。</p></li><li><p>频繁在首部添加/删除元素/节点，不需要过多的访问，可能更适合LinkedList。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;我们都知道&lt;code&gt;ArrayList适合查询/替换&lt;/code&gt;、&lt;code&gt;LinkedList适合添加/删除&lt;/code&gt;，造成这样子的原因也在于它们底层的实现。光说这些理论似乎大家都会，所以准备用更加具体的例子来证明它，也能更好地比较这两者之间的性能关系。在测试具体场景前，简单说明下环境配置，window环境下：内存8个G；JDK8；i7处理器。&lt;/p&gt;
&lt;h3 id=&quot;测试场景&quot;&gt;&lt;a href=&quot;#测试场景&quot; class=&quot;headerlink&quot; title=&quot;测试场景&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;测试场景&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;分别准备1w、5w、10w、50w、100w条数据，也就是说数据类别有上面这几种，将它们分别按照下列场景测试。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在首部、尾部添加元素/节点的效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;随机位置/索引插入元素/节点的效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在首部、尾部删除元素/节点的效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;随机位置/索引删除元素/节点的效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;随机位置/索引获取元素/节点的效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;随机位置/索引修改元素/节点的效率。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索LinkedList底层实现</title>
    <link href="http://zlia.tech/2019/09/02/explain-linkedlist-sourcecode/"/>
    <id>http://zlia.tech/2019/09/02/explain-linkedlist-sourcecode/</id>
    <published>2019-09-02T06:59:49.000Z</published>
    <updated>2019-09-02T07:04:07.272Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>老样子，还是先看注释！本来以为能收获点什么干货，结果注释与<code>ArrayList</code>的注释基本相同，有点尴尬…LinkedList的源码是基于<code>JDK1.8</code>。</p><h3 id="开干"><a href="#开干" class="headerlink" title="开干"></a><div><span>开干</span></div></h3><p>先上LinkedList类的注释，在深入到类中详细说明属性与方法。</p><a id="more"></a><h4 id="阅读注释"><a href="#阅读注释" class="headerlink" title="阅读注释"></a>阅读注释</h4><p class="customize-img"><img src="/assets/blogImg/java/linkedlist/linkedlist-comment-1.png" alt="LinkedList注释-1"></p><p class="customize-img"><img src="/assets/blogImg/java/linkedlist/linkedlist-comment-2.png" alt="LinkedList注释-2"></p><p>它的意思是：通过索引来操作LinkedList的话，每次都需要从头或从尾开始一个一个遍历，直到遇到指定的索引。</p><p class="customize-img"><img src="/assets/blogImg/java/linkedlist/linkedlist-comment-3.png" alt="LinkedList注释-3"></p><p>也是非线程安全，所以在多线程环境下要在外部控制同步防止数据紊乱。</p><p class="customize-img"><img src="/assets/blogImg/java/linkedlist/linkedlist-comment-4.png" alt="LinkedList注释-4"></p><p>不多说了。</p><p class="customize-img"><img src="/assets/blogImg/java/linkedlist/linkedlist-comment-5.png" alt="LinkedList注释-5"></p><p>有一个点要注意下，获取迭代器后，不能在直接通过对象调用方法去修改结构，只能通过迭代器去调用，否则将会抛出异常。</p><p class="customize-img"><img src="/assets/blogImg/java/linkedlist/linkedlist-comment-6.png" alt="LinkedList注释-6"></p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>接下来将详细说明LinkedList类的属性与方法，在这之前，先通过一张图简单了解下它的数据结构。</p><p class="customize-img"><img src="/assets/blogImg/java/linkedlist/linkedlist-data-structure.png" alt="LinkedList注释-6"></p><p>很简单的一张图，每一个节点都保存了当前节点的信息，同时又关联了下一个节点与上一个节点。若要获取指定节点信息，那么只能通过这种关联关系来找到具体节点，这也奠定了它<code>查找</code>的速度相对于<code>ArrayList</code>来说要慢很多，但也是由于有这层关系，<code>添加/删除</code>的速度相对于<code>ArrayList</code>来说要更快，<code>毕竟它只需要更改当前节点关联的上下节点关系即可，而ArrayList需要移动一波元素</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//支持克隆、序列化、双端队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//链表的容量大小，意指包含多少个节点</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//链表的第一个节点，也就是首部节点</span></span><br><span class="line">    <span class="comment">//链表中的每一个节点都保存着当前节点的信息、上一个节点的地址、下一个节点的地址</span></span><br><span class="line">    <span class="comment">//首部节点的上一个节点指向null</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//链表的最后一个节点，也就是尾部节点</span></span><br><span class="line">    <span class="comment">//尾部节点的下一个节点指向null</span></span><br><span class="line">    <span class="comment">//有了首部节点为什么还要有个尾部节点呢，个人理解是为了方便遍历计算</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinkedList的底层是通过链表实现的，并不需要提供成员属性来预先开辟内存空间以便后续的存储节点，所以<code>它充分利用了内存空间，实现灵活的内存管理</code>，不存在什么扩容机制。也正因为此，它并未提供有入参initCapacity的构造函数，在实现上看起来比ArrayList更简单。</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空参数构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个包含指定集合的链表</span></span><br><span class="line"><span class="comment"> * 指定集合中的节点按照迭代器的顺序依次添加到链表的尾部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉上确实比ArrayList简单多了，不用考虑那么多，直接new一个对象即可。</p><h4 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h4><p>接下来按照类的声明顺序介绍<code>方法</code>，有必要的情况下结合例子进行说明。</p><h5 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定节点到首部</span></span><br><span class="line"><span class="comment"> * 指定节点作为首部节点，它的上一个节点指向null</span></span><br><span class="line"><span class="comment"> * 若是空链表，当添加指定节点时首部节点与尾部节点指向同一个节点，即指定节点</span></span><br><span class="line"><span class="comment"> * 若不是空链表，则将原先的首部节点的上一个节点指向指定节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定节点到尾部</span></span><br><span class="line"><span class="comment"> * 指定节点作为尾部节点，它的下一个节点指向null</span></span><br><span class="line"><span class="comment"> * 若是空链表，当添加指定节点时首部节点与尾部节点指向同一个节点，即指定节点</span></span><br><span class="line"><span class="comment"> * 若不是空链表，则将原先的尾部节点的下一个节点指向指定节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定节点到指定节点succ前</span></span><br><span class="line"><span class="comment"> * 在添加节点时，更换对应上下节点的指向地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 添加的指定节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> succ 指定节点处</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除首部节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> f 首部节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除尾部节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> l 尾部节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> E element = l.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除指定节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 指定节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定节点的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否包含指定信息</span></span><br><span class="line"><span class="comment"> * 一个节点一个节点的判断是否与指定信息相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正向遍历的方式获取指定信息的位置</span></span><br><span class="line"><span class="comment"> * 由于是链表的数据结构，每个节点只知道自己的信息与上下两个节点，所以每次查找时都只能从头/尾开始遍历</span></span><br><span class="line"><span class="comment"> * 相当于是一个人一个人的问，直到问到自己想要的人</span></span><br><span class="line"><span class="comment"> * 若未找到指定节点则返回-1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> 0 指定信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定信息的位置或-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取节点个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空所有节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">        Node&lt;E&gt; next = x.next;</span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">    first = last = <span class="keyword">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断指定位置是否越界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否越界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断指定位置是否合法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否合法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取指定位置越界或不合法的信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">outOfBoundsMsg</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Index: "</span>+index+<span class="string">", Size: "</span>+size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 校验指定位置是否越界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isElementIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 校验指定位置是否合法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取指定位置的节点</span></span><br><span class="line"><span class="comment"> * 先判断指定位置处于0-mid-size的哪个区间，避免从头遍历消耗不必要的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反向遍历的方式获取指定信息的位置</span></span><br><span class="line"><span class="comment"> * 由于是链表的数据结构，每个节点只知道自己的信息与上下两个节点，所以每次查找时都只能从头/尾开始遍历</span></span><br><span class="line"><span class="comment"> * 相当于是一个人一个人的问，直到问到自己想要的人</span></span><br><span class="line"><span class="comment"> * 若未找到指定节点则返回-1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> 0 指定信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定信息的位置或-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = size;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储每个节点的信息及指向上下节点的地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当前节点的信息</span></span><br><span class="line">    E item;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前节点的下一个节点</span></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前节点的上一个节点</span></span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prev 当前节点的上一个节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element 当前节点的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> next 当前节点的下一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用该clone之前，该类要实现Cloneable，不然会抛出异常</span></span><br><span class="line"><span class="comment"> * 浅拷贝与深拷贝，举个例子吧</span></span><br><span class="line"><span class="comment"> * 比如A类中包含基本类型与B类，当调用A类clone方法后，两个A对象肯定是不一致，不然就不叫做拷贝了，不过这不是关键</span></span><br><span class="line"><span class="comment"> * 若A1对象中的B对象与A2对象中的B对象指向同一个对象，则认为它是浅拷贝，认为B没有被拷贝新的一份</span></span><br><span class="line"><span class="comment"> * 若两者指向不相等的话，则认为深拷贝，认为B重新拷贝了一份，不过这通常需要我们自定义代码，就像下面的方法一样</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 克隆后的新对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> LinkedList&lt;E&gt; <span class="title">superClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (LinkedList&lt;E&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;E&gt; clone = superClone();</span><br><span class="line"></span><br><span class="line">    clone.first = clone.last = <span class="keyword">null</span>;</span><br><span class="line">    clone.size = <span class="number">0</span>;</span><br><span class="line">    clone.modCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        clone.add(x.item);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造新数组，存放链表中的所有节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有节点信息的新数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    Object[] result = <span class="keyword">new</span> Object[size];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        result[i++] = x.item;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将链表中的所有节点信息放入到指定数组中并返回</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 一开始我也好奇为啥要在索引为size上设置个null呢？</span></span><br><span class="line"><span class="comment"> * 看了注释加上自我的理解，若传入的新数组是个空数组的话，那么除了拷贝列表元素后剩余的所有空间的值都为null，此时在给索引为size的值设置成null似乎没有多大</span></span><br><span class="line"><span class="comment"> * 意思；另外一种情况是若传入的新数组不是个空数组，那这个设置就有意义了，传入的新数组的某些元素会被列表元素覆盖，同时有个null，剩下的才是自己本身的数据，呈现这样子一种效果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment"> * list.add(11);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Integer[] str = new Integer[]&#123;1,2,3,4,5,6,7,8,9,10&#125;;</span></span><br><span class="line"><span class="comment"> * Integer[] s1 = list.toArray(str);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * for (Integer s : s1) &#123;</span></span><br><span class="line"><span class="comment"> *     System.out.println(s + ",");</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输出结果：11,null,3,4,5,6,7,8,9,10,</span></span><br><span class="line"><span class="comment"> * 那么设置这个null的意义就在于能够确定列表中元素个数（长度），但有个前提就是调用者知道链表中的所有节点信息不存在null才有意义，目前我只有想到这一种情况下有用！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 指定数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 填充完链表所有节点信息的指定数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        a = (T[])java.lang.reflect.Array.newInstance(</span><br><span class="line">                            a.getClass().getComponentType(), size);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    Object[] result = a;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        result[i++] = x.item;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义序列化</span></span><br><span class="line"><span class="comment"> * 每个节点当中保存的上下节点的关联关系对于序列化来说可有可无，只要你按次序保存好每个节点的信息，反序列化后依然可以构造出这些关联关系</span></span><br><span class="line"><span class="comment"> * 默认的序列化机制会将非静态与非瞬时（非transient修饰）写入流中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 输出流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        s.writeObject(x.item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义反序列化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 输入流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = s.readInt();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        linkLast((E)s.readObject());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取分割迭代器</span></span><br><span class="line"><span class="comment"> * 分割迭代器的方法作用都是类似的，不同的地方在于算法的实现上，所以不在做重复的分析，可参考另外一篇文章的详细介绍</span></span><br><span class="line"><span class="comment"> * 附上文章地址：http://zlia.tech/2019/08/28/explain-arraylist-spliterator-sourcecode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LLSpliterator&lt;E&gt;(<span class="keyword">this</span>, -<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很多方法都没有过多的说明，是因为可能涉及到算法或者只要简单画一画就能理解了！</p><h5 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取首部节点信息</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 首部节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取尾部节点信息</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 尾部节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取指定位置的信息</span></span><br><span class="line"><span class="comment"> * 校验位置是否越界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定位置的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取首部节点信息</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会返回null</span></span><br><span class="line"><span class="comment"> * 该方法比getFirst更友好</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 首部节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取首部节点信息</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 首部节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取首部节点信息</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会返回null</span></span><br><span class="line"><span class="comment"> * 该方法比getFirst更友好</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 首部节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取尾部节点信息</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会返回null</span></span><br><span class="line"><span class="comment"> * 该方法比getLast更友好</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 首部节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="移除节点"><a href="#移除节点" class="headerlink" title="移除节点"></a>移除节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除首部节点</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 首部节点的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除尾部节点</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 尾部节点的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除指定信息</span></span><br><span class="line"><span class="comment"> * 由于是链表的数据结构，每个节点只知道自己的信息与上下两个节点，所以每次查找时都只能从头开始遍历</span></span><br><span class="line"><span class="comment"> * 相当于是一个人一个人的问，直到问到自己想要的人</span></span><br><span class="line"><span class="comment"> * 若未找到指定节点则返回false</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除指定位置的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除首部节点，相当于队列取出元素</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会返回null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除首部节点</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 首部节点的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除首部节点，相当于队列取出元素</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会返回null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除尾部节点，相当于队列取出元素</span></span><br><span class="line"><span class="comment"> * 若是空链表，则会返回null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正向遍历，删除指定节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否删除指定节点信息成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeFirstOccurrence</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remove(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反向遍历，删除指定节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否删除指定节点信息成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeLastOccurrence</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定信息到首部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定信息到尾部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定信息到尾部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定集合信息到尾部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在指定位置添加指定集合信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        succ = <span class="keyword">null</span>;</span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size += numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定节点信息到指定位置上</span></span><br><span class="line"><span class="comment"> * 在添加过程中只需要修改旧节点的上下节点关联关系即可，可以说效率提升了很多</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 指定节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定节点信息到尾部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定节点信息到首部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定节点信息到尾部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="修改节点"><a href="#修改节点" class="headerlink" title="修改节点"></a>修改节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改指定位置的节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 指定节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含指定位置开始到结尾之间的节点的正向迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含指定位置到结尾之间的节点的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 列表迭代器，正向迭代</span></span><br><span class="line"><span class="comment"> * 可获取上一个元素、下一个元素及位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指向当前节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; lastReturned;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指向上/下一个节点，随着调用方法的不同指向便不同</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上/下一个节点的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nextIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每次调用迭代器中的方法时，都会判断是否调用了LinkedList的外部方法去修改结构列表，如此的操作通常会造成快速失败</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化参数，设置下一个节点及下一个节点的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 当前位置，调用迭代器中的方法时该位置对应的节点信息是第一个获取到的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="comment">// assert isPositionIndex(index);</span></span><br><span class="line">        next = (index == size) ? <span class="keyword">null</span> : node(index);</span><br><span class="line">        nextIndex = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否有下一个节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否有下一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex &lt; size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个节点的信息</span></span><br><span class="line"><span class="comment">     * 初始化时的入参index对应的节点作为开始</span></span><br><span class="line"><span class="comment">     * 在获取下一个节点信息前，会判断是否造成了快速失败</span></span><br><span class="line"><span class="comment">     * 在获取完下一个节点后，将其指向赋值給lastReturned，同时修改next指向下一个节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个节点的信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">if</span> (!hasNext())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">        lastReturned = next;</span><br><span class="line">        next = next.next;</span><br><span class="line">        nextIndex++;</span><br><span class="line">        <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否有上一个节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否有上一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取上一个节点的信息</span></span><br><span class="line"><span class="comment">     * 初始化时的入参index对应的节点的上一个节点作为开始</span></span><br><span class="line"><span class="comment">     * 在获取下一个节点信息前，会判断是否造成了快速失败</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 上一个节点的信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">if</span> (!hasPrevious())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">        lastReturned = next = (next == <span class="keyword">null</span>) ? last : next.prev;</span><br><span class="line">        nextIndex--;</span><br><span class="line">        <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个节点的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个节点的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取上一个节点的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 上一个节点的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextIndex - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除当前节点，也就是lastReturned指向的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line"></span><br><span class="line">        Node&lt;E&gt; lastNext = lastReturned.next;</span><br><span class="line">        unlink(lastReturned);</span><br><span class="line">        <span class="keyword">if</span> (next == lastReturned)</span><br><span class="line">            next = lastNext;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nextIndex--;</span><br><span class="line">        lastReturned = <span class="keyword">null</span>;</span><br><span class="line">        expectedModCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将当前节点的信息修改成指定信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 指定信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line">        lastReturned.item = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在下一个节点前添加指定节点</span></span><br><span class="line"><span class="comment">     * 若下一个节点指向null，也就是说当前节点已经是尾部节点了，在将指定节点添加到尾部</span></span><br><span class="line"><span class="comment">     * 若下一个节点指向不为null，则在下一个节点前添加指定节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 指定节点信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        lastReturned = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">            linkLast(e);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            linkBefore(e, next);</span><br><span class="line">        nextIndex++;</span><br><span class="line">        expectedModCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正向遍历链表的剩余节点，对每一个节点执行指定的动作</span></span><br><span class="line"><span class="comment">     * 对于每个迭代器，除非剩余节点未遍历完毕，否则该方法只能执行一次，因为随着遍历nextIndex的次数在增加</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> action 对每一个节点执行指定的动作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">while</span> (modCount == expectedModCount &amp;&amp; nextIndex &lt; size) &#123;</span><br><span class="line">            action.accept(next.item);</span><br><span class="line">            lastReturned = next;</span><br><span class="line">            next = next.next;</span><br><span class="line">            nextIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        checkForComodification();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化时 modCount 与 expectedModCount 是相等的</span></span><br><span class="line"><span class="comment">     * 但如果在遍历的过程修改数组结构的话，此时 modCount 会有所变化，导致两者不相等，故而抛出异常，也就是我们上面提到的fast-failed异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取反向迭代器，尾部节点作为开始</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 以尾部节点作为开始的反向迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DescendingIterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 列表迭代器，反向迭代</span></span><br><span class="line"><span class="comment"> * 实际上都是采用ListItr类中的方法，只不过包装了一层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DescendingIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ListItr itr = <span class="keyword">new</span> ListItr(size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从反向的角度来看，判断是否有下一个节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否有下一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> itr.hasPrevious();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从反向的角度来看，获取下一个节点信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个节点信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> itr.previous();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从反向的角度来看，移除当前节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        itr.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>队列中的方法简单说明下：</li></ul><p>peek、peekFirst、elements方法都是<code>获取首部节点</code>，但若是空链表的话，前两者不会抛出异常（返回null），最后一个会。</p><p>peekLast方法是<code>获取尾部节点</code>。</p><p>poll、pollFirst、remove、pop方法都是<code>删除并首部节点</code>，但若是空链表的话，前两者不会抛出异常（返回null），后两者会。</p><p>pollLast方法是<code>删除并获取尾部节点</code>。</p><p>offer与offerLast方法都是<code>添加指定节点到尾部</code>，没啥区别。</p><p>offerFirst、push方法是<code>添加指定节点到首部</code>，两者的区别在于有无返回值。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>LinkedList允许存放Null。</p></li><li><p>LinkedList内部通过链表实现，属于非线程安全。</p></li><li><p>LinkedList充分利用了内存空间，不存在扩容机制。</p></li><li><p>ArrayList具有<code>iterator</code>与<code>listIterator</code>，虽然LinkedList也有这两个方法，但实际上这两个方法的内部实现都是调用的<code>listIterator</code>。</p></li><li><p>在遍历过程中不允许修改结构，否则会抛出错误。</p></li><li><p>LinkedList实现了队列。</p></li></ul><h4 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a>重点关注</h4><p><code>底层是通过链表实现，有序可重复</code> <code>充分利用内存空间</code> </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;老样子，还是先看注释！本来以为能收获点什么干货，结果注释与&lt;code&gt;ArrayList&lt;/code&gt;的注释基本相同，有点尴尬…LinkedList的源码是基于&lt;code&gt;JDK1.8&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;开干&quot;&gt;&lt;a href=&quot;#开干&quot; class=&quot;headerlink&quot; title=&quot;开干&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;开干&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;先上LinkedList类的注释，在深入到类中详细说明属性与方法。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索ArrayListSpliterator底层实现</title>
    <link href="http://zlia.tech/2019/08/28/explain-arraylist-spliterator-sourcecode/"/>
    <id>http://zlia.tech/2019/08/28/explain-arraylist-spliterator-sourcecode/</id>
    <published>2019-08-28T09:53:49.000Z</published>
    <updated>2019-08-28T09:57:06.629Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>上次看ArrayList底层机制时把<code>ArrayListSpliterator</code>放了放，现在回过头来具体看看实现。</p><h3 id="简单粗暴"><a href="#简单粗暴" class="headerlink" title="简单粗暴"></a><div><span>简单粗暴</span></div></h3><p>直接上代码吧！</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListSpliterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指向当前集合对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;E&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前索引，可能被trySplit和tryAdvance操作修改</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结束索引，未使用前为-1，使用后为list的size</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> fence;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过与modCount比较来判断集合是否被修改，初始值与modCount相等</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expectedModCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list 当前集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> origin 起始索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fence 结束索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expectedModCount </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ArrayListSpliterator(ArrayList&lt;E&gt; list, <span class="keyword">int</span> origin, <span class="keyword">int</span> fence,</span><br><span class="line">                         <span class="keyword">int</span> expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list; <span class="comment">// OK if null unless traversed</span></span><br><span class="line">        <span class="keyword">this</span>.index = origin;</span><br><span class="line">        <span class="keyword">this</span>.fence = fence;</span><br><span class="line">        <span class="keyword">this</span>.expectedModCount = expectedModCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取结束索引</span></span><br><span class="line"><span class="comment">     * 初始化expectedModCount与fence参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 结束索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getFence</span><span class="params">()</span> </span>&#123; <span class="comment">// initialize fence to size on first use</span></span><br><span class="line">        <span class="keyword">int</span> hi; <span class="comment">// (a specialized variant appears in method forEach)</span></span><br><span class="line">        ArrayList&lt;E&gt; lst;</span><br><span class="line">        <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((lst = list) == <span class="keyword">null</span>)</span><br><span class="line">                hi = fence = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                expectedModCount = lst.modCount;</span><br><span class="line">                hi = fence = lst.size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在当前切割迭代器的基础上再次拆分一个新的迭代器</span></span><br><span class="line"><span class="comment">     * 若切割迭代器是可以拆分的，会返回新的一个切割迭代器，两个迭代器平分原先迭代器中的元素</span></span><br><span class="line"><span class="comment">     * 若切割迭代器无法拆分的话，则返回null</span></span><br><span class="line"><span class="comment">     * 拆分后原先迭代器必须修改起始索引，因为它的元素被拆分了（index = mid）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新的切割迭代器或null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayListSpliterator&lt;E&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (lo &gt;= mid) ? <span class="keyword">null</span> : <span class="comment">// divide range in half unless too small</span></span><br><span class="line">            <span class="keyword">new</span> ArrayListSpliterator&lt;E&gt;(list, lo, index = mid,</span><br><span class="line">                                        expectedModCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 若存在剩余元素，则对其下一个元素执行指定动作，并返回true</span></span><br><span class="line"><span class="comment">     * 若不存在剩余元素，则返回false</span></span><br><span class="line"><span class="comment">     * 该方法是对单独元素进行操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> action 若存在剩余元素，执行指定动作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否存在剩余元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hi = getFence(), i = index;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; hi) &#123;</span><br><span class="line">            index = i + <span class="number">1</span>;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E)list.elementData[i];</span><br><span class="line">            action.accept(e);</span><br><span class="line">            <span class="keyword">if</span> (list.modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历剩余元素，并执行指定动作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> action 若存在剩余元素，执行指定动作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, hi, mc; <span class="comment">// hoist accesses and checks from loop</span></span><br><span class="line">        ArrayList&lt;E&gt; lst; Object[] a;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> ((lst = list) != <span class="keyword">null</span> &amp;&amp; (a = lst.elementData) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                mc = lst.modCount;</span><br><span class="line">                hi = lst.size;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mc = expectedModCount;</span><br><span class="line">            <span class="keyword">if</span> ((i = index) &gt;= <span class="number">0</span> &amp;&amp; (index = hi) &lt;= a.length) &#123;</span><br><span class="line">                <span class="keyword">for</span> (; i &lt; hi; ++i) &#123;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) a[i];</span><br><span class="line">                    action.accept(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (lst.modCount == mc)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取切割迭代器的元素个数</span></span><br><span class="line"><span class="comment">     * 计算结束索引与起始索引之间的元素个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 切割迭代器的元素个数 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">estimateSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">long</span>) (getFence() - index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取切割迭代器的特征值</span></span><br><span class="line"><span class="comment">     * ArrayList底层实现是数组，故是有序、有实际大小、可重复、可存入null、属于非线程安全、在遍历时可添加修改替换元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>分割迭代器可以单个(tryAdvance)或顺序（多个）遍历元素.</p></li><li><p>分割迭代器可拆分成若干个小型的分割迭代器来并行操作元素.</p></li><li><p>分割迭代器属于非线程安全.</p></li><li><p>ArrayListSpliterator属于后期绑定与快速失败的分割迭代器.</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;上次看ArrayList底层机制时把&lt;code&gt;ArrayListSpliterator&lt;/code&gt;放了放，现在回过头来具体看看实现。&lt;/p&gt;
&lt;h3 id=&quot;简单粗暴&quot;&gt;&lt;a href=&quot;#简单粗暴&quot; class=&quot;headerlink&quot; title=&quot;简单粗暴&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;简单粗暴&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;直接上代码吧！&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索Vector的底层实现</title>
    <link href="http://zlia.tech/2019/08/21/explain-vector-sourcecode/"/>
    <id>http://zlia.tech/2019/08/21/explain-vector-sourcecode/</id>
    <published>2019-08-21T10:06:56.000Z</published>
    <updated>2019-08-28T15:17:03.374Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a><div><span>背景</span></div></h3><p>上周发布了<a href="http://zlia.tech/2019/08/16/explain-arraylist-sourcecode/">探索ArrayList的底层实现</a>，趁热打铁！实际上<code>ArrayList</code>与<code>Vector</code>的实现上非常相似，代码基本上都是一样的，还是老样子，先看注释，我能说注释都差不多一样吗。</p><h4 id="阅读注释"><a href="#阅读注释" class="headerlink" title="阅读注释"></a>阅读注释</h4><p class="customize-img"><img src="/assets/blogImg/java/vector/vector-comment-1.png" alt="Vector注释-1"></p><p>Vector内部是通过动态数组实现的。</p><a id="more"></a><p class="customize-img"><img src="/assets/blogImg/java/vector/vector-comment-2.png" alt="Vector注释-2"></p><p>Vector可自定义扩容的大小，<code>若没有指定则默认翻倍，即2倍关系（100%），ArrayList默认是1.5倍关系（50%）</code></p><p class="customize-img"><img src="/assets/blogImg/java/vector/vector-comment-3.png" alt="Vector注释-3"></p><p>截图中应该讲的挺明白了！</p><p class="customize-img"><img src="/assets/blogImg/java/vector/vector-comment-4.png" alt="Vector注释-4"></p><p>又是快速失败！</p><p class="customize-img"><img src="/assets/blogImg/java/vector/vector-comment-5.png" alt="Vector注释-5"></p><p>需要线程安全的情况下使用Vector，不需要则推荐使用ArrayList。</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//支持序列化、可克隆、随机访问</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储元素的数组缓冲区</span></span><br><span class="line">    <span class="comment">//Vector的容量大小就是数组缓冲区的长度大小</span></span><br><span class="line">    <span class="comment">//Vector中排在最后一个元素后面的元素内容都是null，实际上指的是数组长度过大，未存满内容</span></span><br><span class="line">    <span class="keyword">protected</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组中实际元素的个数，指的是包含多少元素，称作有效元素</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> elementCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当容量不足时，指定容量需要扩充的大小</span></span><br><span class="line">    <span class="comment">//若该值小于或等于0，则当容量不足时采用翻倍的方式扩充大小</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> capacityIncrement;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们都知道定义一个数组的大小是 int 类型，那么也就意味着最大的数组大小应该是Integer.MAX_VALUE，但是这里为啥要减去8呢？</span></span><br><span class="line">    <span class="comment">//查阅资源发现大部分的人都在说8个字节是用来存储数组的大小，半信半疑</span></span><br><span class="line">    <span class="comment">//分配最大数组，某些VM会在数组中存储header word，按照上面的说法指的应该是数组的大小</span></span><br><span class="line">    <span class="comment">//若尝试去分配更大的数组可能会造成 OutOfMemoryError: 定义的数组大小超过VM上限</span></span><br><span class="line">    <span class="comment">//不同的操作系统对于不同的JDK可能分配的内存会有所差异，所以8这个数字可能是为了保险起见</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Vector结构被修改的次数</span></span><br><span class="line">    <span class="comment">//该字段主要针对迭代器与子集使用，若该属性被出乎意料的改变了，调用迭代器的相关方法，如 next、 remove、previous、set、add</span></span><br><span class="line">    <span class="comment">//则会抛出 ConcurrentModificationException常，该情况其实就是上面提到的fail-fast</span></span><br><span class="line">    <span class="comment">//严格上来说，该字段并不算是结构被修改的次数，在判断是否需要扩容时，它是首先进行增加在判断，不过这不影响，该字段仅用来判断是否与其他字段相等</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个指定初始容量大小与指定容量增长速率的空数组</span></span><br><span class="line"><span class="comment"> * 若initialCapacity小于0，则抛出参数异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 初始容量大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacityIncrement 当容量不足时，容量扩充的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个指定初始容量大小的空数组</span></span><br><span class="line"><span class="comment"> * 由于未指定容量增长速率，故而采用翻倍的机制</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 初始容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个初始容量为10的空数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建一个包含指定collection集合的数组，这些元素按照迭代器的顺序排列</span></span><br><span class="line"><span class="comment"> * collection集合类型有Map、set、List等子类，所以入参可以是多种类型</span></span><br><span class="line"><span class="comment"> * collection集合转换成数组，elementData指向该数组，elementCount成员属性被赋值为collection集合长度</span></span><br><span class="line"><span class="comment"> * 判断数组类型是否是Ojbect[],若不是则创建一个新的数组，并拷贝elementData数组中的内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    elementCount = elementData.length;</span><br><span class="line">    <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">        elementData = Arrays.copyOf(elementData, elementCount, Object[].class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>若已经提前知道数组容量，则建议使用new Vector(initialCapacity)</p></li><li><p>若不知道数组容量的话，那就没办法了</p></li><li><p>Vector(Collection c)一般是在包含关系的情况下使用</p></li></ul><h4 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h4><p>接下来按照类的声明顺序介绍<code>方法</code>，有必要的情况下结合例子进行说明。</p><h5 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拷贝数组中的有效元素到指定数组中</span></span><br><span class="line"><span class="comment"> * 指定数组不能为null</span></span><br><span class="line"><span class="comment"> * 指定数组的容量大小不能小于Vector中数组的容量大小</span></span><br><span class="line"><span class="comment"> * 指定数组的类型必须能够存储Vector中数组的元素类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> anArray 指定数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">copyInto</span><span class="params">(Object[] anArray)</span> </span>&#123;</span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, anArray, <span class="number">0</span>, elementCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缩小Vector的容量到当前数组的大小，应用可以调用该方法来最小化Vector的存储空间，简单来说就是节约空间，去掉没有用到的剩余数组空间</span></span><br><span class="line"><span class="comment"> * elementCount 是指数组的有效元素，实实在在的大小，而 elementData.length 是数组的总容量大小，也就是说只有当填充/删除元素时elementCount的大小才会变化</span></span><br><span class="line"><span class="comment"> * 而当进行扩容时 elementData.length 才会变化，毕竟数组的长度变大了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">if</span> (elementCount &lt; oldCapacity) &#123;</span><br><span class="line">        elementData = Arrays.copyOf(elementData, elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定的容量增大或缩小Vector的容量大小</span></span><br><span class="line"><span class="comment"> * 若newSize大于有效元素个数，增大的容量会使用null填充</span></span><br><span class="line"><span class="comment"> * 若newSize小于有效元素个数，以newSize为起始索引到结尾的元素都被置为null导致元素丢失，容量保持不变</span></span><br><span class="line"><span class="comment"> * 最后将 elementCount = newSize，导致在增大容量的情况下会出现null</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 若 elementData.length &gt; newSize &gt; elementCount，</span></span><br><span class="line"><span class="comment"> * 若 newSize &gt; elementData.length，Vector容量扩大，多余空间置null</span></span><br><span class="line"><span class="comment"> * 若 elementData.length &gt; elementCount &gt; newSize，则缩小Vector容量，导致元素丢失，容量保持不变</span></span><br><span class="line"><span class="comment"> * 不管大小如何，Vector的有效元素个数都变成 newSize，可能出现null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newSize 指定容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> newSize)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (newSize &gt; elementCount) &#123;</span><br><span class="line">        ensureCapacityHelper(newSize);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize ; i &lt; elementCount ; i++) &#123;</span><br><span class="line">            elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    elementCount = newSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组的容量大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> elementData.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组的有效元素个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组有效元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> elementCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断数组是否为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组是否为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> elementCount == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断数组是否包含指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o, <span class="number">0</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 采用正向遍历的方式，获取与指定元素相等的元素的索引</span></span><br><span class="line"><span class="comment"> * 若存在多个元素，取第一次与指定元素相等的元素的索引</span></span><br><span class="line"><span class="comment"> * 若返回-1则说明不存在指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 与指定元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 采用正向遍历的方式，根据指定起始索引开始，获取与指定元素相等的元素的索引</span></span><br><span class="line"><span class="comment"> * 若存在多个元素，取第一次与指定元素相等的元素的索引</span></span><br><span class="line"><span class="comment"> * 若不存在则返回-1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 与指定元素相等的元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index ; i &lt; elementCount ; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index ; i &lt; elementCount ; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 采用反向遍历的方式，获取与指定元素相等的元素的索引</span></span><br><span class="line"><span class="comment"> * 若存在多个元素，取第一次与指定元素相等的元素的索引</span></span><br><span class="line"><span class="comment"> * 若不存在则返回-1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 与指定元素相等的元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lastIndexOf(o, elementCount-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 采用反向遍历的方式，根据指定起始索引开始，获取与指定元素相等的元素的索引</span></span><br><span class="line"><span class="comment"> * 若存在多个元素，取第一次与指定元素相等的元素的索引</span></span><br><span class="line"><span class="comment"> * 若不存在则返回-1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 与指定元素相等的元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(index + <span class="string">" &gt;= "</span>+ elementCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用该clone之前，该类要实现Cloneable，不然会抛出异常</span></span><br><span class="line"><span class="comment"> * 数组默认已经实现了Cloneable接口，直接调用方法即可，而且直接返回对应的类型，不需要向下转型，同时包含数组元素</span></span><br><span class="line"><span class="comment"> * 浅拷贝与深拷贝，举个例子吧</span></span><br><span class="line"><span class="comment"> * 比如A类中包含基本类型与B类，当调用A类clone方法后，两个A对象肯定是不一致，不然就不叫做拷贝了，不过这不是关键</span></span><br><span class="line"><span class="comment"> * 若A1对象中的B对象与A2对象中的B对象指向同一个对象，则认为它是浅拷贝，认为B没有被拷贝新的一份</span></span><br><span class="line"><span class="comment"> * 若两者指向不相等的话，则认为深拷贝，认为B重新拷贝了一份，不过这通常需要我们自定义代码，就像下面的方法一样</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Vector&lt;E&gt; v = (Vector&lt;E&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, elementCount);</span><br><span class="line">        v.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个包含所有列表元素的有序（按照添加顺序）数组</span></span><br><span class="line"><span class="comment"> * 此方法是创建一个新数组，方便使用者能够随便操作新数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, elementCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将列表的所有元素放入到指定数组中并返回</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：T类型要么是数组中数据的相同类型，要么是数组中数据的父类型，运用多态性质</span></span><br><span class="line"><span class="comment"> * 若传入的新数组容量 &lt; 列表容量，则取它的类类型来创建一个包含列表元素的新数组，并返回</span></span><br><span class="line"><span class="comment"> * 若传入的新数组容量 &gt; 列表容量，则将列表中的元素按照顺序拷贝到新数组中，同时将新数组中索引为size的值设置成null</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 一开始我也好奇为啥要在索引为size上设置个null呢？</span></span><br><span class="line"><span class="comment"> * 看了注释加上自我的理解，若传入的新数组是个空数组的话，那么除了拷贝列表元素后剩余的所有空间的值都为null，此时在给索引为size的值设置成null似乎没有多大</span></span><br><span class="line"><span class="comment"> * 意思；另外一种情况是若传入的新数组不是个空数组，那这个设置就有意义了，传入的新数组的某些元素会被列表元素覆盖，同时有个null，剩下的才是自己本身的数据，呈现这样子一种效果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment"> * list.add(11);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Integer[] str = new Integer[]&#123;1,2,3,4,5,6,7,8,9,10&#125;;</span></span><br><span class="line"><span class="comment"> * Integer[] s1 = list.toArray(str);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * for (Integer s : s1) &#123;</span></span><br><span class="line"><span class="comment"> *     System.out.println(s + ",");</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输出结果：11,null,3,4,5,6,7,8,9,10,</span></span><br><span class="line"><span class="comment"> * 那么设置这个null的意义就在于能够确定列表中元素个数（长度），目前我只有想到这一种情况下有用！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 指定数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 填充完列表元素的指定数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; elementCount)</span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, elementCount, a.getClass());</span><br><span class="line"></span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, elementCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; elementCount)</span><br><span class="line">        a[elementCount] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组中指定索引中的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定索引的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    removeAllElements();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断数组中是否包含指定集合中的所有元素</span></span><br><span class="line"><span class="comment"> * 但凡集合中有一个元素不存在数组中则返回false</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组中是否包含指定集合中的所有元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.containsAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集合与数组取交集</span></span><br><span class="line"><span class="comment"> * 最终数组中只包含与集合共有的元素，相当于在修改数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组元素是否被修改成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.retainAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先判断当前对象与指定对象是否指向同一个对象，就是在判断地址</span></span><br><span class="line"><span class="comment"> * 紧接着判断指定对象属于List的子类</span></span><br><span class="line"><span class="comment"> * 紧接着获取两个对象的迭代器</span></span><br><span class="line"><span class="comment"> * 若两个迭代器的元素个数不相等，则返回false</span></span><br><span class="line"><span class="comment"> * 若两个迭代器的元素个数相等，则将两个迭代器的元素进行对应的比较，但凡出现对应的元素不相等则返回false</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 当前对象与指定对象是否相等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> List))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    ListIterator&lt;E&gt; e1 = listIterator();</span><br><span class="line">    ListIterator&lt;?&gt; e2 = ((List&lt;?&gt;) o).listIterator();</span><br><span class="line">    <span class="keyword">while</span> (e1.hasNext() &amp;&amp; e2.hasNext()) &#123;</span><br><span class="line">        E o1 = e1.next();</span><br><span class="line">        Object o2 = e2.next();</span><br><span class="line">        <span class="keyword">if</span> (!(o1==<span class="keyword">null</span> ? o2==<span class="keyword">null</span> : o1.equals(o2)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !(e1.hasNext() || e2.hasNext());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.hashCode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组元素的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组元素的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取指定起始索引到指定结束索引之间的元素，简称获取指定子集</span></span><br><span class="line"><span class="comment"> * 指定区间中的元素包括起始索引，不包括结束索引</span></span><br><span class="line"><span class="comment"> * 若起始索引与结束索引相等，则返回空元素</span></span><br><span class="line"><span class="comment"> * 对子集的操作，即调用set、add、remove等方法将会影响到整个数组</span></span><br><span class="line"><span class="comment"> * 但在先获取子集后，又对整个数组的结构进行修改，这时在遍历子集则会导致报错，而对于整体的非结构性修改则不会报错，不过依然会影响到子集</span></span><br><span class="line"><span class="comment"> * 所以在获取子集后最好不要修改数组的结构</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 所有跟子集有关的方法和说明，可以参考ArrayList，基本上相似，除了在方法上加上Synchronized(this)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromIndex 起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toIndex 结束索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定区间中的所有元素，称为子集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.synchronizedList(<span class="keyword">super</span>.subList(fromIndex, toIndex), <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历数组，并对数组中的元素进行指定处理</span></span><br><span class="line"><span class="comment"> * 在遍历过程中不允许修改结构，否则会抛出错误</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action 函数式接口，对数组中的元素指定处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">final</span> E[] elementData = (E[]) <span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> elementCount = <span class="keyword">this</span>.elementCount;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; elementCount; i++) &#123;</span><br><span class="line">        action.accept(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定条件移除元素</span></span><br><span class="line"><span class="comment"> * 笔者对BitSet也是第一次接触，针对本文章它显的不是很重要，故而大概了解了一下</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 该方法中将满足条件的元素索引存放到BitSet中，同时记录移除元素的个数removeCount</span></span><br><span class="line"><span class="comment"> * 紧接着BitSet调用 nextClearBit方法，该方法根据指定的索引获取没有在BitSet中存放的下一个索引，直接上个例子吧</span></span><br><span class="line"><span class="comment"> * BitSet removeSet = new BitSet();</span></span><br><span class="line"><span class="comment"> * removeSet.set(1)</span></span><br><span class="line"><span class="comment"> * removeSet.set(2)</span></span><br><span class="line"><span class="comment"> * System.out.println(removeSet.nextClearBit(1))  --&gt; 3</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 一开始已经在BitSet中存放了要移除的元素的索引，当调用nextClearBit方法循环遍历获取到的索引就是要保留的元素的索引</span></span><br><span class="line"><span class="comment"> * 故而直接获取元素的值将其存放到数组中，最后的数组是按照保留元素的顺序进行存放的</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 函数式接口中不能调用修改结构的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filter 使用指定条件来过滤元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> E&gt; filter)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(filter);</span><br><span class="line">    <span class="keyword">int</span> removeCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = elementCount;</span><br><span class="line">    <span class="keyword">final</span> BitSet removeSet = <span class="keyword">new</span> BitSet(size);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="keyword">final</span> E element = (E) elementData[i];</span><br><span class="line">        <span class="keyword">if</span> (filter.test(element)) &#123;</span><br><span class="line">            removeSet.set(i);</span><br><span class="line">            removeCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> anyToRemove = removeCount &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (anyToRemove) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> newSize = size - removeCount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) &#123;</span><br><span class="line">            i = removeSet.nextClearBit(i);</span><br><span class="line">            elementData[j] = elementData[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=newSize; k &lt; size; k++) &#123;</span><br><span class="line">            elementData[k] = <span class="keyword">null</span>;  <span class="comment">// Let gc do its work</span></span><br><span class="line">        &#125;</span><br><span class="line">        elementCount = newSize;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> anyToRemove;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定规则替换所有旧元素</span></span><br><span class="line"><span class="comment"> * operator.apply方法：旧元素作为入参传入，根据规则返回新元素，然后进行替换</span></span><br><span class="line"><span class="comment"> * operator.apply方法中不能调用修改结构的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> operator 指定规则，函数式接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(operator);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = elementCount;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        elementData[i] = operator.apply((E) elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定规则对数组中的元素进行排序</span></span><br><span class="line"><span class="comment"> * 若没有指定规则则使用默认的升序进行排序</span></span><br><span class="line"><span class="comment"> * 指定规则后会调用自定义比较器中的compare方法进行比较排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 自定义比较器，覆写compare方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    Arrays.sort((E[]) elementData, <span class="number">0</span>, elementCount, c);</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取分割迭代器</span></span><br><span class="line"><span class="comment"> * 由于该方法涉及到另外一个接口，会另外新起一篇文章来讲解该内容，这里就不做阐述</span></span><br><span class="line"><span class="comment"> * 附上文章地址：http://zlia.tech/2019/08/28/explain-arraylist-spliterator-sourcecode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> VectorSpliterator&lt;&gt;(<span class="keyword">this</span>, <span class="keyword">null</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="自定义容量-扩容机制"><a href="#自定义容量-扩容机制" class="headerlink" title="自定义容量 + 扩容机制"></a>自定义容量 + 扩容机制</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加Vector的容量大小，在必要情况下，入参minCapacity至少要确保能容纳元素的数量</span></span><br><span class="line"><span class="comment"> * 若当前Vector的容量小于minCapacity，会通过替换内部数组来增加容量大小，换句话就是创建更大长度的数组，然后将elementData指向它</span></span><br><span class="line"><span class="comment"> * 若capacityIncrement大于0，则新数组的长度大小等于旧数组长度大小 + capacityIncrement</span></span><br><span class="line"><span class="comment"> * 若capacityIncrement小于或等于0，则新新数组的长度大小等于旧数组长度大小 * 2，也就是翻倍</span></span><br><span class="line"><span class="comment"> * 但若新数组的长度大小仍然小于minCapacity，则最终的数组大小会是minCapacity</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 综上所述:</span></span><br><span class="line"><span class="comment"> * 扩容时，先计算自动扩充的容量大小</span></span><br><span class="line"><span class="comment"> * 若capacityIncrement大于0，则自动扩容的容量大小是 旧数组长度 + capacityIncrement</span></span><br><span class="line"><span class="comment"> * 若capacityIncrement小于或等于0，则自动扩容的容量大小是 旧数组长度 * 2</span></span><br><span class="line"><span class="comment"> * 得到自动扩容的容量大小后，与minCapacity进行比较，取最大值作为新数组的最终长度大小</span></span><br><span class="line"><span class="comment"> * 最终将elementData指向新数组即可</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity 手动扩充的容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        ensureCapacityHelper(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否需要扩容</span></span><br><span class="line"><span class="comment"> * 注意该方法是没有加synchronized关键字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity 手动扩充的容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityHelper</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 首先获取自动扩充的容量大小</span></span><br><span class="line"><span class="comment"> * 若capacityIncrement大于0，则自动扩充的容量大小：旧数组容量大小 + capacityIncrement</span></span><br><span class="line"><span class="comment"> * 若capacityIncrement小于0，则自动扩充的容量大小：旧数组容量大小 * 2</span></span><br><span class="line"><span class="comment"> * 在不考虑capacityIncrement的前提下，两次自动扩容的关系是翻倍，即2倍</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 判断手动扩充的容量是否大于自动扩充的容量</span></span><br><span class="line"><span class="comment"> * 若大于，则自动扩容的容量修改为手动扩充的容量，即 newCapacity = minCapacity，否则newCapacity不变，即采用自动扩充的容量</span></span><br><span class="line"><span class="comment"> * 为了防止内存溢出，扩容并不是无止境的扩充，当大于一个临界点MAX_ARRAY_SIZE时，就不允许在采用自动扩容的容量大小，而是取最大值或临界点</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 参考hugeCapacity方法：</span></span><br><span class="line"><span class="comment"> * 当程序执行到①时，我们可以知道 newCapacity &gt;= minCapacity（指的是赋值之后的关系）</span></span><br><span class="line"><span class="comment"> * 若MAX_ARRAY_SIZE大于newCapacity，则就开始创建长度为newCapacity的新数组，三者的关系为 MAX_ARRAY_SIZE &gt; newCapacity &gt;= minCapacity</span></span><br><span class="line"><span class="comment"> * 若MAX_ARRAY_SIZE小于newCapacity，则进入到hugeCapacity方法，但此时我们不知道minCapacity 与 MAX_ARRAY_SIZE的大小关系</span></span><br><span class="line"><span class="comment"> * 若minCapacity大于MAX_ARRAY_SIZE，则采用最大值，不允许无限制的手动设置扩充容量，不过最大值有可能会出现内存溢出</span></span><br><span class="line"><span class="comment"> * 三者关系为：newCapacity &gt;= minCapacity &gt; MAX_ARRAY_SIZE</span></span><br><span class="line"><span class="comment"> * 若minCapacity小于MAX_ARRAY_SIZE，则采用临界值，该临界值是保证在不同的操作系统下不会发生内存溢出， 三者关系为：newCapacity &gt; MAX_ARRAY_SIZE &gt; minCapacity</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 得出结论：</span></span><br><span class="line"><span class="comment"> * 添加元素时会先到底临界值，此时不会发生内存溢出，若在往上增长则达到最大值，最大值有可能发生内存溢出</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  minCapacity 手动扩充的容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;    --------------------&gt; ① 手动添加</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断入参minCapacity 是否大于 MAX_ARRAY_SIZE</span></span><br><span class="line"><span class="comment"> * 若 minCapacity &gt; MAX_ARRAY_SIZE，则返回值是最大值</span></span><br><span class="line"><span class="comment"> * 若 minCapacity &lt;= MAX_ARRAY_SIZE，则返回值是临界值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  minCapacity 手动扩充的容量大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 容量大小结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>自动扩容机制</code></p><ul><li>先判断capacityIncrement属性，该属性可以在创建Vector时设置，也可以使用默认值0</li><li>若capacityIncrement大于0，则每次自动扩容都以<code>capacityIncrement</code>大小进行增长</li><li>若capacityIncrement小于0，则每次自动扩容都以<code>2倍</code>的关系进行增长</li><li>如果期间手动扩充容量，则会比较手动扩充的容量大小与自动扩充的容量大小，取较大值进行扩容。</li><li>扩容是比较耗时的，应该尽力去避免，所以在初始化时就应该提供一个容量参数。</li></ul><p><code>容量最大值</code></p><ul><li>最大值是Interger.MAX_VALUE，但容易造成内存溢出，保险起见在容量等于Integer.MAX_VALUE - 8 的时候就应该停止扩充容量。</li></ul><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><p>将枚举类也归到迭代器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有有效元素的枚举类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 枚举类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Enumeration&lt;E&gt; <span class="title">elements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Enumeration&lt;E&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下一个元素的索引</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断当前枚举类中是否有下一个元素</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 是否有下一个元素</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count &lt; elementCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取下一个元素</span></span><br><span class="line"><span class="comment">         * 当获取到下一个元素后，会发生count++ 以此来将索引进行移动，从而达到判断是否有下一个元素</span></span><br><span class="line"><span class="comment">         * 先调用hasMoreElements -&gt; nextElement，否则会抛出异常</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 下一个元素</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">nextElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count &lt; elementCount) &#123;</span><br><span class="line">                    <span class="keyword">return</span> elementData(count++);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Vector Enumeration"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个包含指定索引到结尾之间的元素的列表迭代器</span></span><br><span class="line"><span class="comment"> * 元素之间按照顺序排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含元素的列表迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个包含所有元素的列表迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含元素的列表迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代器，正向迭代</span></span><br><span class="line"><span class="comment"> * 通过判断是否存在下一个元素，若有则获取，若没有则说明迭代结束</span></span><br><span class="line"><span class="comment"> * 由于这块的代码与ArrayList中的代码是一模一样，可以参考ArrayList，不多说了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> E 元素类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;       </span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; </span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != elementCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> elementData(lastRet = i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            Vector.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> size = elementCount;</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            <span class="keyword">final</span> E[] elementData = (E[]) Vector.<span class="keyword">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">                action.accept(elementData[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// update once at end of iteration to reduce heap write traffic</span></span><br><span class="line">            cursor = i;</span><br><span class="line">            lastRet = i - <span class="number">1</span>;</span><br><span class="line">            checkForComodification();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 列表迭代器，正向迭代</span></span><br><span class="line"><span class="comment"> * 可获取上一个元素、下一个元素及索引</span></span><br><span class="line"><span class="comment"> * 与ArrayList一模一样的代码，不多做说明了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        cursor = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">int</span> i = cursor - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            cursor = i;</span><br><span class="line">            <span class="keyword">return</span> elementData(lastRet = i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            Vector.<span class="keyword">this</span>.set(lastRet, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            Vector.<span class="keyword">this</span>.add(i, e);</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组中指定索引的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定索引对应的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">elementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> + elementCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组第一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 第一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">firstElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elementData(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组最后一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最后一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">lastElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elementData(elementCount - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组中指定索引的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定索引对应的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改数组中指定索引的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 新元素，替换索引对应的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> +</span><br><span class="line">                                                 elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    elementData[index] = obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改数组中指定索引的值</span></span><br><span class="line"><span class="comment"> * 与上面的方法区别在于有无返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 新元素，替换索引对应的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧元素，索引对应的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除数组中指定索引的元素，移除元素之前会先进行角标越界判断</span></span><br><span class="line"><span class="comment"> * 移除过程中将index索引位置后续的所有元素都将向左移动一格</span></span><br><span class="line"><span class="comment"> * 为了能让GC尽可能地回收资源，主动将尾部位置设置成null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeElementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> +</span><br><span class="line">                                                 elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j = elementCount - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, j);</span><br><span class="line">    &#125;</span><br><span class="line">    elementCount--;</span><br><span class="line">    elementData[elementCount] = <span class="keyword">null</span>; <span class="comment">/* to let gc do its work */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除数组中第一次出现的指定元素</span></span><br><span class="line"><span class="comment"> * 若数组中不存在指定元素则返回-1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否删除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">removeElement</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> i = indexOf(obj);</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        removeElementAt(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除数组中的所有元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeAllElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// Let gc do its work</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elementCount; i++)</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    elementCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除数组中第一次出现的指定值</span></span><br><span class="line"><span class="comment"> * 与上面的方法区别在于有无返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否删除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeElement(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除数组中指定索引的值，移除元素之前会先进行角标越界判断</span></span><br><span class="line"><span class="comment"> * 移除过程中将index索引位置后续的所有元素都将向左移动一格</span></span><br><span class="line"><span class="comment"> * 为了能让GC尽可能地回收资源，主动将尾部位置设置成null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 移除的旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = elementCount - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--elementCount] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量移除数组中的指定数组的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定移除的元素集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.removeAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除从指定起始索引到指定结束索引之间的所有元素</span></span><br><span class="line"><span class="comment"> * 移除包含fromIndex索引对应的值，但不包括toIndex索引对应的值</span></span><br><span class="line"><span class="comment"> * 移除过程中将toIndex索引位置及其后续的所有元素往左移动 toIndex - fromIndex 格</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 看到这里的时候有些理解难题，在移除元素后索引位置上的元素主动设置成null，我明白这一点，不好理解的点在于算法</span></span><br><span class="line"><span class="comment"> * 假设如下：</span></span><br><span class="line"><span class="comment"> *             f           t</span></span><br><span class="line"><span class="comment"> * 1     2     3     4     5     6     7     8</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 移除3后的结果，注意4是不会被移除的：</span></span><br><span class="line"><span class="comment"> * 1     2     6     7     8     9     null  null</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 根据需求，我们知道要将8位置上的值设置成null，那么问题就在于我怎么才能知道7位置上的索引是多少呢？哦，是7，这个不算，算法应该怎么写呢？</span></span><br><span class="line"><span class="comment"> * 所以我很好奇怎么是这个答案：size - (toIndex-fromIndex)，后面着重理解了一下：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *             f           t</span></span><br><span class="line"><span class="comment"> * 1     2     6     7     8     9     null  null</span></span><br><span class="line"><span class="comment"> * &lt;=             size                         =&gt;</span></span><br><span class="line"><span class="comment"> *                                     &lt;= t-f =&gt;</span></span><br><span class="line"><span class="comment"> * &lt;=               ?                   =&gt;</span></span><br><span class="line"><span class="comment"> * 求?的值，也就是在求null的索引是多少，看上面的图就应该比较好理解了（不知道看的懂不），size - (toIndex-fromIndex)就刚好是索引的值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromIndex 起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toIndex 结束索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = elementCount - toIndex;</span><br><span class="line">    System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">                     numMoved);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let gc do its work</span></span><br><span class="line">    <span class="keyword">int</span> newElementCount = elementCount - (toIndex-fromIndex);</span><br><span class="line">    <span class="keyword">while</span> (elementCount != newElementCount)</span><br><span class="line">        elementData[--elementCount] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义反序列化</span></span><br><span class="line"><span class="comment"> * 直接获取指定键值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> in 输入流</span></span><br><span class="line"><span class="comment"> */</span>    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream in)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    ObjectInputStream.GetField gfields = in.readFields();</span><br><span class="line">    <span class="keyword">int</span> count = gfields.get(<span class="string">"elementCount"</span>, <span class="number">0</span>);</span><br><span class="line">    Object[] data = (Object[])gfields.get(<span class="string">"elementData"</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span> || data == <span class="keyword">null</span> || count &gt; data.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(<span class="string">"Inconsistent vector internals"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    elementCount = count;</span><br><span class="line">    elementData = data.clone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义序列化</span></span><br><span class="line"><span class="comment"> * 直接设置指定键值并写入流中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 输出流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> java.io.ObjectOutputStream.PutField fields = s.putFields();</span><br><span class="line">    <span class="keyword">final</span> Object[] data;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        fields.put(<span class="string">"capacityIncrement"</span>, capacityIncrement);</span><br><span class="line">        fields.put(<span class="string">"elementCount"</span>, elementCount);</span><br><span class="line">        data = elementData.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    fields.put(<span class="string">"elementData"</span>, data);</span><br><span class="line">    s.writeFields();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加-插入元素"><a href="#添加-插入元素" class="headerlink" title="添加/插入元素"></a>添加/插入元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素到数组中的指定位置，添加元素之前会先进行扩容和角标越界判断</span></span><br><span class="line"><span class="comment"> * 插入过程中将index索引位置及后续的所有元素都将向右移动一格，同时将当前索引位置的值修改成新值</span></span><br><span class="line"><span class="comment"> * 数组扩容跟size属性没有任何关系，size只负责数组中有多少个元素，插入元素后故而 + 1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj 新元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insertElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index</span><br><span class="line">                                                 + <span class="string">" &gt; "</span> + elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, elementCount - index);</span><br><span class="line">    elementData[index] = obj;</span><br><span class="line">    elementCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素到数组尾部，添加元素之前会先进行扩容判断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj 新元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addElement</span><span class="params">(E obj)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素到数组尾部，添加元素之前会先进行扩容判断</span></span><br><span class="line"><span class="comment"> * 与上面方法的区别在于是否有返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 新元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素到数组中的指定位置，添加元素之前会先进行扩容和角标越界判断</span></span><br><span class="line"><span class="comment"> * 插入过程中将index索引位置及后续的所有元素都将向右移动一格，同时将当前索引位置的值修改成新值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element  新元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    insertElementAt(element, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加数组到另外一个数组中，从尾部开始追加</span></span><br><span class="line"><span class="comment"> * 相当于合并两个数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组中的元素是否添加到另外一个数组中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityHelper(elementCount + numNew);</span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, elementCount, numNew);</span><br><span class="line">    elementCount += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加数组到另外一个数组中，从指定索引出开始添加</span></span><br><span class="line"><span class="comment"> * 插入过程中将index索引位置及后续的任何元素都将往右移动 numNew 格，相当于是批量插入</span></span><br><span class="line"><span class="comment"> * 相当于在插入前先将原有的元素都往右移动，预先留出空位来给后面要添加的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组中的元素是否添加到另外一个数组中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityHelper(elementCount + numNew);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = elementCount - index;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    elementCount += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>Vector内部通过数组实现，属于线程安全，更准确地来说应该是相对线程安全。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 假设有两个个线程分别调用下面的两个方法</span></span><br><span class="line"><span class="comment"> * 当线程1获取到size方法返回的值时正要去执行get方法，但是却被线程2抢先一步了，导致了remove方法先执行</span></span><br><span class="line"><span class="comment"> * 等到remove方法执行完毕后，也就是删除了最后一个元素，等到get方法执行时，最后一个元素实际上已经被删除了，现在获取的索引已经超出了范围</span></span><br><span class="line"><span class="comment"> * 故会抛出索引越界错误，所以严格来说Vector属于相对线程安全.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  Object <span class="title">getLast</span><span class="params">(Vector list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list.get(list.size() - <span class="number">1</span>);   <span class="comment">//线程1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">deleteLast</span><span class="params">(Vector list)</span> </span>&#123;</span><br><span class="line">    list.remove(list.size() - <span class="number">1</span>);      <span class="comment">//线程2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Vector每次自动扩充的容量大小支持自定义，通过传入capacityIncrement即可。</p></li><li><p>创建空参数的Vector对象时，默认的初始容量是10，当容量不足时，以2倍速度增长。</p></li><li><p>构建Vector对象时，最好能预先设置容量大小，以免减少后期扩容花费的时间。</p></li><li><p>与迭代器不同，elements方法返回的枚举对象不会发生快速失败。</p></li><li><p>Vector容量的临界值是最大值 - 8，这个数字8是因为在数组中除了存储元素之外还会存储数组的长度，而这些数据都在内存中，不同操作系统对内存的分配可能有所差异，减去8更多的是为了防止内存溢出。</p></li><li><p>在获取ArrayList的子集后不能在做结构上的修改。</p></li><li><p>获取迭代器后，不允许进行结构修改操作，因为会 expectedModCount 与 modCount 是否相等。</p></li><li><p>在遍历过程中不允许修改结构，否则会抛出错误。</p></li></ul><h4 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a>重点关注</h4><p><code>默认每次自动扩容的关系是2倍</code> <code>相对线程安全</code> <code>默认初始容量是10</code> <code>底层是通过数组存储元素，故是有序可重复集合</code> <code>自动扩充的容量大小支持自定义（capacityIncrement）</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;上周发布了&lt;a href=&quot;http://zlia.tech/2019/08/16/explain-arraylist-sourcecode/&quot;&gt;探索ArrayList的底层实现&lt;/a&gt;，趁热打铁！实际上&lt;code&gt;ArrayList&lt;/code&gt;与&lt;code&gt;Vector&lt;/code&gt;的实现上非常相似，代码基本上都是一样的，还是老样子，先看注释，我能说注释都差不多一样吗。&lt;/p&gt;
&lt;h4 id=&quot;阅读注释&quot;&gt;&lt;a href=&quot;#阅读注释&quot; class=&quot;headerlink&quot; title=&quot;阅读注释&quot;&gt;&lt;/a&gt;阅读注释&lt;/h4&gt;&lt;p class=&quot;customize-img&quot;&gt;&lt;img src=&quot;/assets/blogImg/java/vector/vector-comment-1.png&quot; alt=&quot;Vector注释-1&quot;&gt;&lt;/p&gt;
&lt;p&gt;Vector内部是通过动态数组实现的。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索ArrayList底层实现</title>
    <link href="http://zlia.tech/2019/08/16/explain-arraylist-sourcecode/"/>
    <id>http://zlia.tech/2019/08/16/explain-arraylist-sourcecode/</id>
    <published>2019-08-16T08:08:04.000Z</published>
    <updated>2019-09-01T09:23:49.379Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a><div><span>背景</span></div></h3><p>想进步，想学习了，反正面试都要问的，还不如早点看了好。探索<code>ArrayList</code>源代码是基于<code>JDK1.8</code>版本的，相比以前的版本不知道有没有优化，毕竟没看过之前版本的底层代码。</p><h3 id="简单说明下"><a href="#简单说明下" class="headerlink" title="简单说明下"></a><div><span>简单说明下</span></div></h3><p>一般看底层代码前我都习惯先阅读下该类的<code>注释说明</code>，也不知道在哪里养成的习惯。相信大家都写过应用代码，既然写过，那也深知注释对于一个使用者来说是多么的重要，决定了它是否能够正确的使用，所以这是一个好习惯。</p><h4 id="阅读注释"><a href="#阅读注释" class="headerlink" title="阅读注释"></a>阅读注释</h4><p class="customize-img"><img src="/assets/blogImg/java/arraylist/arraylist-comment-1.png" alt="ArrayList注释-1"></p><p>看到这不知道你们有没有很惊讶，反正我倒是一惊，所以我说看注释很重要！！！如果是你写代码给别人看，除了看具体代码之外，看注释就是最好的理解方式了，一语道破很多原理，要求不高的我都觉得可以不用看代码实现了，所以接下来会继续阅读注释。</p><a id="more"></a><p class="customize-img"><img src="/assets/blogImg/java/arraylist/arraylist-comment-2.png" alt="ArrayList注释-2"></p><p>这就变相地在说，ArrayList中的get/set效率比LinkedList高，这不正好验证了我们常说的ArryList<code>存取快，插入删除慢</code>，我想它的时间复杂度说明了一切，虽然这里只是给出了结论。在这里顺便提供下<a href="https://blog.csdn.net/qq_41523096/article/details/82142747" target="_blank" rel="noopener">有趣的时间复杂度</a>的介绍文章，便于理解。</p><p class="customize-img"><img src="/assets/blogImg/java/arraylist/arraylist-comment-3.png" alt="ArrayList注释-3"></p><p>简单地说数组会<code>自动扩容</code>。</p><p class="customize-img"><img src="/assets/blogImg/java/arraylist/arraylist-comment-4.png" alt="ArrayList注释-4"></p><p>在这里我将<code>amount</code>翻译成次数，这个单词本意是数量的意思。基于我对ArrayList的了解，当容量不足时，它是需要扩充容量的，就上面咱们提到的自动扩容，每次容量不足时都需要自动扩容，若一开始就设置好这个容量，那么就减少了自动扩容的次数，所以我将它翻译成次数。它的意思就是让你<code>提前设置好容量大小</code>，以便容量不足时需要消耗时间去自动扩容。</p><p class="customize-img"><img src="/assets/blogImg/java/arraylist/arraylist-comment-5.png" alt="ArrayList注释-5"></p><p>大致意思是ArrayList不是线程安全，所以在多线程环境下要在外部控制同步防止数据紊乱。</p><p class="customize-img"><img src="/assets/blogImg/java/arraylist/arraylist-comment-6.png" alt="ArrayList注释-6"></p><p>截图中应该讲的挺明白了！</p><p class="customize-img"><img src="/assets/blogImg/java/arraylist/arraylist-comment-7.png" alt="ArrayList注释-7"></p><p>fail-fast：快速失败，我也是第一次听说该术语，它仅仅用于检测BUG，说明不了什么问题。</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>按照顺序先来看下ArrayList都具有哪些<code>成员属性</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//支持序列化、可克隆、随机访问</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//序列化标识</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认初始值容量大小10</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空数组实例，主要用来做赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[]  EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空数组实例，当采用默认的空构造函数时采用该实例作为默认值</span></span><br><span class="line">    <span class="comment">//该实例与 EMPTY_ELEMENTDATA 被区分开来以便知道当第一个元素被添加时数组该扩充多大，简单来说该属性会参与到计算当中，而 EMPTY_ELEMENTDATA只是用作简单的赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ArrayList中的元素被添加到该数组中</span></span><br><span class="line">    <span class="comment">//ArrayList的容量大小是该数组的长度大小</span></span><br><span class="line">    <span class="comment">//空构造函数的 elementData被赋值为 DEFAULTCAPACITY_EMPTY_ELEMENTDATA，当添加第一个元素时，elementData数组大小将会被扩充到默认容量大小10</span></span><br><span class="line">    <span class="comment">//该对象加上 transient 修饰符表示不对该属性进行序列化</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ArrayList容量大小，意指它包含元素的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们都知道定义一个数组的大小是 int 类型，那么也就意味着最大的数组大小应该是Integer.MAX_VALUE，但是这里为啥要减去8呢？</span></span><br><span class="line">    <span class="comment">//查阅资源发现大部分的人都在说8个字节是用来存储数组的大小，半信半疑</span></span><br><span class="line">    <span class="comment">//分配最大数组，某些VM会在数组中存储header word，按照上面的说法指的应该是数组的大小</span></span><br><span class="line">    <span class="comment">//若尝试去分配更大的数组可能会造成 OutOfMemoryError: 定义的数组大小超过VM上限</span></span><br><span class="line">    <span class="comment">//不同的操作系统对于不同的JDK可能分配的内存会有所差异，所以8这个数字可能是为了保险起见</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ArrayList结构被修改的次数</span></span><br><span class="line">    <span class="comment">//该字段主要针对迭代器与子集使用，若该属性被出乎意料的改变了，调用迭代器的相关方法，如 next、 remove、previous、set、add则会抛出 ConcurrentModificationException异常，该//情况其实就是上面提到的fail-fast</span></span><br><span class="line">    <span class="comment">//严格上来说，该字段并不算是结构被修改的次数，在判断是否需要扩容时，它是首先进行增加在判断，不过这不影响，该字段仅用来判断是否与其他字段相等</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些成员属性都很容易理解，加上提供了注释，所以这边就不做多的阐述！</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>接下来介绍ArrayList提供的<code>构造函数</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个指定初始容量大小的空数组，相当于 new Object[initialCapacity]</span></span><br><span class="line"><span class="comment"> * 若入参initialCapacity大于0，则创建具有指定大小的空数组，并让elementData指向该数组</span></span><br><span class="line"><span class="comment"> * 若入参initialCapacity等于0，则elementData指向已经创建好的空数组</span></span><br><span class="line"><span class="comment"> * 若入参initialCapacity小于0，则抛出参数异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 初始容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span> + initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个初始容量为10的空数组，并让elementData指向已经创建好的空数组</span></span><br><span class="line"><span class="comment"> * 初始容量并不是在这里设置，而是在添加第一个元素时进行初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayLlist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建一个包含指定collection集合的数组，ArrayList容量大小和该集合大小一致，指定集合中的元素按照迭代器的顺序排列</span></span><br><span class="line"><span class="comment"> * collection集合类型有Map、set、List等子类，所以入参可以是多种类型</span></span><br><span class="line"><span class="comment"> * collection集合转换成数组，elementData指向该数组，size成员属性被赋值为collection集合长度</span></span><br><span class="line"><span class="comment"> * 若该数组大小大于0，则判断数组类型是否是Ojbect[],若不是则创建一个新的数组，并拷贝elementData数组中的内容</span></span><br><span class="line"><span class="comment"> * 若该数组大小等于0，则elementData指向空数组</span></span><br><span class="line"><span class="comment"> * collection集合不可能创建长度为负数的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//c.toArray 可能不会返回正确的Object[]类型，这边可能会利用多态的性质，如 A a = new B()</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//空数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>若已经提前知道数组容量，则建议使用new ArrayList(initialCapacity)</p></li><li><p>若不知道数组容量的话，那就没办法了</p></li><li><p>ArrayList(Collection c)一般是在包含关系的情况下使用</p></li></ul><h4 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h4><p>接下来按照类的声明顺序介绍<code>方法</code>，有必要的情况下结合例子进行说明。</p><h5 id="缩小数组大小空间"><a href="#缩小数组大小空间" class="headerlink" title="缩小数组大小空间"></a>缩小数组大小空间</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缩小ArrayList对象的容量到当前数组的大小，应用可以调用该方法来最小化ArrayList对象的存储空间，简单来说就是节约空间，去掉没有用到的剩余数组空间</span></span><br><span class="line"><span class="comment"> * modCount 是记录ArrayList修改结构的次数，节约数组空间就是减少了数组的大小</span></span><br><span class="line"><span class="comment"> * size 是数组填充了元素的个数，实实在在的大小，而 elementData.length 是数组的总容量大小，也就是说只有当填充/删除元素时size的大小才会变化</span></span><br><span class="line"><span class="comment"> * 而当进行扩容时 elementData.length 才会变化，毕竟数组的长度变大了</span></span><br><span class="line"><span class="comment"> * 若size小于elementData.length，则判断 size是否等于0</span></span><br><span class="line"><span class="comment"> * 若size等于0，则将 elementData 指向空数组</span></span><br><span class="line"><span class="comment"> * 若size不等于0，则创建一个大小为size的数组，并将elementData中原有的元素拷贝到新数组中，同时更新elementData指向新数组，从而完成节约数据空间的作用</span></span><br><span class="line"><span class="comment"> * size的长度是不可能大于elementData.length</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        elementData = (size == <span class="number">0</span>) ? EMPTY_ELEMENTDATA</span><br><span class="line">          : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="自定义容量-扩容机制"><a href="#自定义容量-扩容机制" class="headerlink" title="自定义容量 + 扩容机制"></a>自定义容量 + 扩容机制</h5><p>自定义容量可以在创建ArrayList对象时设置，若后期发现容量不足总不能手动去改数值吧，故而提供了其他方法去自定义容量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加ArrayList对象的容量，在必要情况下，入参minCapacity至少要确保能容纳元素的数量</span></span><br><span class="line"><span class="comment"> * 若 elementData 不等于空数组，则minExpand = 0，否则minExpand = DEFAULT_CAPACITY = 10</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 假设去掉设置minExpand的值的语句会造成的影响：</span></span><br><span class="line"><span class="comment"> * 若采用new ArrayList的方式创建对象，则表示在第一次添加元素时，自动将容量扩充到10，而若在此之前先手动扩充容量，如果该值小于10，则会扩容一次，而当容量不足时，</span></span><br><span class="line"><span class="comment"> * 又会扩容一次，总的来说会频繁的进行扩容，而为什么一开始要设置成10呢，微软工程师做过调研，认为该数字比较常用，实际上设置成其它值也是没问题的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 扩容机制为了保证所有的元素都能被容纳，自定义容量与自动扩容的数值会进行比较，取较大值作为扩容的参数，故而有了minCapacity与minExpand的比较</span></span><br><span class="line"><span class="comment"> * 若minCapacity大于minExpand，则调用ensureExplicitCapacity方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  minCapacity 手动扩充的容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span> <span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) ? <span class="number">0</span> : DEFAULT_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * modCount指的是记录修改结构的次数，但若是minCapacity 小于 elementData.length，则结构并没有修改，在这点上不是很难理解</span></span><br><span class="line"><span class="comment"> * 判断完需要扩容的参数，接下来应该判断该参数是否大于预先定义好的总容量大小，还是取较大值</span></span><br><span class="line"><span class="comment"> * 若minCapacity大于elementData.length，则调用grow方法开始扩容</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  minCapacity 手动扩充的容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * oldCapacity &gt;&gt; n：oldCapacity除以2的n次方</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 首先获取当前数组的容量大小，获取自动扩容时的容量大小为 oldCapacity + oldCapacity/2 = 1.5 * oldCapacity，也就是说两次扩容之间是1.5倍的关系</span></span><br><span class="line"><span class="comment"> * 判断手动扩充的容量是否大于自动扩充的容量</span></span><br><span class="line"><span class="comment"> * 若大于，则自动扩容的容量修改为手动扩充的容量，即 newCapacity = minCapacity，否则newCapacity不变，即采用自动扩充的容量</span></span><br><span class="line"><span class="comment"> * 为了防止内存溢出，扩容并不是无止境的扩充，当大于一个临界点MAX_ARRAY_SIZE时，就不允许在采用自动扩容的容量大小，而是取最大值或临界点</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 参考hugeCapacity方法：</span></span><br><span class="line"><span class="comment"> * 当程序执行到①时，我们可以知道 newCapacity &gt;= minCapacity（指的是赋值之后的关系）</span></span><br><span class="line"><span class="comment"> * 若MAX_ARRAY_SIZE大于newCapacity，则就开始创建长度为newCapacity的新数组，三者的关系为 MAX_ARRAY_SIZE &gt; newCapacity &gt;= minCapacity</span></span><br><span class="line"><span class="comment"> * 若MAX_ARRAY_SIZE小于newCapacity，则进入到hugeCapacity方法，但此时我们不知道minCapacity 与 MAX_ARRAY_SIZE的大小关系</span></span><br><span class="line"><span class="comment"> * 若minCapacity大于MAX_ARRAY_SIZE，则采用最大值，不允许无限制的手动设置扩充容量，不过最大值有可能会出现内存溢出</span></span><br><span class="line"><span class="comment"> * 三者关系为：newCapacity &gt;= minCapacity &gt; MAX_ARRAY_SIZE</span></span><br><span class="line"><span class="comment"> * 若minCapacity小于MAX_ARRAY_SIZE，则采用临界值，该临界值是保证在不同的操作系统下不会发生内存溢出， 三者关系为：newCapacity &gt; MAX_ARRAY_SIZE &gt; minCapacity</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 得出结论：</span></span><br><span class="line"><span class="comment"> * 添加元素时会先到底临界值，此时不会发生内存溢出，若在往上增长则达到最大值，最大值有可能发生内存溢出</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  minCapacity 手动扩充的容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;      --------------------&gt; ① 手动添加</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断入参minCapacity 是否大于 MAX_ARRAY_SIZE</span></span><br><span class="line"><span class="comment"> * 若 minCapacity &gt; MAX_ARRAY_SIZE，则返回值是最大值</span></span><br><span class="line"><span class="comment"> * 若 minCapacity &lt;= MAX_ARRAY_SIZE，则返回值是临界值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  minCapacity 手动扩充的容量大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 容量大小结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算出要扩充的容量大小并扩容</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  minCapacity 手动扩充的容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只有在采用new ArrayList()的方式创建对象后，elementData才会等于DEFAULTCAPACITY_EMPTY_ELEMENTDATA，而以其他方式创建对象后都具有一定的容量大小</span></span><br><span class="line"><span class="comment"> * 若 elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA，比较手动扩容与自动扩容的容量大小，取较大值</span></span><br><span class="line"><span class="comment"> * 若不相等，则采用手动扩容容量大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> elementData 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity 手动扩充的容量大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 容量大小结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>什么情况下会扩容</code></p><ul><li>这个问题有点白问，当然了是数组不够用了才需要扩充容量了，不过它不是一个一个的扩充，而是采用一定的规则去扩充，回答的也有点傻！</li></ul><p><code>自动扩容机制</code></p><ul><li>每次自动扩容都以<code>1.5倍</code>的关系进行增长，如果期间手动扩充容量，则会比较手动扩充的容量大小与1.5倍的容量大小，取较大值进行扩容。</li><li>扩容是比较耗时的，应该尽力去避免，所以在初始化时就应该提供一个容量参数。</li></ul><p><code>容量最大值</code></p><ul><li>最大值是Interger.MAX_VALUE，但容易造成内存溢出，保险起见在容量等于Integer.MAX_VALUE - 8 的时候就应该停止扩充容量。</li></ul><h5 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组中指定索引的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定索引对应的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改数组中指定索引的值</span></span><br><span class="line"><span class="comment"> * rangCheck检查角标是否越界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 新元素，替换索引对应的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧元素，索引对应的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加-插入元素"><a href="#添加-插入元素" class="headerlink" title="添加/插入元素"></a>添加/插入元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素到数组尾部，添加元素之前会先进行扩容判断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 新元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素到数组中的指定位置，添加元素之前会先进行扩容和角标越界判断</span></span><br><span class="line"><span class="comment"> * 插入过程中将index索引位置及后续的所有元素都将向右移动一格，同时将当前索引位置的值修改成新值</span></span><br><span class="line"><span class="comment"> * 数组扩容跟size属性没有任何关系，size只负责数组中有多少个元素，插入元素后故而 + 1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element  新元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加数组到另外一个数组中，从尾部开始追加</span></span><br><span class="line"><span class="comment"> * 相当于合并两个数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组中的元素是否添加到另外一个数组中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加数组到另外一个数组中，从指定索引出开始添加</span></span><br><span class="line"><span class="comment"> * 插入过程中将index索引位置及后续的任何元素都将往右移动 numNew 格，相当于是批量插入</span></span><br><span class="line"><span class="comment"> * 相当于在插入前先将原有的元素都往右移动，预先留出空位来给后面要添加的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组中的元素是否添加到另外一个数组中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除数组中指定索引的值，移除元素之前会先进行角标越界判断</span></span><br><span class="line"><span class="comment"> * 移除过程中将index索引位置后续的所有元素都将向左移动一格</span></span><br><span class="line"><span class="comment"> * 为了能让GC尽可能地回收资源，主动将尾部位置设置成null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 移除的旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                            numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除数组中第一次出现的指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否删除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除从指定起始索引到指定结束索引之间的所有元素</span></span><br><span class="line"><span class="comment"> * 移除包含fromIndex索引对应的值，但不包括toIndex索引对应的值</span></span><br><span class="line"><span class="comment"> * 移除过程中将toIndex索引位置及其后续的所有元素往左移动 toIndex - fromIndex 格</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 看到这里的时候有些理解难题，在移除元素后索引位置上的元素主动设置成null，我明白这一点，不好理解的点在于算法</span></span><br><span class="line"><span class="comment"> * 假设如下：</span></span><br><span class="line"><span class="comment"> *             f           t</span></span><br><span class="line"><span class="comment"> * 1     2     3     4     5     6     7     8</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 移除3后的结果，注意4是不会被移除的：</span></span><br><span class="line"><span class="comment"> * 1     2     6     7     8     9     null  null</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 根据需求，我们知道要将8位置上的值设置成null，那么问题就在于我怎么才能知道7位置上的索引是多少呢？哦，是7，这个不算，算法应该怎么写呢？</span></span><br><span class="line"><span class="comment"> * 所以我很好奇怎么是这个答案：size - (toIndex-fromIndex)，后面着重理解了一下：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *             f           t</span></span><br><span class="line"><span class="comment"> * 1     2     6     7     8     9     null  null</span></span><br><span class="line"><span class="comment"> * &lt;=             size                         =&gt;</span></span><br><span class="line"><span class="comment"> *                                     &lt;= t-f =&gt;</span></span><br><span class="line"><span class="comment"> * &lt;=               ?                   =&gt;</span></span><br><span class="line"><span class="comment"> * 求?的值，也就是在求null的索引是多少，看上面的图就应该比较好理解了（不知道看的懂不），size - (toIndex-fromIndex)就刚好是索引的值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromIndex 起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toIndex 结束索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - toIndex;</span><br><span class="line">    System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">                     numMoved);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> newSize = size - (toIndex-fromIndex);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize; i &lt; size; i++) &#123;</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    size = newSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量移除数组中的指定数组的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定移除的元素集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移除元素让我想到一个问题，看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Object[] o = <span class="keyword">new</span> Object[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">System.arraycopy(o, <span class="number">2</span>, o , <span class="number">1</span>, o.length - <span class="number">1</span> - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (Object i :o) &#123;</span><br><span class="line">    System.out.print(i + <span class="string">","</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看下输出结果1,3,4,5,6,6, 前面几个元素应该都明白，但是有一个点：<code>元素你虽然移除了，但是数组的长度依然没变化</code>。当元素往左移动一格后，那最后的索引位置上应该是个什么值，按道理来说，6应该也是往前移动了，所以它的这个位置应该空出来的才对，但是输出结果告诉我们：最后一个位置应该是类似复制操作导致了最后两个元素一样的值，要是不信的话，你可以多试几个值，而在ArrayList中如果不主动设置null的话会造成元素紊乱，就莫名其妙多了一个元素。</p><h5 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组中的元素个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组中的元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否是空元素数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组是否为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 采用正向遍历的方式，获取数组中与指定元素相等的元素的索引</span></span><br><span class="line"><span class="comment"> * 若存在多个元素，取第一次与指定元素相等的元素的索引</span></span><br><span class="line"><span class="comment"> * 若找不到指定元素则返回 -1</span></span><br><span class="line"><span class="comment"> * 方法中通过equals判断两对象是否相等，若是调用Object#equals方法，是在判断两者的地址是否指向同一个</span></span><br><span class="line"><span class="comment"> * 若对象中已经覆写了Object#equals，则应该引起注意！</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 采用反向遍历的方式，获取数组中与指定元素相等的元素的索引</span></span><br><span class="line"><span class="comment"> * 若存在多个元素，取第一次与指定元素相等的元素的索引</span></span><br><span class="line"><span class="comment"> * 若找不到指定元素则返回 -1</span></span><br><span class="line"><span class="comment"> * 方法中通过equals判断两对象是否相等，若是调用Object#equals方法，是在判断两者的地址是否指向同一个</span></span><br><span class="line"><span class="comment"> * 若对象中已经覆写了Object#equals，则应该引起注意！</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用该clone之前，该类要实现Cloneable，不然会抛出异常</span></span><br><span class="line"><span class="comment"> * 数组默认已经实现了Cloneable接口，直接调用方法即可，而且直接返回对应的类型，不需要向下转型，同时包含数组元素</span></span><br><span class="line"><span class="comment"> * 浅拷贝与深拷贝，举个例子吧</span></span><br><span class="line"><span class="comment"> * 比如A类中包含基本类型与B类，当调用A类clone方法后，两个A对象肯定是不一致，不然就不叫做拷贝了，不过这不是关键</span></span><br><span class="line"><span class="comment"> * 若A1对象中的B对象与A2对象中的B对象指向同一个对象，则认为它是浅拷贝，认为B没有被拷贝新的一份</span></span><br><span class="line"><span class="comment"> * 若两者指向不相等的话，则认为深拷贝，认为B重新拷贝了一份，不过这通常需要我们自定义代码，就像下面的方法一样</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 克隆后的新对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">        v.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个包含所有列表元素的有序（按照添加顺序）数组</span></span><br><span class="line"><span class="comment"> * 此方法是创建一个新数组，方便使用者能够随便操作新数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将列表的所有元素放入到指定数组中并返回</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：T类型要么是数组中数据的相同类型，要么是数组中数据的父类型，运用多态性质</span></span><br><span class="line"><span class="comment"> * 若传入的新数组容量 &lt; 列表容量，则取它的类类型来创建一个包含列表元素的新数组，并返回</span></span><br><span class="line"><span class="comment"> * 若传入的新数组容量 &gt; 列表容量，则将列表中的元素按照顺序拷贝到新数组中，同时将新数组中索引为size的值设置成null</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 一开始我也好奇为啥要在索引为size上设置个null呢？</span></span><br><span class="line"><span class="comment"> * 看了注释加上自我的理解，若传入的新数组是个空数组的话，那么除了拷贝列表元素后剩余的所有空间的值都为null，此时在给索引为size的值设置成null似乎没有多大</span></span><br><span class="line"><span class="comment"> * 意思；另外一种情况是若传入的新数组不是个空数组，那这个设置就有意义了，传入的新数组的某些元素会被列表元素覆盖，同时有个null，剩下的才是自己本身的数据，呈现这样子一种效果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment"> * list.add(11);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Integer[] str = new Integer[]&#123;1,2,3,4,5,6,7,8,9,10&#125;;</span></span><br><span class="line"><span class="comment"> * Integer[] s1 = list.toArray(str);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * for (Integer s : s1) &#123;</span></span><br><span class="line"><span class="comment"> *     System.out.println(s + ",");</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输出结果：11,null,3,4,5,6,7,8,9,10,</span></span><br><span class="line"><span class="comment"> * 那么设置这个null的意义就在于能够确定列表中元素个数（长度），但有个前提就是调用者知道链表中的所有节点信息不存在null才有意义，目前我只有想到这一种情况下有用！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 指定数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 填充完列表元素的指定数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组中指定索引中的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定索引的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断索引是否越界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断角标是否越界，该方法专门针对add 和 addAll方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本质上该方法与移除元素没啥区别</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空元素，主动将数组中的元素设置为null方便GC回收垃圾</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集合与数组取交集</span></span><br><span class="line"><span class="comment"> * 最终数组中只包含与集合共有的元素，相当于在修改数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组元素是否被修改成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量删除元素</span></span><br><span class="line"><span class="comment"> * 若集合是否包含指定元素的结果与入参complement比较，</span></span><br><span class="line"><span class="comment"> * 若complement是false，移除数组与集合共有的元素</span></span><br><span class="line"><span class="comment"> * 若complement是true，保留数组与集合共有的元素，即交集</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> complement 比较值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组元素是否被修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">            <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                elementData[w++] = elementData[r];</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></span><br><span class="line">        <span class="comment">// even if c.contains() throws.</span></span><br><span class="line">        <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">            System.arraycopy(elementData, r,</span><br><span class="line">                             elementData, w,</span><br><span class="line">                             size - r);</span><br><span class="line">            w += size - r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">                elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">            modCount += size - w;</span><br><span class="line">            size = w;</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义序列化</span></span><br><span class="line"><span class="comment"> * 若写入过程中数组结构被修改则会抛出异常</span></span><br><span class="line"><span class="comment"> * 如果采用默认的序列化机制，空余的空间会作为null写入本地文件或者在网络中传输，耗费了不必要的资源</span></span><br><span class="line"><span class="comment"> * 故而使用自定义序列化机制，仅写入索引为(0，size）的有效元素以节省资源</span></span><br><span class="line"><span class="comment"> * 默认的序列化机制会将非静态与非瞬时（非transient修饰）写入流中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 输出流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="comment">//执行默认序列化过程</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入元素个数</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按顺序写入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义反序列化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 输入流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行默认的反序列化过程</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//要写读一个字节，因为是按顺序写入</span></span><br><span class="line">    <span class="comment">//因为已经执行了默认的反序列化过程，已经为size赋值了，故不用再次赋值</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> capacity = calculateCapacity(elementData, size);</span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);</span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将流中的元素写入到数组中</span></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历数组，并对数组中的元素进行指定处理</span></span><br><span class="line"><span class="comment"> * 在遍历过程中不允许修改结构，否则会抛出错误</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action 函数式接口，对数组中的元素指定处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">final</span> E[] elementData = (E[]) <span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        action.accept(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定条件移除元素</span></span><br><span class="line"><span class="comment"> * 笔者对BitSet也是第一次接触，针对本文章它显的不是很重要，故而大概了解了一下</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 该方法中将满足条件的元素索引存放到BitSet中，同时记录移除元素的个数removeCount</span></span><br><span class="line"><span class="comment"> * 紧接着BitSet调用 nextClearBit方法，该方法根据指定的索引获取没有在BitSet中存放的下一个索引，直接上个例子吧</span></span><br><span class="line"><span class="comment"> * BitSet removeSet = new BitSet();</span></span><br><span class="line"><span class="comment"> * removeSet.set(1)</span></span><br><span class="line"><span class="comment"> * removeSet.set(2)</span></span><br><span class="line"><span class="comment"> * System.out.println(removeSet.nextClearBit(1))  --&gt; 3</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 一开始已经在BitSet中存放了要移除的元素的索引，当调用nextClearBit方法循环遍历获取到的索引就是要保留的元素的索引</span></span><br><span class="line"><span class="comment"> * 故而直接获取元素的值将其存放到数组中，最后的数组是按照保留元素的顺序进行存放的</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 函数式接口中不能调用修改结构的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filter 使用指定条件来过滤元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> E&gt; filter)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(filter);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> removeCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> BitSet removeSet = <span class="keyword">new</span> BitSet(size);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="keyword">final</span> E element = (E) elementData[i];</span><br><span class="line">        <span class="keyword">if</span> (filter.test(element)) &#123;</span><br><span class="line">            removeSet.set(i);</span><br><span class="line">            removeCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// shift surviving elements left over the spaces left by removed elements</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> anyToRemove = removeCount &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (anyToRemove) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> newSize = size - removeCount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) &#123;</span><br><span class="line">            i = removeSet.nextClearBit(i);</span><br><span class="line">            elementData[j] = elementData[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=newSize; k &lt; size; k++) &#123;</span><br><span class="line">            elementData[k] = <span class="keyword">null</span>;  <span class="comment">// Let gc do its work</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.size = newSize;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> anyToRemove;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定规则替换所有旧元素</span></span><br><span class="line"><span class="comment"> * operator.apply方法：旧元素作为入参传入，根据规则返回新元素，然后进行替换</span></span><br><span class="line"><span class="comment"> * operator.apply方法中不能调用修改结构的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> operator 指定规则，函数式接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(operator);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        elementData[i] = operator.apply((E) elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定规则对数组中的元素进行排序</span></span><br><span class="line"><span class="comment"> * 若没有指定规则则使用默认的升序进行排序</span></span><br><span class="line"><span class="comment"> * 指定规则后会调用自定义比较器中的compare方法进行比较排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 自定义比较器，覆写compare方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    Arrays.sort((E[]) elementData, <span class="number">0</span>, size, c);</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断数组中是否包含指定集合中的所有元素</span></span><br><span class="line"><span class="comment"> * 但凡集合中有一个元素不存在数组中则返回false</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组中是否包含指定集合中的所有元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object e : c)</span><br><span class="line">        <span class="keyword">if</span> (!contains(e))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先判断当前对象与指定对象是否指向同一个对象，就是在判断地址</span></span><br><span class="line"><span class="comment"> * 紧接着判断指定对象属于List的子类</span></span><br><span class="line"><span class="comment"> * 紧接着获取两个对象的迭代器</span></span><br><span class="line"><span class="comment"> * 若两个迭代器的元素个数不相等，则返回false</span></span><br><span class="line"><span class="comment"> * 若两个迭代器的元素个数相等，则将两个迭代器的元素进行对应的比较，但凡出现对应的元素不相等则返回false</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 当前对象与指定对象是否相等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> List))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    ListIterator&lt;E&gt; e1 = listIterator();</span><br><span class="line">    ListIterator&lt;?&gt; e2 = ((List&lt;?&gt;) o).listIterator();</span><br><span class="line">    <span class="keyword">while</span> (e1.hasNext() &amp;&amp; e2.hasNext()) &#123;</span><br><span class="line">        E o1 = e1.next();</span><br><span class="line">        Object o2 = e2.next();</span><br><span class="line">        <span class="keyword">if</span> (!(o1==<span class="keyword">null</span> ? o2==<span class="keyword">null</span> : o1.equals(o2)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !(e1.hasNext() || e2.hasNext());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.hashCode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组元素的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组元素的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取分割迭代器</span></span><br><span class="line"><span class="comment"> * 由于该方法涉及到另外一个接口，会另外新起一篇文章来讲解该内容，这里就不做阐述</span></span><br><span class="line"><span class="comment"> * 附上文章地址：http://zlia.tech/2019/08/28/explain-arraylist-spliterator-sourcecode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayListSpliterator&lt;&gt;(<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个包含指定索引到结尾之间的元素的列表迭代器</span></span><br><span class="line"><span class="comment"> * 元素之间按照顺序排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含元素的列表迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个包含所有元素的列表迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含元素的列表迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代器，正向迭代</span></span><br><span class="line"><span class="comment"> * 通过判断是否存在下一个元素，若有则获取，若没有则说明迭代结束</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> E 元素类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//下一个元素的索引</span></span><br><span class="line">    <span class="keyword">int</span> cursor;</span><br><span class="line">    <span class="comment">//当前元素的索引</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否存在下一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否存在下一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个元素的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个元素的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除迭代过程中当前索引的元素</span></span><br><span class="line"><span class="comment">     * 初始化时当前索引为 -1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">            cursor = lastRet;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历元素，只能遍历一次</span></span><br><span class="line"><span class="comment">     * 在遍历过程中不能调用remove方法，会抛出IllegalStateException异常</span></span><br><span class="line"><span class="comment">     * 因为在移除过程中 lastRet 成员变量始终是 -1，故而会抛出异常</span></span><br><span class="line"><span class="comment">     * 与forEach的区别在于：可以遍历多次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> consumer 函数式接口，声明如何处理元素的函数</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * List&lt;String&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">     * list.add("1");</span></span><br><span class="line"><span class="comment">     * list.add("2");</span></span><br><span class="line"><span class="comment">     * list.iterator().forEachRemaining(str -&gt; &#123;</span></span><br><span class="line"><span class="comment">     *   System.out.println("str:" + str);</span></span><br><span class="line"><span class="comment">     * &#125;);</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * List&lt;String&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">     * list.add("1");</span></span><br><span class="line"><span class="comment">     * list.add("2");</span></span><br><span class="line"><span class="comment">     * list.add("3");</span></span><br><span class="line"><span class="comment">     * list.add("4");</span></span><br><span class="line"><span class="comment">     * list.add("5");</span></span><br><span class="line"><span class="comment">     * Iterator&lt;String&gt; iterator = list.iterator();</span></span><br><span class="line"><span class="comment">     * while (iterator.hasNext()) &#123;</span></span><br><span class="line"><span class="comment">     *  String nextValue = iterator.next();</span></span><br><span class="line"><span class="comment">     *  if (nextValue.equals("3")) &#123;</span></span><br><span class="line"><span class="comment">     *      iterator.forEachRemaining(str -&gt; &#123;</span></span><br><span class="line"><span class="comment">     *          System.out.println("内层：" + str);</span></span><br><span class="line"><span class="comment">     *      &#125;);</span></span><br><span class="line"><span class="comment">     *  &#125;</span></span><br><span class="line"><span class="comment">     *  System.out.println("外层：" + nextValue);</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(consumer);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = ArrayList.<span class="keyword">this</span>.size;</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">            consumer.accept((E) elementData[i++]); <span class="comment">//迭代过程中依次传入元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        cursor = i;</span><br><span class="line">        lastRet = i - <span class="number">1</span>;</span><br><span class="line">        checkForComodification();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化时 modCount 与 expectedModCount 是相等的</span></span><br><span class="line"><span class="comment">     * 但如果在遍历的过程修改数组结构的话，此时 modCount 会有所变化，导致两者不相等，故而抛出异常，也就是我们上面提到的fast-failed异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 列表迭代器，正向迭代</span></span><br><span class="line"><span class="comment"> * 可获取上一个元素、下一个元素及索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        cursor = index;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否有前一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否有前一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个元素的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个元素的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取上一个元素的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 上一个元素的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取上一个元素</span></span><br><span class="line"><span class="comment">     * 在获取过程中会判断该数组结构是否被修改</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 上一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">int</span> i = cursor - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        cursor = i;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随着遍历，索引是会向前移动，用指定元素替换索引处的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 指定元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList.<span class="keyword">this</span>.set(lastRet, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随着遍历，索引是会向前移动，将指定元素添加到下一个索引位置上</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 指定元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            ArrayList.<span class="keyword">this</span>.add(i, e);</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要理解迭代器，很关键的一个点就是<code>cursor</code>，它的位置决定了你调用方法的结果！</p><h5 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取指定起始索引到指定结束索引之间的元素，简称获取指定子集</span></span><br><span class="line"><span class="comment"> * 指定区间中的元素包括起始索引，不包括结束索引</span></span><br><span class="line"><span class="comment"> * 若起始索引与结束索引相等，则返回空元素</span></span><br><span class="line"><span class="comment"> * 对子集的操作，即调用set、add、remove等方法将会影响到整个数组</span></span><br><span class="line"><span class="comment"> * 但在先获取子集后，又对整个数组的结构进行修改，这时在遍历子集则会导致报错，而对于整体的非结构性修改则不会报错，不过依然会影响到子集</span></span><br><span class="line"><span class="comment"> * 所以在获取子集后最好不要修改数组的结构</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromIndex 起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toIndex 结束索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定区间中的所有元素，称为子集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SubList(<span class="keyword">this</span>, <span class="number">0</span>, fromIndex, toIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断起始索引与结束索引</span></span><br><span class="line"><span class="comment"> * 该判断在子集中又获取子集时显得较为重要</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromIndex 起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toIndex 结束索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> size 数组大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">subListRangeCheck</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"fromIndex = "</span> + fromIndex);</span><br><span class="line">    <span class="keyword">if</span> (toIndex &gt; size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"toIndex = "</span> + toIndex);</span><br><span class="line">    <span class="keyword">if</span> (fromIndex &gt; toIndex)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"fromIndex("</span> + fromIndex +</span><br><span class="line">                                           <span class="string">") &gt; toIndex("</span> + toIndex + <span class="string">")"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子集对象，支持随机访问</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  List&lt;String&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment"> *  list.add("1"); //0</span></span><br><span class="line"><span class="comment"> *  list.add("2"); //1</span></span><br><span class="line"><span class="comment"> *  list.add("3"); //2</span></span><br><span class="line"><span class="comment"> *  list.add("4"); //3</span></span><br><span class="line"><span class="comment"> *  list.add("5"); //4</span></span><br><span class="line"><span class="comment"> *  list.add("6"); //5</span></span><br><span class="line"><span class="comment"> *  list.add("7"); //6</span></span><br><span class="line"><span class="comment"> *  list.add("8"); //7</span></span><br><span class="line"><span class="comment"> *  list.add("9"); //8</span></span><br><span class="line"><span class="comment"> *  list.add("10"); //9</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  List&lt;String&gt; sub = list.subList(1,9);</span></span><br><span class="line"><span class="comment"> *  0,1,2,3,4,5,6,7</span></span><br><span class="line"><span class="comment"> *  2,3,4,5,6,7,8,9</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  sub.subList(2,8);</span></span><br><span class="line"><span class="comment"> *  0,1,2,3,4,5</span></span><br><span class="line"><span class="comment"> *  4,5,6,7,8,9</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 以上提供的方法只要是帮助大家去理解子集又获取子集的例子，其中加入了索引（上）及索引对应的元素（下）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SubList</span> <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指向调用者的引用，该变量特别是在子集中又子集时很关键，决定了是否理解该功能的重要因素</span></span><br><span class="line"><span class="comment">     * ArrayList -&gt; subList -&gt; subList</span></span><br><span class="line"><span class="comment">     * 当第一次调用subList获取子集时，为了方便理解，称为子集1，这个时候子集1中的parent指向了ArrayList，这点比较好理解</span></span><br><span class="line"><span class="comment">     * 当子集1又获取子集时，称为子集2，这个时候子集2中的parent指向了子集1，依次类推</span></span><br><span class="line"><span class="comment">     * 如果你仔细看了下面的方法后，你会知道它是如何调用的？例如子集2中调用add方法</span></span><br><span class="line"><span class="comment">     * 子集2#add -&gt; parent#add = 子集1#add -&gt; parent#add = ArrayList#add，最终都会调用到最上层类</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 那么为什么要这么设计呢？何不子集2#add -&gt; ArrayList#add 这样子的调用呢？</span></span><br><span class="line"><span class="comment">     * 理由在于modCount，它是指数组结构被修改的次数，这边就不再阐述何为结构被修改，假设下若按照 子集2#add -&gt; ArrayList#add这样子的顺序调用的话</span></span><br><span class="line"><span class="comment">     * ArrayList#modCount会正常变化，子集2#modCount也会正常变化，可参考add方法中的 this.modCount = parent.modCount 代码片段，</span></span><br><span class="line"><span class="comment">     * 按照上面的假设，此时只有ArrayList与子集2的modCount正常变化，但是子集1却没有变化，那当你在遍历子集1时，它会首先判断子集1的modCount是否与ArrayList的modCount相等</span></span><br><span class="line"><span class="comment">     * 若不相等，则抛出异常，具体可看 checkForComodification 方法，所以子集2#add时，也必须同时修改子集1的modCount，故而如此设计</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 有一个点关键，我们说是因为modCount，而只有结构修改了modCount才会变化，才需要如此调用，那么如果modCount没有被修改呢？</span></span><br><span class="line"><span class="comment">     * 那就不需要那么麻烦了，调用流程就是我们所假设的如此了 子集2#add -&gt; ArrayList#add</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 所以两种设计就用到了两个变量：parentOffset、offset</span></span><br><span class="line"><span class="comment">     * 两个变量分别针对两种方式去调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AbstractList&lt;E&gt; parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前子集索引与父子集索引的偏移量，简单地说就是子集2与子集1的索引偏移量，有一个等式</span></span><br><span class="line"><span class="comment">     * index2：子集2的索引  parentOffset2：子集2的属性</span></span><br><span class="line"><span class="comment">     * index1：子集1的索引  parentOffset1：子集1的属性</span></span><br><span class="line"><span class="comment">     * index3:ArrayList的索引</span></span><br><span class="line"><span class="comment">     * parentOffset2 + index2 = index1 + parentOffset1 = index3</span></span><br><span class="line"><span class="comment">     * 做了那么多，无非就是把子集1与子集2与ArrayList三者关联起来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parentOffset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前子集索引与ArrayList索引的偏移量，简单地说就是子集2与ArrayList的索引偏移量</span></span><br><span class="line"><span class="comment">     * 在创建子集2时，会把子集1与ArrayList的索引偏移量传给子集2，接着在加上子集2与子集1的索引偏移量就可以得到子集2与ArrayList的索引偏移量</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * offset2：子集2与子集1的索引偏移量（fromIndex）</span></span><br><span class="line"><span class="comment">     * offset1：子集1与ArrayList的索引偏移量（offset）</span></span><br><span class="line"><span class="comment">     * offset：当前子集，也就是子集2与ArrayList的索引偏移量</span></span><br><span class="line"><span class="comment">     * offset2 + offset1 = offset</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子集的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent 调用者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> offset 当前子集与ArrayList的索引偏移量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fromIndex 子集的起始索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> toIndex 子集的结束索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SubList(AbstractList&lt;E&gt; parent,</span><br><span class="line">            <span class="keyword">int</span> offset, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex) &#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        <span class="keyword">this</span>.parentOffset = fromIndex;</span><br><span class="line">        <span class="keyword">this</span>.offset = offset + fromIndex;</span><br><span class="line">        <span class="keyword">this</span>.size = toIndex - fromIndex;</span><br><span class="line">        <span class="keyword">this</span>.modCount = ArrayList.<span class="keyword">this</span>.modCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定元素替换子集中的指定索引</span></span><br><span class="line"><span class="comment">     * 指定索引的大小是相对于子集，故而加上offset</span></span><br><span class="line"><span class="comment">     * 由于该方法并没有修改结构，故而直接调用ArrayList的对应方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 相对于子集的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 指定元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 旧元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        E oldValue = ArrayList.<span class="keyword">this</span>.elementData(offset + index);</span><br><span class="line">        ArrayList.<span class="keyword">this</span>.elementData[offset + index] = e;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取子集中指定索引对应的元素</span></span><br><span class="line"><span class="comment">     * 指定索引的大小是相对于子集，故而加上offset</span></span><br><span class="line"><span class="comment">     * 由于该方法并没有修改结构，故而直接调用ArrayList的对应方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 相对于子集的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 指定索引对应的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">return</span> ArrayList.<span class="keyword">this</span>.elementData(offset + index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取子集的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子集中指定索引上添加元素</span></span><br><span class="line"><span class="comment">     * 由于该方法修改了数组结构，故而先调用上层子集的add方法，若没有子集则直接是ArrayList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 相对于子集的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 添加的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        parent.add(parentOffset + index, e);</span><br><span class="line">        <span class="keyword">this</span>.modCount = parent.modCount;</span><br><span class="line">        <span class="keyword">this</span>.size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除子集中指定索引位置的元素</span></span><br><span class="line"><span class="comment">     * 由于该方法修改了数组结构，故而先调用上层子集的remove方法，若没有子集则直接是ArrayList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 相对于子集的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        E result = parent.remove(parentOffset + index);</span><br><span class="line">        <span class="keyword">this</span>.modCount = parent.modCount;</span><br><span class="line">        <span class="keyword">this</span>.size--;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除子集中指定索引范围的所有元素</span></span><br><span class="line"><span class="comment">     * 由于该方法修改了数组结构，故而先调用上层子集的removeRange方法，若没有子集则直接是ArrayList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fromIndex 相对于子集的起始索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> toIndex 相对于子集的结束索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        parent.removeRange(parentOffset + fromIndex,</span><br><span class="line">                           parentOffset + toIndex);</span><br><span class="line">        <span class="keyword">this</span>.modCount = parent.modCount;</span><br><span class="line">        <span class="keyword">this</span>.size -= toIndex - fromIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子集末尾上追加集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c 集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addAll(<span class="keyword">this</span>.size, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子集中指定索引上添加集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 相对于子集的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c 集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        <span class="keyword">int</span> cSize = c.size();</span><br><span class="line">        <span class="keyword">if</span> (cSize==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        checkForComodification();</span><br><span class="line">        parent.addAll(parentOffset + index, c);</span><br><span class="line">        <span class="keyword">this</span>.modCount = parent.modCount;</span><br><span class="line">        <span class="keyword">this</span>.size += cSize;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取子集迭代器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 子集迭代器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> listIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取子集列表迭代器</span></span><br><span class="line"><span class="comment">     * 列表迭代器中的元素是从指定索引开始到结束索引</span></span><br><span class="line"><span class="comment">     * 这里就不对子集列表迭代器中的方法做再次解释了，毕竟它跟ArrayList是类似的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 相对于子集的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="keyword">this</span>.offset;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListIterator&lt;E&gt;() &#123;</span><br><span class="line">            <span class="keyword">int</span> cursor = index;</span><br><span class="line">            <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> expectedModCount = ArrayList.<span class="keyword">this</span>.modCount;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cursor != SubList.<span class="keyword">this</span>.size;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                checkForComodification();</span><br><span class="line">                <span class="keyword">int</span> i = cursor;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= SubList.<span class="keyword">this</span>.size)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">                Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">                <span class="keyword">if</span> (offset + i &gt;= elementData.length)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                cursor = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> (E) elementData[offset + (lastRet = i)];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cursor != <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                checkForComodification();</span><br><span class="line">                <span class="keyword">int</span> i = cursor - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">                Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">                <span class="keyword">if</span> (offset + i &gt;= elementData.length)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                cursor = i;</span><br><span class="line">                <span class="keyword">return</span> (E) elementData[offset + (lastRet = i)];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span> </span>&#123;</span><br><span class="line">                Objects.requireNonNull(consumer);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> size = SubList.<span class="keyword">this</span>.size;</span><br><span class="line">                <span class="keyword">int</span> i = cursor;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">final</span> Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">                <span class="keyword">if</span> (offset + i &gt;= elementData.length) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">                    consumer.accept((E) elementData[offset + (i++)]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// update once at end of iteration to reduce heap write traffic</span></span><br><span class="line">                lastRet = cursor = i;</span><br><span class="line">                checkForComodification();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cursor;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cursor - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">                checkForComodification();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    SubList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">                    cursor = lastRet;</span><br><span class="line">                    lastRet = -<span class="number">1</span>;</span><br><span class="line">                    expectedModCount = ArrayList.<span class="keyword">this</span>.modCount;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">                checkForComodification();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ArrayList.<span class="keyword">this</span>.set(offset + lastRet, e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">                checkForComodification();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = cursor;</span><br><span class="line">                    SubList.<span class="keyword">this</span>.add(i, e);</span><br><span class="line">                    cursor = i + <span class="number">1</span>;</span><br><span class="line">                    lastRet = -<span class="number">1</span>;</span><br><span class="line">                    expectedModCount = ArrayList.<span class="keyword">this</span>.modCount;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (expectedModCount != ArrayList.<span class="keyword">this</span>.modCount)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取子集</span></span><br><span class="line"><span class="comment">     * 子集中又获取子集</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fromIndex 相对于子集的起始索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> toIndex 相对于子集的结束索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 子集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SubList(<span class="keyword">this</span>, offset, fromIndex, toIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验索引是否超出范围</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 相对于子集的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>.size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验索引是否超出范围</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 相对于子集的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="keyword">this</span>.size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 索引超出范围的错误信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 相对于子集的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 错误信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">outOfBoundsMsg</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Index: "</span>+index+<span class="string">", Size: "</span>+<span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验子集的结构修改次数是否与ArrayList一致</span></span><br><span class="line"><span class="comment">     * 若先获取子集后，接着在ArrayList上修改了结构，则会报错</span></span><br><span class="line"><span class="comment">     * 因为子集的modCount并没有随着ArrayList结构的修改而变化，导致了两个变量不一致</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ArrayList.<span class="keyword">this</span>.modCount != <span class="keyword">this</span>.modCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由于该方法涉及到另外一个接口，会另外新起一篇文章来讲解该内容，这里就不做阐述</span></span><br><span class="line"><span class="comment">     * 附上文章地址：http://zlia.tech/2019/07/19/explain-arraylist-spliterator-sourcecode/</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayListSpliterator&lt;E&gt;(ArrayList.<span class="keyword">this</span>, offset,</span><br><span class="line">                                           offset + <span class="keyword">this</span>.size, <span class="keyword">this</span>.modCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Arrays</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拷贝指定数组到新数组中，根据指定的长度缩短或使用null扩充新数组</span></span><br><span class="line"><span class="comment">     * 新数组与原始数组的数据类型是完全一样的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">        <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拷贝指定数组到新数组中，根据指定的长度缩短或使用null扩充新数组</span></span><br><span class="line"><span class="comment">     * 新数组的数据类型由入参newType决定</span></span><br><span class="line"><span class="comment">     * 判断入参newType是否是Ojbect[]类型</span></span><br><span class="line"><span class="comment">     * 若newType是Object[]类型，则创建一个长度为newLength的新数组，并向下转型为T[]类型</span></span><br><span class="line"><span class="comment">     * 若newType不是Object[]类型，则创建一个长度为newLength的新数组，但由于Array.newInstance返回值是Object，故而向下转型为T[]类型</span></span><br><span class="line"><span class="comment">     * Array.newInstance与System.arraycopy属于C底层代码，故而查看不了具体实现</span></span><br><span class="line"><span class="comment">     * System.arraycopye(param1, param2, param3, param4, param5)</span></span><br><span class="line"><span class="comment">     * param1：原始数组； param2：原始数组复制元素的起始角标； param3：新数组； param4：复制元素到新数组的起始角标处；param5：原始数组要从起始角标开始拷贝多少个元素到新数组</span></span><br><span class="line"><span class="comment">     * 从原始数组param1的角标为param2开始复制param5个元素，到新数组param3的角标为param4作为复制元素的起始点</span></span><br><span class="line"><span class="comment">     * 返回新数组，此时已经填充好数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * System.arraycopy性能趋势：当数组大小在百万到千万级别之间时所花费的时间差别不大，但是当达到亿级别后，所花费的时间就会差很多</span></span><br><span class="line"><span class="comment">     * 所以这也就导致了当数组容量达到亿级别后，手动调用ensureCapacity来预先设置容量大小所带来的效率比自动扩容的销量要低很多</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) <span class="keyword">new</span> Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">        System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>, Math.min(original.length, newLength));</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>写的内容有点过多，这里总结一下，方便获取<code>直接获取结果</code>！</p><ul><li><p>ArrayList允许存放Null。</p></li><li><p>ArrayList内部通过数组实现，大体上和Vector类似，除了是非线程安全。</p></li><li><p>ArrayList中的size、isEmpty、get、set、iterator、listIterator的时间复杂度是O(1)，而add操作的时间复杂度是O(n)。</p></li><li><p>由于ArrayList是非线程安全，所以多线程情况下要在外部控制线程安全或使用Collections.synchronizedList也行。</p></li><li><p>创建空参数的ArrayList对象时，默认的初始容量是10，当容量不足时，以1.5倍速度增长。</p></li><li><p>在构建ArrayList对象时，最好能预先设置容量大小，以免减少后期扩容花费的时间。</p></li><li><p>ArrayList容量的临界值是最大值 - 8，这个数字8是因为在数组中除了存储元素之外还会存储数组的长度，而这些数据都在内存中，不同操作系统对内存的分配可能有所差异，减去8更多的是为了防止内存溢出。</p></li><li><p>ArrayList的Iterator迭代器中的forEachRemaining方法只能调用一次，且在该方法中不能调用remove方法。</p></li><li><p>ArrayList的ListIterator迭代器可反向遍历列表。</p></li><li><p>在获取ArrayList的子集后不能在做结构上的修改。</p></li><li><p>获取迭代器后，不允许进行结构修改操作，因为会 expectedModCount 与 modCount 是否相等。</p></li><li><p>在遍历过程中不允许修改结构，否则会抛出错误。</p></li></ul><h4 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a>重点关注</h4><p><code>默认每次自动扩容的关系是1.5倍</code> <code>非线程安全</code> <code>默认初始扩容值10</code> <code>get/set时间复杂度O(1)，add时间复杂度O(n)</code> <code>fail-fast</code> <code>底层是通过数组存储元素，故是有序可重复集合</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;想进步，想学习了，反正面试都要问的，还不如早点看了好。探索&lt;code&gt;ArrayList&lt;/code&gt;源代码是基于&lt;code&gt;JDK1.8&lt;/code&gt;版本的，相比以前的版本不知道有没有优化，毕竟没看过之前版本的底层代码。&lt;/p&gt;
&lt;h3 id=&quot;简单说明下&quot;&gt;&lt;a href=&quot;#简单说明下&quot; class=&quot;headerlink&quot; title=&quot;简单说明下&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;简单说明下&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;一般看底层代码前我都习惯先阅读下该类的&lt;code&gt;注释说明&lt;/code&gt;，也不知道在哪里养成的习惯。相信大家都写过应用代码，既然写过，那也深知注释对于一个使用者来说是多么的重要，决定了它是否能够正确的使用，所以这是一个好习惯。&lt;/p&gt;
&lt;h4 id=&quot;阅读注释&quot;&gt;&lt;a href=&quot;#阅读注释&quot; class=&quot;headerlink&quot; title=&quot;阅读注释&quot;&gt;&lt;/a&gt;阅读注释&lt;/h4&gt;&lt;p class=&quot;customize-img&quot;&gt;&lt;img src=&quot;/assets/blogImg/java/arraylist/arraylist-comment-1.png&quot; alt=&quot;ArrayList注释-1&quot;&gt;&lt;/p&gt;
&lt;p&gt;看到这不知道你们有没有很惊讶，反正我倒是一惊，所以我说看注释很重要！！！如果是你写代码给别人看，除了看具体代码之外，看注释就是最好的理解方式了，一语道破很多原理，要求不高的我都觉得可以不用看代码实现了，所以接下来会继续阅读注释。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Photoshop CC 2014 安装、破解、完全卸载</title>
    <link href="http://zlia.tech/2019/07/19/photoshop-knowledge-1/"/>
    <id>http://zlia.tech/2019/07/19/photoshop-knowledge-1/</id>
    <published>2019-07-19T14:43:22.000Z</published>
    <updated>2019-07-19T14:48:19.317Z</updated>
    
    <content type="html"><![CDATA[<h3 id="先下载在说"><a href="#先下载在说" class="headerlink" title="先下载在说"></a><div><span>先下载在说</span></div></h3><p>废话少说点，上个链接，先下载着在文章。<br><code>安装包下载地址</code>：<a href="https://pan.baidu.com/s/1jijJZpNanLOhZY_yNUJQww" target="_blank" rel="noopener">Photoshop CC 2014 64位安装包</a> 提取码：u3cm。<br><code>破解补丁</code>：<a href="https://pan.baidu.com/s/1r7AFcb32LrRrzWtJb9PD7A" target="_blank" rel="noopener">Photoshop CC 2014 补丁</a> 提取码：cz1c<br>现在都2019年了，为啥还是2014年的版本呢？好老啊！怪作者没有一点基础，有个版本先学着就不错了，莫怪莫怪！</p><a id="more"></a><h3 id="轻松卸载PS"><a href="#轻松卸载PS" class="headerlink" title="轻松卸载PS"></a><div><span>轻松卸载PS</span></div></h3><p>为什么写这个小主题呢？还是吃了没有经验的亏，还以为应该挺好破解的，没想到全程都不能联网，可惜我已经在装好的路上不能回头了，嗯…只好卸载了重新安装了。<br>我也是看了别人写的帖子，这边就不复制粘贴了，没啥意思，以下是<a href="http://www.sucaijishi.com/2016/articles_0318/135.html" target="_blank" rel="noopener">卸载方式</a>，亲测过，很好用，一次成功。<br>不知道该网站作者提供的卸载工具是不是永久有效的，反正我现在使用是可以的，以防万一我在提供个永久有效链接。<br><code>卸载工具地址</code>：<a href="https://pan.baidu.com/s/1mbBytXwsWTq2sUQnJKhpPw" target="_blank" rel="noopener">卸载工具</a> 提取码：19t5。<br>回头一想，万一我提供的网址保个500错误，那我这篇文章岂不是没用了，不行不行，要有它存在的价值，勉强复制下它的内容，哈哈哈。</p><ul><li><p>先像正常软件卸载方式一样卸载它。</p></li><li><p>在使用卸载工具前，先删除以下路径的文件夹：</p><ul><li>C:\Program Files (x86)\Common Files\Adobe</li><li>C:\Program Files\Common Files\Adobe</li><li>C:\ProgramData\Adobe 此目录默认为隐藏目录，先设置系统显示隐藏的文件</li></ul></li><li><p>接着下载卸载工具，这是解压后的目录结构，使用前请先关闭杀毒、卫士等软件。<br><img src="/assets/blogImg/essays/ps/ps-uninstall-tools.png" alt="卸载PS工具目录结构"></p></li></ul><p><code>注意：该卸载工具可以卸载photoshop多个版本，需要卸载哪个版本就选择哪个</code></p><ul><li>紧接着开始扣图了，就按照图片的顺序一一执行就OK了：</li></ul><p class="customize-img"><img src="/assets/blogImg/essays/ps/ps-uninstall-step-1.png" alt="卸载PS步骤-1"></p><p class="customize-img"><img src="/assets/blogImg/essays/ps/ps-uninstall-step-2.png" alt="卸载PS步骤-2"></p><p class="customize-img"><img src="/assets/blogImg/essays/ps/ps-uninstall-step-3.png" alt="卸载PS步骤-3"></p><p class="customize-img"><img src="/assets/blogImg/essays/ps/ps-uninstall-step-4.png" alt="卸载PS步骤-4"></p><p class="customize-img"><img src="/assets/blogImg/essays/ps/ps-uninstall-step-5.png" alt="卸载PS步骤-5"></p><p class="customize-img"><img src="/assets/blogImg/essays/ps/ps-uninstall-step-6.png" alt="卸载PS步骤-6"></p><p><code>清除成功后，别忘记了重启下电脑，这步是不可或缺的!</code>。</p><h3 id="安装与破解"><a href="#安装与破解" class="headerlink" title="安装与破解"></a><div><span>安装与破解</span></div></h3><p>不照搬别人的成果了，安装的文章有很多，这边提供一个<a href="https://ke.qq.com/course/60897?taid=151401892212193&amp;dialog=1" target="_blank" rel="noopener">安装视频链接</a>，该视频中提到的补丁工具我没找到，所以上面只能提供一个补丁，你把下载下来的<code>amtlib.dll</code>补丁放到你安装PS的目录，它会进行替换。</p><p class="customize-img"><img src="/assets/blogImg/essays/ps/ps-crack-patch.png" alt="替换文件"></p><p><code>怎么验证破解成功？当你重启PS时，不会在弹出30天试用期窗口时就代表成功了，恭喜你！</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;先下载在说&quot;&gt;&lt;a href=&quot;#先下载在说&quot; class=&quot;headerlink&quot; title=&quot;先下载在说&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;先下载在说&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;废话少说点，上个链接，先下载着在文章。&lt;br&gt;&lt;code&gt;安装包下载地址&lt;/code&gt;：&lt;a href=&quot;https://pan.baidu.com/s/1jijJZpNanLOhZY_yNUJQww&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Photoshop CC 2014 64位安装包&lt;/a&gt; 提取码：u3cm。&lt;br&gt;&lt;code&gt;破解补丁&lt;/code&gt;：&lt;a href=&quot;https://pan.baidu.com/s/1r7AFcb32LrRrzWtJb9PD7A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Photoshop CC 2014 补丁&lt;/a&gt; 提取码：cz1c&lt;br&gt;现在都2019年了，为啥还是2014年的版本呢？好老啊！怪作者没有一点基础，有个版本先学着就不错了，莫怪莫怪！&lt;/p&gt;
    
    </summary>
    
      <category term="essays" scheme="http://zlia.tech/categories/essays/"/>
    
    
      <category term="photoshop" scheme="http://zlia.tech/tags/photoshop/"/>
    
  </entry>
  
  <entry>
    <title>探索Integer.toBinaryString源码</title>
    <link href="http://zlia.tech/2019/06/25/explain-binary-code/"/>
    <id>http://zlia.tech/2019/06/25/explain-binary-code/</id>
    <published>2019-06-25T11:56:40.000Z</published>
    <updated>2019-06-25T12:02:55.531Z</updated>
    
    <content type="html"><![CDATA[<h3 id="不解驱动着你"><a href="#不解驱动着你" class="headerlink" title="不解驱动着你"></a><div><span>不解驱动着你</span></div></h3><p>一般情况下我是不会主动去看源码的，除非是写专门的主题或者是遇到不懂的难题。果然了，于是带着好奇心尝试理解下源码，一会我先抛出问题，要是有同学一下子就明白了那就可以不用往下看了！还有一个前提就是最好对原码、补码、反码有所了解，因为计算机操作的数据就是以二进制的形式存在的，准确的说是用补码的形式来计算的！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URShift</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(i));</span><br><span class="line"></span><br><span class="line">        i &gt;&gt;&gt;= <span class="number">10</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(i));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> l = -<span class="number">1</span>;</span><br><span class="line">        System.out.println(Long.toBinaryString(l));</span><br><span class="line"></span><br><span class="line">        l &gt;&gt;&gt;= <span class="number">10</span>;</span><br><span class="line">        System.out.println(Long.toBinaryString(l));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">short</span> s = -<span class="number">1</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(s));</span><br><span class="line"></span><br><span class="line">        s &gt;&gt;&gt;= <span class="number">10</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(s));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span> b = -<span class="number">1</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(b));</span><br><span class="line"></span><br><span class="line">        b &gt;&gt;&gt;= <span class="number">10</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11111111111111111111111111111111</span></span><br><span class="line"><span class="number">1111111111111111111111</span></span><br><span class="line"><span class="number">1111111111111111111111111111111111111111111111111111111111111111</span></span><br><span class="line"><span class="number">111111111111111111111111111111111111111111111111111111</span></span><br><span class="line"><span class="number">11111111111111111111111111111111</span></span><br><span class="line"><span class="number">11111111111111111111111111111111</span></span><br><span class="line"><span class="number">11111111111111111111111111111111</span></span><br><span class="line"><span class="number">11111111111111111111111111111111</span></span><br></pre></td></tr></table></figure><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a><div><span>源码</span></div></h3><p><code>Integer.toBinaryString</code>内部实现的方法主要有两个：<code>numberOfLeadingZeros</code> <code>formatUnsignedInt</code>，剩下的就无关紧要了，所以接下来的内容主要围绕着两个方法来讲。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberOfLeadingZeros</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;&gt;&gt; <span class="number">16</span> == <span class="number">0</span>) &#123; n += <span class="number">16</span>; i &lt;&lt;= <span class="number">16</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;&gt;&gt; <span class="number">24</span> == <span class="number">0</span>) &#123; n +=  <span class="number">8</span>; i &lt;&lt;=  <span class="number">8</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;&gt;&gt; <span class="number">28</span> == <span class="number">0</span>) &#123; n +=  <span class="number">4</span>; i &lt;&lt;=  <span class="number">4</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;&gt;&gt; <span class="number">30</span> == <span class="number">0</span>) &#123; n +=  <span class="number">2</span>; i &lt;&lt;=  <span class="number">2</span>; &#125;</span><br><span class="line">    n -= i &gt;&gt;&gt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始之前在复习下计算机的原码、补码、反码的相关计算，举个简单的例子。</p><table><thead><tr><th style="text-align:center">数值</th><th style="text-align:center">原码</th><th style="text-align:center">反码</th><th style="text-align:center">补码</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0000 0000 0000 0000 0000 0000 0000 0001</td><td style="text-align:center">0000 0000 0000 0000 0000 0000 0000 0001</td><td style="text-align:center">0000 0000 0000 0000 0000 0000 0000 0001</td></tr><tr><td style="text-align:center">-1</td><td style="text-align:center">1000 0000 0000 0000 0000 0000 0000 0001</td><td style="text-align:center">1111 1111 1111 1111 1111 1111 1111 1110</td><td style="text-align:center">1111 1111 1111 1111 1111 1111 1111 1111</td></tr></tbody></table><p>为了方便理解，我们采用假设的方式来引导读者。针对<code>numberOfLeadingZeros</code>方法假设入参<code>i = 1</code>，以下分多个步骤来分析该方法，在分析方法之前先跟读者说下该方法的主要作用是：<code>获取该二进制从左侧开始数连续0的个数</code>，有了这个个数就能构建数组的大小去存储有效的数据，二进制中前置位为0的话是不会存储的。</p><ul><li><p>① 判断i是否等于0，结果很明显，此时<code>i = 1，n = 1</code>；</p></li><li><p>② 判断i左移16位后是否等于0，计算如下：</p></li></ul><table><thead><tr><th style="text-align:center">数值</th><th style="text-align:center">计算前</th><th style="text-align:center">移位</th><th style="text-align:center">计算后</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0000 0000 0000 0000 0000 0000 0000 0001</td><td style="text-align:center">左移16</td><td style="text-align:center">0000 0000 0000 0000 0000 0000 0000 0000</td></tr></tbody></table><p>很显然，结果是等于0，故此时<code>n = 17</code>，而i又做了计算，如下：</p><table><thead><tr><th style="text-align:center">数值</th><th style="text-align:center">计算前</th><th style="text-align:center">移位</th><th style="text-align:center">计算后</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0000 0000 0000 0000 0000 0000 0000 0001</td><td style="text-align:center">右移16</td><td style="text-align:center">0000 0000 0000 0001 0000 0000 0000 0000</td></tr></tbody></table><ul><li><p>③ <code>不管是byte还是short类型，它们在移位之前都会被转换成int类型，再进行计算，所以它们的位数也是32位</code>。好奇的地方来了，为啥要左移16位呢，而相等后又要右移16位呢？一开始我也不太懂要这么做，后面看了一片文章觉得应该跟算法有关系，准确的说用的是<code>二分法</code>，就比如有10位数字，利用10位的一半5来做为开头，而后做完逻辑后又取剩下位数的一半来继续做逻辑运算，直接结束。有了以上的两个前提，所以先左移16位，若等于0的话，则说明该二进制左侧<code>至少有连续的16个0</code>，相当于32位中的前16位已经计算好了，接下来就应该计算剩下的16位，因为目前连续的0个数是至少有16位，还有剩下16位不知道情况，所以有可能有更多的0连续。那么问题来了，怎么才能知道后16位的情况呢？准确的来说应该是怎么知道后16位有多少个连续0，这就很明确了，直接计算后16位等于多少不就可以知道结果了吗？是的，就是这么回事，利用二分法，应该是后16位中取前8位来计算，也就是 0000 0000 0000 0000 <u>0000 0000</u> 0000 0001 计算下划线的数字中包含几位连续的0，一般想的话直接会把上面下划线中的数字直接右移8位即可得到结果，可以是可以，只不过写的代码会有很多重复，你要判断多个if-else，而if里头又有if-else，看着很恶心，所以还是算法吊，这边的右移16位是为了跟下一个判断做一个对应。</p></li><li><p>④ 判断i左移24位后是否等于0，相当于计算上面提到的下划线中的数据内容，计算如下：</p></li></ul><table><thead><tr><th style="text-align:center">数值</th><th style="text-align:center">计算前</th><th style="text-align:center">移位</th><th style="text-align:center">计算后</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0000 0000 0000 0001 0000 0000 0000 0001</td><td style="text-align:center">右移24</td><td style="text-align:center">0000 0000 0000 0000 0000 0000 0000 0000</td></tr></tbody></table><p>结果等于0，此时<code>n = 25</code>,而i又做了计算，如下：</p><table><thead><tr><th style="text-align:center">数值</th><th style="text-align:center">计算前</th><th style="text-align:center">移位</th><th style="text-align:center">计算后</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0000 0000 0000 0001 0000 0000 0000 0001</td><td style="text-align:center">右移24</td><td style="text-align:center">0000 0001 0000 0000 0000 0000 0000 0000</td></tr></tbody></table><p>相当于准备要计算最后的8位了，那么就看下一个判断语句了。</p><ul><li><p>⑤ 判断i左移28位，这边就不在一一做运算了，结果<code>n = 29</code>。</p></li><li><p>⑥ 判断i左移30，结果<code>n = 31</code>。</p></li></ul><table><thead><tr><th style="text-align:center">数值</th><th style="text-align:center">结果值</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0100 0000 0000 0000 0000 0000 0000 0000</td></tr></tbody></table><ul><li>⑦ 计算 n = n - i &gt;&gt;&gt; 31，i右移31位后等于0，所以n最终等于31位，刚好说明从左侧开始有连续的31个0。</li></ul><p>接下来讨论另外一个方法<code>formatUnsignedInt</code>，紧接着上面假设后得出的结果，所以<code>mag = 1</code>，表示该数值的有效位是1位，故将会构建长度为1的数组，对于任意数据，最小的长度就是1，而对于最大的长度就要看具体的数值了。好了，<code>formatUnsignedInt</code>方法中入参为<code>val = 1, shift = 1, buf = new char[1], offset = 0, len = 1</code>。在分析之前先说下该方法的主要作用，其实也没啥可说的，就是<code>将数组解析成二进制后并放入到数组中</code>。</p><ul><li><p>① <code>charPos = 1</code>表示有效位的个数，<code>radix = 2</code>表示要转换成二进制的基数，若是要转换后八进制，则radix=8,同理，十六进制radix=16，不过你们也知道二进制的数只有0、1，同理就不阐述其他进制了，<code>mask = 1</code>,一般我们要将十进制转换成其他进制的话，只需要&amp;(与)上对应的进制基数即可得到结果，就好比是八进制的话就&amp;7、十六进制的话就&amp;15，这是最快得到十六进制表示的数值。</p></li><li><p>② 由于要将数组转换成二进制，故&amp;1，根据得到的索引值查找数组当中对应的某个值，然后在数组的最高位上进行存储，相当于越低位应该放在越高位上，正好与二进制的格式相对应，相信不难理解。</p></li><li><p>③ 计算完上一个数后，开始右移动，对于八进制的话应该是右移3位，因为3位数表示1位八进制，同理，对于十六进制应该是右移4位，因为4位数表示1位十六进制，这边是二进制，故右移1位。</p></li><li><p>④ 判断移位后数值是否等于0，毕竟等于0的话咱们就没必要计算了，所以结果会依次循环计算该数值并移位，直到最后。</p></li><li><p>⑤ 每次计算都是把计算结果放到数组当中去，所以<code>buf</code>就是最后的结果，最后在将其转成字符串输出。</p></li></ul><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a><div><span>结束语</span></div></h3><p>源码在适当的情况下还是需要去看的，笔者正在一步一步往这里靠近，努力加强自己的硬实力！加油自己，加油每一个人！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;不解驱动着你&quot;&gt;&lt;a href=&quot;#不解驱动着你&quot; class=&quot;headerlink&quot; title=&quot;不解驱动着你&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;不解驱动着你&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;一般情况下我是不会主动去看源码的，除非是写专门的主题或者是遇到不懂的难题。果然了，于是带着好奇心尝试理解下源码，一会我先抛出问题，要是有同学一下子就明白了那就可以不用往下看了！还有一个前提就是最好对原码、补码、反码有所了解，因为计算机操作的数据就是以二进制的形式存在的，准确的说是用补码的形式来计算的！&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;URShift&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(Integer.toBinaryString(i));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        i &amp;gt;&amp;gt;&amp;gt;= &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(Integer.toBinaryString(i));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; l = -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(Long.toBinaryString(l));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        l &amp;gt;&amp;gt;&amp;gt;= &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(Long.toBinaryString(l));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;short&lt;/span&gt; s = -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(Integer.toBinaryString(s));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        s &amp;gt;&amp;gt;&amp;gt;= &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(Integer.toBinaryString(s));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt; b = -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(Integer.toBinaryString(b));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        b &amp;gt;&amp;gt;&amp;gt;= &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(Integer.toBinaryString(b));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>每日知识点20181212</title>
    <link href="http://zlia.tech/2019/06/25/thinking-in-java-knowledge-20190609/"/>
    <id>http://zlia.tech/2019/06/25/thinking-in-java-knowledge-20190609/</id>
    <published>2019-06-25T11:52:32.000Z</published>
    <updated>2019-09-02T16:00:37.220Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java"><a href="#java" class="headerlink" title="java"></a><div><span>java</span></div></h3><ul><li><p>javadoc只能为public和protected成员进行文档注释，private和默认权限的注释则会被忽略掉，不过可以用-private进行标记，以便把private成员的注释耶包括在内.</p></li><li><p>int x = Character.digit(‘c’, 16)：是把16进制的c转为10进制，结果是12，16进制中a、b、c、d、e、f分别代表10、11、12、13、14、15.</p></li><li><p>计算机中计算都是采用补码计算的。在计算机中的机器字长的最高位表示正负，0为正数，1为负数。正数的原码、反码和补码都一样，都等于原码。负数的反码就是在原码的基础上符号位不变其余位按位取反，负数的补码就是在反码的基础上+1.值得注意的是，计算机将数值10000000表示为最大负数-128.推荐大家看下为什么计算机中要采用补码来储存数据，这是我搜索当中觉得不错的一篇文章-<a href="https://blog.csdn.net/weixin_44734925/article/details/88432355" target="_blank" rel="noopener">为什么计算机采用补码形式进行数据的表示</a>.</p></li><li><p>对于byte或short值进行移位运算，得到的可能不是正确的结果。它们会被转换成int类型，在进行移位操作，然后被<code>截断</code>，赋值给原来的类型.如short i = -1; i &gt;&gt;&gt;= 10; 因为i是short类型，所以会被截断，最终的结果是-1.</p></li><li><p>Math.round：四舍五入.</p></li><li><p>如果在返回void的方法中没有return语句，那么在该方法的结尾处会有一个隐式的return.</p></li><li><p>对于一类中的成员最好使用private访问权限修饰符。若你直接让外部类去访问该属性，有一天如果想要改变获取该属性的方式，那外部类岂不是也要跟着修改，所以最好的方式是用private修改该属性，同时提供具有public修饰符的方法，该方法主要用来获取该属性，至于怎么获取就是你说了算，外部类只要调用该方法即可，即使哪一天获取属性的方式变化了，也只需要修改方法的内部代码即可，外部类的调用方法还是不变.</p></li></ul><a id="more"></a><ul><li><p>当实现某个接口时，并不需要实现嵌套在其内部的任何接口.</p></li><li><p>当某个外围类的对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用.</p></li><li><p>看到这个程序的时候一开始我是不能理解的，后面仔细想想好像很有道理！先不用管为什么要这么写，看就完事了！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> a;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> B b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name);<span class="comment">//compile ok</span></span><br><span class="line">        System.out.println(b.name);<span class="comment">//compile error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> b;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>一开始我想着没问题啊，怎么会报错呢？后面一想想，这是两个事情啊！不能混为一谈.<code>name</code>是在访问A类中的变量，按照<code>protected</code>权限来说是可以访问的，但是对于另外一个对象<code>b</code>自身来说，若是在该类里面去访问name是没问题的，但是借助其他类来访问b对象，让b对象去访问name是不可取的，因为A类与b对象没有任何的关系，<code>b.name</code>就是去访问b类中的name变量，不好意思，它只对子类或同包访问，而A类都不是，可以考虑下若b = new C()，而C类正好继承B，这种多态场景下是不是更好理解一些.</p><ul><li><code>高级for循环</code>，只要是<code>实现了Iterable</code>类都可以使用高级for循环，实际上它底层是调用的迭代器的<code>hasNext</code>与<code>next</code>方法，当然这些是编译器帮你做的，不用我们操心了，于是我又很好奇的尝试了数组，不知道它底层有没有实现Iterable，因为它也是可以使用高级for循环，结果不太一样，也是编译器帮你做的，只不过是假的高级for循环，最终被编译成了普通的for循环了.</li></ul><p class="customize-img"><img src="/assets/blogImg/daliy-konwledge-point/20190812/for-1.png" alt="高级for-1"><br>很简单，以上是源码.</p><p class="customize-img"><img src="/assets/blogImg/daliy-konwledge-point/20190812/for-1.png" alt="高级for-1"><br>以上是编译后的字节码文件，不信你编一个试试.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java&quot;&gt;&lt;a href=&quot;#java&quot; class=&quot;headerlink&quot; title=&quot;java&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;java&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;javadoc只能为public和protected成员进行文档注释，private和默认权限的注释则会被忽略掉，不过可以用-private进行标记，以便把private成员的注释耶包括在内.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;int x = Character.digit(‘c’, 16)：是把16进制的c转为10进制，结果是12，16进制中a、b、c、d、e、f分别代表10、11、12、13、14、15.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;计算机中计算都是采用补码计算的。在计算机中的机器字长的最高位表示正负，0为正数，1为负数。正数的原码、反码和补码都一样，都等于原码。负数的反码就是在原码的基础上符号位不变其余位按位取反，负数的补码就是在反码的基础上+1.值得注意的是，计算机将数值10000000表示为最大负数-128.推荐大家看下为什么计算机中要采用补码来储存数据，这是我搜索当中觉得不错的一篇文章-&lt;a href=&quot;https://blog.csdn.net/weixin_44734925/article/details/88432355&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;为什么计算机采用补码形式进行数据的表示&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于byte或short值进行移位运算，得到的可能不是正确的结果。它们会被转换成int类型，在进行移位操作，然后被&lt;code&gt;截断&lt;/code&gt;，赋值给原来的类型.如short i = -1; i &amp;gt;&amp;gt;&amp;gt;= 10; 因为i是short类型，所以会被截断，最终的结果是-1.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Math.round：四舍五入.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果在返回void的方法中没有return语句，那么在该方法的结尾处会有一个隐式的return.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于一类中的成员最好使用private访问权限修饰符。若你直接让外部类去访问该属性，有一天如果想要改变获取该属性的方式，那外部类岂不是也要跟着修改，所以最好的方式是用private修改该属性，同时提供具有public修饰符的方法，该方法主要用来获取该属性，至于怎么获取就是你说了算，外部类只要调用该方法即可，即使哪一天获取属性的方式变化了，也只需要修改方法的内部代码即可，外部类的调用方法还是不变.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="daily-konwledge-point-java" scheme="http://zlia.tech/tags/daily-konwledge-point-java/"/>
    
  </entry>
  
  <entry>
    <title>推荐初级程序员书单</title>
    <link href="http://zlia.tech/2019/06/08/primary-programmer-book-list/"/>
    <id>http://zlia.tech/2019/06/08/primary-programmer-book-list/</id>
    <published>2019-06-08T07:02:17.000Z</published>
    <updated>2019-06-25T11:50:50.142Z</updated>
    
    <content type="html"><![CDATA[<h3 id="有点菜"><a href="#有点菜" class="headerlink" title="有点菜"></a><div><span>有点菜</span></div></h3><p>嗯…怎么说好呢？由于笔者自我认为还是个初级程序员，所以以下的内容基本上是围绕着我个人的经历来写的。笔者毕业两年了，看过的书籍不是很多，因为刚出来的时候也像你们一样在百度上搜索着程序员书单之类的关键词，然后一一列举下来，做的好一点的呢会去看看书单中每一本书的目录都包含什么及收集一些看过这些书的人的观点，不适合自己的当然是果断排除点！如今自己也看了几本书，觉得都还可以，只不过是针对<code>初级程序员</code>，当然这只是目前情况，笔者还在学习，陆陆续续也会推荐更多的书单介绍。</p><a id="more"></a><h3 id="入门级别"><a href="#入门级别" class="headerlink" title="入门级别"></a><div><span>入门级别</span></div></h3><p>由于笔者对<code>java8</code>有很大的浓厚兴趣，所以我的第一本书籍就是<code>Java核心技术 卷1</code>，市面上有讲java8的书籍应该不是很多吧。这本书的大致内容都是围绕着基础知识来讲，同时涵盖了一些java8的知识内容，比较适合入门不久的同学，遗憾的是对于数据结构这方面的知识只是点到为止，简单介绍而已，这方面的知识不应该也是属于核心技术吗？这我就不懂了，还专门写了swing这块的知识，我直接跳过了，个人觉得知识点不是很重要的块最好可以跳过以免浪费时间，既然看完了卷1，那顺便把卷二也看了吧，哈哈。卷二说实话没有卷一写的好，前面的知识讲的倒一般般，java8 stream的各种使用，后面讲的内容很繁琐，连续跳过了好几个章节，而且给我的感觉是讲的内容很老，当然了，这毕竟是几年前的书了，也难怪！</p><h3 id="入门增强"><a href="#入门增强" class="headerlink" title="入门增强"></a><div><span>入门增强</span></div></h3><p>所谓的入门增强就是在你了解基础知识后进一步的巩固加强它，比如一些原理性的知识能够很大程度的帮助你理解，如果这方面你掌握的很好以后对于框架层源码方面的理解会更容易理解，并且很多公司都注重基础知识，程序员强不强不是看他懂了几个框架，而是你的基础知识，原理性的东西才是最牛逼的，所以笔者一直在各种巩固自己这方面的知识，目前正在看的书籍是<code>java编程思想</code>，具备了前面的基础知识，看这本书会比较容易，该书多数以理论知识来讲解，代码内容不多，更注重于原理方面的知识，非常建议同学去看，只不过可惜的是没有讲到java8，唉，毕竟java8不论是在效率上还是安全性上都增强了，但是具体的理论知识我是想知道的！</p><h3 id="未读书籍"><a href="#未读书籍" class="headerlink" title="未读书籍"></a><div><span>未读书籍</span></div></h3><p>上面提到的书最好能理解透了在过，不然效果没那么明显，或者可以选择看第二遍。以下介绍的书单虽然我还没有看过，但是都是做过功课筛选出来的，罪过罪过。</p><ol><li><code>大话设计模式</code>：重复代码敲多了难免会觉得没意思，来点高大上的代码设计才能冲击你的成就感。</li><li><code>重构改善既有代码的设计</code>：光看这本书的名字就觉得应该很吊，哈哈哈。</li><li><code>数据结构与算法</code>：数据结构这方面的知识一定要下功夫。</li><li><code>java并发编程实战</code>：一样，下功夫吧。</li><li>未完待续。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;有点菜&quot;&gt;&lt;a href=&quot;#有点菜&quot; class=&quot;headerlink&quot; title=&quot;有点菜&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;有点菜&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;嗯…怎么说好呢？由于笔者自我认为还是个初级程序员，所以以下的内容基本上是围绕着我个人的经历来写的。笔者毕业两年了，看过的书籍不是很多，因为刚出来的时候也像你们一样在百度上搜索着程序员书单之类的关键词，然后一一列举下来，做的好一点的呢会去看看书单中每一本书的目录都包含什么及收集一些看过这些书的人的观点，不适合自己的当然是果断排除点！如今自己也看了几本书，觉得都还可以，只不过是针对&lt;code&gt;初级程序员&lt;/code&gt;，当然这只是目前情况，笔者还在学习，陆陆续续也会推荐更多的书单介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="essays" scheme="http://zlia.tech/categories/essays/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>每日知识点20190415</title>
    <link href="http://zlia.tech/2019/05/30/core-java-knowledge-20190415/"/>
    <id>http://zlia.tech/2019/05/30/core-java-knowledge-20190415/</id>
    <published>2019-05-30T15:21:44.000Z</published>
    <updated>2019-08-29T00:26:29.038Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java"><a href="#java" class="headerlink" title="java"></a><div><span>java</span></div></h3><ul><li><p>String v = map.putIfAbsent(“a”, “1”)：若map中不存在指定的key值(a)，则使用指定的key(a)和指定的value(1)进行填充，但此时返回的数据是<code>旧值</code>，所以是null，即v=null，当你真正调用map.get(“a”)时才返回指定的value值，即1.</p></li><li><p>String v = map.computeIfAbsent(“a”, “1”)：若map中不存在指定的key值(a)，则使用指定的key(a)和指定的value(1)进行填充，但此时返回的数据是<code>新值</code>，即v=1.</p></li><li><p>DateTimeFormatter.parse()：可以解析LocalDate、LocalTime、LocalDateTime.</p></li><li><p>MessageFormat：消息格式化，如MessageFormat.format(“hi, my name is {0}”, “zhangsan”)，不仅如此，占位符后面还可以跟一个类型和一个风格，它们之间用逗号隔开.单独将choice拿出来先讲讲，{1,choice,0#no house| 1#one hose | 2#two houses}，一个选择格式是由一个序列对构成的，每一个对包括一个<code>下限</code>和一个<code>格式字符串</code>，下面的列表中是其他的类型.</p></li></ul><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">风格</th></tr></thead><tbody><tr><td style="text-align:center">number</td><td style="text-align:center">integer、currency、percent、$</td></tr><tr><td style="text-align:center">time/date</td><td style="text-align:center">short、medium、long、full、yyyy-MM-dd</td></tr></tbody></table><ul><li>注解中的所有元素值必须是编译期常量.</li></ul><a id="more"></a><ul><li><p>Cannot annotate class literal、Cannot annotate import.</p></li><li><p>注解类型有：基本类型、String、Class、enum类型、注解类型、有前面所述类型组成的数组.</p></li><li><p>引导类加载器负责加载系统类，通常是用C语言来实现的.</p></li><li><p>扩展类加载器用于加载jre/lib/ext目录，即使没有配置任何类路径，它也可以找到其中的各个类.</p></li><li><p>系统类加载器用于加载应用类，查找类路径中的目录或者jar/zip文件里查找这些类.</p></li><li><p>对泛型上下限的理解：<br>  先说个前提，在类型参数确定的情况是可以add具体的对象及子类，个人理解而已.<br>  假设： 苹果 extends 水果、香蕉 extends 水果、其他<br>  <code>? extends 水果</code>：可以指定类型参数为<code>水果或水果的子类</code>，所以<code>类型参数可能是水果也可能是苹果也可能是香蕉</code>，不能确定具体的类型参数，更别说要添加什么类型的对象了，所以是不允许add操作，但是不管类型参数是什么，总之它就是水果，水果是它的最大类型参数，得出结论<code>该语句不能add，但是可以确定返回值是水果</code>.<br>  <code>? super 水果</code>：可以指定类型参数为<code>水果或水果的父类或Object</code>，因为编译器不知道你传入的类型参数是什么，所以不能add水果的父类，否则很容易造成类型参数与值不匹配，但至少有一点是确定的，不管你传入的类型参数是什么，它的子类都有水果，所以不管你传入的类型参数是什么，它都可以添加水果及水果的子类，毕竟水果是确定的一个最小类型参数，但是对于返回值就要看最大类型参数，那就是Object，得出结论<code>该语句能add指定类型参数及子类，但是返回值是Object</code>.<br>  无意中想到的一个快速理解的语句：<code>能不能add看最小类型参数确定没，就能add，没确定就不能，返回值是什么看最大类型参数是什么那返回值就是什么</code>.</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java&quot;&gt;&lt;a href=&quot;#java&quot; class=&quot;headerlink&quot; title=&quot;java&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;java&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;String v = map.putIfAbsent(“a”, “1”)：若map中不存在指定的key值(a)，则使用指定的key(a)和指定的value(1)进行填充，但此时返回的数据是&lt;code&gt;旧值&lt;/code&gt;，所以是null，即v=null，当你真正调用map.get(“a”)时才返回指定的value值，即1.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;String v = map.computeIfAbsent(“a”, “1”)：若map中不存在指定的key值(a)，则使用指定的key(a)和指定的value(1)进行填充，但此时返回的数据是&lt;code&gt;新值&lt;/code&gt;，即v=1.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;DateTimeFormatter.parse()：可以解析LocalDate、LocalTime、LocalDateTime.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MessageFormat：消息格式化，如MessageFormat.format(“hi, my name is {0}”, “zhangsan”)，不仅如此，占位符后面还可以跟一个类型和一个风格，它们之间用逗号隔开.单独将choice拿出来先讲讲，{1,choice,0#no house| 1#one hose | 2#two houses}，一个选择格式是由一个序列对构成的，每一个对包括一个&lt;code&gt;下限&lt;/code&gt;和一个&lt;code&gt;格式字符串&lt;/code&gt;，下面的列表中是其他的类型.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;类型&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;风格&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;number&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;integer、currency、percent、$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;time/date&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;short、medium、long、full、yyyy-MM-dd&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;注解中的所有元素值必须是编译期常量.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="daily-konwledge-point-java" scheme="http://zlia.tech/tags/daily-konwledge-point-java/"/>
    
  </entry>
  
  <entry>
    <title>每日知识点20190226</title>
    <link href="http://zlia.tech/2019/04/14/core-java-knowledge-20190226/"/>
    <id>http://zlia.tech/2019/04/14/core-java-knowledge-20190226/</id>
    <published>2019-04-14T05:02:06.000Z</published>
    <updated>2019-04-15T02:58:41.968Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java"><a href="#java" class="headerlink" title="java"></a><div><span>java</span></div></h3><ul><li><p>java Test &lt; 1.txt表示将1.txt中的内容作为其前面命令的输入.</p></li><li><p>java Test &gt; 1.txt表示将Test的结果输出到1.txt中.</p></li><li><p>双端队列，可以在头部和尾部添加或删除元素，但不支持在队列中间添加元素.</p></li><li><p>coll1.retainAll(coll2)：会从coll1中删除所有未在coll2中出现的元素.</p></li><li><p>方法引用所引用的方法的参数列表必须要和函数式接口中抽象方法的参数列表相同（完全一致），构造引用也是如此.</p></li><li><p>方法引用所引用的方法的的返回值必须要和函数式接口中抽象方法的返回值相同（完全一致），构造引用也是如此.</p><a id="more"></a></li><li><p>Optional作用：它在值不存在的情况下会使用替代物，而只有值存在的情况下才会使用这个值.</p></li><li><p>大家都推荐看核心技术卷1和卷2，为啥我觉得写的不是很通俗易懂呢？很多知识点的内容并没有讲的很明确，比如泛型、通配符这块。</p></li><li><p>对象序列化时序列号的作用是为了标识之前保存过的对象。如一个带有序列号为1的对象之前就被序列化过，那么另外的对象引用了该对象，此时只要在其中保存该对象的序列号即可，就可以引用到该对象.</p></li><li><p>Path类中的normalize方法将移除所有冗余的.和..部件。例如：规范化后/home/cay/../fred/./myprog将产生/home/cay/fred/myprog.</p></li><li><p>通过cmd命令来打包java程序时，可通过jar cvfe TestDemo.jar TestDemo TestDemo.class的方式完成，加上<code>e</code>参数可以在MANIFEST.MF文件中加入<code>Main-Class</code>来指定执行jar包时运行的类，俗称启   动类，如运行java -jar TestDemo.jar时，则会自动去跑TestDemo这个类.</p></li><li><p>p.resolve(q)按照下列规则返回一个路径：</p><ul><li>如果q是绝对路径，则结果就是q.</li><li>否则，根据文件系统的规则，将p后面跟着q作为结果.</li></ul></li><li><p>p.resolveSibling(q)：通过解析指定路径的父路径产生其兄弟路径.</p></li><li><p>Files.createDirectory(path)：其中，路径中除最后一个部件外，其他部分都必须是已存在的。要创建路径中的中间目录，应该使用Files.createDirectories(path).</p></li><li><p>内存映射文件：将一个文件或文件的一部分映射到内存中，然后这个文件就可以当作是内存数组一样地访问，比传统的文件操作要快很多.</p></li><li><p>buffer.flip()是将写模式转成读模式.</p></li><li><p>channel.lock()、channel.tryLock()：第一个调用会阻塞直至可获得锁，而第二个调用将立即返回，要么返回锁，要么在锁不可获得的情况下返回null.</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java&quot;&gt;&lt;a href=&quot;#java&quot; class=&quot;headerlink&quot; title=&quot;java&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;java&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;java Test &amp;lt; 1.txt表示将1.txt中的内容作为其前面命令的输入.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;java Test &amp;gt; 1.txt表示将Test的结果输出到1.txt中.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;双端队列，可以在头部和尾部添加或删除元素，但不支持在队列中间添加元素.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;coll1.retainAll(coll2)：会从coll1中删除所有未在coll2中出现的元素.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;方法引用所引用的方法的参数列表必须要和函数式接口中抽象方法的参数列表相同（完全一致），构造引用也是如此.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;方法引用所引用的方法的的返回值必须要和函数式接口中抽象方法的返回值相同（完全一致），构造引用也是如此.&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="daily-konwledge-point-java" scheme="http://zlia.tech/tags/daily-konwledge-point-java/"/>
    
  </entry>
  
  <entry>
    <title>我叫Spi，新成员</title>
    <link href="http://zlia.tech/2019/04/14/explain-spi-knowledge/"/>
    <id>http://zlia.tech/2019/04/14/explain-spi-knowledge/</id>
    <published>2019-04-14T05:01:40.000Z</published>
    <updated>2019-06-08T06:12:29.709Z</updated>
    
    <content type="html"><![CDATA[<h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a><div><span>自我介绍</span></div></h3><p>Spi，Service Provider Interface，是java提供的一套用来被第三方实现或扩展的API，它可以用来启用框架扩展或替换相应的组件。简单来说就是我提供标准，你按照我的标准提供实现就可以了，当然了，这个实现可以是可以有多个，你想选择哪个都可以，不过前提是你要知道所有的实现才能选择，这操作属于java中的策略模式，而所有的实现都被放在一个配置文件中，所以Spi基本上就是一个<code>接口</code> + <code>策略模式</code> + <code>配置文件</code>组合而成的动态加载机制。在面向对象的设计里，模块之间基于接口编程，模块之间不对实现类硬编码，在不同的场景下需要动态的指明实现类，这就需要一个服务发现的机制，Spi提供这样子的一个机制，为某个接口寻找服务实现的机制，将硬编码移到程序之外，也就是配置文件中，Spi的核心思想就是<code>解耦</code>。<a id="more"></a></p><h3 id="模拟Spi"><a href="#模拟Spi" class="headerlink" title="模拟Spi"></a><div><span>模拟Spi</span></div></h3><p>既然是标准，那么肯定有一些必须要遵守的规范：</p><ol><li>定义服务接口与服务接口的实现类，若是jar包则要在jar包的META-INF/services目录下创建一个以<code>接口全限定名</code>为文件名的文本文件，该文本文件的内容即<code>服务接口实现类的全限定名</code>。</li><li>该jar包记得加入到classpath中。</li><li>服务接口的实现类必须有一个不带参数的构造方法，即默认的构造方法。</li></ol><p>接下来看几个截图，具体的代码实现已经上传到github上了，有兴趣的读者可以看看，菜鸟级别的水平不要见怪！</p><p class="customize-img"><img src="/assets/blogImg/essays/spi/example-spi-1.png" alt="Spi例子-1"></p><p><code>请注意</code>，创建META-INF/service目录后最好看一下目录结构，<code>META-INF是一个目录，而service是它的子目录，这不是只有一层目录</code>，当时就被自己给坑了。</p><p class="customize-img"><img src="/assets/blogImg/essays/spi/example-spi-2.png" alt="Spi例子-2"></p><p>看了以上的内容咱们顺便在说下Spi的优缺点，不对，优点就是一开始说的解耦，将业务代码分离，简单说下缺点吧。看到上面的截图中采用的是ServiceLoader类来加载实现类，源码当中采用的是懒加载的方式，只有当我们去遍历配置文件中的实现类时才会一一实例化，缺点很明显，<code>只能通过遍历的方式去获取每个实现类，若你不想用某个实现类，它最终还是会被实例化，这势必造成了资源的浪费</code>，没有提供通过传入某个参数来获取到指定的实现类，不够灵活。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><div><span>总结</span></div></h3><p>网上有人说很多框架当中使用了Spi机制，比如JDBC加载不同的类型数据库的驱动、不同的日志实现类、Dubbo，虽然这些我都没有看过，但解耦是每个程序都需要的，这也奠定了Spi的重要性。Spi的缺点很明显，<code>可以在它的基础上在包装一层，这部分例子我从其他地方拷贝了过来，挺实用的，而正好是后期完善的，所以上面的截图中并没有显示这些内容，不过我已经放到了github上了</code>，有兴趣可以看看。最后加油自己，加油每一个人。</p><p><a href="https://github.com/JulianHang/little-mvn-project.git" target="_blank" rel="noopener">源码下载</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;自我介绍&quot;&gt;&lt;a href=&quot;#自我介绍&quot; class=&quot;headerlink&quot; title=&quot;自我介绍&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;自我介绍&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;Spi，Service Provider Interface，是java提供的一套用来被第三方实现或扩展的API，它可以用来启用框架扩展或替换相应的组件。简单来说就是我提供标准，你按照我的标准提供实现就可以了，当然了，这个实现可以是可以有多个，你想选择哪个都可以，不过前提是你要知道所有的实现才能选择，这操作属于java中的策略模式，而所有的实现都被放在一个配置文件中，所以Spi基本上就是一个&lt;code&gt;接口&lt;/code&gt; + &lt;code&gt;策略模式&lt;/code&gt; + &lt;code&gt;配置文件&lt;/code&gt;组合而成的动态加载机制。在面向对象的设计里，模块之间基于接口编程，模块之间不对实现类硬编码，在不同的场景下需要动态的指明实现类，这就需要一个服务发现的机制，Spi提供这样子的一个机制，为某个接口寻找服务实现的机制，将硬编码移到程序之外，也就是配置文件中，Spi的核心思想就是&lt;code&gt;解耦&lt;/code&gt;。
    
    </summary>
    
      <category term="essays" scheme="http://zlia.tech/categories/essays/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>我叫QPS，初次见面</title>
    <link href="http://zlia.tech/2019/04/07/explain-qps-knowledge/"/>
    <id>http://zlia.tech/2019/04/07/explain-qps-knowledge/</id>
    <published>2019-04-07T05:33:52.000Z</published>
    <updated>2019-06-08T06:12:19.385Z</updated>
    
    <content type="html"><![CDATA[<h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a><div><span>自我介绍</span></div></h3><p>QPS，query per second，<code>每秒的请求数</code>。当我看到这里的时候很不明白，每秒？按照我的理解应该是计算开始的时间到1秒钟这中间的请求数，但是怎么算是开始的时间，是指服务启动的时间还是第一次请求开始的时间，至少对于我来说讲述的并不是很明确。在比如，有一个时间线，第二秒的后500ms到第三秒的前500ms这样子也算是一个每秒的区间，那这之间的请求数算是咋回事呢？在说说QPS的目的，有人说是为了防止恶意刷取，增加项目负载，既然是控制刷取，那么我觉得这个控制应该是从别人第一次请求的时间开始算起，当它在1秒内多次请求达到上限后被服务限制了，这才算是合理的，所以我觉得应该是<code>从第一次请求开始的时间经过1秒后的请求数</code>，纯属个人理解。最近接触的项目中有提到QPS，说是恶意刷取，更准确的讲应该是用来做<code>流量控制</code>，这个词语给人的感觉更专业！而它算的时间也是从第一次请求开始算起的。 <a id="more"></a></p><h3 id="模拟QPS"><a href="#模拟QPS" class="headerlink" title="模拟QPS"></a><div><span>模拟QPS</span></div></h3><p>方便理解，模拟了一个场景来实现QPS的流量控制效果。<br>假设控制在1秒内不多于Limit个请求，Limit代表请求上限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkQps</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; limit ) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        total++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (System.nanoTime() - start &gt; duration) &#123;</span><br><span class="line">        total++;</span><br><span class="line">        reset();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这只是其中的一部分代码，也是最主要的，要想看所有的可到该文章的底部点击源码下载即可跳转到相应的位置。</p><h3 id="再见朋友"><a href="#再见朋友" class="headerlink" title="再见朋友"></a><div><span>再见朋友</span></div></h3><p>QPS是很多网站来衡量<code>吞吐量</code>的其中一个因素，基本上都会有一个统计图或者曲线图之类的，和QPS有关系的是另外一个朋友-<code>并发数</code>，目前笔者还没有去了解它，对于并发这块的知识点还远远不够，所以还早呢。又到了说几句鸡汤的时候了，技术是永远也学不完的，慢慢来，有一点点的进步总比呆坐着好，加油自己，加油每一个人。</p><p><a href="https://github.com/JulianHang/little-java-project/blob/master/src/tech/zlia/interest/example/FlowControlQpsTest.java" target="_blank" rel="noopener">源码下载</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;自我介绍&quot;&gt;&lt;a href=&quot;#自我介绍&quot; class=&quot;headerlink&quot; title=&quot;自我介绍&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;自我介绍&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;QPS，query per second，&lt;code&gt;每秒的请求数&lt;/code&gt;。当我看到这里的时候很不明白，每秒？按照我的理解应该是计算开始的时间到1秒钟这中间的请求数，但是怎么算是开始的时间，是指服务启动的时间还是第一次请求开始的时间，至少对于我来说讲述的并不是很明确。在比如，有一个时间线，第二秒的后500ms到第三秒的前500ms这样子也算是一个每秒的区间，那这之间的请求数算是咋回事呢？在说说QPS的目的，有人说是为了防止恶意刷取，增加项目负载，既然是控制刷取，那么我觉得这个控制应该是从别人第一次请求的时间开始算起，当它在1秒内多次请求达到上限后被服务限制了，这才算是合理的，所以我觉得应该是&lt;code&gt;从第一次请求开始的时间经过1秒后的请求数&lt;/code&gt;，纯属个人理解。最近接触的项目中有提到QPS，说是恶意刷取，更准确的讲应该是用来做&lt;code&gt;流量控制&lt;/code&gt;，这个词语给人的感觉更专业！而它算的时间也是从第一次请求开始算起的。
    
    </summary>
    
      <category term="essays" scheme="http://zlia.tech/categories/essays/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>每日知识点20190211</title>
    <link href="http://zlia.tech/2019/02/24/core-java-knowledge-20190211/"/>
    <id>http://zlia.tech/2019/02/24/core-java-knowledge-20190211/</id>
    <published>2019-02-24T04:09:16.000Z</published>
    <updated>2019-02-24T04:13:32.696Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java"><a href="#java" class="headerlink" title="java"></a><div><span>java</span></div></h3><ul><li>在同一个catch语句中可以捕获多个<code>不存在子类关系</code>的异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(FileNotFoundException | UnknowHostException e)&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>java中原来有提供<code>断言</code>，学到了学到了.</p></li><li><p>泛型类、泛型方法</p></li><li><p>一个类型变量或通配符可以有多个限定.限定类型用&amp;分隔，而逗号用来分隔类型变量.</p></li></ul><a id="more"></a><ul><li>对于编译器来说，用方法名+参数列表来确定一个方法签名.而对于虚拟机来说，用参数类型+返回类型来确定一个方法，编译器不允许开发者编码出方法名一致，返回值却不同的方法，而它自己却可以自动生成这种操作（产生两个仅返回类型不同的方法字节码）并交给虚拟机来处理.这种操作在泛型中称为<code>桥方法</code>，它主要用来避免类型变量擦除所带来的多态灾难.</li></ul><p class="customize-img"><img src="/assets/blogImg/daliy-konwledge-point/20190217/generic-method.png" alt="桥方法"></p><ul><li>运行时类型查询只适用于原始类型.意思是泛型不支持类型检查.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该类型检查会得到一个编译器错误</span></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Test&lt;String&gt;)&#123;</span><br><span class="line">    <span class="comment">//something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>不能使用像new T()、new T[]、T.class这样子表达式中的类型变量.</p></li><li><p>泛型类的静态上下文中类型变量无效.</p></li><li><p>不能抛出或捕获泛型类的实例.</p></li><li><p>带有超类型限定的通配符可以向泛型对象写入，带有子类型限定的通配符可以从泛型对象读取.</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java&quot;&gt;&lt;a href=&quot;#java&quot; class=&quot;headerlink&quot; title=&quot;java&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;java&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在同一个catch语句中可以捕获多个&lt;code&gt;不存在子类关系&lt;/code&gt;的异常&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt;(FileNotFoundException | UnknowHostException e)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;java中原来有提供&lt;code&gt;断言&lt;/code&gt;，学到了学到了.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;泛型类、泛型方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个类型变量或通配符可以有多个限定.限定类型用&amp;amp;分隔，而逗号用来分隔类型变量.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="daily-konwledge-point-java" scheme="http://zlia.tech/tags/daily-konwledge-point-java/"/>
    
  </entry>
  
  <entry>
    <title>每日知识点20181216</title>
    <link href="http://zlia.tech/2019/02/24/core-java-knowledge-20181216/"/>
    <id>http://zlia.tech/2019/02/24/core-java-knowledge-20181216/</id>
    <published>2019-02-24T04:08:59.000Z</published>
    <updated>2019-02-24T04:08:59.355Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java"><a href="#java" class="headerlink" title="java"></a><div><span>java</span></div></h3><ul><li><p>Arrays.deepToString(a)：打印二维数组.</p></li><li><p>Java8开始时间使用Date类，日期使用<code>LocalDate</code>类.</p></li><li><p>包内的类不能引用默认包中的类.</p></li><li><p>内部类可以是私有类（private），而常规类只可以具有包可见性（default）或公有可见性（public）.</p></li><li><p>内部类不能有static方法.</p></li><li><p>局部类不能用public或private访问说明符进行声明.</p></li></ul><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> flag)</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">FatherInner</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    System.out.println(flag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该段代码编译后生成Father.class与Father$1FatherInner.class文件.反编译Father$1FatherInner.class后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>$1<span class="title">Inner</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Father$<span class="number">1</span>Inner(Father var1,<span class="keyword">boolean</span> var2)&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span> = var1;</span><br><span class="line">        <span class="keyword">this</span>.val$flag = var2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.val$flag)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.val$flag)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> val$flag;</span><br><span class="line">    <span class="keyword">final</span> Father <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>由于构造器的名字与类名相同，而匿名类没有类名，所以匿名类不能有构造器.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java&quot;&gt;&lt;a href=&quot;#java&quot; class=&quot;headerlink&quot; title=&quot;java&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;java&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Arrays.deepToString(a)：打印二维数组.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Java8开始时间使用Date类，日期使用&lt;code&gt;LocalDate&lt;/code&gt;类.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;包内的类不能引用默认包中的类.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内部类可以是私有类（private），而常规类只可以具有包可见性（default）或公有可见性（public）.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内部类不能有static方法.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;局部类不能用public或private访问说明符进行声明.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="daily-konwledge-point-java" scheme="http://zlia.tech/tags/daily-konwledge-point-java/"/>
    
  </entry>
  
  <entry>
    <title>每日知识点20181213</title>
    <link href="http://zlia.tech/2018/12/14/core-java-knowledge-20181213/"/>
    <id>http://zlia.tech/2018/12/14/core-java-knowledge-20181213/</id>
    <published>2018-12-13T16:18:38.000Z</published>
    <updated>2019-02-26T10:38:17.699Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java"><a href="#java" class="headerlink" title="java"></a><div><span>java</span></div></h3><ul><li><p>s.substring(a,b)的长度：b-a.</p></li><li><p>String.join(“/“,”a”,”b”,”c”)：a/b/c.</p></li><li><p><code>字符串常量</code>是共享的，而+或substring等操作产生的结果并不是共享的，所以会导致拼接后的结果随便相同，但引用的地址却不是同一个.</p></li><li><p>Scanner in = new Scanner(System.in),String name = in.next(); //该方法以空格为分隔符，即空格符的之间的内容需要多次获取.</p></li><li><p>上面的读取控制台输入不适合密码，毕竟是明文，所以可采用Console类.但是Console不能在Eclipse或ide中的控制台使用，会报错.必须使用原始控制台，如在终端中编译运行Java代码即可使用.</p></li><li><p>float用<code>24</code>位来表示精确度，int用<code>32</code>位来表示精确度，故当将int转换成float时可能会丢失精度.</p></li><li><p>如果将一个类声明为final，只有其中的方法自动地成为final，而不包括域.</p></li><li><p>编译器对带有文件分割符和扩展名.java的文件进行操作，而java解释器加载类（带有分隔符）.</p></li></ul><a id="more"></a><ul><li><p>最好不要读取在初始化块后面的域</p></li><li><p>自动装箱：<code>Integer.valueOf(int i)</code>.自动装箱规范要求boolean、byte、char&lt;=127，介于-128~127之间的short和int被包装到固定的对象中.在Integer.valueOf(int i)中[-128,127]区间的Integer对象已经被初始化好了，每次调用只会从缓存中取，如果越过了这个区间则会创建新的对象，所以会导致超过了这个区间的Integer对象不相等.</p></li><li><p>装箱和拆箱是<code>编译器</code>认可的，而不是虚拟机.编译器在生成类的字节码时，插入必要的方法调用.虚拟机只是执行这些字节码.</p></li><li><p>整型数组类型int[]可以被转换成Object，但不能转换成对象数组Object[].</p></li><li><p><code>invoke</code>方法访问对象中的静态方法时，第一个参数可以被忽略，即可以将它设置为null.</p></li><li><p>在Java8中接口可以有默认方法和静态方法.</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java&quot;&gt;&lt;a href=&quot;#java&quot; class=&quot;headerlink&quot; title=&quot;java&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;java&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;s.substring(a,b)的长度：b-a.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;String.join(“/“,”a”,”b”,”c”)：a/b/c.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;字符串常量&lt;/code&gt;是共享的，而+或substring等操作产生的结果并不是共享的，所以会导致拼接后的结果随便相同，但引用的地址却不是同一个.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Scanner in = new Scanner(System.in),String name = in.next(); //该方法以空格为分隔符，即空格符的之间的内容需要多次获取.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;上面的读取控制台输入不适合密码，毕竟是明文，所以可采用Console类.但是Console不能在Eclipse或ide中的控制台使用，会报错.必须使用原始控制台，如在终端中编译运行Java代码即可使用.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;float用&lt;code&gt;24&lt;/code&gt;位来表示精确度，int用&lt;code&gt;32&lt;/code&gt;位来表示精确度，故当将int转换成float时可能会丢失精度.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果将一个类声明为final，只有其中的方法自动地成为final，而不包括域.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;编译器对带有文件分割符和扩展名.java的文件进行操作，而java解释器加载类（带有分隔符）.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="daily-konwledge-point-java" scheme="http://zlia.tech/tags/daily-konwledge-point-java/"/>
    
  </entry>
  
  <entry>
    <title>每日知识点20181212</title>
    <link href="http://zlia.tech/2018/12/12/core-java-knowledge-20181212/"/>
    <id>http://zlia.tech/2018/12/12/core-java-knowledge-20181212/</id>
    <published>2018-12-12T14:40:05.000Z</published>
    <updated>2019-01-16T15:16:27.469Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java"><a href="#java" class="headerlink" title="java"></a><div><span>java</span></div></h3><ul><li><p>jdk-8u191-windows-x64：Java SE 8的第<code>191次更新</code>.</p></li><li><p>OpenJDK：Java SE的一个免费的开源实现，不包含浏览器集成或JavaFX（用于图形化界面）.</p></li><li><p>从Java 7开始，数字字面量加下划线：<code>1_000_000</code>，Java编译器会去除这些下划线.</p></li><li><p>Double.isNaN(x)：判断是否是非数值.</p></li><li><p>整型值和布尔值之间不能进行相互转换.</p></li><li><p>Character.isJavaIdentifierStart：指定的字符是否允许作为Java标识符的<code>首字母</code>.</p></li><li><p>Character.isJavaIdentifierPart：指定的字符是否允许作为Java标识符的<code>一部分</code>.</p></li></ul><a id="more"></a><ul><li><p>15.0/2 = 7.5.</p></li><li><p>int -&gt; float：int包含的位数比float所能够表达的<code>位数多</code>，在转换过程中可能会丢失一定的精度.</p></li><li><p>数值类型之间的转换优先级：double &gt; float &gt; long &gt; int.</p></li><li><p>(byte)300 = 44，300是int类型，有32个bits（0000 0000 0001 0010 1100），而byte字节只有<code>8个bits</code>，所以最终取得后8位，即为44.</p></li><li><p>a += b += c：a +=(b += c).</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java&quot;&gt;&lt;a href=&quot;#java&quot; class=&quot;headerlink&quot; title=&quot;java&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;java&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;jdk-8u191-windows-x64：Java SE 8的第&lt;code&gt;191次更新&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;OpenJDK：Java SE的一个免费的开源实现，不包含浏览器集成或JavaFX（用于图形化界面）.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从Java 7开始，数字字面量加下划线：&lt;code&gt;1_000_000&lt;/code&gt;，Java编译器会去除这些下划线.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Double.isNaN(x)：判断是否是非数值.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;整型值和布尔值之间不能进行相互转换.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Character.isJavaIdentifierStart：指定的字符是否允许作为Java标识符的&lt;code&gt;首字母&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Character.isJavaIdentifierPart：指定的字符是否允许作为Java标识符的&lt;code&gt;一部分&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="daily-konwledge-point-java" scheme="http://zlia.tech/tags/daily-konwledge-point-java/"/>
    
  </entry>
  
  <entry>
    <title>搭建基于leancloud的评论系统</title>
    <link href="http://zlia.tech/2018/11/18/leancloud-build/"/>
    <id>http://zlia.tech/2018/11/18/leancloud-build/</id>
    <published>2018-11-18T07:11:42.000Z</published>
    <updated>2019-06-08T06:13:13.216Z</updated>
    
    <content type="html"><![CDATA[<h3 id="博客都有个评论系统"><a href="#博客都有个评论系统" class="headerlink" title="博客都有个评论系统"></a><div><span>博客都有个评论系统</span></div></h3><p>没啥好说的，但凡是个博客都应该有个评论系统。一开始找了个<code>多说</code>还是啥来着，要填写备案信息，好扯，只好绕路。又换了一个，<code>来必力</code>,搜了好几篇文章，都说不错不错，实际上给我的体验一般般，至少它的管理页面让我觉得不爽，当然了，我还是尝试了一波，因为懒，哈哈，结果居然不行！网上的一篇篇博客都TM是复制粘贴的，很难看出谁才是原创作者，没啥意思，真不知道是为了什么？别人的博客可以参考，复制就过分了，把我给气的，所以我的博客并没有放到百度的搜索库中，只有谷歌才能搜到，我宁愿别人没有看到自己的博客，也不想看着自己的成果被人一个个吞噬。后面又看了几篇文章，发现<code>leanCloud</code>这个评论系统是做的真可以，不是我吹牛，不管是文档还是管理端都很符合我的要求，脑子里一下子决定就是它了！当然了，它也没白白让我失望，花了2个晚上的时间就基本搞定了，体验真的好，它是免费的，啥都不用做，就只需要注册登录进去配置内容即可。<a id="more"></a></p><h3 id="动手开始干吧"><a href="#动手开始干吧" class="headerlink" title="动手开始干吧"></a><div><span>动手开始干吧</span></div></h3><p>因为我搭建该评论系统的时候也是参照着别人写好的博客来操作，关键是你提问作者还会准时回答的你，让我很佩服，更加重了我要搭建此评论系统的决心，真的赞！所以这里就贴出两个我觉得很好的博客文章，从零开始搭建的一个教程吧，它们是基于<code>yilia</code>主题来搭建的，因为我的博客应用的便是该主题。这两篇文章加起来刚好很完整，有代码层面的也有配置层面的，当然了，如果你看不懂也是可以在下方进行评论的，我就是其中的一个留言者！</p><p><a href="https://www.xxwhite.com/2017/Valine.html" target="_blank" rel="noopener">yilia主题配置leancloud</a> &amp; <a href="https://panjunwen.com/valine-admin-document/" target="_blank" rel="noopener">leancloud管理端配置</a></p><p><code>这里我在补充一些关键信息，也是非常重要的内容</code>，当初就是该错误让我找不到方向，上面提到的文章的作者也没能给我很好的回答，要是你仔细看评论的话可能会发现我留下的足迹，哈哈，整了2天都是因为该问题，都想放弃了，不够真心觉得它不错所以又拾起来了。按照上面提供的文章配置完毕后，你应该会在你的管理端中发现有这样子的内容，请看截图！</p><p class="customize-img"><img src="/assets/blogImg/leancloud/leancloud-build-1.png" alt="leancloud管理端"></p><p>当初配置完毕后就是少了<code>Comment Count</code>这两张表导致控制台一直报<code>https://xfc3sns5.api.lncld.net/1.1/classes/Comment?····</code>错误，我就想不通了，咋就这样子呢，有人让我创建一个，但我总得知道这表的数据结构吧，我去哪里找呢，肯定不好找，还是找了有一段时间，不好找，于是于是，报着尝试的心里将<code>原有的应用删除掉重新建了一个</code>，果然果然，这两张表有了，是<code>系统帮我们已经创建好的</code>，也就是说之所以第一次没生成成功是因为<code>leancloud</code>系统内部的原因，当然了你看不到内部有啥原因，只是存粹的猜测而已，反正第二次是成功了，开心开心，将内容重新发布后就可以了，控制台也没有报错了，哇！有兴趣的同学可以看下我的博客哈，菜鸟一枚，只为了提高自己来幸福自己！ <a href="http://zlia.tech/">zlia博客</a></p><p>最后的最后，我简单截下我配置后的效果图，里头也加上了评论邮箱通知功能。</p><p class="customize-img"><img src="/assets/blogImg/leancloud/leancloud-build-2.png" alt="配置leancloud管理端-2"></p><p class="customize-img"><img src="/assets/blogImg/leancloud/leancloud-build-3.png" alt="配置leancloud管理端-3"></p><p class="customize-img"><img src="/assets/blogImg/leancloud/leancloud-build-4.png" alt="配置leancloud管理端-4"></p><p class="customize-img"><img src="/assets/blogImg/leancloud/leancloud-build-5.png" alt="配置leancloud管理端-5"></p><p>截的图是相对比较重要的内容，其他像部署库和应用key参考提供的两篇文章就可以解决了，很简单。</p><h3 id="早点实现你想做的事"><a href="#早点实现你想做的事" class="headerlink" title="早点实现你想做的事"></a><div><span>早点实现你想做的事</span></div></h3><p>为啥会是这个小标题呢？好像跟博客没啥毛关系呢，其实是由于搭建了评论系统而进一步完善了博客，基本的东西都拥有了，倘若若干年后我在来回顾自己所写的博客文章，一定会越看越笑，就仿佛吃了蜜一样开心，一步一个脚印建立起来的，很有成就感！我想每个搭建博客的作者都应该会有这样子的感想吧。所以早点去做自己想做的事你就可以早点看到体验到什么叫做成功的人生，哈哈！无奈，感慨了一把！</p><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><a href="https://www.xxwhite.com/2017/Valine.html" target="_blank" rel="noopener">yilia主题配置leancloud</a> &amp; <a href="https://panjunwen.com/valine-admin-document/" target="_blank" rel="noopener">leancloud管理端配置</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;博客都有个评论系统&quot;&gt;&lt;a href=&quot;#博客都有个评论系统&quot; class=&quot;headerlink&quot; title=&quot;博客都有个评论系统&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;博客都有个评论系统&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;没啥好说的，但凡是个博客都应该有个评论系统。一开始找了个&lt;code&gt;多说&lt;/code&gt;还是啥来着，要填写备案信息，好扯，只好绕路。又换了一个，&lt;code&gt;来必力&lt;/code&gt;,搜了好几篇文章，都说不错不错，实际上给我的体验一般般，至少它的管理页面让我觉得不爽，当然了，我还是尝试了一波，因为懒，哈哈，结果居然不行！网上的一篇篇博客都TM是复制粘贴的，很难看出谁才是原创作者，没啥意思，真不知道是为了什么？别人的博客可以参考，复制就过分了，把我给气的，所以我的博客并没有放到百度的搜索库中，只有谷歌才能搜到，我宁愿别人没有看到自己的博客，也不想看着自己的成果被人一个个吞噬。后面又看了几篇文章，发现&lt;code&gt;leanCloud&lt;/code&gt;这个评论系统是做的真可以，不是我吹牛，不管是文档还是管理端都很符合我的要求，脑子里一下子决定就是它了！当然了，它也没白白让我失望，花了2个晚上的时间就基本搞定了，体验真的好，它是免费的，啥都不用做，就只需要注册登录进去配置内容即可。
    
    </summary>
    
      <category term="essays" scheme="http://zlia.tech/categories/essays/"/>
    
    
      <category term="leancloud" scheme="http://zlia.tech/tags/leancloud/"/>
    
  </entry>
  
  <entry>
    <title>不蒜子更换域名通告</title>
    <link href="http://zlia.tech/2018/11/14/busuanzi-latest-notice/"/>
    <id>http://zlia.tech/2018/11/14/busuanzi-latest-notice/</id>
    <published>2018-11-14T13:52:06.000Z</published>
    <updated>2018-11-14T13:54:27.006Z</updated>
    
    <content type="html"><![CDATA[<h3 id="想要告诉不知道的人"><a href="#想要告诉不知道的人" class="headerlink" title="想要告诉不知道的人"></a><div><span>想要告诉不知道的人</span></div></h3><p>你有博客吗？有的话继续往下看，没有的话就再见吧！有博客的人都是有故事的…废话不多说了，由于博客中会用到文章阅读量与网站访问人数的统计，我这边引用的是<code>不蒜子</code>插件。前几天发现控制台不断报与不蒜子相关的404错误，一看就知道肯定有蹊跷，果然，<code>原来它域名更改了</code>！官网都贴出了通告了！<a id="more"></a></p><p class="customize-img"><img src="/assets/blogImg/notice/busuanzi/busuanzi-1.png" alt="不蒜子更换域名通告"></p><p>作者的博客采用的主题为<code>yilia</code>，故这里贴出该主题的解决办法，其实就改个域名重新发布就OK了。</p><p>只需更改该目录下的<code>after-footer.ejs</code>文件即可。</p><p class="customize-img"><img src="/assets/blogImg/notice/busuanzi/busuanzi-2.png" alt="文件目录"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js••"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>更改为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p class="customize-img"><img src="/assets/blogImg/notice/busuanzi/busuanzi-3.png" alt="更改域名"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;想要告诉不知道的人&quot;&gt;&lt;a href=&quot;#想要告诉不知道的人&quot; class=&quot;headerlink&quot; title=&quot;想要告诉不知道的人&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;想要告诉不知道的人&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;你有博客吗？有的话继续往下看，没有的话就再见吧！有博客的人都是有故事的…废话不多说了，由于博客中会用到文章阅读量与网站访问人数的统计，我这边引用的是&lt;code&gt;不蒜子&lt;/code&gt;插件。前几天发现控制台不断报与不蒜子相关的404错误，一看就知道肯定有蹊跷，果然，&lt;code&gt;原来它域名更改了&lt;/code&gt;！官网都贴出了通告了！
    
    </summary>
    
      <category term="essays" scheme="http://zlia.tech/categories/essays/"/>
    
    
      <category term="notice" scheme="http://zlia.tech/tags/notice/"/>
    
  </entry>
  
  <entry>
    <title>简单喵下ActiveMQ生产者源码</title>
    <link href="http://zlia.tech/2018/09/02/explain-activemq-soucecod/"/>
    <id>http://zlia.tech/2018/09/02/explain-activemq-soucecod/</id>
    <published>2018-09-02T01:00:21.000Z</published>
    <updated>2019-06-08T06:12:11.886Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a><div><span>前提</span></div></h3><p>前提前提大前提！准备一份源码呗，activemq生产者的源码。何为生产者？就是发消息的源头，谁来发送消息谁就是生产者。有了生产者自然就会有消费者，今天着重看看生产者的故事，后面的几篇文章咱们都会一一进行讲解，包括服务端、消费者以及<code>ACK</code>模式，<code>消息的传送机制</code>，至于其他的内容还有待发掘，因为目前我也只是了解了部分！生产者的源码大伙可以从网上百度下，只要能跑起来就可以了，如果可以的话最好知道对方写了什么，对代码有个简单的理解，否则下面讲解的内容可能跟你的需求会有很大的出入，也帮助不了你哈，另一方面也是浪费了作者的苦心啦！自我迷恋中，切勿当真，哈哈。最好最好或者你有兴趣的话，可以clone下我的代码，里面都添加了对应的注释，<a href="https://github.com/JulianHang/activemq-client.git" target="_blank" rel="noopener">源码下载</a>。最后一个前提，作者使用的代码工具是<code>IDEA</code>，采用DEBUG模式来查看源码，所以读者对工具的操作最好有个简单的了解。好了，不啰嗦了！<a id="more"></a></p><h3 id="先看客户端如何连接到服务端"><a href="#先看客户端如何连接到服务端" class="headerlink" title="先看客户端如何连接到服务端"></a><div><span>先看客户端如何连接到服务端</span></div></h3><p>作者采用的代码工具是IDEA，所以不熟悉的读者最好先简单熟悉下！作者采取对象开始实例化时作为入口。</p><p class="customize-img"><img src="/assets/blogImg/activemq-producer/connectionFac-part-1.png" alt="实例化连接工厂"></p><p>由于代码跳转过于频繁，固采用择重点部分来讲解，同时用红色方块标记！这样子方便读者理解讲的是什么，毕竟看源码很容易迷失在代码的海洋中，甚至还会头晕，罪过罪过！要知道代码做了什么之前，先理解某个类是做什么用的，加深印象，鉴于理解，而读者只要翻译头部的英文即可大致明白，其他的类也是一个道理。该类是用来创建连接对象，对象有分队列、主题！说到这个，又得提一个点，咱们讲的内容都是基于主题来讲解的。</p><p>进入到内部代码中。</p><p class="customize-img"><img src="/assets/blogImg/activemq-producer/connectionFac-part-2.png" alt="连接工厂对象"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置账号、密码，为啥需要账号密码呢？连接服务端时可能需要提供账号密码来进行授权验证，默认是不需要的，可以在服务端的配置文件中增加授权验证功能</span></span><br><span class="line">setUserName(userName);</span><br><span class="line">setPassword(password);</span><br><span class="line"><span class="comment">//设置URL</span></span><br><span class="line">setBrokerURL(brokerURL);</span><br></pre></td></tr></table></figure><p class="customize-img"><img src="/assets/blogImg/activemq-producer/connectionFac-part-3.png" alt="连接对象"></p><p class="customize-img"><img src="/assets/blogImg/activemq-producer/connectionFac-part-4.png" alt="连接对象内部操作-1"></p><p class="customize-img"><img src="/assets/blogImg/activemq-producer/connectionFac-part-5.png" alt="连接对象内部操作-2"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将URL中QueryString的参数添加到Map中，如tcp://127.0.0.1:61614?wireFormat.cacheEnabled=false&amp;wireFormat.tightEncodingEnabled=false</span></span><br><span class="line"><span class="comment">//QueryString即为wireFormat.cacheEnabled=false&amp;wireFormat.tightEncodingEnabled=false，存入时以wireFormat.cacheEnabled为key，以false为value</span></span><br><span class="line">Map&lt;String, String&gt; options = <span class="keyword">new</span> HashMap&lt;String, String&gt;(URISupport.parseParameters(location));</span><br><span class="line"><span class="comment">//传输协议的配置信息对象，官方解释：专为在线路上的性能和大小而设计，具有更高的性能和更低的网络带宽</span></span><br><span class="line">WireFormat wf = createWireFormat(options);</span><br><span class="line"><span class="comment">//创建传输协议对象,如Tcp,同时将配置信息对象应用到该对象当中</span></span><br><span class="line">Transport transport = createTransport(location, wf);</span><br><span class="line"><span class="comment">//将QueryString中的参数配置应用到传输协议的配置信息对象当中，同时为每个过滤器设置相关联的传输协议对象来形成链条，以便后续对消息进行逐一处理</span></span><br><span class="line"><span class="comment">//链条的顺序：MutexTransport-&gt;WireFormatNegotiator-&gt;InactivityMonitor-&gt;TcpTransport</span></span><br><span class="line">Transport rc = configure(transport, wf, options);</span><br></pre></td></tr></table></figure><p class="customize-img"><img src="/assets/blogImg/activemq-producer/connectionFac-part-6.png" alt="连接对象内部操作-3"></p><p class="customize-img"><img src="/assets/blogImg/activemq-producer/connectionFac-part-7.png" alt="连接对象内部操作-4"></p><p>只是选择了部分代码进行讲解，因为有些代码官方并没有给出详细的说明！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...<span class="comment">//省略代码</span></span><br><span class="line"><span class="comment">//创建连接对象来存储连接信息，包括是否是异步发送，超时时间</span></span><br><span class="line"><span class="keyword">this</span>.info = <span class="keyword">new</span> ConnectionInfo(<span class="keyword">new</span> ConnectionId(uniqueId));</span><br><span class="line"><span class="comment">//创建连接会话对象，填充随机生成的连接ID，在同一个连接下的所有生产者消费者均采用同一个会话，多个生产者通过随机生成ID来区分</span></span><br><span class="line"><span class="keyword">this</span>.connectionSessionId = <span class="keyword">new</span> SessionId(info.getConnectionId(), -<span class="number">1</span>);</span><br><span class="line"><span class="comment">//设置监听，与服务端通信，包括发送连接信息、收发消息都会经过上面提到的链条逐一处理</span></span><br><span class="line"><span class="keyword">this</span>.transport.setTransportListener(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><h3 id="终于看到底层代码了"><a href="#终于看到底层代码了" class="headerlink" title="终于看到底层代码了"></a><div><span>终于看到底层代码了</span></div></h3><p class="customize-img"><img src="/assets/blogImg/activemq-producer/connectionFac-part-8.png" alt="连接对象内部操作-5"></p><p>我想大多数人都知道，实现连接底层的代码无非就是用的<code>socket</code>！好了，客户端到服务端的连接实现咱们已经阐述的差不多了，当然了，其中还有很多细节，包括涉及到模式，其实我到现在还不是很明白设计那些链条的意义都是什么？很疑惑，是出于什么情况下的考虑吗？就仿佛生产线一样，一个产品都需要经过每一个流程加工后才能到下一步，否则就是个废品！今天写的内容大多数以图片为主，主要讲几个重要的点通过代码加注释的方式点出来，一方面是希望读者能去详细查看内部代码做更进一步的了解，另一方面是其他的内容对于今天的主题来说可有可无，感兴趣的可以去了解下！下一步讲客户端如何开启事务及几种<code>ACK</code>模式。</p><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>链条</code></p><p><a href="https://github.com/JulianHang/activemq-client.git" target="_blank" rel="noopener">源码下载</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前提&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;前提前提大前提！准备一份源码呗，activemq生产者的源码。何为生产者？就是发消息的源头，谁来发送消息谁就是生产者。有了生产者自然就会有消费者，今天着重看看生产者的故事，后面的几篇文章咱们都会一一进行讲解，包括服务端、消费者以及&lt;code&gt;ACK&lt;/code&gt;模式，&lt;code&gt;消息的传送机制&lt;/code&gt;，至于其他的内容还有待发掘，因为目前我也只是了解了部分！生产者的源码大伙可以从网上百度下，只要能跑起来就可以了，如果可以的话最好知道对方写了什么，对代码有个简单的理解，否则下面讲解的内容可能跟你的需求会有很大的出入，也帮助不了你哈，另一方面也是浪费了作者的苦心啦！自我迷恋中，切勿当真，哈哈。最好最好或者你有兴趣的话，可以clone下我的代码，里面都添加了对应的注释，&lt;a href=&quot;https://github.com/JulianHang/activemq-client.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源码下载&lt;/a&gt;。最后一个前提，作者使用的代码工具是&lt;code&gt;IDEA&lt;/code&gt;，采用DEBUG模式来查看源码，所以读者对工具的操作最好有个简单的了解。好了，不啰嗦了！
    
    </summary>
    
      <category term="mq" scheme="http://zlia.tech/categories/mq/"/>
    
    
      <category term="activemq" scheme="http://zlia.tech/tags/activemq/"/>
    
  </entry>
  
</feed>
