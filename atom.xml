<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>奇思妙想</title>
  
  <subtitle>越努力越幸运！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zlia.tech/"/>
  <updated>2019-12-12T09:41:37.837Z</updated>
  <id>http://zlia.tech/</id>
  
  <author>
    <name>zlia</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>揭开面纱-ThreadGroup</title>
    <link href="http://zlia.tech/2019/12/12/explain-threadgroup-sourcecode/"/>
    <id>http://zlia.tech/2019/12/12/explain-threadgroup-sourcecode/</id>
    <published>2019-12-12T09:41:37.000Z</published>
    <updated>2019-12-12T09:41:37.837Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开门见山"><a href="#开门见山" class="headerlink" title="开门见山"></a><div><span>开门见山</span></div></h3><p>ThreadGroup在实际开发中很少用到，不过由于它跟Thread的关系比较密切，所以还是了解下为妙，揭开ThreadGroup的面纱是基于<code>JDK1.8</code>。通过阅读注释及相关文章，可以知道ThreadGroup的结构如下：</p><p class="customize-img"><img src="/assets/blogImg/java/thread-group/threadgroup-structure.png" alt="线程组结构"></p><p>除了初始线程组（JVM所属）以外，每个线程组都有一个父线程组及子线程组，父线程组中有个成员变量（groups）来记录它所有的子线程组，所以线程组之间的关系被看作是一棵<code>树</code>。线程组下有多个线程，我们可以将线程组理解成是对一组线程进行管理。</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadGroup</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//父线程组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程组的名称</span></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程组的最大优先级，该优先级不能大于父线程组的优先级</span></span><br><span class="line">    <span class="keyword">int</span> maxPriority;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程组是否已经销毁（清除）</span></span><br><span class="line">    <span class="keyword">boolean</span> destroyed;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//线程组是否是守护线程组</span></span><br><span class="line">    <span class="keyword">boolean</span> daemon;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//未启动的线程个数，即未调用start方法的线程个数</span></span><br><span class="line">    <span class="keyword">int</span> nUnstartedThreads = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//已启动的线程个数，即已调用start方法的线程个数</span></span><br><span class="line">    <span class="keyword">int</span> nthreads;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//已启动的线程个数，该数组会通过创建新数组拷贝源数组的方式进行扩容，新数组的容量是源数据的2倍</span></span><br><span class="line">    Thread threads[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子线程组的个数</span></span><br><span class="line">    <span class="keyword">int</span> ngroups;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储所有子线程组</span></span><br><span class="line">    ThreadGroup groups[];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造线程组，该构造方式通常是创建系统级别的线程组，如由底层C代码来构造初始线程组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"system"</span>;</span><br><span class="line">    <span class="keyword">this</span>.maxPriority = Thread.MAX_PRIORITY;</span><br><span class="line">    <span class="keyword">this</span>.parent = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 线程组的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadGroup</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Thread.currentThread().getThreadGroup(), name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造线程组并指定父线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parant 父线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 线程组的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadGroup</span><span class="params">(ThreadGroup parent, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(checkParentAccess(parent), parent, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造线程组并指定父线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unused 未使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parant 父线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 线程组的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadGroup</span><span class="params">(Void unused, ThreadGroup parent, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.maxPriority = parent.maxPriority;</span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.daemon;</span><br><span class="line">    <span class="keyword">this</span>.vmAllowSuspension = parent.vmAllowSuspension;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    parent.add(<span class="keyword">this</span>); <span class="comment">//指定父线程组后，要将其添加到父线程组所属的子线程组数组中，维护其关系</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程组的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程组的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程组的父线程组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ThreadGroup <span class="title">getParent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>)</span><br><span class="line">        parent.checkAccess();</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程组的最大优先级</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程组的最大优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getMaxPriority</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxPriority;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程组是否是守护线程组</span></span><br><span class="line"><span class="comment"> * 若当前线程组是守护线程组，则当线程组中的线程都终止了或其子线程组都终止了则会自动调用destroy方法</span></span><br><span class="line"><span class="comment"> * 实际上在线程终止底层后调用Thread#exit方法，通过该方法来终止守护线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否是守护线程组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isDaemon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> daemon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程组是否已销毁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否已销毁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isDestroyed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> destroyed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置线程组是否是守护线程组</span></span><br><span class="line"><span class="comment"> * true-属于守护线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> daemon 标志</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setDaemon</span><span class="params">(<span class="keyword">boolean</span> daemon)</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">this</span>.daemon = daemon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置线程组的最大优先级</span></span><br><span class="line"><span class="comment"> * 线程的优先级与线程组的最大优先级互不影响，也就是说即使线程的优先级比线程组的最大优先级还高也不影响</span></span><br><span class="line"><span class="comment"> * 当前线程组的最大优先级不能超过父线程组的最大优先级</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pri 最大优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setMaxPriority</span><span class="params">(<span class="keyword">int</span> pri)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ngroupsSnapshot;</span><br><span class="line">    ThreadGroup[] groupsSnapshot;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="keyword">if</span> (pri &lt; Thread.MIN_PRIORITY || pri &gt; Thread.MAX_PRIORITY) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxPriority = (parent != <span class="keyword">null</span>) ? Math.min(pri, parent.maxPriority) : pri; <span class="comment">//当前线程组的最大优先级不能超过父线程组的最大优先级</span></span><br><span class="line">        ngroupsSnapshot = ngroups;</span><br><span class="line">        <span class="keyword">if</span> (groups != <span class="keyword">null</span>) &#123;</span><br><span class="line">            groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i++) &#123;</span><br><span class="line">        groupsSnapshot[i].setMaxPriority(pri); <span class="comment">//递归更改其子线程组的最大优先级</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前线程组是否与指定线程组是同一个对象或是指定线程组的父线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> g 指定线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parentOf</span><span class="params">(ThreadGroup g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; g != <span class="keyword">null</span> ; g = g.parent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前线程组的活跃线程个数</span></span><br><span class="line"><span class="comment"> * 注意：线程组中还有子线程组，所以计算时也会包含子线程组</span></span><br><span class="line"><span class="comment"> * 该结果只是一个估算值，因为线程数一直在动态变化着，同时JVM也会有一些线程，所以可能会影响该计数结果</span></span><br><span class="line"><span class="comment"> * 该方法主要用来调试与监控</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程组的活跃线程个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">activeCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="keyword">int</span> ngroupsSnapshot;</span><br><span class="line">    ThreadGroup[] groupsSnapshot;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result = nthreads;</span><br><span class="line">        ngroupsSnapshot = ngroups;</span><br><span class="line">        <span class="keyword">if</span> (groups != <span class="keyword">null</span>) &#123;</span><br><span class="line">            groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i++) &#123;</span><br><span class="line">        result += groupsSnapshot[i].activeCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前线程组及其子线程组的活跃线程拷贝到指定数组中</span></span><br><span class="line"><span class="comment"> * 要严格确保指定数组的大小大于活跃线程的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tarray 指定数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程组的活跃线程个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">enumerate</span><span class="params">(Thread list[])</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">return</span> enumerate(list, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前线程组的活跃线程拷贝到指定数组中</span></span><br><span class="line"><span class="comment"> * 通过recurse参数来决定是否拷贝子线程组</span></span><br><span class="line"><span class="comment"> * 要严格确保指定数组的大小大于活跃线程的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tarray 指定数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> recurse 决定是否拷贝子线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程组的活跃线程个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">enumerate</span><span class="params">(Thread list[], <span class="keyword">boolean</span> recurse)</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">return</span> enumerate(list, <span class="number">0</span>, recurse);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前线程组的活跃线程拷贝到指定数组中</span></span><br><span class="line"><span class="comment"> * 通过recurse参数来决定是否拷贝子线程组</span></span><br><span class="line"><span class="comment"> * 要严格确保指定数组的大小大于活跃线程的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tarray 指定数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 从指定数组的指定起始索引开始添加</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> recurse 决定是否拷贝子线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程组的活跃线程个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">enumerate</span><span class="params">(Thread list[], <span class="keyword">int</span> n, <span class="keyword">boolean</span> recurse)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ngroupsSnapshot = <span class="number">0</span>;</span><br><span class="line">    ThreadGroup[] groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nt = nthreads;</span><br><span class="line">        <span class="keyword">if</span> (nt &gt; list.length - n) &#123; <span class="comment">//若指定数组的长度小于活跃线程的个数，则超过的活跃线程将被忽略</span></span><br><span class="line">            nt = list.length - n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nt; i++) &#123; <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (threads[i].isAlive()) &#123;</span><br><span class="line">                list[n++] = threads[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (recurse) &#123; <span class="comment">// 是否加入子线程组的活跃线程</span></span><br><span class="line">            ngroupsSnapshot = ngroups;</span><br><span class="line">            <span class="keyword">if</span> (groups != <span class="keyword">null</span>) &#123;</span><br><span class="line">                groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (recurse) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i++) &#123;</span><br><span class="line">            n = groupsSnapshot[i].enumerate(list, n, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前线程组的子线程组个数</span></span><br><span class="line"><span class="comment"> * 注意：当前线程组中还有子线程组，所以计算时也会包含子线程组</span></span><br><span class="line"><span class="comment"> * 该结果只是一个估算值，因为线程数一直在动态变化着</span></span><br><span class="line"><span class="comment"> * 该方法主要用来调试与监控</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程组的活跃线程个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">activeGroupCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ngroupsSnapshot;</span><br><span class="line">    ThreadGroup[] groupsSnapshot;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ngroupsSnapshot = ngroups;</span><br><span class="line">        <span class="keyword">if</span> (groups != <span class="keyword">null</span>) &#123;</span><br><span class="line">            groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = ngroupsSnapshot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i++) &#123;</span><br><span class="line">        n += groupsSnapshot[i].activeGroupCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前线程组及其子线程组的子线程组拷贝到指定数组中</span></span><br><span class="line"><span class="comment"> * 要严格确保指定数组的大小大于子线程组的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tarray 指定数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程组的子线程组个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">enumerate</span><span class="params">(ThreadGroup list[])</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">return</span> enumerate(list, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////其他enumerate方法就不做展示了，都是类似的/////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 终止当前线程组的所有线程，包括其子线程下的所有线程</span></span><br><span class="line"><span class="comment"> * 由于Thread#stop方法已废弃，故而该方法也是没啥用的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stopOrSuspend(<span class="keyword">false</span>))</span><br><span class="line">        Thread.currentThread().stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归挂起或终止当前线程组的所有线程，除了当前线程之外（会在调用方挂起或终止当前线程）</span></span><br><span class="line"><span class="comment"> * 同时也会挂起或终止其子线程组的所有线程</span></span><br><span class="line"><span class="comment"> * 该方法通过返回值来判断当前线程是否存在于当前线程组或子线程组中，若存在则在该方法返回后也会对当前线程进行挂机或终止，若不存在则不会进行任何操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> suspend true表示挂起  false表示终止</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 当前线程是否存在于当前线程组或子线程组中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">stopOrSuspend</span><span class="params">(<span class="keyword">boolean</span> suspend)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> suicide = <span class="keyword">false</span>;</span><br><span class="line">    Thread us = Thread.currentThread(); <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="keyword">int</span> ngroupsSnapshot;</span><br><span class="line">    ThreadGroup[] groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nthreads ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (threads[i]==us)</span><br><span class="line">                suicide = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (suspend)</span><br><span class="line">                threads[i].suspend();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                threads[i].stop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ngroupsSnapshot = ngroups;</span><br><span class="line">        <span class="keyword">if</span> (groups != <span class="keyword">null</span>) &#123;</span><br><span class="line">            groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i++)</span><br><span class="line">        suicide = groupsSnapshot[i].stopOrSuspend(suspend) || suicide;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> suicide;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中断当前线程组的所有线程，包括子线程组的所有线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ngroupsSnapshot;</span><br><span class="line">    ThreadGroup[] groupsSnapshot;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nthreads ; i++) &#123;</span><br><span class="line">            threads[i].interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        ngroupsSnapshot = ngroups;</span><br><span class="line">        <span class="keyword">if</span> (groups != <span class="keyword">null</span>) &#123;</span><br><span class="line">            groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i++) &#123;</span><br><span class="line">        groupsSnapshot[i].interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 销毁当前线程组及其子线程组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ngroupsSnapshot;</span><br><span class="line">    ThreadGroup[] groupsSnapshot;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="keyword">if</span> (destroyed || (nthreads &gt; <span class="number">0</span>)) &#123; <span class="comment">//如果还有运行中的线程则不允许销毁</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        ngroupsSnapshot = ngroups;</span><br><span class="line">        <span class="keyword">if</span> (groups != <span class="keyword">null</span>) &#123;</span><br><span class="line">            groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123; <span class="comment">//除了初始线程以外，线程组在销毁后需要清理资源</span></span><br><span class="line">            destroyed = <span class="keyword">true</span>;</span><br><span class="line">            ngroups = <span class="number">0</span>;</span><br><span class="line">            groups = <span class="keyword">null</span>;</span><br><span class="line">            nthreads = <span class="number">0</span>;</span><br><span class="line">            threads = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i += <span class="number">1</span>) &#123; <span class="comment">//销毁子线程组</span></span><br><span class="line">        groupsSnapshot[i].destroy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123; <span class="comment">//从父线程组中移除当前线程组，解除关系</span></span><br><span class="line">        parent.remove(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从当前线程组的子线程组中移除指定线程组</span></span><br><span class="line"><span class="comment"> * 若当前线程组是守护线程组，且不存在运行中及未启动的线程，且不不存在子线程组，相当于要移除的线程组是最后一个线程组，则销毁自身</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> g 指定线程组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadGroup g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroups ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (groups[i] == g) &#123;</span><br><span class="line">                ngroups -= <span class="number">1</span>;</span><br><span class="line">                System.arraycopy(groups, i + <span class="number">1</span>, groups, i, ngroups - i); <span class="comment">//在子线程组中移除指定线程组</span></span><br><span class="line">                groups[ngroups] = <span class="keyword">null</span>; <span class="comment">//手动置为null以便垃圾回收器能回收它</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nthreads == <span class="number">0</span>) &#123; <span class="comment">//这里我唯一想到的是可能有其他线程使用了当前对象锁</span></span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (daemon &amp;&amp; (nthreads == <span class="number">0</span>) &amp;&amp;  (nUnstartedThreads == <span class="number">0</span>) &amp;&amp; (ngroups == <span class="number">0</span>)) <span class="comment">//当前线程组是守护线程组，且不存在运行中及未启动的线程，且不存在子线程组</span></span><br><span class="line">        &#123;</span><br><span class="line">            destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对未启动的线程进行计数</span></span><br><span class="line"><span class="comment"> * 未启动的线程不会添加到线程组中，这样即使从未启动过的线程也会被收集，但是必须对它们进行计数，以便不会破坏守护线程组.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addUnstarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        nUnstartedThreads++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加已启动的线程到线程组中</span></span><br><span class="line"><span class="comment"> * 该方法可能会被JVM调用，因为有初始线程组要添加已启动的系统线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (threads == <span class="keyword">null</span>) &#123;</span><br><span class="line">            threads = <span class="keyword">new</span> Thread[<span class="number">4</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nthreads == threads.length) &#123;</span><br><span class="line">            threads = Arrays.copyOf(threads, nthreads * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        threads[nthreads] = t; <span class="comment">//添加已启动的线程</span></span><br><span class="line"></span><br><span class="line">        nthreads++; <span class="comment">//计数已启动的线程个数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为只有在线程启动后才会调用该方法，故而未启动的线程个数应该减去1</span></span><br><span class="line">        nUnstartedThreads--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定线程启动失败后会调用此方法</span></span><br><span class="line"><span class="comment"> * 线程启动失败后，应该对未启动的线程个数进行计数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t 指定线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadStartFailed</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        remove(t);</span><br><span class="line">        nUnstartedThreads++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从当前线程组中移除指定线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t 指定线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nthreads ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (threads[i] == t) &#123;</span><br><span class="line">                System.arraycopy(threads, i + <span class="number">1</span>, threads, i, --nthreads - i);</span><br><span class="line">                threads[nthreads] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定线程终止后调用此方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t 指定线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadTerminated</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        remove(t);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nthreads == <span class="number">0</span>) &#123; <span class="comment">//这里我唯一想到的是可能有其他线程使用了当前对象锁</span></span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (daemon &amp;&amp; (nthreads == <span class="number">0</span>) &amp;&amp; (nUnstartedThreads == <span class="number">0</span>) &amp;&amp; (ngroups == <span class="number">0</span>)) <span class="comment">//当前线程组是守护线程组，且不存在运行中及未启动的线程，且不存在子线程组</span></span><br><span class="line">        &#123;</span><br><span class="line">            destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印线程组的信息到标准输出，包括活跃的线程及其子线程组的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    list(System.out, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印线程组的信息到标准输出，包括活跃的线程及其子线程组的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">list</span><span class="params">(PrintStream out, <span class="keyword">int</span> indent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ngroupsSnapshot;</span><br><span class="line">    ThreadGroup[] groupsSnapshot;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; indent ; j++) &#123;</span><br><span class="line">            out.print(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        out.println(<span class="keyword">this</span>);</span><br><span class="line">        indent += <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nthreads ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; indent ; j++) &#123;</span><br><span class="line">                out.print(<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(threads[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ngroupsSnapshot = ngroups;</span><br><span class="line">        <span class="keyword">if</span> (groups != <span class="keyword">null</span>) &#123;</span><br><span class="line">            groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i++) &#123;</span><br><span class="line">        groupsSnapshot[i].list(out, indent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当线程未设置自定义异常处理器，则当线程发生异常时，会调用该方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t 当前发生异常的线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 异常信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123; </span><br><span class="line">        parent.uncaughtException(t, e); <span class="comment">//若线程未设置自定义异常处理器，则使用父线程组的异常</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Thread.UncaughtExceptionHandler ueh = Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">        <span class="keyword">if</span> (ueh != <span class="keyword">null</span>) &#123; <span class="comment">//线程是否设置了默认的异常处理器</span></span><br><span class="line">            ueh.uncaughtException(t, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> ThreadDeath)) &#123;</span><br><span class="line">            System.err.print(<span class="string">"Exception in thread \""</span> + t.getName() + <span class="string">"\" "</span>);</span><br><span class="line">            e.printStackTrace(System.err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">"[name="</span> + getName() + <span class="string">",maxpri="</span> + maxPriority + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>除了初始线程组以外，每个线程组都有一个父线程组及子线程组，这样子的关系被看作是一棵树</p></li><li><p>若线程组是守护线程组，则在满足一定的条件下会自动调用销毁方法</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;开门见山&quot;&gt;&lt;a href=&quot;#开门见山&quot; class=&quot;headerlink&quot; title=&quot;开门见山&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;开门见山&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;ThreadGroup在实际开发中很少用到，不过由于它跟Thread的关系比较密切，所以还是了解下为妙，揭开ThreadGroup的面纱是基于&lt;code&gt;JDK1.8&lt;/code&gt;。通过阅读注释及相关文章，可以知道ThreadGroup的结构如下：&lt;/p&gt;
&lt;p class=&quot;customize-img&quot;&gt;&lt;img src=&quot;/assets/blogImg/java/thread-group/threadgroup-structure.png&quot; alt=&quot;线程组结构&quot;&gt;&lt;/p&gt;
&lt;p&gt;除了初始线程组（JVM所属）以外，每个线程组都有一个父线程组及子线程组，父线程组中有个成员变量（groups）来记录它所有的子线程组，所以线程组之间的关系被看作是一棵&lt;code&gt;树&lt;/code&gt;。线程组下有多个线程，我们可以将线程组理解成是对一组线程进行管理。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>尽力去探究Thread的方方面面</title>
    <link href="http://zlia.tech/2019/12/11/explain-thread-sourcecode/"/>
    <id>http://zlia.tech/2019/12/11/explain-thread-sourcecode/</id>
    <published>2019-12-11T08:37:08.000Z</published>
    <updated>2019-12-11T08:39:35.355Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>接下来的这一段时间都将探索跟线程有关的内容，包括各种锁，对Thread的总结如下：</p><blockquote><p>线程具有<code>优先级</code>，高优先级的线程优先于低优先级的线程执行，当在某个线程中创建新线程时，新线程的优先级被设置成当前线程的优先级；JVM启动时，默认有一个非守护线程（调用某个类的main方法）；线程能被标记为<code>守护线程</code>，每个线程都可以<code>指定名称</code>，未指定的情况下将由底层帮其生成一个新名称；有两种方式来创建线程，如下所示：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 在只有一个实例的情况下只能创建一个线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"TestA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在只有一个实例的情况下可创建多个线程，这种方式更为常见</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestB</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"TestB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="方方面面"><a href="#方方面面" class="headerlink" title="方方面面"></a><div><span>方方面面</span></div></h3><p>探索Thread源码是基于<code>JDK1.8</code>，在探索之前先了解下<code>线程的状态</code>。</p><ul><li><p><code>新建（NEW）</code>：新创建一个对象，但还没有开始调start方法。</p></li><li><p><code>可运行（RUNNABLE）</code>：调用start方法后，该线程处于就绪状态，简单来就是还未运行，当线程调度器把时间片分配给该线程后变成了运行中状态。</p></li><li><p><code>阻塞（BLOCKED）</code>：等待同步控制方法或代码块上的对象锁，因为该对象锁已经被其他线程所占用。当线程处于阻塞状态时，线程调度器将忽略该线程，不会分配任何CPU时间，直到该线程进入到就绪状态，它才有可能执行操作。</p></li><li><p><code>等待（WAITING）</code>：等待另外一个线程执行特定的操作，如唤醒（通知）或终止，调用Object#wait、Thread#join、LockSupport#park后会处于该状态。</p></li><li><p><code>超时等待（TIMED_WAITING）</code>：该状态与等待有些类似，只不过它是有限时间内的等待，也就是说，当另外一个线程未执行特定的操作时，经过指定的时间后该线程将会变成该状态（此时未获取到锁），当获取到锁之后就会变成可运行状态（这个状态的转变是个人猜想的，Java规范与注释都未明确说明），调用Thread#sleep(long)、Object#wait(long)、Thread#join(long)、LockSupport#parkUntil可能会处于该状态。顺便提一下，若方法中的参数都为0，那么就相当于直接调用了wait方法，此时的状态会是等待</p></li><li><p><code>终止（TERMINATED）</code>：线程执行完成，指的是从run方法返回。</p></li></ul><p class="customize-img"><img src="/assets/blogImg/java/thread/thread-statue.png" alt="线程状态图"></p><p>简要阐述下几个<code>重要概念</code>，该内容摘抄自Java规范。</p><blockquote><p>Object#wait、Object#notify、Object#notify只能在同步控制方法或同步代码块（synchronized）中使用，否则即使能通过编译，但在运行时会抛出IllegalMonitorStateException异常，因为这些方法在调用时会操作锁，所以它必须先获取到锁。Thread#sleep与Thread#yield可以在非同步控制方法中调用，因为它们始终没有释放锁，更不用谈操作了。</p></blockquote><blockquote><p>针对Object#wait(long millisecs, int nanosecs)方法，注意nanosecs参数要在0-999999范围内（毫秒与纳秒单位换算是6个0），millisecs不能为负。</p></blockquote><blockquote><p>我们都知道每个对象都有一个关联的监视器，即通常所说的锁，除此之外，还具有一个关联的等待容器，很容易理解，里头存放的就是处于等待状态的线程（稍微纠结了一下，阻塞状态的线程不会处于该容器中，因为它是跟监视器有关的），也就是说当前线程调用Object#wait方法后，该线程会被添加到Object的等待容器中，并释放对象锁（不管此时有多少嵌套层级的锁都会得到释放，相当于将锁的计数减到0），处于等待容器中的线程不会执行任何其他指令。而当执行notify、notifyAll、interrupt或wait超时后，该线程可能会从等待容器中删除，在获取到对象锁后，该线程会使对象重新上锁（之前是多少嵌套，现在就会有多少嵌套，相当于做了恢复），在获到CPU时间片后从而继续执行。顺便提一下，对象内部持有对锁的计数（猜测），只有当该数量变成0后其他线程才能获取该对象锁。（<code>理解这点概念很重要</code>！！！否则概念多了容易乱）</p></blockquote><blockquote><p>notify<code>无法保证</code>在等待容量中选择哪个线程作为删除，notifyAll会将所有线程从等待容量中删除。</p></blockquote><blockquote><p>interrupt会在对象重新上锁（什么时候重新上锁上面提到过）后引发InterruptedException异常，在try-catch块中获取到的中断状态（isInterrupted）为false，更具体的信息可看方法说明。</p></blockquote><blockquote><p>如果线程在等待时既被通知（notify）又被中断（interrupt），则可能是先通知后中断，也有可能是先中断后通知。</p></blockquote><p>到这里应该对线程的状态有所了解了，读者可以发现实际上线程并没有<code>运行中</code>的状态，而在操作系统层面，它却有执行中的状态，这是为何？一个方面，CPU为每个线程分配时间片进行调度，时间片一般是几十毫秒，当其中一个线程执行一个时间片后会切换到下一个线程，在切换前会保存当前线程的状态，以便下次切换回来时可以加载该线程的状态，这样子的一个过程称为上下文切换，很显然线程之间的切换是非常快的，那么此时去区分运行中与就绪状态是没有多大意思的，有可能上一秒你看到的是运行中状态，可实际上还没等你反应过来后就变成了就绪状态，也许你只能看到这两个状态在互相闪烁着；另外一个方面，Thread注释中说：处于可运行状态下的线程正在JVM中执行，但它可能正在等待来自于操作系统的其他资源，比如处理器，JVM把那些资源都视作资源，比如CPU、各种硬件，有东西在为线程服务，它就认为线程在执行。对于操作系统来说它的侧重点是CPU，它必须要明确每个线程的具体状态，否则对于可运行状态来说，它怎么知道线程是否是可以调度的（部分观点摘自其他人的文章）。最后在提一点，JVM设置线程的状态是为了防止已经启动的线程被重新启动。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册本地方法，比如start0、stop0，至于做了什么只能说太过于底层了，不懂C、C++的可以忽略了</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程的名称</span></span><br><span class="line"><span class="comment">     * 为什么线程的名称要加上volatile关键词呢?</span></span><br><span class="line"><span class="comment">     * 首先volatile保证了内存的可见性，即其中一个线程修改了某个共享变量，其他的线程能够马上看到该变量修改后的值，更多的知识点将会另起文章阐述</span></span><br><span class="line"><span class="comment">     * 有可能多个线程共享该名称变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程的优先级</span></span><br><span class="line"><span class="comment">     * 注意：对于不同的平台可能优先级不同，有的是3个优先级、有的是10个优先级，所以在设置优先级时最好写Thread.MAX_PRIORITY</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> priority;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该线程是否是守护（后台）线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> daemon = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程要执行的任务，即最后会调用该任务的run方法 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Runnable target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程所属的线程组，一般情况下线程并未指定线程组的话默认是采用主线程的线程组，而主线程是从哪里的呢，这就要看JVM启动了...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ThreadGroup group;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类加载器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ClassLoader contextClassLoader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问控制，对访问控制进行操作或决定</span></span><br><span class="line"><span class="comment">     * 1. 决定是否允许还是拒绝对关键系统资源的访问 </span></span><br><span class="line"><span class="comment">     * 2. 特权代码，影响访问控制决定</span></span><br><span class="line"><span class="comment">     * 3. 可获取当前上下文，针对已保存的上下文做出来自不同上下文的访问控制决定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AccessControlContext inheritedAccessControlContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当线程没有指定线程名时，内部会帮助我们生成一个新名字-Thread-number，而其中的number会随着线程的增加而递增，如Thread-1、Thread-2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadInitNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每个线程都有自己的一个本地栈-ThreadLocal，ThreadLocal通过ThreadLocalMap来维护变量</span></span><br><span class="line"><span class="comment">     * ThreadLocalMap底层维护了一个数组，数组中维护了键值对的关系，其中键是当前ThreadLocal对象，也就是说，一个ThreadLocal只能绑定一个值，若是想绑定多个值的话就要定义多个ThreadLocal对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将当前线程的ThreadLocal设置到创建后的线程中，不知道使用的场景是哪里？</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置栈大小，在更底层的代码中用到，该属性依赖于不同的平台会有不同的行为</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> stackSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可中断对象，主要用来I/O阻塞的线程调用interrupt后，需要去唤醒selector</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Interruptible blocker;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 未处理异常的默认处理器，即异常没有被捕获，通常情况下为null，即直接在控制台打印异常堆栈信息</span></span><br><span class="line"><span class="comment">     * 若设置了默认处理器，则所有的线程都会应用该默认处理器，而如果又同时设置了自定义处理器，则指定线程只会应用自定义处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> UncaughtExceptionHandler defaultUncaughtExceptionHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常未处理的自定义处理器，当未指定该自定义处理器后会走默认的处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> UncaughtExceptionHandler uncaughtExceptionHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录线程ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为了生成线程ID，呈现递增趋势，一开始该值并不是0，因为JVM内部也会创建系统线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> threadSeqNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程的状态</span></span><br><span class="line"><span class="comment">     * 0-NEW  1-RUNNABLE 4-RUNNABLE 2-TERMINATED 16-WAITING  32-TIMED-WAITING 1024-BLOCKED</span></span><br><span class="line"><span class="comment">     * 其中1和4应该就是所谓的就绪与运行中，只不过哪个对应哪个就不可而知，操作系统的线程状态映射到JVM的线程状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> threadStatus = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最低优先级</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正常优先级</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大优先级</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化线程</span></span><br><span class="line"><span class="comment"> * 自动生成线程的名称，格式：Thread-i，i是个整数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化线程</span></span><br><span class="line"><span class="comment"> * 自动生成线程的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 指定任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化线程</span></span><br><span class="line"><span class="comment"> * 自动生成线程的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 指定任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> acc 访问控制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Thread(Runnable target, AccessControlContext acc) &#123;</span><br><span class="line">    init(<span class="keyword">null</span>, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>, acc, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化线程</span></span><br><span class="line"><span class="comment"> * 自动生成线程的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> group 线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 指定任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(ThreadGroup group, Runnable target)</span> </span>&#123;</span><br><span class="line">    init(group, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化线程，指定线程的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 线程的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, <span class="keyword">null</span>, name, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化线程，指定线程的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> group 线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 线程的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(ThreadGroup group, String name)</span> </span>&#123;</span><br><span class="line">    init(group, <span class="keyword">null</span>, name, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化线程，指定线程的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 指定任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 线程的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target, String name)</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, target, name, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化线程，指定线程的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> group 线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 指定任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 线程的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(ThreadGroup group, Runnable target, String name)</span> </span>&#123;</span><br><span class="line">    init(group, target, name, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化线程，指定线程的名称</span></span><br><span class="line"><span class="comment"> * stackSize依赖于不同的平台会有不同的值，所以使用该构造函数时要小心点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> group 线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 指定任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 线程的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stackSize 栈大小 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(ThreadGroup group, Runnable target, String name, <span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">    init(group, target, name, stackSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该方法主要使用在nio的selector中，这里是存储可中断的匿名类</span></span><br><span class="line"><span class="comment"> * 当在I/O阻塞中的线程调用interrupt时，需要去唤醒selector</span></span><br><span class="line"><span class="comment"> * 可全局搜索该方法的调用即可知道它的使用目的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> b 可中断对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blockedOn</span><span class="params">(Interruptible b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        blocker = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">nextThreadNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> threadInitNumber++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程ID</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextThreadID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++threadSeqNumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前线程的引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Thread <span class="title">currentThread</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每个线程都有一个CPU时间片，该方法指在自愿放弃CPU时间片，让其他线程能够更快的执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使线程进入指定时间的休眠，该方法不会释放锁，可以在非同步控制方法或同步块内使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> millis 休眠指定时间，毫秒为单位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使线程进入指定时间的休眠，该方法不会释放锁，可以在非同步控制方法或同步块内使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> millis 指定毫秒时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nanos 指定纳秒时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123; <span class="comment">//纳秒与毫秒的单位换算是6个0</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; millis == <span class="number">0</span>)) &#123;</span><br><span class="line">        millis++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(millis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> g 线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 指定任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 指定线程名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stackSize 线程的栈大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name, <span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">    init(g, target, name, stackSize, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> g 线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 指定任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 指定线程名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stackSize 线程的栈大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> acc 访问控制，如是否允许访问系统资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inheritThreadLocals 是否将当前线程的inheritableThreadLocals设置到创建后的线程中，类似于继承</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name, <span class="keyword">long</span> stackSize, AccessControlContext acc, <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    Thread parent = currentThread(); <span class="comment">//获取当前线程</span></span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = security.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = parent.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g.checkAccess(); <span class="comment">//确定当前正在运行的线程是否有权修改此线程组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g.addUnstarted(); <span class="comment">//记录未启动的线程个数，即未调用start方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.group = g;</span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon(); <span class="comment">//若创建线程的当前线程是后台（守护）线程，则创建后的线程也是个后台线程</span></span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority(); <span class="comment">//创建后的线程会被为当前线程的优先级</span></span><br><span class="line">    <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">    <span class="keyword">this</span>.inheritedAccessControlContext = acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">    tid = nextThreadID(); <span class="comment">//设置线程ID</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动线程，底层由JVM调用指定任务的run方法</span></span><br><span class="line"><span class="comment"> * 该方法只能调用一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>) <span class="comment">//threadStatus表示当前线程处于NEW状态</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">    group.add(<span class="keyword">this</span>); <span class="comment">//将当前线程添加到线程组，至少线程组到底做了什么可能需要另外起文章来探索</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0(); <span class="comment">//启动线程</span></span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123; <span class="comment">//若启动失败的话，需要去线程组中将其移除掉</span></span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动线程，底层将C++的线程与Java的线程进行了绑定，至于C++中的线程又做了什么就不得而知了，能猜到应该是跟操作系统打交道了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行任务</span></span><br><span class="line"><span class="comment"> * 若线程未调用start，直接调用run方法的话，那么就相当于执行一个方法，并未存在什么新线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 由JVM调用此方法，使线程在退出之前进行资源清理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (group != <span class="keyword">null</span>) &#123;</span><br><span class="line">        group.threadTerminated(<span class="keyword">this</span>);</span><br><span class="line">        group = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    threadLocals = <span class="keyword">null</span>;</span><br><span class="line">    inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">    inheritedAccessControlContext = <span class="keyword">null</span>;</span><br><span class="line">    blocker = <span class="keyword">null</span>;</span><br><span class="line">    uncaughtExceptionHandler = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 终止线程，即使已经启动的线程也会马上被终止</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1. 该方法已经被废弃了，为什么会被废弃呢？官方定义如下：</span></span><br><span class="line"><span class="comment"> * stop本质上是不安全的. 终止一个线程会造成该线程持有的锁得到释放（当ThreadDeath异常向上传播到堆栈时，锁将被释放）</span></span><br><span class="line"><span class="comment"> * 如果之前由这些锁保护的任何对象处于不一致状态，其他线程可能立即查看这些状态不一致的对象. 这样子的对象被认为已受损.</span></span><br><span class="line"><span class="comment"> * 当线程操作受损对象时会导致不可预测的行为，该行为可能很难被检测到. 不像非受查异常（Exception），ThreadDeath默默地杀死了线程（简单来说，我们无法从ThreadDeath异常上得到任何的消息）</span></span><br><span class="line"><span class="comment"> * 因此，用户没有警告其程序可能已损坏，该损坏是不可预测的.</span></span><br><span class="line"><span class="comment"> * 举个例子：</span></span><br><span class="line"><span class="comment"> * synchronized void f() &#123; </span></span><br><span class="line"><span class="comment"> *       x = 1; </span></span><br><span class="line"><span class="comment"> *       x = 2;</span></span><br><span class="line"><span class="comment"> *       x = 3;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * 不调用stop方法的情况下是可以正常运行的，但是在调用了stop方法后，程序立马被停止了，此时我们并不知道程序执行到了哪里，是 x = 1还是 x = 2 还是 x = 3</span></span><br><span class="line"><span class="comment"> * 所以即使其他线程获取到锁之后也无法确定x的值，第一次执行是1，第二次执行有可能是2，这就导致了结果的不可预测，这就相当于执行中的程序在任意时刻突然被破坏了</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2. 我不能捕捉ThreadDeath异常并修复受损的对象吗?</span></span><br><span class="line"><span class="comment"> *    线程可以在几乎任何地方抛出ThreadDeath异常，那我们怎么知道造成了对象的受损了，那就得慢慢分析每个抛出该异常的方法了.</span></span><br><span class="line"><span class="comment"> *    从第一个线程清除时（在catch或finally子句中），线程可以引发第二个ThreadDeath异常（最后要抛出ThreadDeath来确保线程被终止）. 必须重复进行清理，直到成功.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. 使用什么方式来代替stop?</span></span><br><span class="line"><span class="comment"> *    通过简单地修改变量的值来表明线程应该被终止，线程应定期检查该变量，如果该变量表明要终止运行，则应有序地从其run方法返回.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    方式一：</span></span><br><span class="line"><span class="comment"> *    private volatile Thread blinker;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *    public void stop() &#123;</span></span><br><span class="line"><span class="comment"> *       blinker = null;</span></span><br><span class="line"><span class="comment"> *    &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    public void run() &#123;</span></span><br><span class="line"><span class="comment"> *      Thread thisThread = Thread.currentThread();</span></span><br><span class="line"><span class="comment"> *      while(blinker == thisThread)&#123;</span></span><br><span class="line"><span class="comment"> *         try &#123;</span></span><br><span class="line"><span class="comment"> *              Thread.sleep(interval);</span></span><br><span class="line"><span class="comment"> *          &#125; catch(InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment"> *              </span></span><br><span class="line"><span class="comment"> *          &#125;</span></span><br><span class="line"><span class="comment"> *          repaint(); //业务逻辑</span></span><br><span class="line"><span class="comment"> *       &#125;</span></span><br><span class="line"><span class="comment"> *    &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    方式二：</span></span><br><span class="line"><span class="comment"> *    private final AtomicBoolean running = new AtomicBoolean(false);</span></span><br><span class="line"><span class="comment"> *    private int interval;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    public ControlSubThread(int sleepInterval) &#123;</span></span><br><span class="line"><span class="comment"> *       interval = sleepInterval;</span></span><br><span class="line"><span class="comment"> *    &#125;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *    public void stop() &#123;</span></span><br><span class="line"><span class="comment"> *       running.set(false);</span></span><br><span class="line"><span class="comment"> *    &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    public void run() &#123; </span></span><br><span class="line"><span class="comment"> *      running.set(true);</span></span><br><span class="line"><span class="comment"> *      while (running.get()) &#123;</span></span><br><span class="line"><span class="comment"> *         try &#123; </span></span><br><span class="line"><span class="comment"> *             Thread.sleep(interval); </span></span><br><span class="line"><span class="comment"> *         &#125; catch (InterruptedException e)&#123; </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *         &#125;</span></span><br><span class="line"><span class="comment"> *      &#125;</span></span><br><span class="line"><span class="comment"> *    &#125;</span></span><br><span class="line"><span class="comment"> *    </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread()) &#123;</span><br><span class="line">            security.checkPermission(SecurityConstants.STOP_THREAD_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>) &#123;</span><br><span class="line">        resume(); <span class="comment">//唤醒挂起的线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用程序中不能去catch ThreadDeath的实例，若真要catch，则处理完逻辑之后必须在重新抛出ThreadDeath异常对象，以便确定线程被终止</span></span><br><span class="line"><span class="comment">     * 线程中可以自定义异常处理器，只不过该异常处理器在针对ThreadDeath时不会打印任何消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    stop0(<span class="keyword">new</span> ThreadDeath()); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中断线程</span></span><br><span class="line"><span class="comment"> * 1. 若是调用wait、join、sleep方法时导致线程处于等待状态，可调用此方法来中断线程，即从这些方法处返回并抛出InterruptedException异常，同时清除中断状态</span></span><br><span class="line"><span class="comment"> * 2. 若是调用I/O操作导致线程处于阻塞状态，可调用此方法来将通道关闭，同时会抛出一个异常，及设置中断状态</span></span><br><span class="line"><span class="comment"> * 3. 若是调用selector.select导致线程处于阻塞状态，可调用此方法来使select立即返回，并设置中断状态</span></span><br><span class="line"><span class="comment"> * 4. 如果上述条件均不成立，则将设置该线程的中断状态.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker; <span class="comment">//上面咱们提到了关于blocker的作用，主要用于nio中的selector</span></span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interrupt0();</span><br><span class="line">            b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();<span class="comment">// 1、2、4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中断线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">interrupt0</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前线程是否被中断，该方法会清除中断状态</span></span><br><span class="line"><span class="comment"> * 如果方法调用多次，则多次调用后会返回false，除了在多次调用后又发生中断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否被中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程是否被中断，该方法不会清除中断状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程是否被中断，是否清除中断状态取决于ClearInterrupted参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ClearInterrupted 是否清除中断状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该方法原先被设计为破坏线程，并未清理资源，也就是说线程持有的锁会继续持有，并未释放锁，幸好还未实现就已经被废弃了</span></span><br><span class="line"><span class="comment"> * 官方说若是实现了它，将与Thread#suspend方法一样容易导致死锁，锁未得到释放，其他线程无法访问</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程是否处于活动状态中，活动状态表示：线程已启动（已调用start）且尚未终结</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 挂起/暂停线程</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1. 该方法已废弃，为什么呢? 官方定义如下：</span></span><br><span class="line"><span class="comment"> * suspend本质上是容易死锁的. 当某个线程被挂起时，其任务还持有对关键系统资源的锁，其他线程都访问不了该资源.</span></span><br><span class="line"><span class="comment"> * 若有其他线程在调用resume之前尝试获取该锁，则会导致死锁（线程并未释放锁）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2. 使用什么方式来代替suspend?</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    private volatile boolean threadSuspended;</span></span><br><span class="line"><span class="comment"> *   </span></span><br><span class="line"><span class="comment"> *    public synchronized void mousePressed() &#123;</span></span><br><span class="line"><span class="comment"> *        //业务逻辑</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *        threadSuspended = !threadSuspended;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *         if (!threadSuspended) &#123;</span></span><br><span class="line"><span class="comment"> *            notify();</span></span><br><span class="line"><span class="comment"> *         &#125;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     public void run() &#123;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          wihle(true) &#123;  //这里并未退出该任务</span></span><br><span class="line"><span class="comment"> *              try &#123;</span></span><br><span class="line"><span class="comment"> *                  Thread.sleep(interval);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                  if(threadSuspended) &#123; //这样子的方式可以在线程没有被挂起的情况不用花费synchronized关键词引起的代价</span></span><br><span class="line"><span class="comment"> *                      synchronized(this) &#123;</span></span><br><span class="line"><span class="comment"> *                          while(threadSuspended) &#123;</span></span><br><span class="line"><span class="comment"> *                              wait();</span></span><br><span class="line"><span class="comment"> *                          &#125;</span></span><br><span class="line"><span class="comment"> *                      &#125;</span></span><br><span class="line"><span class="comment"> *                  &#125;</span></span><br><span class="line"><span class="comment"> *              &#125; catch(InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment"> *    </span></span><br><span class="line"><span class="comment"> *              &#125;</span></span><br><span class="line"><span class="comment"> *          &#125;</span></span><br><span class="line"><span class="comment"> *          //业务逻辑</span></span><br><span class="line"><span class="comment"> *    &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. stop与suspend结合</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    public void run() &#123;</span></span><br><span class="line"><span class="comment"> *      Thread thisThread = Thread.currentThread();</span></span><br><span class="line"><span class="comment"> *      while (blinker == thisThread) &#123; //调用stop后会正常退出</span></span><br><span class="line"><span class="comment"> *          try &#123;</span></span><br><span class="line"><span class="comment"> *              Thread.sleep(interval);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              synchronized(this) &#123;</span></span><br><span class="line"><span class="comment"> *                 while (threadSuspended &amp;&amp; blinker==thisThread)</span></span><br><span class="line"><span class="comment"> *                     wait();</span></span><br><span class="line"><span class="comment"> *             &#125;</span></span><br><span class="line"><span class="comment"> *          &#125; catch (InterruptedException e)&#123;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *         &#125;</span></span><br><span class="line"><span class="comment"> *          //业务逻辑</span></span><br><span class="line"><span class="comment"> *      &#125;</span></span><br><span class="line"><span class="comment"> *    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public synchronized void stop() &#123;</span></span><br><span class="line"><span class="comment">    blinker = null;</span></span><br><span class="line"><span class="comment">    notify();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">suspend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    suspend0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 挂起线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">suspend0</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 恢复线程</span></span><br><span class="line"><span class="comment"> * 该方法仅与suspend一起使用，但由于suspend容易造成死锁而被废弃了，故而resume也用不到了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    resume0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置线程的优先级</span></span><br><span class="line"><span class="comment"> * 1 &lt; newPriority &lt; g.maxPriority &lt;= 10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newPriority 指定优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">    ThreadGroup g;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((g = getThreadGroup()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">            newPriority = g.getMaxPriority();</span><br><span class="line">        &#125;</span><br><span class="line">        setPriority0(priority = newPriority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取优先级</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPriority</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> priority;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置线程的名称</span></span><br><span class="line"><span class="comment"> * 即使线程已经启动了依然还是可以设置线程的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 指定线程的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>) &#123; <span class="comment">// threadStatus != 0 表示线程已启动</span></span><br><span class="line">        setNativeName(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ThreadGroup <span class="title">getThreadGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> group;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前线程组的活跃线程个数</span></span><br><span class="line"><span class="comment"> * 注意：线程组中还有子线程组，所以计算时也会包含子线程组</span></span><br><span class="line"><span class="comment"> * 该结果只是一个估算值，因为线程数一直在动态变化着，同时JVM也会有一些线程，所以可能会影响该计数结果</span></span><br><span class="line"><span class="comment"> * 该方法主要用来调试与监控</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程组的活跃线程个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">activeCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().getThreadGroup().activeCount();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前线程组的活跃线程拷贝到指定数组中</span></span><br><span class="line"><span class="comment"> * 要严格确保指定数组的大小大于活跃线程的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tarray 指定数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程组的活跃线程个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">enumerate</span><span class="params">(Thread tarray[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().getThreadGroup().enumerate(tarray);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算线程的栈帧，何为栈帧? 这就涉及到JVM的知识了，笔者还在慢慢往上走呢.</span></span><br><span class="line"><span class="comment"> * 调用该方法时，线程应该被挂起，而suspend已被废弃了，故而该方法也没啥用了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">countStackFrames</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前线程最多等待指定时间</span></span><br><span class="line"><span class="comment"> * t1.join(time);</span></span><br><span class="line"><span class="comment"> * 这里指的当前线程并不是t1，而是执行这些所属的线程，也就是main线程，按照最上面的概念来说，应该是当前线程添加到了t1对象的等待容器中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> millis 指定毫秒时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay); <span class="comment">//等待状态下的线程若是调用interruput去中断的话则会直接抛出InterruptedException异常后恢复运行，若是使用notify的话，那么最终都会等待指定的millis时间才会恢复运行</span></span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前线程最多等待指定时间</span></span><br><span class="line"><span class="comment"> * 若指定时间设置为0，则会一直等下去</span></span><br><span class="line"><span class="comment"> * 做了一些参数校验</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> millis 指定毫秒时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nanos 指定纳秒数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; millis == <span class="number">0</span>)) &#123;</span><br><span class="line">        millis++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    join(millis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前线程处于等待状态中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印线程的堆栈到标准输出</span></span><br><span class="line"><span class="comment"> * 该方法仅用于调试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dumpStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Exception(<span class="string">"Stack trace"</span>).printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据传入的值来决定将线程变成后台线程还是用户线程</span></span><br><span class="line"><span class="comment"> * 当所有正在运行的线程都是后台线程时，JVM退出</span></span><br><span class="line"><span class="comment"> * 该方法必须在start之前调用</span></span><br><span class="line"><span class="comment"> * false-用户线程   true-后台线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> on 标志</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setDaemon</span><span class="params">(<span class="keyword">boolean</span> on)</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (isAlive()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">    &#125;</span><br><span class="line">    daemon = on;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程是否是后台（守护）线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否是后台线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isDaemon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> daemon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前线程是否有权限修改当前对象所属的线程，若没有权限则抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkAccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        security.checkAccess(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印线程的名称，优先级，线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadGroup group = getThreadGroup();</span><br><span class="line">    <span class="keyword">if</span> (group != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Thread["</span> + getName() + <span class="string">","</span> + getPriority() + <span class="string">","</span> + group.getName() + <span class="string">"]"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Thread["</span> + getName() + <span class="string">","</span> + getPriority() + <span class="string">","</span> + <span class="string">""</span> + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前线程是否持有指定对象锁</span></span><br><span class="line"><span class="comment"> * true-表示当前线程持有指定对象锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否持有指定对象锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">holdsLock</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程的ID</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程的ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前线程的状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 当前线程的状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sun.misc.VM.toThreadState(threadStatus);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置未处理异常的默认处理器</span></span><br><span class="line"><span class="comment"> * 若设置了默认处理器，则所有的线程都将应用到，相当于全局处理器，而如果同时设置了自定义处理器，那么指定线程只会应用自定义处理器（可看dispatchUncaughtException方法）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> eh 默认处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDefaultUncaughtExceptionHandler</span><span class="params">(UncaughtExceptionHandler eh)</span> </span>&#123;</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sm.checkPermission(</span><br><span class="line">            <span class="keyword">new</span> RuntimePermission(<span class="string">"setDefaultUncaughtExceptionHandler"</span>)</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">     defaultUncaughtExceptionHandler = eh;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取未处理异常的默认处理器</span></span><br><span class="line"><span class="comment"> * 返回null表示没有设置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 默认处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UncaughtExceptionHandler <span class="title">getDefaultUncaughtExceptionHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> defaultUncaughtExceptionHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取未处理异常的自定义处理器</span></span><br><span class="line"><span class="comment"> * 若未设置自定义处理器，则走线程组的异常处理，线程组中会获取默认处理器，若也未设置，则打印堆栈信息到控制台，若设置了则走默认处理器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 自定义处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UncaughtExceptionHandler <span class="title">getUncaughtExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uncaughtExceptionHandler != <span class="keyword">null</span> ? uncaughtExceptionHandler : group;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置自定义处理器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> eh 自定义处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUncaughtExceptionHandler</span><span class="params">(UncaughtExceptionHandler eh)</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    uncaughtExceptionHandler = eh;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下发异常到指定处理器上，该方法只会被JVM调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchUncaughtException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">    getUncaughtExceptionHandler().uncaughtException(<span class="keyword">this</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>创建线程有<code>两个方式</code>，一种是继承Thread，第二种是实现Runnable，第二种方式更为常见，且能够在只有一个任务实例的情况下创建多个线程。</p></li><li><p>线程的<code>6</code>个状态-新建、可运行、阻塞、等待、超时等待、终止。</p></li><li><p>wait的实现机制是通过对象的等待容器，更具体的描述可参考概念。</p></li><li><p>我们都知道每个线程都有一个本地栈，实际上是通过Thread对象中的threadLocals变量维护起来的，也就是说即使将ThreadLocal变量传入到不同的线程中也不会造成多线程之间共享同一个ThreadLocal，因为每个线程都有一个ThreadLocal对象，即上面提到的threadLocals变量，在为ThreadLocal设值时，每个线程都会检查当前线程下的threadLocals变量是否初始化了，若没有则初始化该变量。有一点需要注意下，ThreadLocal中通过维护一个Map来保存键值对的关系，而其中的键值就是当前的ThreadLocal对象，也就是说，将ThreadLocal传入到不同的线程中会造成它们的threadLocals变量所引用的键值是同一个，不过这丝毫不影响。</p></li><li><p>sleep、yield<code>不会</code>释放对象锁，可以在非同步控制方法或同步块中使用；wait、join、notify、notifyAll释放对象锁，必须在同步控制方法或同步块中使用，因为它们对锁进行了操作，故而需要先获取到锁才能操作。</p></li><li><p>stop：因为会造成数据的不完整，最终会导致不可预测的行为而废弃；suspend：因为始终都没有释放锁，容易造成死锁而废弃；destroy：官方说还未实现就已经废弃了，同样会造成死锁；resume：该方法仅与suspend一起使用，由于suspend已经被废弃了，那它也只好跟着牺牲了。</p></li><li><p>未处理异常的默认处理器与自定义处理器的使用。</p></li></ul><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a><div><span>重点</span></div></h3><p><code>线程的状态转变</code> <code>wait/join/notify/notify/sleep/yield</code></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><div><span>参考资料</span></div></h3><p>《Java编程思想》</p><p>《Java并发编程的艺术》</p><p><a href="https://www.javazhiyin.com/52519.html" target="_blank" rel="noopener">https://www.javazhiyin.com/52519.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;接下来的这一段时间都将探索跟线程有关的内容，包括各种锁，对Thread的总结如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;线程具有&lt;code&gt;优先级&lt;/code&gt;，高优先级的线程优先于低优先级的线程执行，当在某个线程中创建新线程时，新线程的优先级被设置成当前线程的优先级；JVM启动时，默认有一个非守护线程（调用某个类的main方法）；线程能被标记为&lt;code&gt;守护线程&lt;/code&gt;，每个线程都可以&lt;code&gt;指定名称&lt;/code&gt;，未指定的情况下将由底层帮其生成一个新名称；有两种方式来创建线程，如下所示：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 在只有一个实例的情况下只能创建一个线程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestA&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Thread&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;TestA&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 在只有一个实例的情况下可创建多个线程，这种方式更为常见&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestB&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Runnable&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;TestB&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>为入门操作系统而读-《计算机的心智-操作系统之哲学原理》</title>
    <link href="http://zlia.tech/2019/12/03/read-computer-mind/"/>
    <id>http://zlia.tech/2019/12/03/read-computer-mind/</id>
    <published>2019-12-03T10:27:16.000Z</published>
    <updated>2019-12-03T10:27:16.129Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>为什么会想着入门操作系统呢？还是跟Java有关系，在深入学习的过程中发现很多点都会涉及到操作系统底层的知识，特别是并发这块内容，而笔者我现在只是刚刚起步学习就已经要了解与操作系统相关的内容，所以还是早点入坑吧。为什么是先看这本书呢？当然了，我不会无缘无故随便看一本，是经过从前人的推荐到知识点的考察才最终定下来！《计算机的心智-操作系统之哲学原理》这本书出版于09年，也算是一本年代已久的书籍，不过相对于计算机的诞生时间来说，它的知识点应该不会显得过时，该书在商城上可能买不到了，笔者也是找的PDF，Google一下就有了。打算借着这本书的知识点来对操作系统的入门做一个总结，同时也希望能够帮助其他有缘人吧。</p><a id="more"></a><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a><div><span>概念</span></div></h3><ul><li><p><code>中断</code>：当你正在看电影时，突然心血来潮迫不及待想要听上一首周杰伦的新歌曲，看似很简单的操作，实际上CPU会打断正在执行的任务并保存当前任务的上下文信息，转而去帮你完成更重要的任务，等重要的任务完成后会根据之前保存的上下文信息进行任务的恢复，以便继续执行，不过若中断发生异常可能会直接导致任务终止。中断分为硬件中断与软件中断，两者都可以通过总线向CPU发送中断请求（CPU内部有个中断控制器负责接收），可能同时出现多个中断请求，但每次CPU只能响应其中一个，所以会根据预先设置好的优先级进行排队，等候CPU处理，所谓的处理就会转入相应的中断服务程序，也就是上面提到的更重要的任务。在多CPU中，有一个全局中断控制器负责将接收到的中断请求按照某个规则下发到指定CPU中。</p></li><li><p><code>内核态与用户态</code>：有的程序可以访问计算机的任何资源，而有的计算机只能访问非常受限的少量资源。操作系统作为计算机的管理者，它应该享有更多的方便或特权，否则怎么管理计算机？所以内核态就是拥有资源多的状态，或者说访问资源多的状态，我们也称之为特权态。相对来说，用户态就是非特权态，在此种状态下访问的资源将受到限制。计算机如何知道现在正在运行的程序是内核态还是用户态呢？CPU内部有一个状态位，通过设置该状态位来表示内核态与用户态，程序在运行时，CPU是什么态，这个程序就运行在什么态上。既然已经知道了某个程序是哪种状态了，那么如何通过状态来限制其访问的资源呢？要限制一个程序对资源的访问，需要对程序执行的每一条指令进行检查才能完成。而这种检查就是地址翻译，程序发出的每一条指令都要经过这个地址翻译过程，通过对翻译的控制，就可以限制程序对资源的访问，很明显这是针对用户态来说。对于内核态，程序可以绕过内存地址翻译而直接执行指令。</p></li><li><p><code>进程</code>：表示执行中的程序，一旦程序在计算机中运行起来，它就成为了一个进程。每个进程都有一个地址空间，该地址空间存储了可执行文件的代码与数据，进程可以创建子进程，子进程又可以创建进程，在Linux中这些进程称为进程组。系统对进程的管理通过进程表来实现，进程表里存放的是关于进程的一切信息。</p></li><li><p><code>线程</code>：程序执行流的最小单元。一个进程至少有一个线程，在多线程下可共享进程的资源，如全局变量、堆内存，但也有一些只有自身才能访问的资源，如栈内存、寄存器、线程本地存储（ThreadLocal）。</p></li><li><p><code>多线程的调度</code>：CPU通过给每个线程分配时间片来实现多线程的调度。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程，让我们感觉多个线程是同时执行，时间片一般是几十毫秒。CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务，可以再加载这个任务的状态，所以任务从保存到再加载的过程就是一次<code>上下文切换</code>。</p></li><li><p><code>内存架构</code>：由高速缓存、主存、磁盘等组成的一个内存架构。高速缓存的特点是低容量、高速度、高价格；主存的特点是中容量、中速度、中价格；磁盘则是大容量、地速度、低成本的存储媒介。</p></li><li><p><code>内存管理</code>：对内存架构进行管理，使程序在内存架构的任何一个层次上的存放对于用户来说都是一样的。用户无需担心自己的程序是存在高速缓存、主存、磁盘，反正运行、计算、输出的结果都是一样的。让内存管理实现这种媒介透明的手段就是<code>虚拟内存</code>。</p></li><li><p><code>虚拟内存</code>：程序在运行时会加载到主存中，但是主存的容量非常有限，这将限制我们只能编写很小的程序。加大主存？这显然不合理，无疑增加了更多的成本，所以这就诞生了虚拟内存：不增加成本的情况下扩大内存容量。虚拟内存的中心思想是将主存扩大到便宜、大容量的磁盘上，即将磁盘空间看作是主存空间的一部分。程序存放在磁盘上就相当于存放在主存内。程序既可以完全存放在主存，也可以完全存放在磁盘上，当然也可以部分存放在主存、部分存放在磁盘。而程序执行时，程序发出的地址到底是在主存还是在磁盘则由操作系统的内存管理模块负责判断，并到相应的地方进行读写操作。</p></li></ul><p>操作系统的概念是真的多，还有很多重要的概念并未提及，比如缓存一致性、多核、原子操作。</p><h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a><div><span>评价</span></div></h3><p>该书以一种通俗易懂的方式引出知识点，结合生活中的例子对知识点的原理进行一步步地深入分析，点到为止！很适合入门级的操作系统书籍。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;为什么会想着入门操作系统呢？还是跟Java有关系，在深入学习的过程中发现很多点都会涉及到操作系统底层的知识，特别是并发这块内容，而笔者我现在只是刚刚起步学习就已经要了解与操作系统相关的内容，所以还是早点入坑吧。为什么是先看这本书呢？当然了，我不会无缘无故随便看一本，是经过从前人的推荐到知识点的考察才最终定下来！《计算机的心智-操作系统之哲学原理》这本书出版于09年，也算是一本年代已久的书籍，不过相对于计算机的诞生时间来说，它的知识点应该不会显得过时，该书在商城上可能买不到了，笔者也是找的PDF，Google一下就有了。打算借着这本书的知识点来对操作系统的入门做一个总结，同时也希望能够帮助其他有缘人吧。&lt;/p&gt;
    
    </summary>
    
      <category term="essays" scheme="http://zlia.tech/categories/essays/"/>
    
    
      <category term="operating-system" scheme="http://zlia.tech/tags/operating-system/"/>
    
  </entry>
  
  <entry>
    <title>每日知识点20191107</title>
    <link href="http://zlia.tech/2019/11/26/core-java-knowledge-20191107/"/>
    <id>http://zlia.tech/2019/11/26/core-java-knowledge-20191107/</id>
    <published>2019-11-26T08:34:07.000Z</published>
    <updated>2019-11-26T08:34:07.855Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java"><a href="#java" class="headerlink" title="java"></a><div><span>java</span></div></h3><ul><li><p>Exception#fillInStackTrace：将当前调用栈信息填入到原来异常对象，相当于更新最新的抛出点（catch异常后又抛出的点）</p></li><li><p>try-finally某些情况下会吃掉抛出的异常</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>覆盖方法时，只能抛出在基类方法的异常说明里列出的那些异常或其子类或选择不抛出，但是此限制对构造器不起作用，派生类构造器可以抛出任何异常，只需要在异常说明中包含基类构造器的异常说明</p></li><li><p>Collections.nCopies能添加新元素，Collections.fill只能替换元素，无法添加新元素</p></li><li><p>通配符代表着持有具有某种具体类型的同构集合</p></li></ul><a id="more"></a><ul><li>下面的代码摘抄自编程思想P550</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestS</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标准输入、输出和错误IO流进行重定向</span></span><br><span class="line"><span class="comment">     * 一开始只有in.out中有数据，而test.out中是空内容，执行完程序后，test.out中的数据和in.out是一致的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        PrintStream console = System.out;</span><br><span class="line">        BufferedInputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"in.out"</span>));</span><br><span class="line">        PrintStream out = <span class="keyword">new</span> PrintStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"test.out"</span>)));</span><br><span class="line">        System.setIn(in);<span class="comment">//默认是从控制台读取数据，但是这里进行了重定向，于是从in.out中读取数据</span></span><br><span class="line">        System.setOut(out);<span class="comment">//默认是将数据写入到控制台，但是这里进行了重定向，于是写入到test.out中</span></span><br><span class="line">        System.setErr(out);<span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认情况下是从控制台读取数据，然而这里是读取in.out文件中的数据</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s ;</span><br><span class="line">        <span class="keyword">while</span>((s = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        out.close();</span><br><span class="line">        System.setOut(console);<span class="comment">//切换到默认情况下</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>容错：发生故障时，如何让系统继续运行</p></li><li><p>高可用：系统中断时，如何尽快恢复</p></li><li><p>灾备：系统毁灭时，如何抢救数据</p></li><li><p>TestA.class.isAssignableFrom(TestB.class)：TestA与TestB是同一个类类型或TestA是TestB的父类或TestA是TestB的父接口</p></li><li><p>java中采用高位优先（大端模式）进行存储字节数据，也就是高位存储在低地址，低位存储在高地址上</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java&quot;&gt;&lt;a href=&quot;#java&quot; class=&quot;headerlink&quot; title=&quot;java&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;java&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Exception#fillInStackTrace：将当前调用栈信息填入到原来异常对象，相当于更新最新的抛出点（catch异常后又抛出的点）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;try-finally某些情况下会吃掉抛出的异常&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RuntimeException();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;覆盖方法时，只能抛出在基类方法的异常说明里列出的那些异常或其子类或选择不抛出，但是此限制对构造器不起作用，派生类构造器可以抛出任何异常，只需要在异常说明中包含基类构造器的异常说明&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Collections.nCopies能添加新元素，Collections.fill只能替换元素，无法添加新元素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通配符代表着持有具有某种具体类型的同构集合&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="daily-konwledge-point-java" scheme="http://zlia.tech/tags/daily-konwledge-point-java/"/>
    
  </entry>
  
  <entry>
    <title>探索ByteBuffer底层实现</title>
    <link href="http://zlia.tech/2019/11/26/explain-bytebuffer-sourcecode/"/>
    <id>http://zlia.tech/2019/11/26/explain-bytebuffer-sourcecode/</id>
    <published>2019-11-26T08:27:15.000Z</published>
    <updated>2019-11-26T08:27:15.081Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>由于最近在了解IO相关知识，而正好看到了nio，这是我以前从来没接触过的，虽然它很早就出现了，所以先来看看有关于它的一些基础。探索<code>ByteBuffer</code>源代码是基于<code>JDK1.8</code>版本的，ByteBuffer的父类是<code>Buffer</code>，通过阅读注释后对Buffer总结如下：</p><blockquote><p>缓冲区是特定基本类型的元素的线性有限序列，除了内容之外，缓冲区的基本属性还包括<code>capacity</code>、<code>limit</code>、<code>position</code>、<code>mark</code>。假设缓冲区是一本1000页的书籍，你已经看到800页了，其中在500页处有个很重要的知识点，你做了个标记以便下次能够轻松找到它。那么capacity指代的就是1000，意思就是这本书的最大页数，缓冲区的最大容量，该属性值不会为负不会改变；limit指代的是800，意思是目前只学了这么多知识，可以理解为界限；position指代的是具体某一页，也就是你每看一页，position就会有所增加；mark很容易理解，指代的是我们标记到具体某一页。在实际代码中有读、写模式，我们将读模式比喻成复习，也就是说你可以从第0页复习到第800页，此时的postion从0-800，limit保持800不变，也可以从你所标记的点到第800页，此时的position从mark-800，但是切记不能从第0页复习而后直接跳到mark处，这样子就导致知识点的不连续性，简单来说<code>0 &lt;= mark &lt;= posiiton &lt;= limit &lt;= capacity</code>；将写模式比喻成继续学习新知识点，也就是从第801页继续往后看，position会逐步增加。对于只读缓冲区来说，不允许修改它的内容，但是limit、position、mark是可以变化的。最后一点是缓冲区属于非线程安全！</p></blockquote><p>提供一张图片方便理解。接下来在总结下ByteBuffer，以便对其有个大概性的了解。</p><p class="customize-img"><img src="/assets/blogImg/java/bytebuffer/bytebuffer-variable.png" alt="Buffer相关变量"></p><blockquote><p><code>字节缓冲区</code>，可创建视图缓冲区，视图缓冲区指的是包含其他基本类型值的缓冲区，如CharBuffer，视图缓冲区的索引不是以字节为单位，而是根据其值的特定类型的大小决定的，如CharBuffer是2个字节。字节缓冲区可分为直接或间接，直接缓冲区的内容存放在堆外内存，JVM将尽最大努力直接执行原生IO操作，而间接缓冲区存放在堆内存中，交由JVM操作，与操作系统并未直接交互，直接缓冲区通常比间接缓冲区具有更高的分配和释放成本，简单来说，对于大型缓冲区来说直接分配直接缓冲区。</p></blockquote><p>概念性的内容就阐述到这里了，接着就直接进入源码世界吧！</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><p>由于ByteBuffer是个抽象类，故方法可能涉及到多个类，先贴一张继承结构类图。</p><p class="customize-img"><img src="/assets/blogImg/java/bytebuffer/bytebuffer-hierarchy.png" alt="Buffer继承结构"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 抽象类没办法直接创建该对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuffer</span> <span class="keyword">extends</span> <span class="title">Buffer</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ByteBuffer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储缓冲区的内容</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] hb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓冲区的第一个元素在hb数组中索引</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓冲区是否是只读缓冲区</span></span><br><span class="line">    <span class="keyword">boolean</span> isReadOnly;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓冲区的字节顺序</span></span><br><span class="line">    <span class="keyword">boolean</span> bigEndian = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该属性定义在Buffer中，标记缓冲区中的某个位置  mark &lt;= position</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mark = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该属性定义在Buffer中，代表缓冲区中下一个读取或写入的元素的索引 position &lt;= limit</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该属性定义在Buffer中，代表着界限，该值在写模式下等于capacity，读模式下等于position写模式下的索引 limit &lt;= capacity</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该属性定义在Buffer中，代表着缓冲区的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化，设置属性值</span></span><br><span class="line"><span class="comment"> * 在初始化之前需要校验这些成员属性是否合法性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mark 标记缓冲区中的某个索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pos 下一个读取或写入的元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lim 界限-读模式下等于position写模式下的索引，简单来说就是记住最后写入内容的索引，以便知道读取结束了；写模式下等于capacity，以便知道缓冲区已经写满了，不能再写了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cap 缓冲区的容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hb 字节数组-存储缓冲区的内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> offset 缓冲区中第一个元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ByteBuffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap, <span class="keyword">byte</span>[] hb, <span class="keyword">int</span> offset) &#123;</span><br><span class="line">    <span class="keyword">super</span>(mark, pos, lim, cap);</span><br><span class="line">    <span class="keyword">this</span>.hb = hb;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mark 标记缓冲区中的某个索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pos 下一个读取或写入的元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lim 界限-读模式下等于position写模式下的索引，简单来说就是记住最后写入内容的索引，以便知道读取结束了；写模式下等于capacity，以便知道缓冲区已经写满了，不能再写了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cap 缓冲区的容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ByteBuffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap) &#123;</span><br><span class="line">    <span class="keyword">this</span>(mark, pos, lim, cap, <span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该构造函数中涉及到的知识点比较多，笔者也是不懂，借助别人分析的文章进行讲解</span></span><br><span class="line"><span class="comment"> * 申请堆外内存与设置释放堆外内存机制</span></span><br><span class="line"><span class="comment"> * 堆外内存是不受JVM管理，这导致了堆外内存没办法被JVM回收，所以它通过在堆内存中创建对象，当该对象被回收时，会先调用Cleaner#clean，而在该方法中调用了Deallocator#run，这样子就将堆外内存释放了</span></span><br><span class="line"><span class="comment"> * 这里涉及到了虚引用的使用，可参考Reference类中的代码，或者看有关文章</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cap 要申请的容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">DirectByteBuffer(<span class="keyword">int</span> cap) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="keyword">boolean</span> pa = VM.isDirectMemoryPageAligned(); <span class="comment">// 判断是否需要页面对齐，默认是false，何为页面对齐，目前我是不知道有什么用</span></span><br><span class="line">    <span class="keyword">int</span> ps = Bits.pageSize();</span><br><span class="line">    <span class="keyword">long</span> size = Math.max(<span class="number">1L</span>, (<span class="keyword">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap); <span class="comment">// 主要用于判断申请的堆外内存是否超过了最大值，这里的代码就不做深入了，要求大概能懂就行了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size); <span class="comment">// 申请堆外内存</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (<span class="keyword">byte</span>) <span class="number">0</span>); <span class="comment">// 初始化堆外内存空间为0</span></span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap)); <span class="comment">// 使用Cleaner机制回收堆外内存</span></span><br><span class="line">    att = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 校验并设置属性</span></span><br><span class="line"><span class="comment"> * 由于mark &lt;= position &lt;= limit 所以只要校验mark、position即可</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> limit 界限值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 当前对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">limit</span><span class="params">(<span class="keyword">int</span> newLimit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((newLimit &gt; capacity) || (newLimit &lt; <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    limit = newLimit;</span><br><span class="line">    <span class="keyword">if</span> (position &gt; limit) position = limit;</span><br><span class="line">    <span class="keyword">if</span> (mark &gt; limit) mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 校验并设置属性</span></span><br><span class="line"><span class="comment"> * 由于mark &lt;= position 所以只要校验mark即可</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newPosition 下一个读取或写入的元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 当前对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">position</span><span class="params">(<span class="keyword">int</span> newPosition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((newPosition &gt; limit) || (newPosition &lt; <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    position = newPosition;</span><br><span class="line">    <span class="keyword">if</span> (mark &gt; position) mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过申请堆外内存来构造直接缓冲区</span></span><br><span class="line"><span class="comment"> * 当该对象被回收时会出发释放堆外内存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity 申请的容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造间接缓冲区</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity 缓冲区的容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(capacity, capacity); <span class="comment">// 虽然这是另外一个类，实际上挺简单的，所以这里就不做继续阐述了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个包含指定字节数组的缓冲区</span></span><br><span class="line"><span class="comment"> * 若在外部修改该字节数组，对应的缓冲区内容也会变化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arry 指定字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> offset 下一个要读取或写入的元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length 指定写入或读取的元素的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] array, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(array, offset, length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException x) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个包含指定字节数组的缓冲区</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 指定字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> wrap(array, <span class="number">0</span>, array.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个包含从position到limit之间的源缓冲区内容的新缓冲区（HeapByteBuffer）</span></span><br><span class="line"><span class="comment"> * 源缓冲区与新缓冲区共享同一个字节数组，两者的属性position、limit、capacity是相互独立的</span></span><br><span class="line"><span class="comment"> * 在源缓冲区构建完后它的offset就已经确定下来了，而对于position来说，它会随着读或写不断的变化，但它始终 &gt;= offset，因为offset代表着缓冲区的第一个元素对应到字节数组上的索引</span></span><br><span class="line"><span class="comment"> * position相当于它离第一个元素多远，offset + position = 当前读或者写入的元素对应到字节数组上的索引，所以对于新缓冲区来说，它的第一个元素对应到字节数组上的索引就是position + offset，不知道说清楚没有</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0  1  2  3  4  5  6  7  8  9  10</span></span><br><span class="line"><span class="comment"> * 假设这是字节数组，1：offset  position：3（此时的3并不是指的3索引，而是指定离第一个元素有多远，那么position对应的索引应该是1 + 3 = 4索引）</span></span><br><span class="line"><span class="comment"> * 该类中的arrayOffset方法在第一次获取offset值时个人觉得写的不对，就好比我上面已经指定了position的值了，可惜返回的结果并不是我想要的，而在调用完slice完后再次通过arrayOffset获取offset，这次的结果确实正确的，于是我就有点纳闷了</span></span><br><span class="line"><span class="comment"> * 况且它的注释已经写的很明白了</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新缓冲区，与源缓冲区共享同一个字节数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">slice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(hb, -<span class="number">1</span>, <span class="number">0</span>, <span class="keyword">this</span>.remaining(), <span class="keyword">this</span>.remaining(), <span class="keyword">this</span>.position() + offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取缓冲区中剩余元素的数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 剩余元素的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">remaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> limit - position;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取position的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> position</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">position</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> position;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对于直接缓冲区来说，笔者不敢保证是否共享同一块内存区域，这块的知识点并不是很充裕</span></span><br><span class="line"><span class="comment"> * 注释上说，若调用该方法的是个直接缓冲区，那么新缓冲区将是个只读缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">slice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="keyword">this</span>.position();</span><br><span class="line">    <span class="keyword">int</span> lim = <span class="keyword">this</span>.limit();</span><br><span class="line">    <span class="keyword">assert</span> (pos &lt;= lim);</span><br><span class="line">    <span class="keyword">int</span> rem = (pos &lt;= lim ? lim - pos : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> off = (pos &lt;&lt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">assert</span> (off &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(<span class="keyword">this</span>, -<span class="number">1</span>, <span class="number">0</span>, rem, rem, off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 复制源缓冲区，包括其属性position、limit、capacity、offset</span></span><br><span class="line"><span class="comment"> * 源缓冲区与新缓冲区共享同一个字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">duplicate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(hb, <span class="keyword">this</span>.markValue(), <span class="keyword">this</span>.position(), <span class="keyword">this</span>.limit(), <span class="keyword">this</span>.capacity(), offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注释上说，若调用该方法的是个直接缓冲区，那么新缓冲区将是个只读缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">duplicate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(<span class="keyword">this</span>, <span class="keyword">this</span>.markValue(), <span class="keyword">this</span>.position(), <span class="keyword">this</span>.limit(), <span class="keyword">this</span>.capacity(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 复制源缓冲区，但是不允许新缓冲区修改内容，源缓冲区还是可以继续修改其内容，毕竟它不属于只读</span></span><br><span class="line"><span class="comment"> * HeapByteBufferR类中覆写了put方法，调用put方法都将抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">asReadOnlyBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBufferR(hb, <span class="keyword">this</span>.markValue(), <span class="keyword">this</span>.position(), <span class="keyword">this</span>.limit(), <span class="keyword">this</span>.capacity(), offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取缓冲区中position上的字节</span></span><br><span class="line"><span class="comment"> * 缓冲区中position会对应到字节数组中的索引来获取字节</span></span><br><span class="line"><span class="comment"> * 调用完该方法后position会自增</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 与该方法类似的直接缓冲区的知识点将尽量讲解，不懂的点我不会讲解！！！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 字节</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hb[ix(nextGetIndex())];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取下一个读取的元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 下一个读取的元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextGetIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position &gt;= limit)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line">    <span class="keyword">return</span> position++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取字节数组上对应的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 对应position</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 字节数组上对应的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">ix</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定字节写入到缓冲区中position位置上</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 指定字节</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">    hb[ix(nextPutIndex())] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取下一个写入的元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 下一个写入的元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextPutIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position &gt;= limit)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    <span class="keyword">return</span> position++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取缓冲区中指定位置上的字节</span></span><br><span class="line"><span class="comment"> * 注意这里并没有修改position的值</span></span><br><span class="line"><span class="comment"> * 这里一直称作是指定位置，而不是指定索引，因为该位置并不是字节数组中的索引，而是缓冲区的指定位置对应到字节数组的指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定位置上的字节</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hb[ix(checkIndex(i))];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 校验指定索引是否超过界限</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">checkIndex</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((i &lt; <span class="number">0</span>) || (i &gt;= limit))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定字节写入到缓冲区中指定位置上</span></span><br><span class="line"><span class="comment"> * 注意这里并没有修改position的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 指定字节</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">    hb[ix(checkIndex(i))] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将缓冲区中的剩余元素复制指定数量，从指定字节数组的指定起始索引处开始复制缓冲区的内容</span></span><br><span class="line"><span class="comment"> * 校验字节数组的参数是否合法</span></span><br><span class="line"><span class="comment"> * 若所需数量大于缓冲区的剩余元素长度，则会抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dst 指定字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> offset 指定起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length 指定数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    checkBounds(offset, length, dst.length);</span><br><span class="line">    <span class="keyword">if</span> (length &gt; remaining())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line">    <span class="keyword">int</span> end = offset + length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = offset; i &lt; end; i++)</span><br><span class="line">        dst[i] = get();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将缓冲区中的剩余元素复制到指定字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dst 指定字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(dst, <span class="number">0</span>, dst.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定缓冲区的剩余元素复制到当前缓冲区</span></span><br><span class="line"><span class="comment"> * 若当前缓冲区是个只读，则抛出异常</span></span><br><span class="line"><span class="comment"> * 若当前的缓冲区的剩余元素个数小于指定缓冲区的剩余元素个数，简单来说，就是不够放了，那么抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src 指定缓冲区</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(ByteBuffer src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (src == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (isReadOnly())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ReadOnlyBufferException();</span><br><span class="line">    <span class="keyword">int</span> n = src.remaining();</span><br><span class="line">    <span class="keyword">if</span> (n &gt; remaining())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        put(src.get());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从指定字节数组的指定起始位置开始遍历指定数量，将遍历后的元素复制到缓冲区中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src 指定字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> offset 指定起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length 指定数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span>[] src, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    checkBounds(offset, length, src.length);</span><br><span class="line">    <span class="keyword">if</span> (length &gt; remaining())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    <span class="keyword">int</span> end = offset + length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = offset; i &lt; end; i++)</span><br><span class="line">        <span class="keyword">this</span>.put(src[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将字节数组的内容复制到缓冲区中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src 指定字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span>[] src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> put(src, <span class="number">0</span>, src.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否是可访问数组（缓冲区），代表非只读缓冲区已初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否是可访问数组（缓冲区）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (hb != <span class="keyword">null</span>) &amp;&amp; !isReadOnly;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取字节数组</span></span><br><span class="line"><span class="comment"> * 若修改缓冲区的内容，则返回的字节数组的内容也将跟着变化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 字节数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] array() &#123;</span><br><span class="line">    <span class="keyword">if</span> (hb == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    <span class="keyword">if</span> (isReadOnly)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ReadOnlyBufferException();</span><br><span class="line">    <span class="keyword">return</span> hb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取缓冲区的第一个元素对应到字节数组中的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">arrayOffset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hb == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    <span class="keyword">if</span> (isReadOnly)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ReadOnlyBufferException();</span><br><span class="line">    <span class="keyword">return</span> offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将缓冲区的剩余元素拷贝到缓冲区的起始位置</span></span><br><span class="line"><span class="comment"> * postion上的字节被拷贝到索引0上</span></span><br><span class="line"><span class="comment"> * 该方法最好在缓冲区写完数据后调用，防止数据不完整</span></span><br><span class="line"><span class="comment"> * positions设置到limit，limit设置到capacity，mark = -1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   buf.clear();</span></span><br><span class="line"><span class="comment"> *   while (in.read(buf) &gt;= 0 || buf.position != 0) &#123; // in.read(buf)：从channel读取数据到buf中 channel -&gt; buf</span></span><br><span class="line"><span class="comment"> *       buf.flip();  // 将limit设置到position, position = 0  实际上就是将写模式切换到读模式，一般在写完后要开始读取数据了调用</span></span><br><span class="line"><span class="comment"> *       out.write(buf);  // 将buf中的数据写入到channel中  buf -&gt; channel</span></span><br><span class="line"><span class="comment"> *       buf.compact();    // In case of partial write</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">compact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.arraycopy(hb, ix(position()), hb, ix(<span class="number">0</span>), remaining());</span><br><span class="line">    position(remaining());</span><br><span class="line">    limit(capacity());</span><br><span class="line">    discardMark(); <span class="comment">//mark = -1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否是直接缓冲区</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否是直接缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDirect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 比较两个缓冲区的剩余元素是否完全相同</span></span><br><span class="line"><span class="comment"> * 若有一处不同则直接返回结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> that 另一个缓冲区</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 比较结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ByteBuffer that)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">this</span>.position() + Math.min(<span class="keyword">this</span>.remaining(), that.remaining());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.position(), j = that.position(); i &lt; n; i++, j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = compare(<span class="keyword">this</span>.get(i), that.get(j));</span><br><span class="line">        <span class="keyword">if</span> (cmp != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> cmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.remaining() - that.remaining();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取缓冲区的字节顺序，默认是高位优先</span></span><br><span class="line"><span class="comment"> * 不同的机器可能会使用不同的字节排序方法来存储数据</span></span><br><span class="line"><span class="comment"> * 高位优先：高位字节存放在内存的低地址，低位字节存放在高地址</span></span><br><span class="line"><span class="comment"> * 低位优先：低位字节存放在内存的高地址，高位字节存放在低地址</span></span><br><span class="line"><span class="comment"> * 对于不同的基本类型的位数是不一样的</span></span><br><span class="line"><span class="comment"> * 高位  低位   </span></span><br><span class="line"><span class="comment"> * 0001 1111</span></span><br><span class="line"><span class="comment"> * 低地址 -----&gt; 高地址</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 代表字节顺序的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ByteOrder <span class="title">order</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bigEndian ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改缓冲区的字节顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ByteBuffer <span class="title">order</span><span class="params">(ByteOrder bo)</span> </span>&#123;</span><br><span class="line">    bigEndian = (bo == ByteOrder.BIG_ENDIAN);</span><br><span class="line">    nativeByteOrder = (bigEndian == (Bits.byteOrder() == ByteOrder.BIG_ENDIAN));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取缓冲区的position与position对应的字节，根据当前字节顺序将两个字节组成一个char值，然后将position + 2</span></span><br><span class="line"><span class="comment"> * 因为char类型是占用两个字节, 所以会将两个字节变成1个char类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 97 |  bytes</span></span><br><span class="line"><span class="comment"> * |       |       |       |   a    |  chars</span></span><br><span class="line"><span class="comment"> * |   0   |   0   |   0   |   97   |  shorts</span></span><br><span class="line"><span class="comment"> * |       0       |       97       |   ints</span></span><br><span class="line"><span class="comment"> * 以此类推....</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> char值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Bits.getChar(<span class="keyword">this</span>, ix(nextGetIndex(<span class="number">2</span>)), bigEndian);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定char值写入到缓冲区中指定位置上</span></span><br><span class="line"><span class="comment"> * 由于char占用两个字节，分为高位与低位，根据缓冲区中字节的顺序进行存储，默认情况是将高位存储在低地址，低位存储在高地址</span></span><br><span class="line"><span class="comment"> * 最终position会加2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 指定char值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">putChar</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">    Bits.putChar(<span class="keyword">this</span>, ix(nextPutIndex(<span class="number">2</span>)), x, bigEndian);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取缓冲区中指定位置上的char值</span></span><br><span class="line"><span class="comment"> * 注意这里并没有修改position的值</span></span><br><span class="line"><span class="comment"> * char值占用两个字节，所以会将position与position + 1上的字节进行组合，position放在高位、position + 1放在低位</span></span><br><span class="line"><span class="comment"> * 这里一直称作是指定位置，而不是指定索引，因为该位置并不是字节数组中的索引，而是缓冲区的指定位置对应到字节数组的指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定位置上的char值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getChar</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Bits.getChar(<span class="keyword">this</span>, ix(checkIndex(i, <span class="number">2</span>)), bigEndian);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定char值写入到缓冲区中指定位置上</span></span><br><span class="line"><span class="comment"> * 注意这里并没有修改position的值</span></span><br><span class="line"><span class="comment"> * char值可分成高低位，根据缓冲区中的字节顺序进行存放，默认情况下将高位存储在低地址，低位存储在高地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 指定char值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">putChar</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">    Bits.putChar(<span class="keyword">this</span>, ix(checkIndex(i, <span class="number">2</span>)), x, bigEndian);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将字节缓冲区转换成字符缓冲区</span></span><br><span class="line"><span class="comment"> * 实际上内部还是通过字节缓冲区来操作，由于char占用两个字节，所以该对象对应的position、limit、capacity可能都会/2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 字符缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CharBuffer <span class="title">asCharBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">this</span>.remaining() &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> off = offset + position();</span><br><span class="line">    <span class="keyword">return</span> (bigEndian ? (CharBuffer)(<span class="keyword">new</span> ByteBufferAsCharBufferB(<span class="keyword">this</span>, -<span class="number">1</span>, <span class="number">0</span>, size, size, off)) : (CharBuffer)(<span class="keyword">new</span> ByteBufferAsCharBufferL(<span class="keyword">this</span>, -<span class="number">1</span>, <span class="number">0</span>, size, size, off)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于转换成其他类型，如short、int、float、double都是一样的道理，就不在做展示了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 相当于从写模式切换到读模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否缓冲区中还有剩余元素</span></span><br><span class="line"><span class="comment"> * 要么是写满缓冲区、要么是缓冲区的内容读完了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区是否还有剩余元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasRemaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> position &lt; limit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重新读取/写入缓冲区</span></span><br><span class="line"><span class="comment"> * 可重复读取缓冲区的内容，可重复写入来覆盖缓冲区的内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>缓冲区的基本属性有position、limit、capacity、mark，这些属性必须满足<code>0 &lt;= mark &lt;= posiiton &lt;= limit &lt;= capacity</code></p></li><li><p>可创建视图缓冲区，视图缓冲区指的是包含其他基本类型值的缓冲区，省去了类型转换的麻烦。但是千万记住视图缓冲区的索引不是以字节为单位，而是根据其值的特定类型的大小决定的</p></li><li><p>直接缓冲区建议还是了解下，不过本文没有讲的很详细，笔者能力有限</p></li><li><p>高低位、高地址、低地址，缓冲区的字节顺序</p></li><li><p>compact：将缓冲区的剩余元素拷贝到缓冲区的起始位置，修改position = limit，limit = capacity</p></li><li><p>slice：构造一个包含从position到limit之间的源缓冲区内容的新缓冲区，源缓冲区与新缓冲区共享同一个字节数组，但两者的基本属性是相互的独立</p></li><li><p>duplicate：复制源缓冲区的内容构造一个新缓冲区，包括复制基本属性，两个缓冲区共享同一个字节数组</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>基本属性</code> <code>compact、slice、duplicate</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;由于最近在了解IO相关知识，而正好看到了nio，这是我以前从来没接触过的，虽然它很早就出现了，所以先来看看有关于它的一些基础。探索&lt;code&gt;ByteBuffer&lt;/code&gt;源代码是基于&lt;code&gt;JDK1.8&lt;/code&gt;版本的，ByteBuffer的父类是&lt;code&gt;Buffer&lt;/code&gt;，通过阅读注释后对Buffer总结如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;缓冲区是特定基本类型的元素的线性有限序列，除了内容之外，缓冲区的基本属性还包括&lt;code&gt;capacity&lt;/code&gt;、&lt;code&gt;limit&lt;/code&gt;、&lt;code&gt;position&lt;/code&gt;、&lt;code&gt;mark&lt;/code&gt;。假设缓冲区是一本1000页的书籍，你已经看到800页了，其中在500页处有个很重要的知识点，你做了个标记以便下次能够轻松找到它。那么capacity指代的就是1000，意思就是这本书的最大页数，缓冲区的最大容量，该属性值不会为负不会改变；limit指代的是800，意思是目前只学了这么多知识，可以理解为界限；position指代的是具体某一页，也就是你每看一页，position就会有所增加；mark很容易理解，指代的是我们标记到具体某一页。在实际代码中有读、写模式，我们将读模式比喻成复习，也就是说你可以从第0页复习到第800页，此时的postion从0-800，limit保持800不变，也可以从你所标记的点到第800页，此时的position从mark-800，但是切记不能从第0页复习而后直接跳到mark处，这样子就导致知识点的不连续性，简单来说&lt;code&gt;0 &amp;lt;= mark &amp;lt;= posiiton &amp;lt;= limit &amp;lt;= capacity&lt;/code&gt;；将写模式比喻成继续学习新知识点，也就是从第801页继续往后看，position会逐步增加。对于只读缓冲区来说，不允许修改它的内容，但是limit、position、mark是可以变化的。最后一点是缓冲区属于非线程安全！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提供一张图片方便理解。接下来在总结下ByteBuffer，以便对其有个大概性的了解。&lt;/p&gt;
&lt;p class=&quot;customize-img&quot;&gt;&lt;img src=&quot;/assets/blogImg/java/bytebuffer/bytebuffer-variable.png&quot; alt=&quot;Buffer相关变量&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;字节缓冲区&lt;/code&gt;，可创建视图缓冲区，视图缓冲区指的是包含其他基本类型值的缓冲区，如CharBuffer，视图缓冲区的索引不是以字节为单位，而是根据其值的特定类型的大小决定的，如CharBuffer是2个字节。字节缓冲区可分为直接或间接，直接缓冲区的内容存放在堆外内存，JVM将尽最大努力直接执行原生IO操作，而间接缓冲区存放在堆内存中，交由JVM操作，与操作系统并未直接交互，直接缓冲区通常比间接缓冲区具有更高的分配和释放成本，简单来说，对于大型缓冲区来说直接分配直接缓冲区。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;概念性的内容就阐述到这里了，接着就直接进入源码世界吧！&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>深入理解String与new String</title>
    <link href="http://zlia.tech/2019/11/09/string-newString-compare/"/>
    <id>http://zlia.tech/2019/11/09/string-newString-compare/</id>
    <published>2019-11-09T15:41:06.000Z</published>
    <updated>2019-11-28T06:14:33.667Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>字符串是最常用的类型之一，趁此机会准备探索下它的源码。有关该类的注释作一个总结：</p><blockquote><p>String-字符串，是个常量，它们被创建后<code>其值</code>就不允许被改变，由于它是不可变的，所以它们可以被共享，在内部提供了多个方法来操作字符串。</p></blockquote><p>探索之前我曾看过其他人写的有关于此的文章，发现<code>JDK1.7版本前后的内存模型</code>不一样，而这部分的内容还没有排上行程，简单来说，我还不懂…所以不敢妄下结论，这篇文章的内容也不会从这方面展开来讲，此次探索是基于<code>JDK1.8</code>。</p><a id="more"></a><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a><div><span>原理</span></div></h3><p>字符串是存放在<code>常量池</code>中，至于什么是常量池不准备讨论它。先来个简单的示例方便分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String testOne = <span class="keyword">new</span> String(<span class="string">"testOne"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例就是这么简单…先让我们来看看仅仅是这么一句话，而它的底层都做了什么。紧接着反编译它的字节码文件，命令是<code>javap -v TestString</code>，输出的信息内容比较多，咱们只要常量池的内容，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/java/string/constant-pool-1.png" alt="常量池-1"></p><p>实际上我也看的不是很懂，但有几个点咱们是能确定的，也就是说<code>常量池中有testOne字符串</code>，而此时的字节码文件是编译而来的，并未实际上的运行，所以该字符串对象在堆内存中还未创建，这就说明了在编译阶段时字符串就存在于常量池中，同时也验证了一点：<code>常量池中的字符串对象</code>与运行时在<code>堆内存中创建的字符串对象</code>完全是两个对象，因为在编译时期堆内存中的对象还未出生呢，所以不可能引用到它…不知道我讲明白了没有。接着我们从另外一个角度去分析这段示例，因为后续的其他示例可能会羞涩难懂，所以先从简单的示例开始逐渐熟悉起来，最终也是希望读者能够理解这方面的知识。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    Constant pool:</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 编号  类型                值              注释            --------&gt; 这里的注释不一定对，只是作一个标记方便理解        </span></span><br><span class="line">    #1 = Methodref          #6.#22         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">    #2 = Class              #23            // java/lang/String</span><br><span class="line">    #3 = String             #18            // testOne</span><br><span class="line">    #4 = Methodref          #2.#24         // java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V</span><br><span class="line">    #5 = Class              #25            // test20190820/TestString</span><br><span class="line">    #6 = Class              #26            // java/lang/Object</span><br><span class="line">    #7 = Utf8               &lt;init&gt;</span><br><span class="line">    #8 = Utf8               ()V</span><br><span class="line">    #9 = Utf8               Code</span><br><span class="line">    #10 = Utf8               LineNumberTable</span><br><span class="line">    #11 = Utf8               LocalVariableTable</span><br><span class="line">    #12 = Utf8               this</span><br><span class="line">    #13 = Utf8               Ltest20190820/TestString;</span><br><span class="line">    #14 = Utf8               main</span><br><span class="line">    #15 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">    #16 = Utf8               args</span><br><span class="line">    #17 = Utf8               [Ljava/lang/String;</span><br><span class="line">    #18 = Utf8               testOne</span><br><span class="line">    #19 = Utf8               Ljava/lang/String;</span><br><span class="line">    #20 = Utf8               SourceFile</span><br><span class="line">    #21 = Utf8               TestString.java</span><br><span class="line">    #22 = NameAndType        #7:#8          // "&lt;init&gt;":()V</span><br><span class="line">    #23 = Utf8               java/lang/String</span><br><span class="line">    #24 = NameAndType        #7:#27         // "&lt;init&gt;":(Ljava/lang/String;)V</span><br><span class="line">    #25 = Utf8               test20190820/TestString</span><br><span class="line">    #26 = Utf8               java/lang/Object</span><br><span class="line">    #27 = Utf8               (Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><p>执行<code>javap -c TestString</code>获取底层代码执行逻辑，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/java/string/constant-pool-2.png" alt="常量池-2"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test20190820</span>.<span class="title">TestString</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> test20190820.TestString(); <span class="comment">//这里是构造器的执行逻辑，咱们忽略它，毕竟不是重点</span></span><br><span class="line">        Code:</span><br><span class="line">        <span class="number">0</span>: aload_0</span><br><span class="line">        1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">        <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>; <span class="comment">//下面的内容涉及到字节码的指令，网上很多资料，可自行查阅</span></span><br><span class="line">    Code:</span><br><span class="line">    <span class="comment">// #2：对应常量池中编号#2，加上注释我们得出这里是创建字符串对象  -&gt; new String();</span></span><br><span class="line">    0: new           #2                  // class java/lang/String</span><br><span class="line">    <span class="comment">// dup：复制0序号中的引用并压入栈中  -&gt; 也就是将字符串对象的引用放入到栈中</span></span><br><span class="line">    <span class="number">3</span>: dup</span><br><span class="line">    <span class="comment">// ldc：从常量池中加载指定项的引用到栈  #3：同上，对应着常量池的编号#3 -&gt; 将"testOne"字符串的引用加载到栈中</span></span><br><span class="line">    4: ldc           #3                  // String testOne</span><br><span class="line">    <span class="comment">// invokespecial：初始化常量池中的指定项  -&gt; 调用字符串对象的初始化并将4序号中的引用作为参数传入，形成new String("testOne")</span></span><br><span class="line">    6: invokespecial #4                  // Method java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V</span><br><span class="line">    <span class="comment">// astore_n：将引用赋值给第n个局部变量  -&gt; 将6序号的引用赋值给第一个局部变量，String testOne = new String("testOne")，jvm中是有记录局部变量的信息</span></span><br><span class="line">    <span class="number">9</span>: astore_1</span><br><span class="line">    <span class="comment">// 退出方法的标志</span></span><br><span class="line">    <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的分析可以知道：<code>常量池中的字符串对象与在堆内存中创建的字符串对象是两个对象</code>，这一点很重要！接下来是各种示例，我们将采用上面的方式进行分析。</p><h4 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String testOne = <span class="keyword">new</span> String(<span class="string">"testOne"</span>);</span><br><span class="line">        String testOneAnother = <span class="string">"testOne"</span>;</span><br><span class="line">        System.out.println(testOne == testOneAnother); <span class="comment">//false -&gt; 上面说了testOne和testOneAnother是两个对象，所以很容易得出结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        String s2 = <span class="string">"a"</span>;</span><br><span class="line">        String s3 = <span class="string">"bc"</span>;</span><br><span class="line">        String s4 = s2 + s3; <span class="comment">// StringBuilder.append(a).append(bc) -&gt; StringBuilder.toString() -&gt; new String("abc")</span></span><br><span class="line">        System.out.println(s1 == s4); <span class="comment">//false, s1指向了常量池中的字符串abc，s4相当于生成了新的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里就不贴常量池的信息了，反正我们能确定的是在编译时期字符串已经加载到常量池中了，所以常量池中应该存在abc、a、bc字符串</span></span><br><span class="line"><span class="comment"> * 贴出代码的执行逻辑：</span></span><br><span class="line"><span class="comment"> *  public static void main(java.lang.String[]);</span></span><br><span class="line"><span class="comment"> *      Code:</span></span><br><span class="line"><span class="comment"> *          0: ldc           #2                  // String abc   -&gt;  ldc：从常量池中加载指定项的引用到栈</span></span><br><span class="line"><span class="comment"> *          2: astore_1                                          -&gt;  abstor_1：将引用赋值给第1个局部变量， 即 s1 = "abc"</span></span><br><span class="line"><span class="comment"> *          3: ldc           #3                  // String a</span></span><br><span class="line"><span class="comment"> *          5: astore_2                                          -&gt;  s2 = "a"</span></span><br><span class="line"><span class="comment"> *          6: ldc           #4                  // String bc</span></span><br><span class="line"><span class="comment"> *          8: astore_3                                          -&gt;  s3 = "bc"</span></span><br><span class="line"><span class="comment"> *          9: new           #5                  // class java/lang/StringBuilder    -&gt; 创建StringBuilder对象</span></span><br><span class="line"><span class="comment"> *          12: dup    -&gt;  复制StringBuilder对象的引用并压入栈中</span></span><br><span class="line"><span class="comment"> *          13: invokespecial #6                  // Method java/lang/StringBuilder."&lt;init&gt;":()V    -&gt; 初始化StringBuilder对象</span></span><br><span class="line"><span class="comment"> *          16: aload_2                            -&gt; 加载第二个局部变量的值</span></span><br><span class="line"><span class="comment"> *          17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;  -&gt; 调用常量池中指定项的方法，即调用StringBuilder对象中的append方法，并传入序号 *                                                                                                                                           16中的引用，所以最终是StringBuilder#append(a)</span></span><br><span class="line"><span class="comment"> *          20: aload_3</span></span><br><span class="line"><span class="comment"> *          21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line"><span class="comment"> *          24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;      -&gt; StringBuilder#toString, 可以看下该类的toString方法，生成了一个新的对象，该对象中的字符串不会再*                                                                                                                        常量池中生成</span></span><br><span class="line"><span class="comment"> *          27: astore        4                    -&gt; 将序号24中的引用赋值给第4个局部变量 s4 = StringBuilder.toString = new String()</span></span><br><span class="line"><span class="comment"> *          29: getstatic     #9                  // Field java/lang/System.out:Ljava/io/PrintStream;   -&gt; 下面的就讨论了，执行的是System.out.println代码片段了</span></span><br><span class="line"><span class="comment"> *          32: aload_1</span></span><br><span class="line"><span class="comment"> *          33: aload         4</span></span><br><span class="line"><span class="comment"> *          35: if_acmpne     42</span></span><br><span class="line"><span class="comment"> *          38: iconst_1</span></span><br><span class="line"><span class="comment"> *          39: goto          43</span></span><br><span class="line"><span class="comment"> *          42: iconst_0</span></span><br><span class="line"><span class="comment"> *          43: invokevirtual #10                 // Method java/io/PrintStream.println:(Z)V</span></span><br><span class="line"><span class="comment"> *          46: return</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 从上面的分析中我们得出结论：s1指向常量池中的字符串对象abc，而从序号16-27我们知道生成了新的对象，相当于是执行了new String("abc")，而这不就又回到了示例一了吗，结果自然是false</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        <span class="keyword">final</span> String s2 = <span class="string">"a"</span>;</span><br><span class="line">        <span class="keyword">final</span> String s3 = <span class="string">"bc"</span>;</span><br><span class="line">        String s4 = s2 + s3; <span class="comment">//由于s2、s3被final修饰了，故而直接替换变量的值，最后s4 = "abc"，直接使用了常量池中的字符串对象abc</span></span><br><span class="line">        System.out.println(s1 == s4); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同样贴出代码的执行逻辑：</span></span><br><span class="line"><span class="comment"> *  public static void main(java.lang.String[]);</span></span><br><span class="line"><span class="comment"> *      Code:</span></span><br><span class="line"><span class="comment"> *          0: ldc           #2                  // String abc  -&gt; ldc：从常量池中加载指定项的引用到栈</span></span><br><span class="line"><span class="comment"> *          2: astore_1                                         -&gt; s1 = "abc"</span></span><br><span class="line"><span class="comment"> *          3: ldc           #3                  // String a</span></span><br><span class="line"><span class="comment"> *          5: astore_2                                         -&gt; s2 = "a" </span></span><br><span class="line"><span class="comment"> *          6: ldc           #4                  // String bc</span></span><br><span class="line"><span class="comment"> *          8: astore_3                                         -&gt; s3 = "bc"</span></span><br><span class="line"><span class="comment"> *          9: ldc           #2                  // String abc</span></span><br><span class="line"><span class="comment"> *          11: astore        4                                 -&gt; s4 = "abc"  示例三与示例二的区别在于加了final修饰，被final修饰的变量会在编译阶段直接替换成对应的值，即"a" + "bc"，而这个在示例四中我们也会分析到，是直接采用</span></span><br><span class="line"><span class="comment"> *                                                                             字符串合并，而合并后的字符串abc在常量池中已经存在了，故直接使用</span></span><br><span class="line"><span class="comment"> *          13: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line"><span class="comment"> *          16: aload_1</span></span><br><span class="line"><span class="comment"> *          17: aload         4</span></span><br><span class="line"><span class="comment"> *          19: if_acmpne     26</span></span><br><span class="line"><span class="comment"> *          22: iconst_1</span></span><br><span class="line"><span class="comment"> *          23: goto          27</span></span><br><span class="line"><span class="comment"> *          26: iconst_0</span></span><br><span class="line"><span class="comment"> *          27: invokevirtual #6                  // Method java/io/PrintStream.println:(Z)V</span></span><br><span class="line"><span class="comment"> *          30: return</span></span><br><span class="line"><span class="comment"> * 从上面的分析中我们得出结论：s1指向了常量池中的字符串对象abc，s4也是指向了常量池中的字符串对象abc</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="示例四"><a href="#示例四" class="headerlink" title="示例四"></a>示例四</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        String s2 = <span class="string">"a"</span> + <span class="string">"bc"</span>; <span class="comment">//s1、s2指向同一个字符串</span></span><br><span class="line">        String s3 = <span class="string">"test"</span> + <span class="string">"One"</span>; <span class="comment">//说明常量池是直接存储合并后的字符串</span></span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里多贴出常量池的信息，为了说明s3的行为</span></span><br><span class="line"><span class="comment"> * Constant pool:</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * #30 = Utf8               abc</span></span><br><span class="line"><span class="comment"> * #31 = Utf8               testOne</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * 省略了一部分信息，说明常量池是直接存储合并后的字符串，而并分开存储，所以常量池中只会有"testOne"，并没有"test"或"One"</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  public static void main(java.lang.String[]);</span></span><br><span class="line"><span class="comment"> *       Code:</span></span><br><span class="line"><span class="comment"> *          0: ldc           #2                  // String abc</span></span><br><span class="line"><span class="comment"> *          2: astore_1                            -&gt; s1 = "abc" 指向常量池中#2的引用</span></span><br><span class="line"><span class="comment"> *          3: ldc           #2                  // String abc</span></span><br><span class="line"><span class="comment"> *          5: astore_2                            -&gt; s2 = "abc" 从常量池中#2的引用，可以看到引用的字符串对象是同一个</span></span><br><span class="line"><span class="comment"> *          6: ldc           #3                  // String testOne</span></span><br><span class="line"><span class="comment"> *          8: astore_3</span></span><br><span class="line"><span class="comment"> *          9: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line"><span class="comment"> *          12: aload_1</span></span><br><span class="line"><span class="comment"> *          13: aload_2</span></span><br><span class="line"><span class="comment"> *          14: if_acmpne     21</span></span><br><span class="line"><span class="comment"> *          17: iconst_1</span></span><br><span class="line"><span class="comment"> *          18: goto          22</span></span><br><span class="line"><span class="comment"> *          21: iconst_0</span></span><br><span class="line"><span class="comment"> *          22: invokevirtual #5                  // Method java/io/PrintStream.println:(Z)V</span></span><br><span class="line"><span class="comment"> *          25: return</span></span><br><span class="line"><span class="comment"> * 从上面的分析中我们得出结论：s1、s2指向了常量池中的同一个字符串对象</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="示例五"><a href="#示例五" class="headerlink" title="示例五"></a>示例五</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        String s2 = <span class="string">"a"</span>;</span><br><span class="line">        String s3 = s2 + <span class="string">"bc"</span>; <span class="comment">// StringBuilder.append(a).append(bc) -&gt; StringBuilder.toString() -&gt; new String("abc")</span></span><br><span class="line">        System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * public static void main(java.lang.String[]);</span></span><br><span class="line"><span class="comment"> *       Code:</span></span><br><span class="line"><span class="comment"> *          0: ldc           #2                  // String abc</span></span><br><span class="line"><span class="comment"> *          2: astore_1                             -&gt; s1 = "abc"</span></span><br><span class="line"><span class="comment"> *          3: ldc           #3                  // String a</span></span><br><span class="line"><span class="comment"> *          5: astore_2                             -&gt; s2 = "a"</span></span><br><span class="line"><span class="comment"> *          6: new           #4                  // class java/lang/StringBuilder   -&gt; 创建StringBuilder对象</span></span><br><span class="line"><span class="comment"> *          9: dup           -&gt;  复制StringBuilder对象的引用并压入栈中</span></span><br><span class="line"><span class="comment"> *          10: invokespecial #5                  // Method java/lang/StringBuilder."&lt;init&gt;":()V   -&gt; 初始化StringBuilder</span></span><br><span class="line"><span class="comment"> *          13: aload_2                             -&gt; 加载第二个局部变量的值</span></span><br><span class="line"><span class="comment"> *          14: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;   -&gt; StringBuilder.append("a")</span></span><br><span class="line"><span class="comment"> *          17: ldc           #7                  // String bc</span></span><br><span class="line"><span class="comment"> *          19: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;   -&gt; StringBuilder.append("bc")</span></span><br><span class="line"><span class="comment"> *          22: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;    -&gt; StringBuilder.toString</span></span><br><span class="line"><span class="comment"> *          25: astore_3                           -&gt; s3 = "abc"</span></span><br><span class="line"><span class="comment"> *          26: getstatic     #9                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line"><span class="comment"> *          29: aload_1</span></span><br><span class="line"><span class="comment"> *          30: aload_3</span></span><br><span class="line"><span class="comment"> *          31: if_acmpne     38</span></span><br><span class="line"><span class="comment"> *          34: iconst_1</span></span><br><span class="line"><span class="comment"> *          35: goto          39</span></span><br><span class="line"><span class="comment"> *          38: iconst_0</span></span><br><span class="line"><span class="comment"> *          39: invokevirtual #10                 // Method java/io/PrintStream.println:(Z)V</span></span><br><span class="line"><span class="comment"> *          42: return</span></span><br><span class="line"><span class="comment"> * 从上面的分析中我们得出结论：s1指向常量池中的字符串对象abc，而从序号9-25我们知道生成了新的对象，相当于是执行了new String("abc")，结果自然是false</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="示例六"><a href="#示例六" class="headerlink" title="示例六"></a>示例六</h4><p>先来看下String#intern方法作了什么动作，还是采用此分析方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String testOne = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"bc"</span>); <span class="comment">//常量池中存储字符串a、bc，最终testOne指向堆内存中的对象，而该对象对应的字符串是不会在常量池中存在</span></span><br><span class="line">        String testOneAnother = testOne.intern(); <span class="comment">//先去常量池中查询是否已经存在该字符串，如果存在，则返回常量池中的引用，若不存在则不会将该对象的字符串拷贝到常量池中，而是在常量池中持有对该对象的引用</span></span><br><span class="line">                                                  <span class="comment">//这里的引用没办法从该方式得出，可能需要看下native的方法，反正我是看了别人的分析，虽然我是知道原理但还是忍不住看了以下底层实现</span></span><br><span class="line">        System.out.println(testOne == testOneAnther) <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constant pool:</span></span><br><span class="line"><span class="comment"> *  ...</span></span><br><span class="line"><span class="comment"> * #31 = Utf8               a</span></span><br><span class="line"><span class="comment"> *  ...</span></span><br><span class="line"><span class="comment"> * #34 = Utf8               bc</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="示例七"><a href="#示例七" class="headerlink" title="示例七"></a>示例七</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"bc"</span>);</span><br><span class="line">        s1.intern(); <span class="comment">//执行方法前我们知道常量池中并未有abc字符串，执行该方法后，常量池中已经存在指向s1对象的引用，即"abc"字符串的引用</span></span><br><span class="line">        String s2 = <span class="string">"abc"</span>; <span class="comment">// 常量池中已经存在"abc"字符串的引用，即为s1对象的引用</span></span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * public static void main(java.lang.String[]);</span></span><br><span class="line"><span class="comment"> *      Code:</span></span><br><span class="line"><span class="comment"> *          0: new           #2                  // class java/lang/StringBuilder    -&gt; 创建StringBuilder对象</span></span><br><span class="line"><span class="comment"> *          3: dup                                -&gt; 复制StringBuilder对象的引用并压入栈中</span></span><br><span class="line"><span class="comment"> *          4: invokespecial #3                  // Method java/lang/StringBuilder."&lt;init&gt;":()V  -&gt; 初始化StringBuilder</span></span><br><span class="line"><span class="comment"> *          7: new           #4                  // class java/lang/String    -&gt; 创建字符串对象 new String()</span></span><br><span class="line"><span class="comment"> *          10: dup                               -&gt; 复制String对象的引用并压入栈中</span></span><br><span class="line"><span class="comment"> *          11: ldc           #5                  // String a</span></span><br><span class="line"><span class="comment"> *          13: invokespecial #6                  // Method java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V    -&gt; new String("a")</span></span><br><span class="line"><span class="comment"> *          16: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; -&gt; StringBuilder.append()</span></span><br><span class="line"><span class="comment"> *          19: new           #4                  // class java/lang/String    -&gt;  创建字符串对象 new String()</span></span><br><span class="line"><span class="comment"> *          22: dup                               -&gt; 复制String对象的引用并压入栈中</span></span><br><span class="line"><span class="comment"> *          23: ldc           #8                  // String bc</span></span><br><span class="line"><span class="comment"> *          25: invokespecial #6                  // Method java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V   -&gt; new String("bc")</span></span><br><span class="line"><span class="comment"> *          28: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; -&gt; StringBuilder.append()</span></span><br><span class="line"><span class="comment"> *          31: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;  -&gt; StringBuilder.toString()</span></span><br><span class="line"><span class="comment"> *          34: astore_1                          -&gt; s1 = "abc", 由StringBuilder#toString创建的字符串对象</span></span><br><span class="line"><span class="comment"> *          35: aload_1                           -&gt; 加载第一个局部变量的值</span></span><br><span class="line"><span class="comment"> *          36: invokevirtual #10                 // Method java/lang/String.intern:()Ljava/lang/String;  -&gt; s1.intern()</span></span><br><span class="line"><span class="comment"> *          39: pop                               -&gt; pop：移除栈顶的值</span></span><br><span class="line"><span class="comment"> *          40: ldc           #11                 // String abc</span></span><br><span class="line"><span class="comment"> *          42: astore_2                          -&gt; s2 = "abc"</span></span><br><span class="line"><span class="comment"> *          43: getstatic     #12                 // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line"><span class="comment"> *          46: aload_1</span></span><br><span class="line"><span class="comment"> *          47: aload_2</span></span><br><span class="line"><span class="comment"> *          48: if_acmpne     55</span></span><br><span class="line"><span class="comment"> *          51: iconst_1</span></span><br><span class="line"><span class="comment"> *          52: goto          56</span></span><br><span class="line"><span class="comment"> *          55: iconst_0</span></span><br><span class="line"><span class="comment"> *          56: invokevirtual #13                 // Method java/io/PrintStream.println:(Z)V</span></span><br><span class="line"><span class="comment"> *          59: return</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="示例八"><a href="#示例八" class="headerlink" title="示例八"></a>示例八</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>); <span class="comment">//生成两个对象，堆内存一个，常量池一个</span></span><br><span class="line">        s1.intern(); <span class="comment">//常量池中已经存在该字符串对象，故而直接返回</span></span><br><span class="line">        String s2 = <span class="string">"abc"</span>; <span class="comment">//指向常量池的字符串对象</span></span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//false  -&gt; s1指向堆内存中的对象，s2指向常量池的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>在编译阶段，字符串已经被存储与常量池中</p></li><li><p>new String(“abc”)：一共有两个不同的对象，一个在堆内存、一个在常量池</p></li><li><p>s2 + s3拼接（s2、s3未被final修饰）：底层创建StringBuilder对象，通过append拼接起来，最终调用toString生成一个新的对象</p></li><li><p>“a” + “bc”直接拼接：直接将拼接后的字符串存储于常量池中</p></li><li><p>s2 + “bc”拼接（s2未被final修饰）：底层创建StringBuilder对象，通过append拼接起来，最终调用toString生成一个新的对象</p></li><li><p>s.intern：若常量池中存在字符串，则直接返回引用，若不存在，则在常量池中生成指向该字符串对象的引用，后续若有声明此字符串，会返回指向该字符串对象的引用，也就是同一个引用（参考示例七、八）</p></li></ul><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a><div><span>重点</span></div></h3><p><code>new String与String的区别</code> <code>(s1 + s2)与(&quot;a&quot; + &quot;bc&quot;)的区别</code> <code>intern</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;字符串是最常用的类型之一，趁此机会准备探索下它的源码。有关该类的注释作一个总结：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;String-字符串，是个常量，它们被创建后&lt;code&gt;其值&lt;/code&gt;就不允许被改变，由于它是不可变的，所以它们可以被共享，在内部提供了多个方法来操作字符串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;探索之前我曾看过其他人写的有关于此的文章，发现&lt;code&gt;JDK1.7版本前后的内存模型&lt;/code&gt;不一样，而这部分的内容还没有排上行程，简单来说，我还不懂…所以不敢妄下结论，这篇文章的内容也不会从这方面展开来讲，此次探索是基于&lt;code&gt;JDK1.8&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Comparable VS Comparator</title>
    <link href="http://zlia.tech/2019/11/06/comparable-comparator-compare/"/>
    <id>http://zlia.tech/2019/11/06/comparable-comparator-compare/</id>
    <published>2019-11-06T10:45:42.000Z</published>
    <updated>2019-11-06T10:45:42.075Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>在阅读TreeMap源码时发现了Comparable与Comparator，光是名字看起来就很像，既然都是比较器，那有何区别呢？实际上我对于比较器的使用场景并不是很多，所以这篇还是借鉴了别人的想法。</p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a><div><span>比较</span></div></h3><p>通过下面的这段代码来说明问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Apple appleOne = <span class="keyword">new</span> Apple(<span class="number">1</span>, <span class="string">"red"</span>);</span><br><span class="line">        Apple appleTwo = <span class="keyword">new</span> Apple(<span class="number">2</span>, <span class="string">"green"</span>);</span><br><span class="line">        appleOne.compareTo(appleTwo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Apple</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    Apple(<span class="keyword">int</span> size, String color)&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Apple o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size &gt; o.size ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">//比较Apple的大小</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getter、setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>代码上挺简单的，只是比较了Apple的大小，现在来思考一下，哪一天突然想比较Apple的颜色了，那岂不是要改代码了，而对于新需求我们通常说现有代码尽量保持不变，通过新增类的方式来满足，所以Comparable的缺点很明显，一旦某个类指定了比较方式后就无法做修改（除非是修改代码…），即使能修改代码我们也不知道会不会造成新的问题或新的需求产生，所以这是行不通的。而对于Comparator来说，它就显得更加灵活了，支持多个比较器，只要新增类即可，看如下的代码展示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Apple appleOne = <span class="keyword">new</span> Apple(<span class="number">1</span>, <span class="string">"red"</span>);</span><br><span class="line">        Apple appleTwo = <span class="keyword">new</span> Apple(<span class="number">2</span>, <span class="string">"green"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较Apple的大小</span></span><br><span class="line">        AppleCompareSize acs = <span class="keyword">new</span> AppleCompareSize();</span><br><span class="line">        acs.compare(appleOne, appleTwo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较Apple的颜色</span></span><br><span class="line">        AppleCompareColor acc = <span class="keyword">new</span> AppleCompareColor();</span><br><span class="line">        acc.compare(appleOne, appleTwo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    Apple(<span class="keyword">int</span> size, String color) &#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getter、setter</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleCompareSize</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Apple</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Apple o1, Apple o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getSize() &gt; o2.getSize() ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleCompareColor</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Apple</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Apple o1, Apple o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getColor().compareTo(o2.getColor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该很容易就能看出效果了，即使别人已经写好了一个比较器，对于新需求，我们只要增加即可，并不会出现修改或污染其他人代码的情况。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><div><span>总结</span></div></h3><p>Comparator与Comaparable的最大区别在于<code>Comparator能够定义多种不同的比较策略</code>，即新增多个比较来，同时避免往比较对象（Apple）中添加其他代码（比较）</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;在阅读TreeMap源码时发现了Comparable与Comparator，光是名字看起来就很像，既然都是比较器，那有何区别呢？实际上我对于比较器的使用场景并不是很多，所以这篇还是借鉴了别人的想法。&lt;/p&gt;
&lt;h3 id=&quot;比较&quot;&gt;&lt;a href=&quot;#比较&quot; class=&quot;headerlink&quot; title=&quot;比较&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;比较&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;通过下面的这段代码来说明问题。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Apple appleOne = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Apple(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Apple appleTwo = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Apple(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        appleOne.compareTo(appleTwo);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Apple&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Comparable&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;Apple&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String color;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Apple(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; size, String color)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.size = size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.color = color;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;compareTo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Apple o)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; size &amp;gt; o.size ? &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; : &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//比较Apple的大小&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//getter、setter&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索LinkedHashSet底层实现</title>
    <link href="http://zlia.tech/2019/11/06/explain-linkedhashset-sourcecode/"/>
    <id>http://zlia.tech/2019/11/06/explain-linkedhashset-sourcecode/</id>
    <published>2019-11-06T06:24:42.000Z</published>
    <updated>2019-11-06T06:24:42.323Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>额… 底层实现了LinkedHashMap，它的数据结构是<code>数组 + 链表 + 红黑树</code>，内部通过一条<code>链表</code>来维护<code>有序性</code>，按照插入顺序进行排列。代码只有100行…</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定初始容量与加载因子来初始化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loadFactor 指定加载因子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定初始容量来初始化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">16</span>, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定集合来初始化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Math.max(<span class="number">2</span>*c.size(), <span class="number">11</span>), .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>LinkedHashSet底层基于LinkedHashMap</p></li><li><p>LinkedHashSet有序、不可重复、非线程安全</p></li><li><p>LinkedHashSet允许空元素</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>基于LinkedHashMap</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;额… 底层实现了LinkedHashMap，它的数据结构是&lt;code&gt;数组 + 链表 + 红黑树&lt;/code&gt;，内部通过一条&lt;code&gt;链表&lt;/code&gt;来维护&lt;code&gt;有序性&lt;/code&gt;，按照插入顺序进行排列。代码只有100行…&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索TreeSet底层实现</title>
    <link href="http://zlia.tech/2019/11/06/explain-treeset-sourcecode/"/>
    <id>http://zlia.tech/2019/11/06/explain-treeset-sourcecode/</id>
    <published>2019-11-06T03:20:51.000Z</published>
    <updated>2019-11-06T03:20:51.091Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>TreeSet的内部实现基于TreeMap，所以它的数据结构是<code>红黑树</code>。注释也不总结了，此探索是基于<code>JDK1.8</code>，直接进入正题。</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//存储元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//既然用了TreeMap就要考虑值应该存什么，就是它了，不管新增的元素是什么，它都作为值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定NavigableMap实现类来初始化</span></span><br><span class="line"><span class="comment"> * ConcurrentSkipListMap是NavigableMap的实现类！！！埋下伏笔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class="line">    <span class="keyword">this</span>.m = m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定比较器进行初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> comparator 比较器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;&gt;(comparator));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定集合进行初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定Set集合进行初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s Set集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(SortedSet&lt;E&gt; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(s.comparator());</span><br><span class="line">    addAll(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.navigableKeySet().iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取按降序排列的迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 降序排列的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.descendingKeySet().iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取按降序排列的Set集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 降序排列的Set集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">descendingSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeSet&lt;&gt;(m.descendingMap());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TreeSet集合的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TreeSet集合是否为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TreeSet是否包含指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.containsKey(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否新增成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量添加指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Use linear-time version if applicable</span></span><br><span class="line">    <span class="keyword">if</span> (m.size()==<span class="number">0</span> &amp;&amp; c.size() &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        c <span class="keyword">instanceof</span> SortedSet &amp;&amp;</span><br><span class="line">        m <span class="keyword">instanceof</span> TreeMap) &#123;</span><br><span class="line">        SortedSet&lt;? extends E&gt; set = (SortedSet&lt;? extends E&gt;) c;</span><br><span class="line">        TreeMap&lt;E,Object&gt; map = (TreeMap&lt;E, Object&gt;) m;</span><br><span class="line">        Comparator&lt;?&gt; cc = set.comparator();</span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> E&gt; mc = map.comparator();</span><br><span class="line">        <span class="keyword">if</span> (cc==mc || (cc != <span class="keyword">null</span> &amp;&amp; cc.equals(mc))) &#123;</span><br><span class="line">            map.addAllForTreeSet(set, PRESENT); <span class="comment">//指定集合来添加一颗红黑树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定起始元素与结束元素及是否包含起始、结束元素来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * 当前对象是已经排好序了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromElement 起始元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromInclusive 子集中是否包含起始元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toElement 结束元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toInclusive 子集中是否包含结束元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, <span class="keyword">boolean</span> fromInclusive, E toElement,   <span class="keyword">boolean</span> toInclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeSet&lt;&gt;(m.subMap(fromElement, fromInclusive, toElement, toInclusive));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定结束元素及是否包含结束元素来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * 当前对象是已经排好序了，相当于起始元素已经指定好了</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toElement 结束元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inclusive 子集中是否包含结束元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement, <span class="keyword">boolean</span> inclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeSet&lt;&gt;(m.headMap(toElement, inclusive));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定起始元素及是否包含起始元素来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * 相当于介绍元素已经指定好了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromElement 起始元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inclusive 子集中是否包含起始元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement, <span class="keyword">boolean</span> inclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeSet&lt;&gt;(m.tailMap(fromElement, inclusive));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定起始元素与结束元素来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * 包含起始元素、不包含结束元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromElement 起始元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toElement 结束元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SortedSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, E toElement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> subSet(fromElement, <span class="keyword">true</span>, toElement, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取比较器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 比较器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator() &#123;</span><br><span class="line">    <span class="keyword">return</span> m.comparator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取排序后的第一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 排序后的第一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.firstKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取排序后的最后一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 排序后的最后一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">last</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.lastKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取小于指定元素的最大值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 小于指定元素的最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">lower</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.lowerKey(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取等于或小于指定元素的最大值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 等于或小于指定元素的最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">floor</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.floorKey(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取等于或大于指定元素的最小值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 等于或大于指定元素的最小值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">ceiling</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.ceilingKey(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取大于指定元素的最小值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 大于指定元素的最小值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">higher</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.higherKey(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取排序后的第一个元素并移除</span></span><br><span class="line"><span class="comment"> * 获取最左边的元素并移除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最左边的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map.Entry&lt;E,?&gt; e = m.pollFirstEntry();</span><br><span class="line">    <span class="keyword">return</span> (e == <span class="keyword">null</span>) ? <span class="keyword">null</span> : e.getKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取排序后的最后一个元素并移除</span></span><br><span class="line"><span class="comment"> * 获取最右边的元素并移除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最右边的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map.Entry&lt;E,?&gt; e = m.pollLastEntry();</span><br><span class="line">    <span class="keyword">return</span> (e == <span class="keyword">null</span>) ? <span class="keyword">null</span> : e.getKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>TreeSet底层是TreeMa，所以它的数据结构是红黑树</p></li><li><p>TreeSet有序、不可重复、非线程安全</p></li><li><p>TreeSet默认按照自然顺序排列元素，可指定比较器来自定义排序</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>基于TreeMap</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;TreeSet的内部实现基于TreeMap，所以它的数据结构是&lt;code&gt;红黑树&lt;/code&gt;。注释也不总结了，此探索是基于&lt;code&gt;JDK1.8&lt;/code&gt;，直接进入正题。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索HashSet底层实现</title>
    <link href="http://zlia.tech/2019/11/05/explain-hashset-sourcecode/"/>
    <id>http://zlia.tech/2019/11/05/explain-hashset-sourcecode/</id>
    <published>2019-11-05T12:59:05.000Z</published>
    <updated>2019-11-05T12:59:05.138Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>HashSet的底层实现依赖于HashMap，所以它的数据结构也是<code>数组 + 链表 + 红黑树</code>，而对于它的类注释也没什么好总结的，探索HashSet底层实现是基于<code>JDK1.8</code>。仔细一想，HashSet存在的意义是什么？有时候需要添加元素时，也就是只有单个对象，并没有所谓的键值对，或许还有些用处，可这ArrayList也能做到啊！可是相比之下，HashSet由于有HashMap撑腰，它的性能要高于ArrayList，所以我认为HashSet是List和Map独有的特性结合后的产物。</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//可序列化、可克隆</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接使用了HashMap来存储它的元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//既然用了HashMap就要考虑值应该存什么，就是它了，不管新增的元素是什么，它都作为值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定集合来初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量与加载因子来初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor 指定加载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量来初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量与加载因子来初始化</span></span><br><span class="line"><span class="comment"> * 对比上面这里构造了LinkedHashMap，说明它是有序的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor 指定加载因子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dummy 无实际意义，为了与上面的构造函数区分开来</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取元素个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashSet是否为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashSet是否包含指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否新增成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 浅克隆</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        newSet.map = (HashMap&lt;E, Object&gt;) map.clone();</span><br><span class="line">        <span class="keyword">return</span> newSet;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>HashSet无序、不可重复、非线程安全</p></li><li><p>HashSet允许存放空元素</p></li><li><p>HashSet底层基于HashMap</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>基于HashMap</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;HashSet的底层实现依赖于HashMap，所以它的数据结构也是&lt;code&gt;数组 + 链表 + 红黑树&lt;/code&gt;，而对于它的类注释也没什么好总结的，探索HashSet底层实现是基于&lt;code&gt;JDK1.8&lt;/code&gt;。仔细一想，HashSet存在的意义是什么？有时候需要添加元素时，也就是只有单个对象，并没有所谓的键值对，或许还有些用处，可这ArrayList也能做到啊！可是相比之下，HashSet由于有HashMap撑腰，它的性能要高于ArrayList，所以我认为HashSet是List和Map独有的特性结合后的产物。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>比较Map实现类的不同点</title>
    <link href="http://zlia.tech/2019/11/05/map-different-compare/"/>
    <id>http://zlia.tech/2019/11/05/map-different-compare/</id>
    <published>2019-11-05T08:22:02.000Z</published>
    <updated>2019-11-05T13:10:22.159Z</updated>
    
    <content type="html"><![CDATA[<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a><div><span>比较</span></div></h3><p>趁热打铁！比较最近学习到的几个Map实现类，也正好总结下！此比较是基于<code>JDK1.8</code>，直接用表格展示。</p><table><thead><tr><th style="text-align:center">比较点</th><th style="text-align:center">HashMap</th><th style="text-align:center">Hashtable</th><th style="text-align:center">IdentityHashMap</th><th style="text-align:center">LinkedHashMap</th><th style="text-align:center">TreeMap</th><th style="text-align:center">WeakHashMap</th></tr></thead><tbody><tr><td style="text-align:center">数据结构</td><td style="text-align:center">数组<br>链表<br>红黑树</td><td style="text-align:center">数组<br>链表</td><td style="text-align:center">数组<br>（哈希探针表）</td><td style="text-align:center">数组<br>链表<br>红黑树</td><td style="text-align:center">红黑树</td><td style="text-align:center">数组<br>链表</td></tr><tr><td style="text-align:center">是否有序/可重复</td><td style="text-align:center">无序不可重复</td><td style="text-align:center">无序不可重复</td><td style="text-align:center">无序不可重复</td><td style="text-align:center">默认按插入顺序排列<br>可按访问顺序排列<br>不可重复</td><td style="text-align:center">默认按自然顺序<br>可指定比较器进行自定义排序<br>不可重复</td><td style="text-align:center">无序不可重复</td></tr><tr><td style="text-align:center">键值对为null</td><td style="text-align:center">允许</td><td style="text-align:center">不允许</td><td style="text-align:center">允许</td><td style="text-align:center">允许</td><td style="text-align:center">默认排序中键不允许，值允许<br>自定义排序中键值对都允许</td><td style="text-align:center">允许</td></tr><tr><td style="text-align:center">默认初始容量</td><td style="text-align:center">16</td><td style="text-align:center">11</td><td style="text-align:center">64</td><td style="text-align:center">16</td><td style="text-align:center"></td><td style="text-align:center">16</td></tr><tr><td style="text-align:center">默认加载因子</td><td style="text-align:center">0.75</td><td style="text-align:center">0.75</td><td style="text-align:center">1/3</td><td style="text-align:center">0.75</td><td style="text-align:center"></td><td style="text-align:center">0.75</td></tr><tr><td style="text-align:center">扩容策略</td><td style="text-align:center">2 * capacity</td><td style="text-align:center">2 * capacity + 1</td><td style="text-align:center">2 * capacity</td><td style="text-align:center">2 * capacity</td><td style="text-align:center"></td><td style="text-align:center">2 * capacity</td></tr><tr><td style="text-align:center">计算hash方式</td><td style="text-align:center">hash ^ (hash &gt;&gt;&gt; 16)</td><td style="text-align:center">hash &amp; 0x7FFFFFFF</td><td style="text-align:center">(hash &lt;&lt; 1) - (hash &lt;&lt; 8)</td><td style="text-align:center">hash ^ (hash &gt;&gt;&gt; 16)</td><td style="text-align:center"></td><td style="text-align:center">有点复杂，就不贴了</td></tr><tr><td style="text-align:center">计算索引</td><td style="text-align:center">hash &amp; (capacity - 1)</td><td style="text-align:center">hash % capacity</td><td style="text-align:center">hash &amp; (capacity - 1)</td><td style="text-align:center">hash &amp; (capacity - 1)</td><td style="text-align:center"></td><td style="text-align:center">hash &amp; (capacity - 1)</td></tr><tr><td style="text-align:center">新增节点</td><td style="text-align:center">尾插法</td><td style="text-align:center">头插法</td><td style="text-align:center"></td><td style="text-align:center">尾插法</td><td style="text-align:center"></td><td style="text-align:center">头插法</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;比较&quot;&gt;&lt;a href=&quot;#比较&quot; class=&quot;headerlink&quot; title=&quot;比较&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;比较&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;趁热打铁！比较最近学习到的几个Map实现类，也正好总结下！此比较是基于&lt;code&gt;JDK1.
      
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索EnumMap底层实现</title>
    <link href="http://zlia.tech/2019/11/05/explain-enummap-sourcecode/"/>
    <id>http://zlia.tech/2019/11/05/explain-enummap-sourcecode/</id>
    <published>2019-11-05T08:17:02.000Z</published>
    <updated>2019-11-05T09:28:40.140Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>EnumMap初次见面，请多多关照！对于该类的注释直接上总结：</p><blockquote><p>专门用于<code>枚举类型</code>的键的Map实现。EnumMap内部的数据结构是数组，按枚举常量的声明顺序排列它的键，与其他Map实现类不同的是，它的迭代器并不会抛出快速失败错误！</p></blockquote><p>该类的代码不到1000行，速速解决掉，探索EnumMap底层实现是基于<code>JDK1.8</code>。</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumMap</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">K</span>&gt;, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 枚举类型的类类型</span></span><br><span class="line"><span class="comment">     * 为什么需要类类型呢? </span></span><br><span class="line"><span class="comment">     * 因为在一开始初始化时，EnumMap就会将枚举类的所有对象加载到数组中，所以每次添加节点时，实际上只是添加了值对象而已</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;K&gt; keyType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 包含枚举类的所有对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> K[] keyUniverse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储值对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Object[] vals;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点个数</span></span><br><span class="line"><span class="comment">     * vals数组中存储的值对象个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存entrySet方法的返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化键数组与值数组</span></span><br><span class="line"><span class="comment"> * 这个就是上面我们所说将枚举类型的所有对象存储到键数组中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keyType 枚举类型的类类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EnumMap</span><span class="params">(Class&lt;K&gt; keyType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.keyType = keyType;</span><br><span class="line">    keyUniverse = getKeyUniverse(keyType);<span class="comment">//该方法会将枚举类的所有对象按照声明的顺序存放</span></span><br><span class="line">    vals = <span class="keyword">new</span> Object[keyUniverse.length];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定EnumMap来初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m EnumMap对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EnumMap</span><span class="params">(EnumMap&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    keyType = m.keyType;</span><br><span class="line">    keyUniverse = m.keyUniverse;</span><br><span class="line">    vals = m.vals.clone();</span><br><span class="line">    size = m.size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定集合来初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EnumMap</span><span class="params">(Map&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m <span class="keyword">instanceof</span> EnumMap) &#123;</span><br><span class="line">        EnumMap&lt;K, ? extends V&gt; em = (EnumMap&lt;K, ? extends V&gt;) m;</span><br><span class="line">        keyType = em.keyType;</span><br><span class="line">        keyUniverse = em.keyUniverse;</span><br><span class="line">        vals = em.vals.clone();</span><br><span class="line">        size = em.size;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (m.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Specified map is empty"</span>);</span><br><span class="line">        keyType = m.keySet().iterator().next().getDeclaringClass();</span><br><span class="line">        keyUniverse = getKeyUniverse(keyType);</span><br><span class="line">        vals = <span class="keyword">new</span> Object[keyUniverse.length];</span><br><span class="line">        putAll(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 倘若值为null则采用NULL_KEY作为值</span></span><br><span class="line"><span class="comment"> * 正如方法名一样，隐藏Null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> NULL_KEY或指定值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">maskNull</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (value == <span class="keyword">null</span> ? NULL : value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 倘若值为NULL_KEY则返回null</span></span><br><span class="line"><span class="comment"> * 正如方法名一样，揭露Null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或指定值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">unmaskNull</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (V)(value == NULL ? <span class="keyword">null</span> : value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取节点个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 节点个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组中是否包含指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    value = maskNull(value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object val : vals)</span><br><span class="line">        <span class="keyword">if</span> (value.equals(val))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组中是否包含指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isValidKey(key) &amp;&amp; vals[((Enum&lt;?&gt;)key).ordinal()] != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键是否有效</span></span><br><span class="line"><span class="comment"> * 是否符合指定的类类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否有效</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; keyClass = key.getClass();</span><br><span class="line">    <span class="keyword">return</span> keyClass == keyType || keyClass.getSuperclass() == keyType; <span class="comment">//keyClass.getSuperclass这个判断语句没有什么意义，枚举类既不能继承其他类，也不能被继承，两个类就无法发生关系，那这个判断结果只会是false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组中是否包含指定键值对</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含键值对</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">containsMapping</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isValidKey(key) &amp;&amp; maskNull(value).equals(vals[((Enum&lt;?&gt;)key).ordinal()]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键获取值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (isValidKey(key) ? unmaskNull(vals[((Enum&lt;?&gt;)key).ordinal()]) : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增键值对</span></span><br><span class="line"><span class="comment"> * 可能会发生替换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    typeCheck(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = key.ordinal();</span><br><span class="line">    Object oldValue = vals[index];</span><br><span class="line">    vals[index] = maskNull(value);</span><br><span class="line">    <span class="keyword">if</span> (oldValue == <span class="keyword">null</span>)</span><br><span class="line">        size++;</span><br><span class="line">    <span class="keyword">return</span> unmaskNull(oldValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键移除值对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isValidKey(key))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> index = ((Enum&lt;?&gt;)key).ordinal();</span><br><span class="line">    Object oldValue = vals[index];</span><br><span class="line">    vals[index] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldValue != <span class="keyword">null</span>)</span><br><span class="line">        size--;</span><br><span class="line">    <span class="keyword">return</span> unmaskNull(oldValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键值对移除值对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除值对象成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">removeMapping</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isValidKey(key))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> index = ((Enum&lt;?&gt;)key).ordinal();</span><br><span class="line">    <span class="keyword">if</span> (maskNull(value).equals(vals[index])) &#123;</span><br><span class="line">        vals[index] = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量添加集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123; <span class="comment">//枚举类之间无法继承，所以这里压根就只能指定K、V</span></span><br><span class="line">    <span class="keyword">if</span> (m <span class="keyword">instanceof</span> EnumMap) &#123;</span><br><span class="line">        EnumMap&lt;?, ?&gt; em = (EnumMap&lt;?, ?&gt;)m;</span><br><span class="line">        <span class="keyword">if</span> (em.keyType != keyType) &#123;</span><br><span class="line">            <span class="keyword">if</span> (em.isEmpty())</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException(em.keyType + <span class="string">" != "</span> + keyType);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; keyUniverse.length; i++) &#123;</span><br><span class="line">            Object emValue = em.vals[i];</span><br><span class="line">            <span class="keyword">if</span> (emValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vals[i] == <span class="keyword">null</span>)</span><br><span class="line">                    size++;</span><br><span class="line">                vals[i] = emValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.putAll(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中间省略了相关迭代器...较为简单相似，有兴趣的读者可自行查看</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空值数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Arrays.fill(vals, <span class="keyword">null</span>);</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取枚举类中所有对象的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keyType 枚举类类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有对象的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;K extends Enum&lt;K&gt;&gt; K[] getKeyUniverse(Class&lt;K&gt; keyType) &#123;</span><br><span class="line">    <span class="keyword">return</span> SharedSecrets.getJavaLangAccess().getEnumConstantsShared(keyType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>专门用于其键为<code>枚举类型</code>的Map实现</p></li><li><p>EnumMap的数据结构是数组，按枚举常量的声明顺序进行排列</p></li><li><p>EnumMap的键不允许为空，值允许为空</p></li><li><p>EnumMap的迭代器不会发生快速失败</p></li><li><p>EnumMap有序、不可重复、非线程安全</p></li><li><p>EnumMap在初始化时将枚举类中的所有对象存储到数组中，而后续的增删改查实际上都是对其值对象的操作</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>内部实现机制</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;EnumMap初次见面，请多多关照！对于该类的注释直接上总结：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;专门用于&lt;code&gt;枚举类型&lt;/code&gt;的键的Map实现。EnumMap内部的数据结构是数组，按枚举常量的声明顺序排列它的键，与其他Map实现类不同的是，它的迭代器并不会抛出快速失败错误！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该类的代码不到1000行，速速解决掉，探索EnumMap底层实现是基于&lt;code&gt;JDK1.8&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索WeakHashMap底层实现</title>
    <link href="http://zlia.tech/2019/11/04/explain-weakhashmap-sourcecode/"/>
    <id>http://zlia.tech/2019/11/04/explain-weakhashmap-sourcecode/</id>
    <published>2019-11-04T10:00:55.000Z</published>
    <updated>2019-11-05T06:34:25.218Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>探索<code>WeakHashMap</code>底层实现是基于<code>JDK1.8</code>，它的数据结构是<code>数组 + 链表</code>。就不贴它的注释了，直接总结一下吧：</p><blockquote><p>WeakHashMap基于<code>弱键</code>实现了Map接口，也就是说，当某个键不在使用时会被丢弃，对应的键值对将会被自动移除。如何确定不在使用取决于GC是否运行，而对于GC何时运行我们并不知道，所以某个键何时被丢弃我们也不得而知，至于GC如何运行就是另外一个话题了，有可能导致上一分钟与下一分钟获取到的结果是不一致的。另一个方面，WeakHashMap的值对象由强引用所持有（何为强引用下面会介绍），应确保值对象不会直接或间接引用自身的键或其他键，这会导致键无法被丢弃。</p></blockquote><ul><li><p>强引用：简单来说指向new出来的对象就是一个强引用，可以说是经常使用。对于强引用来说，它们不会被GC回收，即使内存空间不足，JVM宁愿抛出内存溢出错误也不敢动它们，总体来说还是很有威信的。</p></li><li><p>软引用：首先给强引用包裹上一层<code>SoftReference</code>，通过SoftReference获取到的引用即为软引用。对于软引用来说，在内存充足的情况下，GC可以选择性的清除，而一旦内存不足了，它们一个都跑不了，都会被清除掉。软引用最常用用于实现对内存敏感的缓存。</p></li><li><p>弱引用：首先给强引用包裹上一层<code>WeakReference</code>，通过WeakReference获取到的引用即为弱引用，看到这里你应该就已经明白了WeakHashMap内部的机制。对于弱引用来说，GC压根就不管内存是否充足，直接回收，很没有人性！</p></li><li><p>虚引用：首先给强引用包裹上一层<code>PhantomReference</code>，通过PhantomReference获取到的引用即为虚引用。对于虚引用来说，它在任何时候都可能被回收，常用于跟踪对象。</p></li></ul><p>还有一个方面，读者最好去了解下<code>Reference</code>类，内部通过队列实现了一些机制。</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><p>前奏都准备好了，开始进入正题吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始容量，必须是2的幂次方，可参考HashMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大容量，必须是2的幂次方</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认加载因子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希表，长度必须是2的幂次方</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Entry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希表中包含节点的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩容前需要判断的阈值</span></span><br><span class="line"><span class="comment">     * 若超过该值则扩容，若没超过则不需要</span></span><br><span class="line"><span class="comment">     * 该值的计算方式：capacity * load factor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载因子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用队列</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 为什么需要引用队列呢?</span></span><br><span class="line"><span class="comment">     * 通过上面的介绍我们可以知道哈希表中某些键可能会被移除掉，而移除是GC帮我们做的，那WeakHashMap怎么知道哪些键被移除掉了以便更新自己的键值对，就是该队列做了它们两个之间的媒介</span></span><br><span class="line"><span class="comment">     * 上面让读者去了解Reference类，下面讲的内容其实都在该类中有提到，比较简单</span></span><br><span class="line"><span class="comment">     * GC在丢弃某个键时会将它的键值对，也就是节点信息存放到Reference类中的pending队列中，Reference类在初始化时会启动一个线程，那么该线程会将pending队列中的节点信息放入到queue队列中</span></span><br><span class="line"><span class="comment">     * 也就是在告诉WeakHashMap，队列中的这些节点是我要删除的，你记得更新</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存entrySet方法的返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结构修改的次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> modCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量与加载因子构造哈希表</span></span><br><span class="line"><span class="comment"> * 在上面中我们提到了容量必须是2的幂次方，所以调用tableSizeFor方法来进行调整</span></span><br><span class="line"><span class="comment"> * Float.isNaN：检测是否是数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor 指定加载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeakHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Initial Capacity: "</span>+ initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Load factor: "</span>+ loadFactor);</span><br><span class="line">    <span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (capacity &lt; initialCapacity) <span class="comment">//这段代码有点精髓啊，个人感觉比HashMap中的算法简单，两者要表达的意思是一致的，都是获取大于initialCapacity的最小值</span></span><br><span class="line">        capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    table = newTable(capacity);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(capacity * loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量与默认加载因子（0.75）构造哈希表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeakHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始容量（16）与默认加载因子（0.75）构造哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeakHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定集合添加到哈希表中，采用默认加载因子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeakHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);<span class="comment">//Math.max是为了获取尽可能大的容量</span></span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定长度构造哈希表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 指定长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">private</span> Entry&lt;K,V&gt;[] newTable(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">return</span> (Entry&lt;K,V&gt;[]) <span class="keyword">new</span> Entry&lt;?,?&gt;[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 倘若键为null则采用NULL_KEY作为键</span></span><br><span class="line"><span class="comment"> * 正如方法名一样，隐藏Null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> NULL_KEY或指定键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">maskNull</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? NULL_KEY : key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 倘若键为NULL_KEY则返回null</span></span><br><span class="line"><span class="comment"> * 正如方法名一样，揭露Null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 哈希表中的键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或指定键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">unmaskNull</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (key == NULL_KEY) ? <span class="keyword">null</span> : key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 两个对象是否相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> y 另外一个对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否相等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">eq</span><span class="params">(Object x, Object y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == y || x.equals(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算哈希值</span></span><br><span class="line"><span class="comment"> * 这边的计算哈希值比HashMap复杂多了，涉及到算法的内容我感觉我没办法理解到位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = k.hashCode();</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算哈希表中的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h 哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length 哈希表的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清除哈希表中过时的节点信息</span></span><br><span class="line"><span class="comment"> * 过时指的是已经被丢弃的键，也可以说是被GC回收的键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object x; (x = queue.poll()) != <span class="keyword">null</span>; ) &#123;<span class="comment">//poll：队列中获取首部节点并删除</span></span><br><span class="line">        <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, table.length);</span><br><span class="line"></span><br><span class="line">            Entry&lt;K,V&gt; prev = table[i]; <span class="comment">//代表当前节点的上一个节点</span></span><br><span class="line">            Entry&lt;K,V&gt; p = prev;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (prev == e) <span class="comment">//说明当前节点是链表的首部节点</span></span><br><span class="line">                        table[i] = next;</span><br><span class="line">                    <span class="keyword">else</span> <span class="comment">//说明当前节点不是首部节点</span></span><br><span class="line">                        prev.next = next;</span><br><span class="line">                    <span class="comment">// Must not null out e.next;</span></span><br><span class="line">                    <span class="comment">// stale entries may be in use by a HashIterator</span></span><br><span class="line">                    e.value = <span class="keyword">null</span>; <span class="comment">// Help GC</span></span><br><span class="line">                    size--;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取哈希表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Entry&lt;K,V&gt;[] getTable() &#123;</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取哈希表的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希表的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表是否为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希表是否为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键获取指</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    <span class="keyword">int</span> h = hash(k);</span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    <span class="keyword">int</span> index = indexFor(h, tab.length);</span><br><span class="line">    Entry&lt;K,V&gt; e = tab[index];</span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == h &amp;&amp; eq(k, e.get()))</span><br><span class="line">            <span class="keyword">return</span> e.value;</span><br><span class="line">        e = e.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否包含指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getEntry(key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键获取节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    <span class="keyword">int</span> h = hash(k);</span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    <span class="keyword">int</span> index = indexFor(h, tab.length);</span><br><span class="line">    Entry&lt;K,V&gt; e = tab[index];</span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span> &amp;&amp; !(e.hash == h &amp;&amp; eq(k, e.get())))</span><br><span class="line">        e = e.next;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增节点</span></span><br><span class="line"><span class="comment"> * 链表中采用头插法的方式进行新增节点</span></span><br><span class="line"><span class="comment"> * 若超过阈值则会进行扩容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    <span class="keyword">int</span> h = hash(k);</span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(h, tab.length); <span class="comment">//获取索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123; <span class="comment">//链表中判断是否重复</span></span><br><span class="line">        <span class="keyword">if</span> (h == e.hash &amp;&amp; eq(k, e.get())) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (value != oldValue)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    Entry&lt;K,V&gt; e = tab[i];</span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry&lt;&gt;(k, value, queue, h, e);</span><br><span class="line">    <span class="keyword">if</span> (++size &gt;= threshold)</span><br><span class="line">        resize(tab.length * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt;[] oldTable = getTable();</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry&lt;K,V&gt;[] newTable = newTable(newCapacity);</span><br><span class="line">    transfer(oldTable, newTable); <span class="comment">//将源哈希表中的所有节点信息复制到目标哈希表中</span></span><br><span class="line">    table = newTable;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果忽略null元素并处理队列导致大量收缩，则还原旧表。 这应该很少见，但是可以避免持有大量无用节点的哈希表的无限扩展。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold / <span class="number">2</span>) &#123;</span><br><span class="line">        threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//GC回收了大量的节点后则不进行扩容</span></span><br><span class="line">        expungeStaleEntries(); <span class="comment">//检测新表中哪些节点已经被丢弃了</span></span><br><span class="line">        transfer(newTable, oldTable);</span><br><span class="line">        table = oldTable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将源哈希表中的所有节点信息复制到目标哈希表中</span></span><br><span class="line"><span class="comment"> * 源哈希表中可能出现被丢弃的键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src 源哈希表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dest 目标哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry&lt;K,V&gt;[] src, Entry&lt;K,V&gt;[] dest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; ++j) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        src[j] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            Object key = e.get(); <span class="comment">//若当前节点已经被GC回收了，则此方法返回将返回null</span></span><br><span class="line">            <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.next = <span class="keyword">null</span>;  <span class="comment">// Help GC</span></span><br><span class="line">                e.value = <span class="keyword">null</span>; <span class="comment">//  "   "</span></span><br><span class="line">                size--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, dest.length); <span class="comment">//该索引出现的可能应该跟HashMap是一样的，原索引或与原索引 + 旧容量的大小，只不过它是一个一个的计算并添加，而HashMap是分批计算，一次性添加</span></span><br><span class="line">                e.next = dest[i];</span><br><span class="line">                dest[i] = e;</span><br><span class="line">            &#125;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量添加节点到哈希表中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numKeysToBeAdded = m.size();</span><br><span class="line">    <span class="keyword">if</span> (numKeysToBeAdded == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 倘若指定集合的键值对数量超过阈值则进行扩容. 这是保守的；</span></span><br><span class="line"><span class="comment">      * 很明显的条件应该是 (m.size + size) &gt;= threshold， 但是这个条件会导致适当的容量变成2倍，如果被添加的键已经存在于哈希表中.</span></span><br><span class="line"><span class="comment">      * 通过使用保守的计算，我们最多只能调整一种尺寸。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">if</span> (numKeysToBeAdded &gt; threshold) &#123;</span><br><span class="line">        <span class="keyword">int</span> targetCapacity = (<span class="keyword">int</span>)(numKeysToBeAdded / loadFactor + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (targetCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            targetCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = table.length;</span><br><span class="line">        <span class="keyword">while</span> (newCapacity &lt; targetCapacity)</span><br><span class="line">            newCapacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity &gt; table.length) <span class="comment">//预先计算好要添加节点的数量以便进行一次性扩容</span></span><br><span class="line">            resize(newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</span><br><span class="line">        put(e.getKey(), e.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键移除节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    <span class="keyword">int</span> h = hash(k);</span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(h, tab.length);</span><br><span class="line">    Entry&lt;K,V&gt; prev = tab[i];</span><br><span class="line">    Entry&lt;K,V&gt; e = prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">        <span class="keyword">if</span> (h == e.hash &amp;&amp; eq(k, e.get())) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">if</span> (prev == e)</span><br><span class="line">                tab[i] = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                prev.next = next;</span><br><span class="line">            <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = e;</span><br><span class="line">        e = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键移除节点是否成功</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 移除节点是否成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeMapping</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">    Object k = maskNull(entry.getKey());</span><br><span class="line">    <span class="keyword">int</span> h = hash(k);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(h, tab.length);</span><br><span class="line">    Entry&lt;K,V&gt; prev = tab[i];</span><br><span class="line">    Entry&lt;K,V&gt; e = prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">        <span class="keyword">if</span> (h == e.hash &amp;&amp; e.equals(entry)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">if</span> (prev == e)</span><br><span class="line">                tab[i] = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                prev.next = next;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = e;</span><br><span class="line">        e = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (queue.poll() != <span class="keyword">null</span>) <span class="comment">//清空队列中只有一部分过时节点</span></span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    Arrays.fill(table, <span class="keyword">null</span>); <span class="comment">//清空哈希表后</span></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空哈希表后可能导致GC，另外一部分节点会被添加到队列中，所以此处需要再次清空队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (queue.poll() != <span class="keyword">null</span>)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表中是否包含指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> containsNullValue();</span><br><span class="line"></span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tab.length; i-- &gt; <span class="number">0</span>;)</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">            <span class="keyword">if</span> (value.equals(e.value))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表中是否包含null值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含null值 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">containsNullValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tab.length; i-- &gt; <span class="number">0</span>;)</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">            <span class="keyword">if</span> (e.value==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表中的节点，该类继承了WeakReference加上调用了父类的构造，说明它的键是个弱引用</span></span><br><span class="line"><span class="comment"> * 该类中的其他方法就不做展示了，比较简单</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    V value;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     * 指定键生成弱引用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queue 与弱引用关联的队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash 哈希值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> next 下一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Entry(Object key, V value, ReferenceQueue&lt;Object&gt; queue, <span class="keyword">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(key, queue);</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.hash  = hash;</span><br><span class="line">        <span class="keyword">this</span>.next  = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历所有键并执行指定动作</span></span><br><span class="line"><span class="comment"> * 遍历过程中不允许WeakHashMap调用任何会修改结构的方法，否则最后会抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action 指定动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    Entry&lt;K, V&gt;[] tab = getTable();</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K, V&gt; entry : tab) &#123;</span><br><span class="line">        <span class="keyword">while</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object key = entry.get();</span><br><span class="line">            <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                action.accept((K)WeakHashMap.unmaskNull(key), entry.value);</span><br><span class="line">            &#125;</span><br><span class="line">            entry = entry.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (expectedModCount != modCount) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历哈希表并执行指定动作后获取新值，利用新值替换所有节点的旧值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> function 指定动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; function)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(function);</span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    Entry&lt;K, V&gt;[] tab = getTable();;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K, V&gt; entry : tab) &#123;</span><br><span class="line">        <span class="keyword">while</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object key = entry.get();</span><br><span class="line">            <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                entry.value = function.apply((K)WeakHashMap.unmaskNull(key), entry.value);</span><br><span class="line">            &#125;</span><br><span class="line">            entry = entry.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (expectedModCount != modCount) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一些重复性的东西，比如包含键、值、键值对的迭代器、可分割迭代器就不讲解了，可参考HashMap</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>WeakHashMap的键值对允许为null</p></li><li><p>WeakHashMap采用弱键，当某个键不在使用时会被GC回收，而键对应的节点也会被移除掉</p></li><li><p>WeakHashMap无序不可重复、非线程安全</p></li><li><p>在添加节点，值对象最好不要与任何的键直接或间接的关联，否则GC无法丢弃该键</p></li><li><p>WeakHashMap#ReferendeQueue是用来查看哈希表中哪些键被丢球了，以便哈希表能够及时更新</p></li><li><p>WeakHashMap的容量必须是2的幂次方</p></li><li><p>WeakHashMap在新增节点时采用的是头插法</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>弱键</code> <code>ReferenceQueue</code> <code>头插法</code> <code>强、软、弱、虚引用</code> <code>Reference</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;探索&lt;code&gt;WeakHashMap&lt;/code&gt;底层实现是基于&lt;code&gt;JDK1.8&lt;/code&gt;，它的数据结构是&lt;code&gt;数组 + 链表&lt;/code&gt;。就不贴它的注释了，直接总结一下吧：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;WeakHashMap基于&lt;code&gt;弱键&lt;/code&gt;实现了Map接口，也就是说，当某个键不在使用时会被丢弃，对应的键值对将会被自动移除。如何确定不在使用取决于GC是否运行，而对于GC何时运行我们并不知道，所以某个键何时被丢弃我们也不得而知，至于GC如何运行就是另外一个话题了，有可能导致上一分钟与下一分钟获取到的结果是不一致的。另一个方面，WeakHashMap的值对象由强引用所持有（何为强引用下面会介绍），应确保值对象不会直接或间接引用自身的键或其他键，这会导致键无法被丢弃。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;强引用：简单来说指向new出来的对象就是一个强引用，可以说是经常使用。对于强引用来说，它们不会被GC回收，即使内存空间不足，JVM宁愿抛出内存溢出错误也不敢动它们，总体来说还是很有威信的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;软引用：首先给强引用包裹上一层&lt;code&gt;SoftReference&lt;/code&gt;，通过SoftReference获取到的引用即为软引用。对于软引用来说，在内存充足的情况下，GC可以选择性的清除，而一旦内存不足了，它们一个都跑不了，都会被清除掉。软引用最常用用于实现对内存敏感的缓存。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;弱引用：首先给强引用包裹上一层&lt;code&gt;WeakReference&lt;/code&gt;，通过WeakReference获取到的引用即为弱引用，看到这里你应该就已经明白了WeakHashMap内部的机制。对于弱引用来说，GC压根就不管内存是否充足，直接回收，很没有人性！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;虚引用：首先给强引用包裹上一层&lt;code&gt;PhantomReference&lt;/code&gt;，通过PhantomReference获取到的引用即为虚引用。对于虚引用来说，它在任何时候都可能被回收，常用于跟踪对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有一个方面，读者最好去了解下&lt;code&gt;Reference&lt;/code&gt;类，内部通过队列实现了一些机制。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索Hashtable底层实现</title>
    <link href="http://zlia.tech/2019/10/31/explain-hashtable-sourcecode/"/>
    <id>http://zlia.tech/2019/10/31/explain-hashtable-sourcecode/</id>
    <published>2019-10-31T10:15:34.000Z</published>
    <updated>2019-11-29T02:18:43.657Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>探索<code>Hashtable</code>底层实现是基于<code>JDK1.8</code>，它的数据结构是<code>数组 + 链表</code>。在不考虑线程是否安全的前提下，它的很多细节处理都不如HashMap，何况如今的HashMap又加了<code>红黑树</code>，查询修改肯定比不上，因为红黑树的时间复杂度是O（logN），而链表的时间复杂度是O（N），新增与删除无法比较，毕竟两者的策略不一致；而倘若比较讨论并发的话，<code>ConcurrentHashMap</code>比它更适合，Hashtable的作者也说了，看来是已经废弃的节奏了。</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><p>既然是与HashMap类似，那数据结构上肯定比它简单，我们就速速通过！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//可克隆、序列化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希表，负责存储节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希表中节点的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阈值 = 初始容量 * 加载因子    当超过指定阈值时会对哈希表重新散列，所有节点（链表）重新计算在新表中的索引，这就相当于所有节点都要参与计算、在新表中设置，效率非常地下</span></span><br><span class="line"><span class="comment">     * HashMap是先将所有节点分成两部分，最终只需要在新表中设置这两部分即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载因子，容量大小不变的情况下，加载因子过大减少空间开销，增加查询成本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结构修改的次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//包含所有键的迭代器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Set&lt;K&gt; keySet;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//包含所有键值对的迭代器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//包含所有值的迭代器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Collection&lt;V&gt; values;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大容量，若设置过高的话可能会发生内存泄露</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义键类型，用于迭代器或枚举</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEYS = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义值类型，用于迭代器或枚举</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALUES = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义键值对类型，用于迭代器或枚举</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ENTRIES = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量与加载因子构造哈希表</span></span><br><span class="line"><span class="comment"> * Float.isNaN：检测是否是数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor 指定加载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span> + initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Load: "</span>+loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</span><br><span class="line">        initialCapacity = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    table = <span class="keyword">new</span> Entry&lt;?,?&gt;[initialCapacity]; <span class="comment">//初始化哈希表</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>); <span class="comment">//设置阈值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量与默认加载因子（0.75）构造哈希表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始容量（11）与默认加载因子（0.75）构造哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定集合添加到哈希表中，采用默认加载因子</span></span><br><span class="line"><span class="comment"> * 设置尽可能大的初始容量以便减少重新散列的次数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(Map&lt;? extends K, ? extends V&gt; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Math.max(<span class="number">2</span>*t.size(), <span class="number">11</span>), <span class="number">0.75f</span>);</span><br><span class="line">    putAll(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取哈希表中的元素个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希表中的元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断哈希表是否为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希表是否为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有键的枚举</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有键的枚举</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Enumeration&lt;K&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.&lt;K&gt;getEnumeration(KEYS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有值的枚举</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有值的枚举</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Enumeration&lt;V&gt; <span class="title">elements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.&lt;V&gt;getEnumeration(VALUES);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表中是否包含指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tab.length ; i-- &gt; <span class="number">0</span> ;) &#123; <span class="comment">//遍历哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[i] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.value.equals(value)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表中是否包含指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> contains(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表中是否包含指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 0x7FFFFFFF = 0111 1111 1111 1111 1111 1111 1111 1111</span></span><br><span class="line"><span class="comment">     * hash &amp; 0x7FFFFFFF 是为了保证结果不出现负数的情况，否则负数取余之后的结果也就为负数了，索引并没有负数</span></span><br><span class="line"><span class="comment">     * hash &amp; 0x7FFFFFFF % tab.leng 是为了取在[0, tab.length -1]区间内的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键获取值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; <span class="comment">//hash与equasl都相等才算是相等</span></span><br><span class="line">            <span class="keyword">return</span> (V)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容并重新散列所有节点</span></span><br><span class="line"><span class="comment"> * 新容量 = 旧容量 * 2 + 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = table.length;</span><br><span class="line">    Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">            <span class="comment">// Keep running with MAX_ARRAY_SIZE buckets</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;?,?&gt;[] newMap = <span class="keyword">new</span> Entry&lt;?,?&gt;[newCapacity];</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">    table = newMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123; <span class="comment">//将哈希表中的所有节点，包括链表都进行重新散列</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != <span class="keyword">null</span> ; ) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = old;</span><br><span class="line">            old = old.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> index = (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;<span class="comment">//重新计算在新表中的索引</span></span><br><span class="line">            e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">            newMap[index] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增节点</span></span><br><span class="line"><span class="comment"> * 采用头插法，每新增一个节点就放到链表的头部</span></span><br><span class="line"><span class="comment"> * 节点个数超过阈值时会进行扩容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">        <span class="comment">// Rehash the table if the threshold is exceeded</span></span><br><span class="line">        rehash();</span><br><span class="line"></span><br><span class="line">        tab = table;</span><br><span class="line">        hash = key.hashCode();</span><br><span class="line">        index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creates the new entry.</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">    tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增节点</span></span><br><span class="line"><span class="comment"> * 若发生重复则进行值替换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make sure the value is not null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123; <span class="comment">//遍历链表看看是否有重复的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            V old = entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键移除节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K,V&gt; prev = <span class="keyword">null</span> ; e != <span class="keyword">null</span> ; prev = e, e = e.next) &#123; <span class="comment">//遍历链表 prev：前一个节点  e：当前节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                prev.next = e.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[index] = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量添加节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : t.entrySet())</span><br><span class="line">        put(e.getKey(), e.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = tab.length; --index &gt;= <span class="number">0</span>; )</span><br><span class="line">        tab[index] = <span class="keyword">null</span>;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 浅拷贝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 克隆后的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Hashtable&lt;?,?&gt; t = (Hashtable&lt;?,?&gt;)<span class="keyword">super</span>.clone();</span><br><span class="line">        t.table = <span class="keyword">new</span> Entry&lt;?,?&gt;[table.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = table.length ; i-- &gt; <span class="number">0</span> ; ) &#123;</span><br><span class="line">            t.table[i] = (table[i] != <span class="keyword">null</span>)</span><br><span class="line">                ? (Entry&lt;?,?&gt;) table[i].clone() : <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t.keySet = <span class="keyword">null</span>;</span><br><span class="line">        t.entrySet = <span class="keyword">null</span>;</span><br><span class="line">        t.values = <span class="keyword">null</span>;</span><br><span class="line">        t.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据类型获取枚举</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type 类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 枚举</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Enumeration&lt;T&gt; <span class="title">getEnumeration</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyEnumeration();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Enumerator&lt;&gt;(type, <span class="keyword">false</span>);<span class="comment">//false不允许删除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据类型获取迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type 类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Iterator&lt;T&gt; <span class="title">getIterator</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyIterator();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Enumerator&lt;&gt;(type, <span class="keyword">true</span>);<span class="comment">//true允许删除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有键的迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有键的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (keySet == <span class="keyword">null</span>)</span><br><span class="line">        keySet = Collections.synchronizedSet(<span class="keyword">new</span> KeySet(), <span class="keyword">this</span>);<span class="comment">//线程安全</span></span><br><span class="line">    <span class="keyword">return</span> keySet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有键值对的迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有键值对的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    <span class="keyword">if</span> (entrySet==<span class="keyword">null</span>)</span><br><span class="line">        entrySet = Collections.synchronizedSet(<span class="keyword">new</span> EntrySet(), <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> entrySet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有值的迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有值的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (values==<span class="keyword">null</span>)</span><br><span class="line">        values = Collections.synchronizedCollection(<span class="keyword">new</span> ValueCollection(), <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前节点的哈希值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前节点的键</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前节点的值</span></span><br><span class="line">    V value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前节点的下一个节点</span></span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有些方法并没有展示，请参考HashMap</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>Hashtable的键值对不允许为空，因为它是直接拿这个键去获取哈希值，这不就造成空指针了（感觉有点白痴），它还对值做了空指针判断</p></li><li><p>Hashtable默认初始容量11、默认加载因子0.75</p></li><li><p>Hashtable扩容时以<code>2倍 + 1</code>进行增长，旧表中的所有节点重新散列到新表中，效率较为低下</p></li><li><p>Hashtable计算索引时采用的是取余，而HashMap采用的与运算</p></li><li><p>Hashtable新增节点时采用的头插法</p></li><li><p>Hashtable计算hash值的方式可能会出现高位不同低位相同的两个不同数造成最终的索引相同，相比hashMap，它的hash计算方式降低了碰撞的概率</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>键值对不允许null</code> <code>计算索引采用取余</code> <code>头插法</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;探索&lt;code&gt;Hashtable&lt;/code&gt;底层实现是基于&lt;code&gt;JDK1.8&lt;/code&gt;，它的数据结构是&lt;code&gt;数组 + 链表&lt;/code&gt;。在不考虑线程是否安全的前提下，它的很多细节处理都不如HashMap，何况如今的HashMap又加了&lt;code&gt;红黑树&lt;/code&gt;，查询修改肯定比不上，因为红黑树的时间复杂度是O（logN），而链表的时间复杂度是O（N），新增与删除无法比较，毕竟两者的策略不一致；而倘若比较讨论并发的话，&lt;code&gt;ConcurrentHashMap&lt;/code&gt;比它更适合，Hashtable的作者也说了，看来是已经废弃的节奏了。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索TreeMap底层实现</title>
    <link href="http://zlia.tech/2019/10/31/explain-treemap-sourcecode/"/>
    <id>http://zlia.tech/2019/10/31/explain-treemap-sourcecode/</id>
    <published>2019-10-31T03:31:42.000Z</published>
    <updated>2019-11-06T03:13:15.560Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>探索<code>TreeMap</code>底层实现是基于<code>JDK1.8</code>，通过该类的注释可以了解它的数据结构是<code>红黑树</code>，默认是按照<code>自然顺序</code>进行排序（所有的键都必须去实现<code>Comparable</code>），当然也可以通过<code>指定比较器</code>进行排序（所有的键都必须实现<code>Comparator</code>）。至于什么是红黑树，读者最好有一定的了解，那看懂它的源码也就是分分钟的事了。</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//可序列化、克隆</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 比较器</span></span><br><span class="line"><span class="comment">     * 通过该比较器来维持顺序，若为null则按照自然顺序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 红黑树的根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 红黑树中节点的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结构修改的次数，用来检测快速失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 红色标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED   = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 黑色标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存entrySet方法的返回值，用于迭代器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> EntrySet entrySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储按照降序排列的键值对</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;K,V&gt; descendingMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储按照降序排列的键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> KeySet&lt;K&gt; navigableKeySet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始化</span></span><br><span class="line"><span class="comment"> * 按照自然顺序排列，所有的键都必须实现Comparable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    comparator = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定比较器来初始化</span></span><br><span class="line"><span class="comment"> * 按照比较器中定义的规则进行排列，所有的键都必须实现Comparator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> comparator 比较器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定集合到红黑树中</span></span><br><span class="line"><span class="comment"> * 按照自然顺序排列，所有的键都必须实现Comparable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    comparator = <span class="keyword">null</span>;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 添加指定有序集合到红黑树中，并采用该有序集合的比较器作为红黑树的比较器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 有序集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    comparator = m.comparator();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        buildFromSorted(m.size(), m.entrySet().iterator(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取红黑树中节点的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 节点的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树中是否包含指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getEntry(key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键获取红黑树节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 红黑树节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Offload comparator-based version for sake of performance</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) <span class="comment">//比较结果小于0说明在左子树上</span></span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) <span class="comment">//比较结果大于0说明在右子树上</span></span><br><span class="line">            p = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在红黑树中通过指定键与指定比较器获取节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntryUsingComparator</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        K k = (K) key;</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; p = root; <span class="comment">//获取红黑树的根节点</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = cpr.compare(k, p.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) <span class="comment">//比较结果小于0说明在左子树上</span></span><br><span class="line">                p = p.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)<span class="comment">//比较结果大于0说明在右子树上</span></span><br><span class="line">                p = p.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取等于或大于指定键的最小节点，若不存在，即红黑树中最大的键小于指定键则返回null</span></span><br><span class="line"><span class="comment"> * 大于指定键的最小节点：表示大于指定键且与指定键最为接近</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或指定键的最小节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getCeilingEntry</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = compare(key, p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) <span class="comment">//比较结果小于0可以明确的是已经找到大于指定键的节点了，但可能不是最小节点，故而往左子树继续查找</span></span><br><span class="line">                p = p.left;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) &#123; <span class="comment">//比较结果大于0说明还没有找到大于指定键的节点，故而继续往右子树上找</span></span><br><span class="line">                p = p.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 走到这里是已经没有右子树可以查找了，说明已经没有大于指定键的节点了，那么我们需要尝试往上查询之前找到的大于指定键的最近节点或压根就没有大于指定键的节点</span></span><br><span class="line"><span class="comment">                 * 针对查找大于指定键的节点，那么指定键的节点一定在该节点的左子树上（总体来看），所以最终只要不断去查找某个节点是否在其父节点的左子树即可，若是则它的父节点就是大于指定键的最近节点，若最终</span></span><br><span class="line"><span class="comment">                 * parent == null说明整个树始终都没有大于指定键的节点，也就返回null</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                Entry&lt;K,V&gt; parent = p.parent;</span><br><span class="line">                Entry&lt;K,V&gt; ch = p;</span><br><span class="line">                <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; ch == parent.right) &#123;</span><br><span class="line">                    ch = parent;</span><br><span class="line">                    parent = parent.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取等于或小于指定键的最大节点，若不存在，即红黑树中最小的键大于指定键则返回null</span></span><br><span class="line"><span class="comment"> * 小于指定键的最大节点：表示小于指定键且与指定键最为接近</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或指定键的最大节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getFloorEntry</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = compare(key, p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) <span class="comment">//比较结果大于0可以明确的是已经找到小于指定键的节点了，但可能不是最大节点，故而往右子树继续查找</span></span><br><span class="line">                p = p.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) &#123; <span class="comment">//比较结果小于0说明还没有找到小于指定键的节点，故而继续往左子树上找</span></span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 走到这里是已经没有左子树可以查找了，说明已经没有小于指定键的节点了，那么我们需要尝试往上查询之前找到的小于指定键的最近节点或压根就没有小于指定键的节点</span></span><br><span class="line"><span class="comment">                 * 针对查找小于指定键的节点，那么指定键的节点一定在该节点的右子树上（总体来看），所以最终只要不断去查找某个节点是否在其父节点的右子树即可，若是则它的父节点就是小于指定键的最近节点，若最终</span></span><br><span class="line"><span class="comment">                 * parent == null说明整个树始终都没有小于指定键的节点，也就返回null</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                Entry&lt;K,V&gt; parent = p.parent;</span><br><span class="line">                Entry&lt;K,V&gt; ch = p;</span><br><span class="line">                <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; ch == parent.left) &#123;</span><br><span class="line">                    ch = parent;</span><br><span class="line">                    parent = parent.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取大于指定键的最小节点，若不存在则返回null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或指定键的最小节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getHigherEntry</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = compare(key, p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.left != <span class="keyword">null</span>)</span><br><span class="line">                p = p.left;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                p = p.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; parent = p.parent;</span><br><span class="line">                Entry&lt;K,V&gt; ch = p;</span><br><span class="line">                <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; ch == parent.right) &#123;</span><br><span class="line">                    ch = parent;</span><br><span class="line">                    parent = parent.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取小于指定键的最大节点，若不存在则返回null</span></span><br><span class="line"><span class="comment"> * lower &lt; key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或指定键的最大节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getLowerEntry</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = compare(key, p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.right != <span class="keyword">null</span>)</span><br><span class="line">                p = p.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; parent = p.parent;</span><br><span class="line">                Entry&lt;K,V&gt; ch = p;</span><br><span class="line">                <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; ch == parent.left) &#123;</span><br><span class="line">                    ch = parent;</span><br><span class="line">                    parent = parent.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增节点后维持红黑树的平衡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 新增节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    x.color = RED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123; <span class="comment">//x的父节点是红色</span></span><br><span class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123; <span class="comment">//x的父节点在x的爷爷节点的左子树上</span></span><br><span class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); <span class="comment">//x的叔叔节点</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123; <span class="comment">//x的叔叔节点是红色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//x的叔叔节点是黑色</span></span><br><span class="line">                <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123; <span class="comment">//x在x的父节点的右子树上</span></span><br><span class="line">                    x = parentOf(x);<span class="comment">//x变成了x的父节点</span></span><br><span class="line">                    rotateLeft(x);<span class="comment">//将x的父节点进行左旋</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//x在x的父节点的左子树上</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                rotateRight(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//x的父节点在x的爷爷节点的右子树上</span></span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); <span class="comment">//x的叔叔节点</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123; <span class="comment">//x在x的父节点的左子树上</span></span><br><span class="line">                    x = parentOf(x);<span class="comment">//x变成了x的父节点</span></span><br><span class="line">                    rotateRight(x);<span class="comment">//将x的父节点进行右旋</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//x在x的父节点的右子树上</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除节点并调整红黑树使之平衡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 移除节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123; <span class="comment">//移除节点有两个子节点</span></span><br><span class="line">        Entry&lt;K,V&gt; s = successor(p); <span class="comment">//查找大于指定节点的最小节点</span></span><br><span class="line">        p.key = s.key;</span><br><span class="line">        p.value = s.value; <span class="comment">//替换值</span></span><br><span class="line">        p = s;</span><br><span class="line">    &#125; <span class="comment">// p has 2 children</span></span><br><span class="line"></span><br><span class="line">    Entry&lt;K,V&gt; replacement = (p.left != <span class="keyword">null</span> ? p.left : p.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123; <span class="comment">//移除节点至少有一个子节点，先更改移除节点的子节点与其父节点的关系</span></span><br><span class="line">        replacement.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">            p.parent.left  = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = replacement;</span><br><span class="line"></span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK) <span class="comment">//移除节点为黑色的情况才会导致红黑是失去平衡</span></span><br><span class="line">            fixAfterDeletion(replacement);  <span class="comment">//最后调整红黑树使之平衡</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) &#123; <span class="comment">//只有一个节点的情况下</span></span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//移除节点无子节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">                p.parent.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right)</span><br><span class="line">                p.parent.right = <span class="keyword">null</span>;</span><br><span class="line">            p.parent = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取大于指定节点的最小节点</span></span><br><span class="line"><span class="comment"> * 提供一篇文章：https://blog.csdn.net/iwts_24/article/details/87165743  讲的内容不错</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t 指定节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或大于指定节点的最小节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">successor</span><span class="params">(Entry&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; p = t.right;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 在有右子树的情况下查找大于指定键的最小节点，所以应该查找它的右子树的最左边的节点，因为越左边说明越靠近指定键</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *              5</span></span><br><span class="line"><span class="comment">         *            /   \</span></span><br><span class="line"><span class="comment">         *           3     6</span></span><br><span class="line"><span class="comment">         *         /  \</span></span><br><span class="line"><span class="comment">         *        1    4</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         *       1   3 4 5 6</span></span><br><span class="line"><span class="comment">         * t = 3，则 p = 4</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 下面这段代码和上面的getCeilingEntry方法是一样的</span></span><br><span class="line"><span class="comment">         * 在没有右子树的情况下往上查找大于指定键的最小节点，即当某个节点为其父节点的左子树时就是了</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *              5</span></span><br><span class="line"><span class="comment">         *            /   \</span></span><br><span class="line"><span class="comment">         *           3     6</span></span><br><span class="line"><span class="comment">         *         /  \</span></span><br><span class="line"><span class="comment">         *        1    4</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         *       1   3 4 5 6</span></span><br><span class="line"><span class="comment">         * t = 4，则 p = 5</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Entry&lt;K,V&gt; p = t.parent;</span><br><span class="line">        Entry&lt;K,V&gt; ch = t;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; ch == p.right) &#123;</span><br><span class="line">            ch = p;</span><br><span class="line">            p = p.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除节点后调整红黑树的平衡</span></span><br><span class="line"><span class="comment"> * 因为这里涉及到红黑树的算法，较为复杂，目前我也还没有完全理解，虽然之前尝试写过一篇关于红黑树的文章，但发现还是有些问题，所以打算后面探索算法的时候在更改</span></span><br><span class="line"><span class="comment"> * 由于咱们只是探索TreeMap的源码，所以这部分的内容个人觉得并不用花太多的时间去关注</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 移除节点或替代节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != root &amp;&amp; colorOf(x) == BLACK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; sib = rightOf(parentOf(x));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);</span><br><span class="line">                setColor(parentOf(x), RED);</span><br><span class="line">                rotateLeft(parentOf(x));</span><br><span class="line">                sib = rightOf(parentOf(x));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(leftOf(sib))  == BLACK &amp;&amp;</span><br><span class="line">                colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED);</span><br><span class="line">                x = parentOf(x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(leftOf(sib), BLACK);</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    rotateRight(sib);</span><br><span class="line">                    sib = rightOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(rightOf(sib), BLACK);</span><br><span class="line">                rotateLeft(parentOf(x));</span><br><span class="line">                x = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// symmetric</span></span><br><span class="line">            Entry&lt;K,V&gt; sib = leftOf(parentOf(x));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);</span><br><span class="line">                setColor(parentOf(x), RED);</span><br><span class="line">                rotateRight(parentOf(x));</span><br><span class="line">                sib = leftOf(parentOf(x));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK &amp;&amp;</span><br><span class="line">                colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED);</span><br><span class="line">                x = parentOf(x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(rightOf(sib), BLACK);</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    rotateLeft(sib);</span><br><span class="line">                    sib = leftOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(leftOf(sib), BLACK);</span><br><span class="line">                rotateRight(parentOf(x));</span><br><span class="line">                x = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setColor(x, BLACK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    root = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 浅拷贝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 克隆后的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TreeMap&lt;?,?&gt; clone;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        clone = (TreeMap&lt;?,?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将成员属性恢复到初始值，预防后续两个对象产生影响</span></span><br><span class="line">    clone.root = <span class="keyword">null</span>;</span><br><span class="line">    clone.size = <span class="number">0</span>;</span><br><span class="line">    clone.modCount = <span class="number">0</span>;</span><br><span class="line">    clone.entrySet = <span class="keyword">null</span>;</span><br><span class="line">    clone.navigableKeySet = <span class="keyword">null</span>;</span><br><span class="line">    clone.descendingMap = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建红黑树</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        clone.buildFromSorted(size, entrySet().iterator(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键值对来构建一颗红黑树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> size 红黑树的节点个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> it 包含键值对的迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str 包含键值对的输出流，it与str应该其中有一个不为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> defaultVal 若不为空，则使用该默认值作为键的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildFromSorted</span><span class="params">(<span class="keyword">int</span> size, Iterator&lt;?&gt; it, java.io.ObjectInputStream str, V defaultVal)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span>  java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line">    root = buildFromSorted(<span class="number">0</span>, <span class="number">0</span>, size-<span class="number">1</span>, computeRedLevel(size), it, str, defaultVal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算节点的高度达到某个值时应该变成红色，为了能够更好的分配红黑树的颜色</span></span><br><span class="line"><span class="comment"> * 至于它是怎么计算的，只能说这些写算法的人是真的牛逼</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sz 红黑树的节点个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 高度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">computeRedLevel</span><span class="params">(<span class="keyword">int</span> sz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = sz - <span class="number">1</span>; m &gt;= <span class="number">0</span>; m = m / <span class="number">2</span> - <span class="number">1</span>)</span><br><span class="line">        level++;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键值对来构建一颗红黑树</span></span><br><span class="line"><span class="comment"> * 注释上说明了构建后的红黑树的颜色分配很鲜明，实际上最终是通过redLevel来确定哪一部分是黑色，哪一部分是红色，但是顺序依然还是原来的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> level 当前节点的高度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lo 当前节点的子树的第一个节点的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hi 子树的最后一个节点的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> redLevel 当前节点达到此高度时应该是红色</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> it 包含键值对的迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str 包含键值对的输出流，it与str应该其中有一个不为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> defaultVal 若不为空，则使用该默认值作为键的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 根节点，红黑树的结构可能会发生变化，但是它的顺序不会变</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">buildFromSorted</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> redLevel, Iterator&lt;?&gt; it, java.io.ObjectInputStream str, V defaultVal)</span> <span class="keyword">throws</span>  java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hi &lt; lo) <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//hi &gt;= lo 说明子树已经构造完成</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">//取中间位置，无符号右移相当于除以2</span></span><br><span class="line"></span><br><span class="line">    Entry&lt;K,V&gt; left  = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (lo &lt; mid) </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 通过递归的方式构建当前节点的左子树</span></span><br><span class="line"><span class="comment">         * 若你了解红黑树的中序遍历，那应该就很容易理解了</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         *                   4</span></span><br><span class="line"><span class="comment">         *                 3    5</span></span><br><span class="line"><span class="comment">         *               2        6</span></span><br><span class="line"><span class="comment">         *             1            7</span></span><br><span class="line"><span class="comment">         *                           8</span></span><br><span class="line"><span class="comment">         * 中序遍历：  1 2 3 4 5 6 7 8 9    索引是从0开始的，类似数组</span></span><br><span class="line"><span class="comment">         * lo：0  hi：8 mid：4 redLevel：3  故当前节点是5，那么要构建左子树的话，可以认为5的左边的那些数字都是它的左子树中的节点，lo应该从0开始，hi应该是3</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        left = buildFromSorted(level+<span class="number">1</span>, lo, mid - <span class="number">1</span>, redLevel, it, str, defaultVal);</span><br><span class="line"></span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="keyword">if</span> (it != <span class="keyword">null</span>) &#123; <span class="comment">//通过迭代器获取键值对</span></span><br><span class="line">        <span class="keyword">if</span> (defaultVal==<span class="keyword">null</span>) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;)it.next();</span><br><span class="line">            key = (K)entry.getKey();</span><br><span class="line">            value = (V)entry.getValue();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            key = (K)it.next();</span><br><span class="line">            value = defaultVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 通过流的方式获取键值对</span></span><br><span class="line">        key = (K) str.readObject();</span><br><span class="line">        value = (defaultVal != <span class="keyword">null</span> ? defaultVal : (V) str.readObject());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry&lt;K,V&gt; middle =  <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (level == redLevel) <span class="comment">//上面说了某个节点达到此高度时就要变成红色</span></span><br><span class="line">        middle.color = RED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123; <span class="comment">//左子树构建完了就要关联关系</span></span><br><span class="line">        middle.left = left;</span><br><span class="line">        left.parent = middle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mid &lt; hi) &#123; <span class="comment">//通过递归的方式构建当前节点的右子树</span></span><br><span class="line">        Entry&lt;K,V&gt; right = buildFromSorted(level+<span class="number">1</span>, mid+<span class="number">1</span>, hi, redLevel,</span><br><span class="line">                                           it, str, defaultVal);</span><br><span class="line">        middle.right = right;</span><br><span class="line">        right.parent = middle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> middle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 封装键值对，以便控制某些方法不允许暴露给开发者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定键值对</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 封装后的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; Map.<span class="function">Entry&lt;K,V&gt; <span class="title">exportEntry</span><span class="params">(TreeMap.Entry&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (e == <span class="keyword">null</span>) ? <span class="keyword">null</span> : <span class="keyword">new</span> AbstractMap.SimpleImmutableEntry&lt;&gt;(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有键的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有键的Set集合 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> navigableKeySet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有键的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有键的Set集合 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableSet&lt;K&gt; <span class="title">navigableKeySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    KeySet&lt;K&gt; nks = navigableKeySet;</span><br><span class="line">    <span class="keyword">return</span> (nks != <span class="keyword">null</span>) ? nks : (navigableKeySet = <span class="keyword">new</span> KeySet&lt;&gt;(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含按照降序排列的键的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含降序排列的键的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableSet&lt;K&gt; <span class="title">descendingKeySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> descendingMap().navigableKeySet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取按照降序排列的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 降序排列的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableMap&lt;K, V&gt; <span class="title">descendingMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NavigableMap&lt;K, V&gt; km = descendingMap;</span><br><span class="line">    <span class="keyword">return</span> (km != <span class="keyword">null</span>) ? km : (descendingMap = <span class="keyword">new</span> DescendingSubMap&lt;&gt;(<span class="keyword">this</span>, <span class="keyword">true</span>, <span class="keyword">null</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">null</span>, <span class="keyword">true</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有值的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有值的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Collection&lt;V&gt; vs = values;</span><br><span class="line">    <span class="keyword">if</span> (vs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        vs = <span class="keyword">new</span> Values();</span><br><span class="line">        values = vs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有键值对的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有键值对的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    EntrySet es = entrySet;</span><br><span class="line">    <span class="keyword">return</span> (es != <span class="keyword">null</span>) ? es : (entrySet = <span class="keyword">new</span> EntrySet());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定起始键与结束键及是否包含起始、结束键来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * 当前对象是已经排好序了</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * TreeMap&lt;Integer, String&gt; treeMap = new TreeMap&lt;&gt;();</span></span><br><span class="line"><span class="comment"> * treeMap.put(5, "2");</span></span><br><span class="line"><span class="comment"> * treeMap.put(4, "2");</span></span><br><span class="line"><span class="comment"> * treeMap.put(10, "2");</span></span><br><span class="line"><span class="comment"> * treeMap.put(1, "2");</span></span><br><span class="line"><span class="comment"> * treeMap.put(20, "2");</span></span><br><span class="line"><span class="comment"> * treeMap.put(7, "2");</span></span><br><span class="line"><span class="comment"> * treeMap.put(8, "2");</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * System.out.println(treeMap.keySet()); -&gt; [1, 4, 5, 7, 8, 10, 20]</span></span><br><span class="line"><span class="comment"> * System.out.println(treeMap.subMap(2,true, 6, true).keySet());  -&gt; [4, 5]  实际上是在treeMap取2-6区间中的所有键 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromKey 起始键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromInclusive 子集中是否包含起始键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toKey 结束键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toInclusive 子集中是否包含结束键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableMap&lt;K,V&gt; <span class="title">subMap</span><span class="params">(K fromKey, <span class="keyword">boolean</span> fromInclusive, K toKey,   <span class="keyword">boolean</span> toInclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AscendingSubMap&lt;&gt;(<span class="keyword">this</span>, <span class="keyword">false</span>, fromKey, fromInclusive, <span class="keyword">false</span>, toKey, toInclusive);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定结束键及是否包含结束键来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * 当前对象是已经排好序了</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参照上面的代码</span></span><br><span class="line"><span class="comment"> * System.out.println(treeMap.headMap(4, true).keySet()); -&gt; [1, 4]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toKey 结束键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inclusive 子集中是否包含结束键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableMap&lt;K,V&gt; <span class="title">headMap</span><span class="params">(K toKey, <span class="keyword">boolean</span> inclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AscendingSubMap&lt;&gt;(<span class="keyword">this</span>, <span class="keyword">true</span>,  <span class="keyword">null</span>,  <span class="keyword">true</span>, <span class="keyword">false</span>, toKey, inclusive);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定起始键及是否包含起始键来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromKey 起始键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inclusive 子集中是否包含起始键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableMap&lt;K,V&gt; <span class="title">tailMap</span><span class="params">(K fromKey, <span class="keyword">boolean</span> inclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AscendingSubMap&lt;&gt;(<span class="keyword">this</span>, <span class="keyword">false</span>, fromKey, inclusive, <span class="keyword">true</span>,  <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定起始键与结束键来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * 包含起始键、不包含结束键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromKey 起始键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toKey 结束键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SortedMap&lt;K,V&gt; <span class="title">subMap</span><span class="params">(K fromKey, K toKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> subMap(fromKey, <span class="keyword">true</span>, toKey, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定结束键来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * 不包含结束键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toKey 结束键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SortedMap&lt;K,V&gt; <span class="title">headMap</span><span class="params">(K toKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> headMap(toKey, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定起始键来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * 包含起始键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromKey 起始键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SortedMap&lt;K,V&gt; <span class="title">tailMap</span><span class="params">(K fromKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tailMap(fromKey, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 替换指定键的节点的值，过程中要比较节点的值与指定值是否相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> oldValue 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newValue 新值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否替换成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">if</span> (p!=<span class="keyword">null</span> &amp;&amp; Objects.equals(oldValue, p.value)) &#123;</span><br><span class="line">        p.value = newValue;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 替换指定键的节点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 新值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">if</span> (p!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        V oldValue = p.value;</span><br><span class="line">        p.value = value;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按排列后的顺序遍历所有节点并执行指定动作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action 执行指定动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K, V&gt; e = getFirstEntry(); e != <span class="keyword">null</span>; e = successor(e)) &#123; <span class="comment">//successor是获取大于当前节点的最小节点，按照红黑树的中序排列后，实际上就是获取的下一个元素</span></span><br><span class="line">        action.accept(e.key, e.value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (expectedModCount != modCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按排列后的顺序遍历所有节点并执行指定动作后获取新值，利用新值替换所有节点的旧值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> function 指定动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; function)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(function);</span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K, V&gt; e = getFirstEntry(); e != <span class="keyword">null</span>; e = successor(e)) &#123;</span><br><span class="line">        e.value = function.apply(e.key, e.value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (expectedModCount != modCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 比较两个键</span></span><br><span class="line"><span class="comment"> * 若未指定比较器，则必须实现Comparable，通过覆写该类来进行比较</span></span><br><span class="line"><span class="comment"> * 若是指定了比较器，则必须实现Comparator，通过覆写该类来进行比较</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k1 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k2 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 比较结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object k1, Object k2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> comparator==<span class="keyword">null</span> ? ((Comparable&lt;? <span class="keyword">super</span> K&gt;)k1).compareTo((K)k2) : comparator.compare((K)k1, (K)k2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 比较两个值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o1 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o2 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 比较结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">valEquals</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (o1==<span class="keyword">null</span> ? o2==<span class="keyword">null</span> : o1.equals(o2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上面提到的关于获取子集的内容就列出重要的方法，其余的方法都是类似的，就不做重复性的工作了</span></span><br><span class="line"><span class="comment"> * 获取子集时是已经按顺序排列好了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NavigableSubMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前对象，也就是从该对象中获取子集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> TreeMap&lt;K,V&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 起始键与结束键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> K lo, hi;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * fromStart为true的话表示当前对象的第一个键作为起始，相当于是已经明确了起始键，若为false就说明起始键需要调用者指定</span></span><br><span class="line"><span class="comment">     * toEnd为true的话表示当前对象的最后一个键作为结尾，相当于是已经明确了结束键，若为false就说明结束键需要调用者指定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> fromStart, toEnd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子集是否需要包含起始键、结束键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> loInclusive, hiInclusive;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定键是否小于起始键</span></span><br><span class="line"><span class="comment">     * 若等于则看loInclusive变量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否小于起始键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tooLow</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!fromStart) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = m.compare(key, lo);</span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (c == <span class="number">0</span> &amp;&amp; !loInclusive))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定键是否大于结束键</span></span><br><span class="line"><span class="comment">     * 若等于则看hiInclusive变量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否大于起始键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tooHigh</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!toEnd) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = m.compare(key, hi);</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">0</span> || (c == <span class="number">0</span> &amp;&amp; !hiInclusive))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定键是否在起始键与结束键之间，该区间可能是[lo,hi]、(lo,hi) 、[lo,hi)、(lo,hi] 这取决于loInclusive、hiInclusive</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否在起始键与结束键之间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">inRange</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !tooLow(key) &amp;&amp; !tooHigh(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定键是否在起始键与结束键之间，区间是[lo,hi]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否在起始键与结束键之间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">inClosedRange</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (fromStart || m.compare(key, lo) &gt;= <span class="number">0</span>)</span><br><span class="line">            &amp;&amp; (toEnd || m.compare(hi, key) &gt;= <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定键是否在起始键与结束键之间</span></span><br><span class="line"><span class="comment">     * inclusive为true时，key在起始键与结束键之间不会报错，不过若key刚好是等于起始键或结束键，那么对应的区间必须是闭区间，假设key等于起始键，那么它的区间应该是[lo,hi)或[lo,ih]，若是等于结束键，那么区间应该是(lo,hi]或[lo,hi]</span></span><br><span class="line"><span class="comment">     * inclusive为false时，key在起始键与结束键之间不会报错，不过若key刚好是等于起始键或结束键，不管区间如何，都不会报错</span></span><br><span class="line"><span class="comment">     * 当然了，不管inclusive的值如何，如果指定键大于结束键或小于起始键，那肯定会报错</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inclusive 子集中是否包含指定键 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">inRange</span><span class="params">(Object key, <span class="keyword">boolean</span> inclusive)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inclusive ? inRange(key) : inClosedRange(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前对象中大于或等于起始键的节点</span></span><br><span class="line"><span class="comment">     * 因为指定了区间lo-hi，所以还要判断该节点是否超过了结束键hi</span></span><br><span class="line"><span class="comment">     * 如果fromStart为true，说明已经指定了起始键，直接获取第一个节点即可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> null或大于或等于起始键的节点，为null说明要么节点不存在，要么该节点超过了结束键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">absLowest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeMap.Entry&lt;K,V&gt; e = (fromStart ?  m.getFirstEntry() : (loInclusive ? m.getCeilingEntry(lo) : m.getHigherEntry(lo)));</span><br><span class="line">        <span class="keyword">return</span> (e == <span class="keyword">null</span> || tooHigh(e.key)) ? <span class="keyword">null</span> : e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前对象中小于或等于结束键的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> null或小于或等于结束键的节点，为null说明要么节点不存在，要么该节点小于起始键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">absHighest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeMap.Entry&lt;K,V&gt; e = (toEnd ?  m.getLastEntry() : (hiInclusive ?  m.getFloorEntry(hi) : m.getLowerEntry(hi)));</span><br><span class="line">        <span class="keyword">return</span> (e == <span class="keyword">null</span> || tooLow(e.key)) ? <span class="keyword">null</span> : e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取大于或等于指定键的节点</span></span><br><span class="line"><span class="comment">     * 若指定键小于起始键，那么只需要获取起始键即可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> null或大于或等于指定键的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">absCeiling</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tooLow(key))</span><br><span class="line">            <span class="keyword">return</span> absLowest();</span><br><span class="line">        TreeMap.Entry&lt;K,V&gt; e = m.getCeilingEntry(key);</span><br><span class="line">        <span class="keyword">return</span> (e == <span class="keyword">null</span> || tooHigh(e.key)) ? <span class="keyword">null</span> : e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取大于指定键的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> null或大于指定键的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">absHigher</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tooLow(key))</span><br><span class="line">            <span class="keyword">return</span> absLowest();</span><br><span class="line">        TreeMap.Entry&lt;K,V&gt; e = m.getHigherEntry(key);</span><br><span class="line">        <span class="keyword">return</span> (e == <span class="keyword">null</span> || tooHigh(e.key)) ? <span class="keyword">null</span> : e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取小于或等于指定键的节点</span></span><br><span class="line"><span class="comment">     * 若指定键大于结束键，则直接获取结束键即可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> null或小于或等于指定键的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">absFloor</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tooHigh(key))</span><br><span class="line">            <span class="keyword">return</span> absHighest();</span><br><span class="line">        TreeMap.Entry&lt;K,V&gt; e = m.getFloorEntry(key);</span><br><span class="line">        <span class="keyword">return</span> (e == <span class="keyword">null</span> || tooLow(e.key)) ? <span class="keyword">null</span> : e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取小于指定键的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> null或小于指定键的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">absLower</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tooHigh(key))</span><br><span class="line">            <span class="keyword">return</span> absHighest();</span><br><span class="line">        TreeMap.Entry&lt;K,V&gt; e = m.getLowerEntry(key);</span><br><span class="line">        <span class="keyword">return</span> (e == <span class="keyword">null</span> || tooLow(e.key)) ? <span class="keyword">null</span> : e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取子集的尾节点（结果不包含尾节点）</span></span><br><span class="line"><span class="comment">     * 当hiInclusive为true时，说明结果要包含指定的结束键，所以它就取了比指定结束键还要大的节点作为尾节点</span></span><br><span class="line"><span class="comment">     * 当hiInclusive为false时，说明结果不包含指定的结束键，所以它就取了等于结束键的节点作为尾节点</span></span><br><span class="line"><span class="comment">     * 不管是哪一种，反正它是不包含尾节点，可以在迭代器的hasNext中看到：next != null &amp;&amp; next.key != fenceKey;  说明不包含尾节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 尾节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">absHighFence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (toEnd ? <span class="keyword">null</span> : (hiInclusive ? m.getHigherEntry(hi) : m.getCeilingEntry(hi)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取子集的头节点（不包含头节点）</span></span><br><span class="line"><span class="comment">     * 分析同上</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 头节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">absLowFence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (fromStart ? <span class="keyword">null</span> : (loInclusive ? m.getLowerEntry(lo) : m.getFloorEntry(lo)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//剩下的方法就不一一分析了，大多数都是类似的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        compare(key, key); <span class="comment">//校验指定键至是否实现Comparable或Comparator</span></span><br><span class="line"></span><br><span class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>); <span class="comment">//设置红黑树的根节点</span></span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="comment">// split comparator and comparable paths</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123; <span class="comment">//采用Comparator的方式进行比较，查找新增节点应该放在哪个位置上</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value); <span class="comment">//新增节点已经存在则进行替换值</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">//采用Comparable的方式进行比较，查找新增节点应该放在哪个位置上</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = k.compareTo(t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent); <span class="comment">//构建节点并关联关系</span></span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="移除节点"><a href="#移除节点" class="headerlink" title="移除节点"></a>移除节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除指定键对应的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 移除节点的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    V oldValue = p.value;</span><br><span class="line">    deleteEntry(p); <span class="comment">//移除节点并调整红黑树的平衡</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取排序后的第一个节点并移除</span></span><br><span class="line"><span class="comment"> * 获取最左边的节点并移除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最左边的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">pollFirstEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getFirstEntry();</span><br><span class="line">    Map.Entry&lt;K,V&gt; result = exportEntry(p);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>)</span><br><span class="line">        deleteEntry(p);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取排序后的最后一个节点并移除</span></span><br><span class="line"><span class="comment"> * 获取最右边的节点并移除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最右边的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">pollLastEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getLastEntry();</span><br><span class="line">    Map.Entry&lt;K,V&gt; result = exportEntry(p);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>)</span><br><span class="line">        deleteEntry(p);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取排序后的第一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 排序后的第一个节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">firstEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exportEntry(getFirstEntry());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取最左边的节点，实际上就是在获取排序后的第一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最左边的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getFirstEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取排序后的最后一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 排序后的最后一个节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">lastEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exportEntry(getLastEntry());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取最右边的节点，实际上就是在获取排序后的最后一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最右边的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getLastEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">while</span> (p.right != <span class="keyword">null</span>)</span><br><span class="line">            p = p.right;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取小于指定键的最大节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 小于指定键的最大节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">lowerEntry</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exportEntry(getLowerEntry(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取小于指定键的最大节点的键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 小于指定键的最大节点的键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> K <span class="title">lowerKey</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> keyOrNull(getLowerEntry(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取等于或小于指定键的最大节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 等于或小于指定键的最大节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">floorEntry</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exportEntry(getFloorEntry(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取小于指定键的最大节点的键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 小于指定键的最大节点的键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> K <span class="title">floorKey</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> keyOrNull(getFloorEntry(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取等于或大于指定键的最小节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 等于或大于指定键的最小节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">ceilingEntry</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exportEntry(getCeilingEntry(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取等于或大于指定键的最小节点的键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 等于或大于指定键的最小节点的键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> K <span class="title">ceilingKey</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> keyOrNull(getCeilingEntry(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取大于指定键的最小节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 大于指定键的最小节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">higherEntry</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exportEntry(getHigherEntry(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取大于指定键的最小节点的键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 大于指定键的最小节点的键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> K <span class="title">higherKey</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> keyOrNull(getHigherEntry(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>若要按自然顺序排列则键必须实现Comparable，此时TreeMap中键不可以为null；若要自定义排列顺序则键必须实现Comparator，此时TreeMap中键可以为null</p></li><li><p>TreeMap中的很多算法跟红黑树中的中序有很大的关联，所以最好提前了解</p></li><li><p>TreeMap有序不可重复，非线程安全</p></li><li><p>TreeMap的数据结构是<code>红黑树</code></p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>红黑树</code> <code>Comparable与Comparator</code> <code>有序不可重复</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;探索&lt;code&gt;TreeMap&lt;/code&gt;底层实现是基于&lt;code&gt;JDK1.8&lt;/code&gt;，通过该类的注释可以了解它的数据结构是&lt;code&gt;红黑树&lt;/code&gt;，默认是按照&lt;code&gt;自然顺序&lt;/code&gt;进行排序（所有的键都必须去实现&lt;code&gt;Comparable&lt;/code&gt;），当然也可以通过&lt;code&gt;指定比较器&lt;/code&gt;进行排序（所有的键都必须实现&lt;code&gt;Comparator&lt;/code&gt;）。至于什么是红黑树，读者最好有一定的了解，那看懂它的源码也就是分分钟的事了。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索LinkedHashMap底层实现</title>
    <link href="http://zlia.tech/2019/10/25/explain-linkedhashmap-sourcecode/"/>
    <id>http://zlia.tech/2019/10/25/explain-linkedhashmap-sourcecode/</id>
    <published>2019-10-25T06:59:27.000Z</published>
    <updated>2019-10-31T03:29:19.477Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>印象中对LinkedHashMap的使用次数好像也不多，参考了几篇文章发现它依赖于<code>HashMap</code>而存在，也就是说它在HashMap的基础上又增加了某些特性，比如说<code>有序</code>。既然是基于HashMap，那么它内部的数据结构也应该有数组 + 链表 + 红黑树，而刚才说它又加上了自己的有序特性，那么应该还有<code>一条链表来维护该顺序</code>，如下图所示：</p><p class="customize-img"><img src="/assets/blogImg/java/linkedhashmap/data-structure.png" alt="LinkedHashMap数据结构"></p><p>该图侧重于它是如何保持有序的，就像上面说的是一条链表，画的有点丑，不过应该不难理解。另外一方面，由于它是基于HashMap，所以在看这篇文章之前最好能对HashMap有个了解，加上接下来并不会过多的解释它的数据结构，更多的关注还是在有序及其他特性上，毕竟它的数据结构是偷来的，探索LinkedHashMap底层实现是基于<code>JDK1.8</code>。</p><a id="more"></a><h3 id="阅读注释"><a href="#阅读注释" class="headerlink" title="阅读注释"></a><div><span>阅读注释</span></div></h3><p class="customize-img"><img src="/assets/blogImg/java/linkedhashmap/linkedhashmap-comment-1.png" alt="LinkedHashMap注释-1"></p><p>提供了一条链表来维护有序性，默认顺序是节点的插入顺序。</p><p class="customize-img"><img src="/assets/blogImg/java/linkedhashmap/linkedhashmap-comment-2.png" alt="LinkedHashMap注释-2"></p><p>还提供了按照访问顺序进行排序，该排序方式适合左LRU缓存。</p><p class="customize-img"><img src="/assets/blogImg/java/linkedhashmap/linkedhashmap-comment-3.png" alt="LinkedHashMap注释-3"></p><p>LinkedHashMap的迭代性能比HashMap高，因为HashMap会迭代所有容量，包括某些索引上并没有节点，而LinkedHashMap按照链表来迭代，并不会理会空节点。</p><p class="customize-img"><img src="/assets/blogImg/java/linkedhashmap/linkedhashmap-comment-4.png" alt="LinkedHashMap注释-4"></p><p>非线程安全，与HashMap相比，结构修改的概念不太一样。</p><p class="customize-img"><img src="/assets/blogImg/java/linkedhashmap/linkedhashmap-comment-5.png" alt="LinkedHashMap注释-5"></p><p>迭代器会发生快速失败倒是每个集合的共有特点。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//继承了HashMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//唯一序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3801124242820219131L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//双向链表的头节点，也代表着最少访问</span></span><br><span class="line">    <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//双向链表的尾节点，也代表着最多访问</span></span><br><span class="line">    <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置排序方式，也是迭代时的顺序</span></span><br><span class="line"><span class="comment">     * true：按照访问顺序，最多访问的节点会更新到尾节点</span></span><br><span class="line"><span class="comment">     * false：按照插入顺序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量与加载因子来初始化，按照插入顺序排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor 指定加载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量来初始，按照插入顺序排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 采用默认的初始容量与加载因子来初始化，按照插入顺序排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定结集合添加到表中，按照插入顺序排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定容量与加载因子、排序方式来初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor 指定加载因子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> accessOrder 指定排序方式-按照插入顺序、访问顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h4><p>以下的方法将不会详细介绍HashMap中的相关方法，只可能会略微提到，读者最好能够对HashMap有一定的了解。</p><h5 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定节点添加到尾部</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 指定节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">//添加到尾部后要进行关联关系，以便通过上下节点维护顺序</span></span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 复制节点的关联关系以保持有序</span></span><br><span class="line"><span class="comment"> * HashMap中可能出现链表转换成红黑树、也有可能出现红黑树转换为链表，所以相应的在转换过程中对象的结构也应该发生变化，为了保持有序性，必须复制原有结构的关联关系到新结构上</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src 原结构的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dst 现结构的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transferLinks</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; src, LinkedHashMap.Entry&lt;K,V&gt; dst)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; b = dst.before = src.before;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; a = dst.after = src.after;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = dst;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = dst;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = dst;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = dst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 恢复到初始状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reinitialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.reinitialize();</span><br><span class="line">    head = tail = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建普通结构的节点</span></span><br><span class="line"><span class="comment"> * 相当于在HashMap原有节点的基础上又维护了一层有序</span></span><br><span class="line"><span class="comment"> * 添加节点时会调用HashMap#putVal，紧着会调用该方法用来创建新节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 下一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p = <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将红黑树结构的节点的变成普通结构的节点，实际上只是对象变了，其成员属性拷贝原有节点上对应的值</span></span><br><span class="line"><span class="comment"> * HashMap#untreeify时会调用该方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 红黑树结构的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> next 下一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 普通结构的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; q = (LinkedHashMap.Entry&lt;K,V&gt;)p;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; t =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(q.hash, q.key, q.value, next);</span><br><span class="line">    transferLinks(q, t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建红黑树结构的节点</span></span><br><span class="line"><span class="comment"> * HashMap#putTreeVal时会调用该方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> next 下一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">newTreeNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(hash, key, value, next);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将普通结构的节点变成红黑树结构的节点，实际上只是对象变了，其成员属性拷贝原有节点上对应的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 普通结构的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> next 下一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 红黑树结构的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; q = (LinkedHashMap.Entry&lt;K,V&gt;)p;</span><br><span class="line">    TreeNode&lt;K,V&gt; t = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(q.hash, q.key, q.value, next);</span><br><span class="line">    transferLinks(q, t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除节点后的动作</span></span><br><span class="line"><span class="comment"> * HashMap#removeNode时会调用该方法</span></span><br><span class="line"><span class="comment"> * 将指定节点移除后应该维护其剩余节点的关联关系</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增节点后的动作</span></span><br><span class="line"><span class="comment"> * 默认情况下不会移除最少访问的节点</span></span><br><span class="line"><span class="comment"> * HashMap#putVal时会调用该方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict 模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123; <span class="comment">//可根据覆写removeEldestEntry方法来实现不同策略的缓存机制，默认是不会移除</span></span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>); <span class="comment">//移除最少访问的节点，即头部节点，默认情况下不会调用该方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问节点后的动作</span></span><br><span class="line"><span class="comment"> * 上面我们提到accessOrder = true时会按照访问顺序排序，最多访问的节点会被移动到尾部，即将当前节点移动到尾部，若是accessOrder = false则按照插入顺序排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 当前节点，即访问的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123; <span class="comment">//说明当前节点不是尾部节点，那就说明要移动到尾部</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; <span class="comment">//当前节点的上下节点</span></span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>) <span class="comment">//说明当前节点是头部节点</span></span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//当前节点是中间节点</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//a = null 说明当前节点是尾部，可是我们在一开始就判断了当前节点不是尾部节点，所以这里的else就不会走到</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>) <span class="comment">//last = tail也不可能为空，因为只有当前节点存在的情况才会调用该方法</span></span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p; <span class="comment">//将当前节点当作尾部节点</span></span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将键值对分别写入到流中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 输出流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">internalWriteEntries</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after) &#123;</span><br><span class="line">        s.writeObject(e.key);</span><br><span class="line">        s.writeObject(e.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否包含指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after) &#123;</span><br><span class="line">        V v = e.value;</span><br><span class="line">        <span class="keyword">if</span> (v == value || (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键获取值</span></span><br><span class="line"><span class="comment"> * 若accessOrder = true 调用该方法时认为是访问节点，同时也认为是结构修改，所以会去调用afterNodeAccess</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键获取值，若不存在指定节点则返回默认值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> defaultValue 默认值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 值或默认值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">   Node&lt;K,V&gt; e;</span><br><span class="line">   <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">       <span class="keyword">return</span> defaultValue;</span><br><span class="line">   <span class="keyword">if</span> (accessOrder)</span><br><span class="line">       afterNodeAccess(e);</span><br><span class="line">   <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.clear();</span><br><span class="line">    head = tail = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否移除最少访问的节点</span></span><br><span class="line"><span class="comment"> * 可通过覆写该方法来实现不同的策略，比如当缓存达到指定瓶颈时，每添加新节点时就删除掉最少访问的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> eldest 最少访问的节点，即头节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有键的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有键的Set集合 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Set&lt;K&gt; ks = keySet;</span><br><span class="line">    <span class="keyword">if</span> (ks == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ks = <span class="keyword">new</span> LinkedKeySet();</span><br><span class="line">        keySet = ks;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含所有键的集合</span></span><br><span class="line"><span class="comment"> * 跟HashMap中的代码类似，就不做解释了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedKeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; LinkedHashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedKeyIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsKey(o); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;K&gt; <span class="title">spliterator</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, Spliterator.SIZED |</span><br><span class="line">                                        Spliterator.ORDERED |</span><br><span class="line">                                        Spliterator.DISTINCT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> mc = modCount;</span><br><span class="line">        <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after)</span><br><span class="line">            action.accept(e.key);</span><br><span class="line">        <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有值的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有值的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Collection&lt;V&gt; vs = values;</span><br><span class="line">    <span class="keyword">if</span> (vs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        vs = <span class="keyword">new</span> LinkedValues();</span><br><span class="line">        values = vs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含所有值的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedValues</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; LinkedHashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedValueIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsValue(o); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;V&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, Spliterator.SIZED |</span><br><span class="line">                                        Spliterator.ORDERED);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> mc = modCount;</span><br><span class="line">        <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after)</span><br><span class="line">            action.accept(e.value);</span><br><span class="line">        <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有键值对的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有键值对的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> LinkedEntrySet()) : es;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含所有键值对的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedEntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; LinkedHashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedEntryIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">        Object key = e.getKey();</span><br><span class="line">        Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class="line">        <span class="keyword">return</span> candidate != <span class="keyword">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">            Object key = e.getKey();</span><br><span class="line">            Object value = e.getValue();</span><br><span class="line">            <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, Spliterator.SIZED |</span><br><span class="line">                                        Spliterator.ORDERED |</span><br><span class="line">                                        Spliterator.DISTINCT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> mc = modCount;</span><br><span class="line">        <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after)</span><br><span class="line">            action.accept(e);</span><br><span class="line">        <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历表并执行指定动作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action 指定动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> mc = modCount;</span><br><span class="line">    <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after)</span><br><span class="line">        action.accept(e.key, e.value);</span><br><span class="line">    <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历表并执行指定动作后获取新值，利用新值替换所有节点的旧值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> function 指定动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; function)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (function == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> mc = modCount;</span><br><span class="line">    <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after)</span><br><span class="line">        e.value = function.apply(e.key, e.value);</span><br><span class="line">    <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代器基类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashIterator</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; next;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; current;</span><br><span class="line">    <span class="keyword">int</span> expectedModCount;</span><br><span class="line"></span><br><span class="line">    LinkedHashIterator() &#123;</span><br><span class="line">        next = head;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        current = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> LinkedHashMap.<span class="function">Entry&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        current = e;</span><br><span class="line">        next = e.after;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; p = current;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        current = <span class="keyword">null</span>;</span><br><span class="line">        K key = p.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含所有键的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedKeyIterator</span> <span class="keyword">extends</span> <span class="title">LinkedHashIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().getKey(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含所有值的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedValueIterator</span> <span class="keyword">extends</span> <span class="title">LinkedHashIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含所有键值对的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedEntryIterator</span> <span class="keyword">extends</span> <span class="title">LinkedHashIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>有序、不可重复、非线程安全：内部通过维护一条双向链表来保证有序性</p></li><li><p>排序方式有两种：按插入顺序；按访问顺序，最近访问的节点会被移动到尾部，相当于头节点是最少访问的节点</p></li><li><p>removeEldestEntry：是否移除最少访问的节点，可覆写该方法来实现不同策略的缓存机制</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>双向链表保证有序性</code> <code>可按插入顺序或按访问顺序</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;印象中对LinkedHashMap的使用次数好像也不多，参考了几篇文章发现它依赖于&lt;code&gt;HashMap&lt;/code&gt;而存在，也就是说它在HashMap的基础上又增加了某些特性，比如说&lt;code&gt;有序&lt;/code&gt;。既然是基于HashMap，那么它内部的数据结构也应该有数组 + 链表 + 红黑树，而刚才说它又加上了自己的有序特性，那么应该还有&lt;code&gt;一条链表来维护该顺序&lt;/code&gt;，如下图所示：&lt;/p&gt;
&lt;p class=&quot;customize-img&quot;&gt;&lt;img src=&quot;/assets/blogImg/java/linkedhashmap/data-structure.png&quot; alt=&quot;LinkedHashMap数据结构&quot;&gt;&lt;/p&gt;
&lt;p&gt;该图侧重于它是如何保持有序的，就像上面说的是一条链表，画的有点丑，不过应该不难理解。另外一方面，由于它是基于HashMap，所以在看这篇文章之前最好能对HashMap有个了解，加上接下来并不会过多的解释它的数据结构，更多的关注还是在有序及其他特性上，毕竟它的数据结构是偷来的，探索LinkedHashMap底层实现是基于&lt;code&gt;JDK1.8&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索IdentityHashMap底层实现</title>
    <link href="http://zlia.tech/2019/10/23/explain-identityhashmap-sourcecode/"/>
    <id>http://zlia.tech/2019/10/23/explain-identityhashmap-sourcecode/</id>
    <published>2019-10-23T09:11:08.000Z</published>
    <updated>2019-11-04T08:05:22.859Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a><div><span>前沿</span></div></h3><p>我也是第一次认识IdentityHashMap，在工作中从未使用过它，所以对它的使用场景可能并不是很了解，本文也仅仅针对基于<code>JDK1.8</code>的源码进行探索。<code>IdentityHashMap</code>的数据结构应该是如图所示：</p><p class="customize-img"><img src="/assets/blogImg/java/identityhashmap/data-structure.png" alt="IdentityHashMap数据结构"></p><p>这个数据结构是我在看源码之前看了几篇别人写的文章所了解到的，个人喜欢在看源码对目标有所了解的习惯，紧接着才去深入它。</p><a id="more"></a><h3 id="阅读注释"><a href="#阅读注释" class="headerlink" title="阅读注释"></a><div><span>阅读注释</span></div></h3><p class="customize-img"><img src="/assets/blogImg/java/identityhashmap/identityhashmap-comment-1.png" alt="IdentityHashMap注释-1"></p><p>在IdentityHashMap中，对于两个键只有在k1 == k2成立时才认为是相等的，而在HashMap中确实k1.equals(k2)成立是才被认为相等，<code>前者是引用相等，而后者是对象相等</code>。</p><p class="customize-img"><img src="/assets/blogImg/java/identityhashmap/identityhashmap-comment-2.png" alt="IdentityHashMap注释-2"></p><p class="customize-img"><img src="/assets/blogImg/java/identityhashmap/identityhashmap-comment-3.png" alt="IdentityHashMap注释-3"></p><p>Identity可用于序列化或深拷贝或对象代理。</p><p class="customize-img"><img src="/assets/blogImg/java/identityhashmap/identityhashmap-comment-4.png" alt="IdentityHashMap注释-4"></p><p>键值对允许存放null，同样也是无序的。</p><p class="customize-img"><img src="/assets/blogImg/java/identityhashmap/identityhashmap-comment-5.png" alt="IdentityHashMap注释-5"></p><p>IdentityHashMap属于非线程安全，和集合中的其他类一样迭代器都可能发生快速失败。</p><p class="customize-img"><img src="/assets/blogImg/java/identityhashmap/identityhashmap-comment-6.png" alt="IdentityHashMap注释-6"></p><p>线性探针哈希表，这是对其数据结构的称呼。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//可序列化、克隆</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdentityHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认键值对个数</span></span><br><span class="line"><span class="comment">     * 虽然注释上写着是默认初始容量，但当你发现有这样子的一段代码时：table = new Object[2 * initCapacity]，你就会明白默认初始容量应该是64</span></span><br><span class="line"><span class="comment">     * 容量大小必须是2的幂次方，在添加节点时会先判断当前节点的个数是否超过了容量的1/3，所以我认为1/3是加载因子</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 为什么必须是2的幂次方?</span></span><br><span class="line"><span class="comment">     * 在计算索引时用&amp;代码了%，提升了效率，不过这导致了一个前提，就是必须是2的幂次方，为了是能够取到容量区间中的每个索引，有人将这种做法称为均匀分布</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最小键值对个数</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 为什么最小是4?</span></span><br><span class="line"><span class="comment">     * 假设手动指定容量大小是1，则初始容量应该是2，在添加第一个节点时会先判断当前节点的个数是否超过了容量的1/3，很显然，2 * 1/3的结果都不足1，所以它会先扩容，扩容后再添加节点，由于扩容是需要消耗一定的成本，为何不在初始化时就设定较 * 高的值来避免此次扩容；那么如果指定容量大小是2呢? 4 * 1/3 不足2，因为它的数据结构是同时存储key与value，所以在存储value时也必定会扩容，故也不行；那3就更不行了，毕竟要是2的幂次方，所以4属于最小指定容量值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MINIMUM_CAPACITY = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大键值对个数</span></span><br><span class="line"><span class="comment">     * 虽然注释上写着是最大容量，但实际上并不是，此数值用于当构造函数中指定的容量过高时会直接该数值，而当你发现有这样子一句代码时：table = new Object[2 * initCapacity]; 你就会发现实际上最大的容量应该是 1&lt;&lt;30才对</span></span><br><span class="line"><span class="comment">     * 实际上，线性探针表中能存储的节点个数不能超过 1&lt;&lt;&lt;30 - 1 个，因为它至少有一个位置是存储了null，用来避免死循环</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">29</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线性探针表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线性探针表中存储的节点个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 结构被修改的次数</span></span><br><span class="line"><span class="comment">     * 该成员属性是用于检测迭代器的快速失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代表键为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object NULL_KEY = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存entrySet方法的返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 采用默认键值对个数初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdentityHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init(DEFAULT_CAPACITY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键值对个数来初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expectedMaxSize 指定键值对个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdentityHashMap</span><span class="params">(<span class="keyword">int</span> expectedMaxSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (expectedMaxSize &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"expectedMaxSize is negative: "</span></span><br><span class="line">                                           + expectedMaxSize);</span><br><span class="line">    init(capacity(expectedMaxSize));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键值对个数进行初始化，并将指定集合添加到线性探针表中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdentityHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Allow for a bit of growth</span></span><br><span class="line">    <span class="keyword">this</span>((<span class="keyword">int</span>) ((<span class="number">1</span> + m.size()) * <span class="number">1.1</span>));</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 倘若键为null则采用NULL_KEY作为键</span></span><br><span class="line"><span class="comment">  * 正如方法名一样，隐藏Null</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> NULL_KEY或指定键</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">maskNull</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span> ? NULL_KEY : key);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 倘若键为NULL_KEY则返回null</span></span><br><span class="line"><span class="comment">  * 正如方法名一样，揭露Null</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key 线性探针表中的键</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> null或指定键</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title">unmaskNull</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (key == NULL_KEY ? <span class="keyword">null</span> : key);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 调整指定键值对个数</span></span><br><span class="line"><span class="comment">  * Integer.highestOneBit 返回只含有二进制中最高位（从左到右第一个数字为1）的十进制，如15对应的二进制是1111，结果是1000，也就是数字8</span></span><br><span class="line"><span class="comment">  * 这里有一点我觉得代码写的不够完美，假设expectedMaxSize = 3，意思我可能要存储3个键值对，而它最终的容量是16，那么在我添加最后一对键值对时，它仍然会进行扩容，个人觉得设计的不够完美</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> expectedMaxSize 指定键值对个数</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 调整后的键值对个数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">(<span class="keyword">int</span> expectedMaxSize)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line">         (expectedMaxSize &gt; MAXIMUM_CAPACITY / <span class="number">3</span>) ? MAXIMUM_CAPACITY :</span><br><span class="line">         (expectedMaxSize &lt;= <span class="number">2</span> * MINIMUM_CAPACITY / <span class="number">3</span>) ? MINIMUM_CAPACITY :</span><br><span class="line">         Integer.highestOneBit(expectedMaxSize + (expectedMaxSize &lt;&lt; <span class="number">1</span>));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 指定键值对个数来初始化哈希探针表</span></span><br><span class="line"><span class="comment">  * 由于参数代表着键值对个数，相当于是2倍的节点个数，故在初始化时 * 2</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> initCapacity 指定键值对个数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> initCapacity)</span> </span>&#123;</span><br><span class="line">     table = <span class="keyword">new</span> Object[<span class="number">2</span> * initCapacity];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取哈希探针表中节点的个数</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 节点的个数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> size;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 判断哈希探针表是否为空</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 哈希探针表是否为空</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 在指定区间内获取偶数索引位置</span></span><br><span class="line"><span class="comment">  * 为什么是偶数位置?</span></span><br><span class="line"><span class="comment">  * 因为它的数据结构是按照 | key | value | key1 | value1 | 的形式进行存储，导致了键是存储在偶数位置上，而值是存储在奇数位置上</span></span><br><span class="line"><span class="comment">  * 它采用的System.identityHashCode，该方法的结果与Object#hashCode的结果是一样的，只不过这样子就调不到开发人员自己覆写的hashCode方法</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> x 指定键</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> length 指定容量大小</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 偶数索引位置</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object x, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> h = System.identityHashCode(x);</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * (h &lt;&lt; 1) - (h &lt;&lt;8) </span></span><br><span class="line"><span class="comment">      * h * Math.pow(2,1) - h * Math.pow(2,8) -&gt; -h * (Math.pow(2,8) - Math.pow(2,1)) -&gt; -h * 2 * (Math.pow(2,7) - 1) -&gt; -h * 2 * 127 -&gt; -h * 127 * 2</span></span><br><span class="line"><span class="comment">      * 简化后的结果正好跟注释对应上，不过它始终没解释为啥是乘以-127，目前只知道 * 2是一定会得到偶数，因为它相当于进行了左移，去掉了最右边的一位，即1</span></span><br><span class="line"><span class="comment">      * 然后偶数 &amp; (length - 1) 最终是确定索引只可能是该区间内上的某一个偶数位置</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">return</span> ((h &lt;&lt; <span class="number">1</span>) - (h &lt;&lt; <span class="number">8</span>)) &amp; (length - <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取下一个偶数索引位置</span></span><br><span class="line"><span class="comment">  * 若下一个偶数索引位置超过了哈希探针表的容量大小，则从头开始，相当于在循环遍历哈希探针表</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> i 当前索引位置</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> len 表的容量大小</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 下一个偶数索引位置</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextKeyIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (i + <span class="number">2</span> &lt; len ? i + <span class="number">2</span> : <span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 对哈希探针表进行扩容</span></span><br><span class="line"><span class="comment">  * 新表是旧表的2倍，原来在旧表中节点重新散列到新表上</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> newCapacity 指定容量大小</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 是否扩容成功</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> newLength = newCapacity * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">     Object[] oldTable = table;</span><br><span class="line">     <span class="keyword">int</span> oldLength = oldTable.length;</span><br><span class="line">     <span class="keyword">if</span> (oldLength == <span class="number">2</span> * MAXIMUM_CAPACITY) &#123;</span><br><span class="line">         <span class="keyword">if</span> (size == MAXIMUM_CAPACITY - <span class="number">1</span>) <span class="comment">//最大节点的个数不能超过 MAXIMUM_CAPACITY - 1，因为有一个位置要存储Null，避免死循环</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Capacity exhausted."</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (oldLength &gt;= newLength)</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">     Object[] newTable = <span class="keyword">new</span> Object[newLength];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLength; j += <span class="number">2</span>) &#123; <span class="comment">//查找偶数位置上的键</span></span><br><span class="line">         <span class="comment">//扩容后将键值对重新散列到新表上</span></span><br><span class="line">         Object key = oldTable[j];</span><br><span class="line">         <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">             Object value = oldTable[j+<span class="number">1</span>];</span><br><span class="line">             oldTable[j] = <span class="keyword">null</span>;</span><br><span class="line">             oldTable[j+<span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">             <span class="keyword">int</span> i = hash(key, newLength);</span><br><span class="line">             <span class="keyword">while</span> (newTable[i] != <span class="keyword">null</span>)</span><br><span class="line">                 i = nextKeyIndex(i, newLength);</span><br><span class="line">             newTable[i] = key;</span><br><span class="line">             newTable[i + <span class="number">1</span>] = value;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     table = newTable;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 哈希探针表中是否包含指定键</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 是否包含指定键</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     Object k = maskNull(key);</span><br><span class="line">     Object[] tab = table;</span><br><span class="line">     <span class="keyword">int</span> len = tab.length;</span><br><span class="line">     <span class="keyword">int</span> i = hash(k, len);</span><br><span class="line">     <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">         Object item = tab[i];</span><br><span class="line">         <span class="keyword">if</span> (item == k)</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         <span class="keyword">if</span> (item == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         i = nextKeyIndex(i, len);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 哈希探针表中是否包含指定值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 是否包含指定值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">     Object[] tab = table;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tab.length; i += <span class="number">2</span>)</span><br><span class="line">         <span class="keyword">if</span> (tab[i] == value &amp;&amp; tab[i - <span class="number">1</span>] != <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 哈希探针表中是否包含指定键值对</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 是否包含指定键值对</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">containsMapping</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">     Object k = maskNull(key);</span><br><span class="line">     Object[] tab = table;</span><br><span class="line">     <span class="keyword">int</span> len = tab.length;</span><br><span class="line">     <span class="keyword">int</span> i = hash(k, len);</span><br><span class="line">     <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">         Object item = tab[i];</span><br><span class="line">         <span class="keyword">if</span> (item == k)</span><br><span class="line">             <span class="keyword">return</span> tab[i + <span class="number">1</span>] == value;</span><br><span class="line">         <span class="keyword">if</span> (item == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         i = nextKeyIndex(i, len);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 删除节点后重新散列所有可能冲突的节点</span></span><br><span class="line"><span class="comment">  * | key | value | key1 | value1 | key2 | value2 | -&gt; | key1 | value1 | key2 | value2 | null | null |</span></span><br><span class="line"><span class="comment">  * 该方法的实现较为混乱</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> d 指定索引位置</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeDeletion</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// Adapted from Knuth Section 6.4 Algorithm R</span></span><br><span class="line">     Object[] tab = table;</span><br><span class="line">     <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Look for items to swap into newly vacated slot</span></span><br><span class="line">     <span class="comment">// starting at index immediately following deletion,</span></span><br><span class="line">     <span class="comment">// and continuing until a null slot is seen, indicating</span></span><br><span class="line">     <span class="comment">// the end of a run of possibly-colliding keys.</span></span><br><span class="line">     Object item;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = nextKeyIndex(d, len); (item = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">          i = nextKeyIndex(i, len) ) &#123;</span><br><span class="line">         <span class="keyword">int</span> r = hash(item, len);</span><br><span class="line">         <span class="keyword">if</span> ((i &lt; r &amp;&amp; (r &lt;= d || d &lt;= i)) || (r &lt;= d &amp;&amp; d &lt;= i)) &#123;</span><br><span class="line">             tab[d] = item;</span><br><span class="line">             tab[d + <span class="number">1</span>] = tab[i + <span class="number">1</span>];</span><br><span class="line">             tab[i] = <span class="keyword">null</span>;</span><br><span class="line">             tab[i + <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">             d = i;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 清空</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     modCount++;</span><br><span class="line">     Object[] tab = table;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; i++)</span><br><span class="line">         tab[i] = <span class="keyword">null</span>;</span><br><span class="line">     size = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 比较当前对象与指定对象是否相等</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> o 指定对象</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 是否相等</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (o == <span class="keyword">this</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> IdentityHashMap) &#123;</span><br><span class="line">         IdentityHashMap&lt;?,?&gt; m = (IdentityHashMap&lt;?,?&gt;) o;</span><br><span class="line">         <span class="keyword">if</span> (m.size() != size)</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">         Object[] tab = m.table;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; i+=<span class="number">2</span>) &#123;</span><br><span class="line">             Object k = tab[i];</span><br><span class="line">             <span class="keyword">if</span> (k != <span class="keyword">null</span> &amp;&amp; !containsMapping(k, tab[i + <span class="number">1</span>]))</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">         Map&lt;?,?&gt; m = (Map&lt;?,?&gt;)o;</span><br><span class="line">         <span class="keyword">return</span> entrySet().equals(m.entrySet());</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">// o is not a Map</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取哈希值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 哈希值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">     Object[] tab = table;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; i +=<span class="number">2</span>) &#123;</span><br><span class="line">         Object key = tab[i];</span><br><span class="line">         <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">             Object k = unmaskNull(key);</span><br><span class="line">             result += System.identityHashCode(k) ^</span><br><span class="line">                       System.identityHashCode(tab[i + <span class="number">1</span>]);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 浅拷贝</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 克隆后的对象</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         IdentityHashMap&lt;?,?&gt; m = (IdentityHashMap&lt;?,?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">         m.entrySet = <span class="keyword">null</span>;</span><br><span class="line">         m.table = table.clone();</span><br><span class="line">         <span class="keyword">return</span> m;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 迭代器</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IdentityHashMapIterator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">     <span class="comment">//当前索引位置</span></span><br><span class="line">     <span class="keyword">int</span> index = (size != <span class="number">0</span> ? <span class="number">0</span> : table.length);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//结构修改次数</span></span><br><span class="line">     <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//移除节点前需要先获取当前索引位置，即先调用nextIndex后才能移除，下一次移除仍然需要先调用该方法</span></span><br><span class="line">     <span class="keyword">int</span> lastReturnedIndex = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//是否是有效索引</span></span><br><span class="line">     <span class="keyword">boolean</span> indexValid; <span class="comment">// To avoid unnecessary next computation</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//哈希探针表</span></span><br><span class="line">     Object[] traversalTable = table; <span class="comment">// reference to main table or copy</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 从当前索引位置开始后续是否有下一个键</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span> 是否有下一个键</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         Object[] tab = traversalTable;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; tab.length; i+=<span class="number">2</span>) &#123;</span><br><span class="line">             Object key = tab[i];</span><br><span class="line">             <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 index = i;</span><br><span class="line">                 <span class="keyword">return</span> indexValid = <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         index = tab.length;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 获取下一个索引</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span> 下一个索引</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">         <span class="keyword">if</span> (!indexValid &amp;&amp; !hasNext())</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">         indexValid = <span class="keyword">false</span>;</span><br><span class="line">         lastReturnedIndex = index;</span><br><span class="line">         index += <span class="number">2</span>;</span><br><span class="line">         <span class="keyword">return</span> lastReturnedIndex;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 移除当前节点</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (lastReturnedIndex == -<span class="number">1</span>)</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">         <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line"></span><br><span class="line">         expectedModCount = ++modCount;</span><br><span class="line">         <span class="keyword">int</span> deletedSlot = lastReturnedIndex;</span><br><span class="line">         lastReturnedIndex = -<span class="number">1</span>;</span><br><span class="line">         <span class="comment">// back up index to revisit new contents after deletion</span></span><br><span class="line">         index = deletedSlot;</span><br><span class="line">         indexValid = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">         Object[] tab = traversalTable;</span><br><span class="line">         <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">int</span> d = deletedSlot;</span><br><span class="line">         Object key = tab[d];</span><br><span class="line">         tab[d] = <span class="keyword">null</span>;        <span class="comment">// vacate the slot</span></span><br><span class="line">         tab[d + <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// If traversing a copy, remove in real table.</span></span><br><span class="line">         <span class="comment">// We can skip gap-closure on copy.</span></span><br><span class="line">         <span class="keyword">if</span> (tab != IdentityHashMap.<span class="keyword">this</span>.table) &#123;</span><br><span class="line">             IdentityHashMap.<span class="keyword">this</span>.remove(key);</span><br><span class="line">             expectedModCount = modCount;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         size--;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//在删除节点后所有可能冲突的节点会被重新散列，但是遍历的索引确实不变的，这也就是导致了移动后的某些节点可能会遍历不到，所以它在变化前做了数组的拷贝以便能够正常访问</span></span><br><span class="line">         Object item;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = nextKeyIndex(d, len); (item = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">              i = nextKeyIndex(i, len)) &#123;</span><br><span class="line">             <span class="keyword">int</span> r = hash(item, len);</span><br><span class="line">             <span class="comment">// See closeDeletion for explanation of this conditional</span></span><br><span class="line">             <span class="keyword">if</span> ((i &lt; r &amp;&amp; (r &lt;= d || d &lt;= i)) ||</span><br><span class="line">                 (r &lt;= d &amp;&amp; d &lt;= i)) &#123;</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">if</span> (i &lt; deletedSlot &amp;&amp; d &gt;= deletedSlot &amp;&amp;</span><br><span class="line">                     traversalTable == IdentityHashMap.<span class="keyword">this</span>.table) &#123;</span><br><span class="line">                     <span class="keyword">int</span> remaining = len - deletedSlot;</span><br><span class="line">                     Object[] newTable = <span class="keyword">new</span> Object[remaining];</span><br><span class="line">                     System.arraycopy(tab, deletedSlot,</span><br><span class="line">                                      newTable, <span class="number">0</span>, remaining);</span><br><span class="line">                     traversalTable = newTable;</span><br><span class="line">                     index = <span class="number">0</span>;</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 tab[d] = item;</span><br><span class="line">                 tab[d + <span class="number">1</span>] = tab[i + <span class="number">1</span>];</span><br><span class="line">                 tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                 tab[i + <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">                 d = i;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 包含所有键的迭代器</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">IdentityHashMapIterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">     <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">     <span class="function"><span class="keyword">public</span> K <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> (K) unmaskNull(traversalTable[nextIndex()]);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 包含所有值的迭代器</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">IdentityHashMapIterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">     <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">     <span class="function"><span class="keyword">public</span> V <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> (V) traversalTable[nextIndex() + <span class="number">1</span>];</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 包含所有键值对的迭代器，都是类似的代码就不做解释了</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">IdentityHashMapIterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> Entry lastReturnedEntry;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         lastReturnedEntry = <span class="keyword">new</span> Entry(nextIndex());</span><br><span class="line">         <span class="keyword">return</span> lastReturnedEntry;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         lastReturnedIndex =</span><br><span class="line">             ((<span class="keyword">null</span> == lastReturnedEntry) ? -<span class="number">1</span> : lastReturnedEntry.index);</span><br><span class="line">         <span class="keyword">super</span>.remove();</span><br><span class="line">         lastReturnedEntry.index = lastReturnedIndex;</span><br><span class="line">         lastReturnedEntry = <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">         <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">private</span> <span class="title">Entry</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">this</span>.index = index;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">         <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             checkIndexForEntryUse();</span><br><span class="line">             <span class="keyword">return</span> (K) unmaskNull(traversalTable[index]);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">         <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             checkIndexForEntryUse();</span><br><span class="line">             <span class="keyword">return</span> (V) traversalTable[index+<span class="number">1</span>];</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">         <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">             checkIndexForEntryUse();</span><br><span class="line">             V oldValue = (V) traversalTable[index+<span class="number">1</span>];</span><br><span class="line">             traversalTable[index+<span class="number">1</span>] = value;</span><br><span class="line">             <span class="comment">// if shadowing, force into main table</span></span><br><span class="line">             <span class="keyword">if</span> (traversalTable != IdentityHashMap.<span class="keyword">this</span>.table)</span><br><span class="line">                 put((K) traversalTable[index], value);</span><br><span class="line">             <span class="keyword">return</span> oldValue;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">super</span>.equals(o);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">             <span class="keyword">return</span> (e.getKey() == unmaskNull(traversalTable[index]) &amp;&amp;</span><br><span class="line">                    e.getValue() == traversalTable[index+<span class="number">1</span>]);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">if</span> (lastReturnedIndex &lt; <span class="number">0</span>)</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">super</span>.hashCode();</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span> (System.identityHashCode(unmaskNull(traversalTable[index])) ^</span><br><span class="line">                    System.identityHashCode(traversalTable[index+<span class="number">1</span>]));</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span> (unmaskNull(traversalTable[index]) + <span class="string">"="</span></span><br><span class="line">                     + traversalTable[index+<span class="number">1</span>]);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkIndexForEntryUse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Entry was removed"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取包含所有键的集合</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 包含所有键的Set集合 </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Set&lt;K&gt; ks = keySet;</span><br><span class="line">     <span class="keyword">if</span> (ks == <span class="keyword">null</span>) &#123;</span><br><span class="line">         ks = <span class="keyword">new</span> KeySet();</span><br><span class="line">         keySet = ks;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ks;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 包含哈希探针表中所有键的集合</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> size;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> containsKey(o);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> oldSize = size;</span><br><span class="line">         IdentityHashMap.<span class="keyword">this</span>.remove(o);</span><br><span class="line">         <span class="keyword">return</span> size != oldSize;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">         Objects.requireNonNull(c);</span><br><span class="line">         <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">for</span> (Iterator&lt;K&gt; i = iterator(); i.hasNext(); ) &#123;</span><br><span class="line">             <span class="keyword">if</span> (c.contains(i.next())) &#123;</span><br><span class="line">                 i.remove();</span><br><span class="line">                 modified = <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> modified;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         IdentityHashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (K key : <span class="keyword">this</span>)</span><br><span class="line">             result += System.identityHashCode(key);</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">         <span class="keyword">return</span> toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">     <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">         <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">         <span class="keyword">int</span> size = size();</span><br><span class="line">         <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">             a = (T[]) Array.newInstance(a.getClass().getComponentType(), size);</span><br><span class="line">         Object[] tab = table;</span><br><span class="line">         <span class="keyword">int</span> ti = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> si = <span class="number">0</span>; si &lt; tab.length; si += <span class="number">2</span>) &#123;</span><br><span class="line">             Object key;</span><br><span class="line">             <span class="keyword">if</span> ((key = tab[si]) != <span class="keyword">null</span>) &#123; <span class="comment">// key present ?</span></span><br><span class="line">                 <span class="comment">// more elements than expected -&gt; concurrent modification from other thread</span></span><br><span class="line">                 <span class="keyword">if</span> (ti &gt;= size) &#123;</span><br><span class="line">                     <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                 &#125;</span><br><span class="line">                 a[ti++] = (T) unmaskNull(key); <span class="comment">// unmask key</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// fewer elements than expected or concurrent modification from other thread detected</span></span><br><span class="line">         <span class="keyword">if</span> (ti &lt; size || expectedModCount != modCount) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// final null marker as per spec</span></span><br><span class="line">         <span class="keyword">if</span> (ti &lt; a.length) &#123;</span><br><span class="line">             a[ti] = <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> a;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Spliterator&lt;K&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> KeySpliterator&lt;&gt;(IdentityHashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取包含所有值的对象</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 包含所有值的对象</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Collection&lt;V&gt; vs = values;</span><br><span class="line">     <span class="keyword">if</span> (vs == <span class="keyword">null</span>) &#123;</span><br><span class="line">         vs = <span class="keyword">new</span> Values();</span><br><span class="line">         values = vs;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> vs;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 包含所有值的对象</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Values</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> ValueIterator();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> size;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> containsValue(o);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">for</span> (Iterator&lt;V&gt; i = iterator(); i.hasNext(); ) &#123;</span><br><span class="line">             <span class="keyword">if</span> (i.next() == o) &#123;</span><br><span class="line">                 i.remove();</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         IdentityHashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">         <span class="keyword">return</span> toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">     <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">         <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">         <span class="keyword">int</span> size = size();</span><br><span class="line">         <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">             a = (T[]) Array.newInstance(a.getClass().getComponentType(), size);</span><br><span class="line">         Object[] tab = table;</span><br><span class="line">         <span class="keyword">int</span> ti = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> si = <span class="number">0</span>; si &lt; tab.length; si += <span class="number">2</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (tab[si] != <span class="keyword">null</span>) &#123; <span class="comment">// key present ?</span></span><br><span class="line">                 <span class="comment">// more elements than expected -&gt; concurrent modification from other thread</span></span><br><span class="line">                 <span class="keyword">if</span> (ti &gt;= size) &#123;</span><br><span class="line">                     <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                 &#125;</span><br><span class="line">                 a[ti++] = (T) tab[si+<span class="number">1</span>]; <span class="comment">// copy value</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// fewer elements than expected or concurrent modification from other thread detected</span></span><br><span class="line">         <span class="keyword">if</span> (ti &lt; size || expectedModCount != modCount) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// final null marker as per spec</span></span><br><span class="line">         <span class="keyword">if</span> (ti &lt; a.length) &#123;</span><br><span class="line">             a[ti] = <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> a;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Spliterator&lt;V&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> ValueSpliterator&lt;&gt;(IdentityHashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取包含所有键值对的集合</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 包含所有键值对的集合</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">     Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet;</span><br><span class="line">     <span class="keyword">if</span> (es != <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">return</span> es;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">return</span> entrySet = <span class="keyword">new</span> EntrySet();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 包含所有键值对的集合</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">         <span class="keyword">return</span> containsMapping(entry.getKey(), entry.getValue());</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">         <span class="keyword">return</span> removeMapping(entry.getKey(), entry.getValue());</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> size;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         IdentityHashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">         Objects.requireNonNull(c);</span><br><span class="line">         <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = iterator(); i.hasNext(); ) &#123;</span><br><span class="line">             <span class="keyword">if</span> (c.contains(i.next())) &#123;</span><br><span class="line">                 i.remove();</span><br><span class="line">                 modified = <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> modified;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">         <span class="keyword">return</span> toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">     <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">         <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">         <span class="keyword">int</span> size = size();</span><br><span class="line">         <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">             a = (T[]) Array.newInstance(a.getClass().getComponentType(), size);</span><br><span class="line">         Object[] tab = table;</span><br><span class="line">         <span class="keyword">int</span> ti = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> si = <span class="number">0</span>; si &lt; tab.length; si += <span class="number">2</span>) &#123;</span><br><span class="line">             Object key;</span><br><span class="line">             <span class="keyword">if</span> ((key = tab[si]) != <span class="keyword">null</span>) &#123; <span class="comment">// key present ?</span></span><br><span class="line">                 <span class="comment">// more elements than expected -&gt; concurrent modification from other thread</span></span><br><span class="line">                 <span class="keyword">if</span> (ti &gt;= size) &#123;</span><br><span class="line">                     <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                 &#125;</span><br><span class="line">                 a[ti++] = (T) <span class="keyword">new</span> AbstractMap.SimpleEntry&lt;&gt;(unmaskNull(key), tab[si + <span class="number">1</span>]);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// fewer elements than expected or concurrent modification from other thread detected</span></span><br><span class="line">         <span class="keyword">if</span> (ti &lt; size || expectedModCount != modCount) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// final null marker as per spec</span></span><br><span class="line">         <span class="keyword">if</span> (ti &lt; a.length) &#123;</span><br><span class="line">             a[ti] = <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> a;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> EntrySpliterator&lt;&gt;(IdentityHashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 自定义序列化</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> s 输出流</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> java.io.IOException  </span>&#123;</span><br><span class="line">     <span class="comment">// Write out and any hidden stuff</span></span><br><span class="line">     s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Write out size (number of Mappings)</span></span><br><span class="line">     s.writeInt(size);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Write out keys and values (alternating)</span></span><br><span class="line">     Object[] tab = table;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">         Object key = tab[i];</span><br><span class="line">         <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">             s.writeObject(unmaskNull(key));</span><br><span class="line">             s.writeObject(tab[i + <span class="number">1</span>]);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 自定义反序列化</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> s 输入流</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException  </span>&#123;</span><br><span class="line">     <span class="comment">// Read in any hidden stuff</span></span><br><span class="line">     s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Read in size (number of Mappings)</span></span><br><span class="line">     <span class="keyword">int</span> size = s.readInt();</span><br><span class="line">     <span class="keyword">if</span> (size &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> java.io.StreamCorruptedException</span><br><span class="line">             (<span class="string">"Illegal mappings count: "</span> + size);</span><br><span class="line">     <span class="keyword">int</span> cap = capacity(size);</span><br><span class="line">     SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, cap);</span><br><span class="line">     init(cap);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Read the keys and values, and put the mappings in the table</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">         <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">             K key = (K) s.readObject();</span><br><span class="line">         <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">             V value = (V) s.readObject();</span><br><span class="line">         putForCreate(key, value);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 反序列化时将键值对存储到哈希探针表上</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putForCreate</span><span class="params">(K key, V value)</span> <span class="keyword">throws</span> java.io.StreamCorruptedException </span>&#123;</span><br><span class="line">     Object k = maskNull(key);</span><br><span class="line">     Object[] tab = table;</span><br><span class="line">     <span class="keyword">int</span> len = tab.length;</span><br><span class="line">     <span class="keyword">int</span> i = hash(k, len);</span><br><span class="line"></span><br><span class="line">     Object item;</span><br><span class="line">     <span class="keyword">while</span> ( (item = tab[i]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (item == k)</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> java.io.StreamCorruptedException();</span><br><span class="line">         i = nextKeyIndex(i, len);</span><br><span class="line">     &#125;</span><br><span class="line">     tab[i] = k;</span><br><span class="line">     tab[i + <span class="number">1</span>] = value;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 遍历哈希探针表并执行指定动作</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> action 指定动作</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">     Objects.requireNonNull(action);</span><br><span class="line">     <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">     Object[] t = table;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; t.length; index += <span class="number">2</span>) &#123;</span><br><span class="line">         Object k = t[index];</span><br><span class="line">         <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">             action.accept((K) unmaskNull(k), (V) t[index + <span class="number">1</span>]);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 遍历哈希探针表并执行指定动作后获取新值，利用新值替换所有节点的旧值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> function 指定动作</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; function)</span> </span>&#123;</span><br><span class="line">     Objects.requireNonNull(function);</span><br><span class="line">     <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">     Object[] t = table;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; t.length; index += <span class="number">2</span>) &#123;</span><br><span class="line">         Object k = t[index];</span><br><span class="line">         <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">             t[index + <span class="number">1</span>] = function.apply((K) unmaskNull(k), (V) t[index + <span class="number">1</span>]);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加节点</span></span><br><span class="line"><span class="comment"> * 先获取偶数索引位置，若该位置上已经存在节点且两者的节点相等，则进行替换，若两者的节点不相等则继续往下查找偶数索引位置，直到偶数位置上不存在节点时才跳出循环</span></span><br><span class="line"><span class="comment"> * 在上面我们提到，在最大键值对中必须有一个地方存在null，否则会陷入死循环，而这里正好也是说明了这一点，要是在最大键值对中所有的偶数位置上都已经填充了节点，那么它会一直查找，陷入了一个环形的查找中，反正就是死循环了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object k = maskNull(key);</span><br><span class="line"></span><br><span class="line">    retryAfterResize: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">final</span> Object[] tab = table;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> len = tab.length;</span><br><span class="line">        <span class="keyword">int</span> i = hash(k, len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object item; (item = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">             i = nextKeyIndex(i, len)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item == k) &#123; <span class="comment">//若新增的节点与当前偶数索引位置上的节点相等，将新值替换旧值</span></span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    V oldValue = (V) tab[i + <span class="number">1</span>];</span><br><span class="line">                tab[i + <span class="number">1</span>] = value;</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> s = size + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * s + (s &lt;&lt; 1) -&gt; 3 * s</span></span><br><span class="line"><span class="comment">         * 添加节点后是否超过容量的1/3，若超过则进行扩容，扩容成功后要在新表中重新查找偶数索引位置，若扩容失败或不需要扩容则直接存储节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (s + (s &lt;&lt; <span class="number">1</span>) &gt; len &amp;&amp; resize(len))</span><br><span class="line">            <span class="keyword">continue</span> retryAfterResize; <span class="comment">//代码又回到for循环上</span></span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        tab[i] = k;</span><br><span class="line">        tab[i + <span class="number">1</span>] = value;</span><br><span class="line">        size = s;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定集合到线性探针表中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = m.size();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; size)</span><br><span class="line">        resize(capacity(n)); <span class="comment">//保守扩容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</span><br><span class="line">        put(e.getKey(), e.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过指定键获取值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    Object[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = hash(k, len);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        Object item = tab[i];</span><br><span class="line">        <span class="keyword">if</span> (item == k)</span><br><span class="line">            <span class="keyword">return</span> (V) tab[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        i = nextKeyIndex(i, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="移除节点"><a href="#移除节点" class="headerlink" title="移除节点"></a>移除节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过指定键移除节点</span></span><br><span class="line"><span class="comment"> * 移除节点后会重新散列所有可能冲突的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    Object[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = hash(k, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        Object item = tab[i];</span><br><span class="line">        <span class="keyword">if</span> (item == k) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                V oldValue = (V) tab[i + <span class="number">1</span>];</span><br><span class="line">            tab[i + <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            closeDeletion(i); <span class="comment">//删除节点后重新散列所有可能冲突的节点</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        i = nextKeyIndex(i, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过键值对移除节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">removeMapping</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    Object[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = hash(k, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        Object item = tab[i];</span><br><span class="line">        <span class="keyword">if</span> (item == k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tab[i + <span class="number">1</span>] != value)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            modCount++;</span><br><span class="line">            size--;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            tab[i + <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">            closeDeletion(i);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        i = nextKeyIndex(i, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>IdentityHashMap的数据结构是<code>线性探针表</code></p></li><li><p>IdentityHashMap采用的是<code>引用相等</code>，而HashMap采用的是<code>对象相等</code></p></li><li><p>IdentityHashMap默认容量大小是64，个人认为加载因子是1/3</p></li><li><p>IdentityHashMap的容量大小必须是2的幂次方</p></li><li><p>IdentityHashMap用于序列化或深拷贝、代理场景中，不过即使这么说，我还是没能感受到它的用处</p></li><li><p>IdentityHashMap无序、不可重复、非线程安全</p></li><li><p>IdentityHashMap的键值对允许存放null</p></li><li><p><code>添加节点流程</code>：首先获取索引位置，接着若发现当前位置上不存在节点则直接添加皆可，若发现当前位置上已经存在节点了则比较两者是否相等（采用 k1 == k2的方式），若相等则说明重复进行替换值即可，若不相等说明发生冲突，它会往后查抄偶数索引位置，直到发现偶数索引位置上不存在节点时才进行存储</p></li><li><p><code>扩容机制</code>：在添加元素时判断当前节点个数是否超过了容量的1/3，若超过则以<code>2倍大小</code>进行扩容，扩容时对哈希探针表中的所有节点进行重新散列，扩容结束后从重新走上面的添加节点流程，因为节点的索引位置已经发生变化；最大键值对是 1 &lt;&lt; 29，最小键值对是 4，虽说最大键值对是1 &lt;&lt; 29，但实际上能存储的最大键值对是 1 &lt;&lt; 29 -1，因为它要保留一个null来防止死循环，在程序中它采用的是不断遍历哈希探针表来获取偶数位置上不存在节点的索引，若所有位置上都填充了节点，就会陷入死循环中，所以至少要有这样子的一个null</p></li><li><p><code>删除节点流程</code>：在删除节点后，它会重新散列所有可能冲突的节点。按照上面的添加节点流程中我们知道，两个节点即使发生冲突了也只是找其他的位置进行存储，这和不冲突的情况下进行存储并没有什么区别，所以在删除节点后，它会重新散列所有节点</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>resize</code> <code>put</code> <code>remove</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前沿&quot;&gt;&lt;a href=&quot;#前沿&quot; class=&quot;headerlink&quot; title=&quot;前沿&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前沿&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;我也是第一次认识IdentityHashMap，在工作中从未使用过它，所以对它的使用场景可能并不是很了解，本文也仅仅针对基于&lt;code&gt;JDK1.8&lt;/code&gt;的源码进行探索。&lt;code&gt;IdentityHashMap&lt;/code&gt;的数据结构应该是如图所示：&lt;/p&gt;
&lt;p class=&quot;customize-img&quot;&gt;&lt;img src=&quot;/assets/blogImg/java/identityhashmap/data-structure.png&quot; alt=&quot;IdentityHashMap数据结构&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个数据结构是我在看源码之前看了几篇别人写的文章所了解到的，个人喜欢在看源码对目标有所了解的习惯，紧接着才去深入它。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索HashMap底层实现</title>
    <link href="http://zlia.tech/2019/10/21/explain-hashmap-sourcecode/"/>
    <id>http://zlia.tech/2019/10/21/explain-hashmap-sourcecode/</id>
    <published>2019-10-21T02:32:13.000Z</published>
    <updated>2019-10-31T03:29:26.045Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>探索<code>HashMap</code>底层实现是基于<code>JDK1.8</code>，看代码之前翻了一下别人写的博客我才知道<code>JDK1.7</code>版本的HashMap是由<code>数组 + 链表</code>的数据结构组成，而对于JDK1.8是由<code>数组 + 链表 + 红黑树</code>的数据结构组成，所以我又去了解了什么是二叉树、平衡二叉树、红黑树，为的就是能做个铺垫。既然是由数组、链表、红黑树组成，加上平时我们了解过的一些细节，可以猜到它的数据结构应该是这样子的，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/java/hashmap/hashmap-data-structure.png" alt="HashMap数据结构"></p><p>长的虽然有点丑。下面我们就开始探索它吧，还是先从注释开始看！</p><a id="more"></a><h3 id="阅读注释"><a href="#阅读注释" class="headerlink" title="阅读注释"></a><div><span>阅读注释</span></div></h3><p class="customize-img"><img src="/assets/blogImg/java/hashmap/hashmap-comment-1.png" alt="HashMap注释-1"></p><p>HashMap的每个节点都由一个键值对组成，也就是一个Key对应着一个Value，相当于绑定关系了，这两者都可以为Null。Hashtable的代码我还没有看过，不过这个结论不用质疑。HashMap是<code>无序</code>的，这跟它的实现机制有关。</p><p class="customize-img"><img src="/assets/blogImg/java/hashmap/hashmap-comment-2.png" alt="HashMap注释-2"></p><p>简单来说，迭代所需的时间与遍历数组、链表、红黑树的大小成比例，因为数据有可能存放在链表、红黑树中，它要把所有的数据都遍历出来。</p><p class="customize-img"><img src="/assets/blogImg/java/hashmap/hashmap-comment-3.png" alt="HashMap注释-3"></p><p>当哈希表中元素的填充数量超过加载因子与当前容量的乘积时，就会发生扩容！</p><p class="customize-img"><img src="/assets/blogImg/java/hashmap/hashmap-comment-4.png" alt="HashMap注释-4"></p><p>为什么较高的加载因子会减少空间开销，增加了查找的成本呢？加载因子表示元素填满的程度，在容量不变的情况下，随着加载因子越大，填满的元素就越多，空间利用率变大了。假设容量固定值为16，有以下情况：</p><ul><li><p>A. 加载因子0.75，该数组在不扩容的情况下最多可填充0.75 * 16 = 12。</p></li><li><p>B. 加载因子1，该数组在不扩容的情况下最多可填充1* 16 = 16。</p></li></ul><p>所以我们说空间利用率变大了，同样的，元素多了，查找的成本也就自然增加了。</p><p class="customize-img"><img src="/assets/blogImg/java/hashmap/hashmap-comment-5.png" alt="HashMap注释-5"></p><p>若是知道键值对的数量，可创建具有指定容量大小的HashMap。</p><p class="customize-img"><img src="/assets/blogImg/java/hashmap/hashmap-comment-6.png" alt="HashMap注释-6"></p><p>HashMap属于非线程安全，需要在外部进行控制。</p><p class="customize-img"><img src="/assets/blogImg/java/hashmap/hashmap-comment-7.png" alt="HashMap注释-7"></p><p>Java提供了方法来保证HashMap的线程安全。</p><p class="customize-img"><img src="/assets/blogImg/java/hashmap/hashmap-comment-8.png" alt="HashMap注释-8"></p><p>该说法很ArrayList很像。</p><p class="customize-img"><img src="/assets/blogImg/java/hashmap/hashmap-comment-9.png" alt="HashMap注释-9"></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唯一序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的初始容量，必须是2的幂次方！！！</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 1 &lt;&lt; 4 = 16，为什么不直接写16呢?</span></span><br><span class="line"><span class="comment">     * 我们都知道计算机底层都是用二进制操作的，而如果直接写16的话最终还是要转换成二进制，对于位运算来说，就是直接用二进制进行计算的，所以效率会更高一些</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 为什么是2的幂次方?</span></span><br><span class="line"><span class="comment">     * HashMap的底层是由数组 + 链表 + 红黑树组成的，那么先从数组开始存起，先不管规则如何，想要往数组中存入元素，必须要先知道指定索引</span></span><br><span class="line"><span class="comment">     * 虽然和ArrayList一样都是数组，但对于HashMap添加一个元素来说，并不是按照顺序存入，那将和ArrayList没什么区别了</span></span><br><span class="line"><span class="comment">     * 既然不是按顺序存入，那就是按照一定的规则去计算索引了，当然了，这个规则不能是死的，所以只能拿着传入的值进行一定的规则运算</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 因为HashMap可以存入任意类型的元素，不管是Key还是Value，所以对于任意类型来说都应该可以使用这个规则，也就是说它必须存在于任意类型中，不管是方法还是成员变量，那我们能想到的</span></span><br><span class="line"><span class="comment">     * 也只有Object了，它是所有类型的父类，加上索引的值应该是int类型的，所以它最终采用了hashCode方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 不过你会发现hashCode方法返回的数值是不可预测的，而对于HashMap中的数组来说，索引的取值必须要在0~15之间，所以这个规则还没有结束，必须把hashCode的结果控制在0-15之间</span></span><br><span class="line"><span class="comment">     * 第一个反应想到的对容量大小采用取余运算，没错，是可以的，但是有更好的方法，就像上面一样，为了提高效率采用了位运算，这里我们采用的位运算是&amp;</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 那为什么不用 | 呢？只能说在A | B计算中（A相当于是hashCode，B相当于是容量大小），B没办法对结果产生范围性的控制，比如下面：</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * A:    1000</span></span><br><span class="line"><span class="comment">     *    | </span></span><br><span class="line"><span class="comment">     * B：   0111</span></span><br><span class="line"><span class="comment">     * ----------</span></span><br><span class="line"><span class="comment">     *       1111</span></span><br><span class="line"><span class="comment">     * B的最大值只能取到7，而结果确实15，肯定不行，所以最终采用了&amp;。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 因为索引的最大值只能取到15，所以是 &amp; 15，如果是16，那么就能取到16造成索引越界了，不过它有一些要求（重点来了），细心的同学会发现在构造HashMap时是可以指定其他值，比如13、17，这* 些都不是2的幂次方，我们假设采用13</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   1000         0010</span></span><br><span class="line"><span class="comment">     * &amp;            &amp;</span></span><br><span class="line"><span class="comment">     *   1101         1101</span></span><br><span class="line"><span class="comment">     * -------      -------</span></span><br><span class="line"><span class="comment">     *   0000         0000</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 你可以都计算几个，我们发现，有些索引它没办法取到，就上面的索引为2它取不到，关键就是因为1101（13）中的第三位是0，不管上面的取值（hashCode）如何，它的结果都是0，所以它的值必须要* 是1才可以，才能取到所有的值，所以应该是1111这样子的一种格式，就是最后几位都是1，不能是0和1发生间隔，而我们刚才说了最多只能取到1111（15），这个值是由容量大小 -1 决定的，所以应* 该是capacity -1的结果要是1111的这种格式才可以，我们发现：</span></span><br><span class="line"><span class="comment">     * capacity = 111 + 1 = 1000 = 8</span></span><br><span class="line"><span class="comment">     * capacity = 1111 + 1 = 10000 = 16</span></span><br><span class="line"><span class="comment">     * capacity = 11111 + 1 = 100000 = 32</span></span><br><span class="line"><span class="comment">     * capacity = 111111 + 1 = 1000000 = 64</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 多的就不计算了，这些结果都是2的幂次方，不知道我讲明白了没有...</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * ===========================================================分割线=========================================================================================</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 既然已经解释那么多，还差一个，反正后面还是要解释的，就一起得了...</span></span><br><span class="line"><span class="comment">     * 到目前为止我们得到的结论是：hashCode &amp; (capacity - 1) ，还没有结束...</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 为了更好的说明接下来的问题，我们随便取值一个hashCode来做运算</span></span><br><span class="line"><span class="comment">     * 情况A：</span></span><br><span class="line"><span class="comment">     *      0000 0010 0100 0110 0000 0110 0000 0011</span></span><br><span class="line"><span class="comment">     *   &amp;</span></span><br><span class="line"><span class="comment">     *      0000 0000 0000 0000 0000 0000 0000 1111</span></span><br><span class="line"><span class="comment">     *  ---------------------------------------------</span></span><br><span class="line"><span class="comment">     *      0000 0000 0000 0000 0000 0000 0000 0011</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 看情况A我们可以看出对于hashCode来说，它的后面好几位（从右向左看）基本上没啥用，反正不管是1还是0，结果都是0，排面都是靠低位撑着呢...也就是说索引的结果基本上由低位说了算的，所以* 这样子造成了一个现象，有可能出现高位不同低位相同的两个数计算出的索引结果是一致的！看情况B：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 情况B：</span></span><br><span class="line"><span class="comment">     *      1111 0000 0000 0000 0000 0000 0000 0011</span></span><br><span class="line"><span class="comment">     *   &amp;</span></span><br><span class="line"><span class="comment">     *      0000 0000 0000 0000 0000 0000 0000 1111</span></span><br><span class="line"><span class="comment">     * ----------------------------------------------</span></span><br><span class="line"><span class="comment">     *      0000 0000 0000 0000 0000 0000 0000 0011</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 情况A与情况B的结果是一致的，可是它们的hashCode是不一样的啊，说明了这是两个不同的数，有点问题啊！所以我们必须对这个hashCode在做一次计算，因为要使得高位不同得出的结果应该也要不* 同，故而要拿这个高位来做文章才能做区分，最简单的方式是拿hashCode的高位与hashCode自身在做一次计算，在HashMap中16位我们称之位高位（从左向右开始数），所以是拿这个16位在做一次运* 算，同样是采用位运算，有可能是&amp;、|、^（异或）</span></span><br><span class="line"><span class="comment">     * 上面我们说，有可能出现高位不同低位相同的两个数，针对不同的位运算我们采用假设：</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 若是采用位运算&amp;，AB两个数的低位都为0，A的高位为1，B的高位为0，即使在做一次运算，得到的结果还是一样的</span></span><br><span class="line"><span class="comment">     * 若是采用位运算|，AB两个数的低位都为1，A的高位为0，B的高位为1，即使在做一次运算，得到的结果也是一样的</span></span><br><span class="line"><span class="comment">     * 若是采用位运算^，AB两个数的低位都为1，A的高位为0，B的高位为1，结果就不一样了，A的结果为0，B的结果为1，是不是巧合呢</span></span><br><span class="line"><span class="comment">     * 若是采用位运算^，AB两个数的低位都为1，A的高位为1，B的高位为0，结果也是不一样的</span></span><br><span class="line"><span class="comment">     * 若是采用位运算^，AB两个数的低位都为0，A的高位为0，B的高位为1，结果也是不一样的</span></span><br><span class="line"><span class="comment">     * 若是采用位运算^，AB两个数的低位都为0，A的高位为1，B的高位为0，结果也是不一样的</span></span><br><span class="line"><span class="comment">     * 已经很明显了，最终采用的位运算是^，所以会经过如下计算：hashCode ^ (hashCode &gt;&gt;&gt; 16)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ==============================================================分割线====================================================================================  </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 上面说的有点多来总结下吧：</span></span><br><span class="line"><span class="comment">     * 1. 为什么HashMap的容量大小必须是2的幂次方：因为在HashMap中采用了位运算&amp;代替了取余运算%，这样做是为了提升效率，不过在替换运算符号的同时也有一个要求，为了能取到区间中的每个数，</span></span><br><span class="line"><span class="comment">     * 比如0-15中的每个数都能取到，也就是说最后几位要是连续的1（01111，从左向右看），不能是0与1发生间隔，而把这个数去 + 1就等于容量大小，你会发现它正是2的幂次方，所以按照我个人的理解来说，就是在将&amp;替换了%后，为了能取到区间中的每* 个索引，必须是2的幂次方，有人将这种做法叫做均匀分布</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. 为什么采用hashCode方法：HashMap能存放任意类型的数据，要想按照HashMap的规则进行运算，在任意类型的数据当中一定存在着这些规则，那就只有Object#hashCode</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. result = hasCode ^ (hashCode &gt;&gt;&gt; 16)目的是什么：为了降低不同的数导致同样的结果（索引），简单来说就是为了降低碰撞，但还是有可能发生碰撞</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 4. result &amp; (capacity - 1)：计算索引的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大容量值，必须是2的幂次方</span></span><br><span class="line"><span class="comment">     * 当通过构造函数传入更高的值时会使用最大容量指来代替</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的加载因子</span></span><br><span class="line"><span class="comment">     * 设置成0.75是对空间与时间的一个权衡（折中），加载因子过大会减少空间开销，增加查找成本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当添加节点后链表的长度超过该数值时会将链表转换为红黑树，提升查询速度，但同时内存使用会增大，因为树节点的大小约是常规节点的两倍</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 为什么是8?</span></span><br><span class="line"><span class="comment">     * 在节点良好分布的情况下，基本不会用到红黑树。而在理想情况下的随机哈希，节点分布遵循泊松分布，链表下的长度达到8已经是非常小的概率，超过8的概率我们认为是几乎不可能发生的事情</span></span><br><span class="line"><span class="comment">     * 不过HashMap还是做了预防措施，当链表的长度达到8时会被转换成红黑树，至于为什么不是7，个人认为8更合适，应该尽可能的提升性能.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当红黑树的节点个数小于该数值时，红黑树将转换回链表</span></span><br><span class="line"><span class="comment">     * 这里有个点很重要，当初我以为红黑树在删除节点后长度就会变小，那应该会按照这个指标来将其变成单向链表结构，可惜不是，红黑树在删除节点前会判断是否次树过小，若过小则转换为链表，若不是则删除节点并进行自我平衡，所以只有在重新散列时* 才会判断该数值！！！！</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 为什么不是7?</span></span><br><span class="line"><span class="comment">     * 若是频繁地添加删除添加删除元素，那么HashMap将在转换中消耗很大的性能，而7的空隙让它有一个很好的缓冲</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当链表的长度大于8时：</span></span><br><span class="line"><span class="comment">     * 若哈希表的容量大于64，则将链表转换成红黑树</span></span><br><span class="line"><span class="comment">     * 若哈希表的容量小于64，数据结构保持不变，对哈希表进行扩容，扩容时原来的节点可能在旧的索引上，有可能在新的索引上（原来的索引 + 旧的容量大小）</span></span><br><span class="line"><span class="comment">     * 至少应该是4 * TREEIFY_THRESHOLD，防止重新散列和树化阈值(TREEIFY_THRESHOLD)产生冲突</span></span><br><span class="line"><span class="comment">     * 在哈希表容量很小的情况下，随着不断的添加节点，链表的长度会越来越大，也会有越来越多的链表，当长度超过一定的阈值之后便需要转换成红黑树，而在扩容时又需要拆解成链表，这些都是需要一定的成本，所以在容量较小的情况下直接选择* 扩容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义加载因子</span></span><br><span class="line"><span class="comment">     * 容量大小不变的情况下，加载因子过大减少空间开销，增加查询成本</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 注意：该属性是可以指定大于1，但是会造成一定的成本，具体可看threshold属性说明，最终是建议不应该超过1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希表</span></span><br><span class="line"><span class="comment">     * 数组结构中包括链表、红黑树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存entrySet方法的返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 键值对的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashMap中结构修改的次数</span></span><br><span class="line"><span class="comment">     * 在上面的翻译中我们已经解释了什么是结构修改</span></span><br><span class="line"><span class="comment">     * 该成员属性是用于检测迭代器的快速失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩容前需要判断的阈值</span></span><br><span class="line"><span class="comment">     * 若超过该值则扩容，若没超过则不需要</span></span><br><span class="line"><span class="comment">     * 该值的计算方式：capacity * load factor</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 注意：该属性是可以超过指定容量大小（capacity），准备来说，应该是加载因子（load factor）可以指定大于1，下面假设是2</span></span><br><span class="line"><span class="comment">     * 相当于指定了容量大小是10，但是会到大于20时才会扩充容量</span></span><br><span class="line"><span class="comment">     * 当填充的元素个数超过10个而小于20个后，那么后续的元素必定会造成碰撞从而形成链表或红黑树，这就为后续的增加/查找造成了一定的成本</span></span><br><span class="line"><span class="comment">     * 所以建议加载因子（load factor）不应该超过1</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 我为什么会想到这个注意点呢，是因为putMapEntries方法中有一段代码：float ft = ((float)s / loadFactor) + 1.0F，这段代码很有意思，可以看具体方法中的说明</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储Key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;K&gt; keySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储Value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Collection&lt;V&gt; values;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap的大部分知识点，包括一些细节方面，其实都在上面的注释中提到了，应该尽可能的去理解它！</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量与加载因子构造哈希表</span></span><br><span class="line"><span class="comment"> * 在上面中我们提到了容量必须是2的幂次方，所以调用tableSizeFor方法来进行调整</span></span><br><span class="line"><span class="comment"> * Float.isNaN：检测是否是数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor 指定加载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量与默认加载因子（0.75）构造哈希表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始容量（16）与默认加载因子（0.75）构造哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定集合添加到哈希表中，采用默认加载因子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h4><h5 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br><span class="line">1319</span><br><span class="line">1320</span><br><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br><span class="line">1345</span><br><span class="line">1346</span><br><span class="line">1347</span><br><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br><span class="line">1366</span><br><span class="line">1367</span><br><span class="line">1368</span><br><span class="line">1369</span><br><span class="line">1370</span><br><span class="line">1371</span><br><span class="line">1372</span><br><span class="line">1373</span><br><span class="line">1374</span><br><span class="line">1375</span><br><span class="line">1376</span><br><span class="line">1377</span><br><span class="line">1378</span><br><span class="line">1379</span><br><span class="line">1380</span><br><span class="line">1381</span><br><span class="line">1382</span><br><span class="line">1383</span><br><span class="line">1384</span><br><span class="line">1385</span><br><span class="line">1386</span><br><span class="line">1387</span><br><span class="line">1388</span><br><span class="line">1389</span><br><span class="line">1390</span><br><span class="line">1391</span><br><span class="line">1392</span><br><span class="line">1393</span><br><span class="line">1394</span><br><span class="line">1395</span><br><span class="line">1396</span><br><span class="line">1397</span><br><span class="line">1398</span><br><span class="line">1399</span><br><span class="line">1400</span><br><span class="line">1401</span><br><span class="line">1402</span><br><span class="line">1403</span><br><span class="line">1404</span><br><span class="line">1405</span><br><span class="line">1406</span><br><span class="line">1407</span><br><span class="line">1408</span><br><span class="line">1409</span><br><span class="line">1410</span><br><span class="line">1411</span><br><span class="line">1412</span><br><span class="line">1413</span><br><span class="line">1414</span><br><span class="line">1415</span><br><span class="line">1416</span><br><span class="line">1417</span><br><span class="line">1418</span><br><span class="line">1419</span><br><span class="line">1420</span><br><span class="line">1421</span><br><span class="line">1422</span><br><span class="line">1423</span><br><span class="line">1424</span><br><span class="line">1425</span><br><span class="line">1426</span><br><span class="line">1427</span><br><span class="line">1428</span><br><span class="line">1429</span><br><span class="line">1430</span><br><span class="line">1431</span><br><span class="line">1432</span><br><span class="line">1433</span><br><span class="line">1434</span><br><span class="line">1435</span><br><span class="line">1436</span><br><span class="line">1437</span><br><span class="line">1438</span><br><span class="line">1439</span><br><span class="line">1440</span><br><span class="line">1441</span><br><span class="line">1442</span><br><span class="line">1443</span><br><span class="line">1444</span><br><span class="line">1445</span><br><span class="line">1446</span><br><span class="line">1447</span><br><span class="line">1448</span><br><span class="line">1449</span><br><span class="line">1450</span><br><span class="line">1451</span><br><span class="line">1452</span><br><span class="line">1453</span><br><span class="line">1454</span><br><span class="line">1455</span><br><span class="line">1456</span><br><span class="line">1457</span><br><span class="line">1458</span><br><span class="line">1459</span><br><span class="line">1460</span><br><span class="line">1461</span><br><span class="line">1462</span><br><span class="line">1463</span><br><span class="line">1464</span><br><span class="line">1465</span><br><span class="line">1466</span><br><span class="line">1467</span><br><span class="line">1468</span><br><span class="line">1469</span><br><span class="line">1470</span><br><span class="line">1471</span><br><span class="line">1472</span><br><span class="line">1473</span><br><span class="line">1474</span><br><span class="line">1475</span><br><span class="line">1476</span><br><span class="line">1477</span><br><span class="line">1478</span><br><span class="line">1479</span><br><span class="line">1480</span><br><span class="line">1481</span><br><span class="line">1482</span><br><span class="line">1483</span><br><span class="line">1484</span><br><span class="line">1485</span><br><span class="line">1486</span><br><span class="line">1487</span><br><span class="line">1488</span><br><span class="line">1489</span><br><span class="line">1490</span><br><span class="line">1491</span><br><span class="line">1492</span><br><span class="line">1493</span><br><span class="line">1494</span><br><span class="line">1495</span><br><span class="line">1496</span><br><span class="line">1497</span><br><span class="line">1498</span><br><span class="line">1499</span><br><span class="line">1500</span><br><span class="line">1501</span><br><span class="line">1502</span><br><span class="line">1503</span><br><span class="line">1504</span><br><span class="line">1505</span><br><span class="line">1506</span><br><span class="line">1507</span><br><span class="line">1508</span><br><span class="line">1509</span><br><span class="line">1510</span><br><span class="line">1511</span><br><span class="line">1512</span><br><span class="line">1513</span><br><span class="line">1514</span><br><span class="line">1515</span><br><span class="line">1516</span><br><span class="line">1517</span><br><span class="line">1518</span><br><span class="line">1519</span><br><span class="line">1520</span><br><span class="line">1521</span><br><span class="line">1522</span><br><span class="line">1523</span><br><span class="line">1524</span><br><span class="line">1525</span><br><span class="line">1526</span><br><span class="line">1527</span><br><span class="line">1528</span><br><span class="line">1529</span><br><span class="line">1530</span><br><span class="line">1531</span><br><span class="line">1532</span><br><span class="line">1533</span><br><span class="line">1534</span><br><span class="line">1535</span><br><span class="line">1536</span><br><span class="line">1537</span><br><span class="line">1538</span><br><span class="line">1539</span><br><span class="line">1540</span><br><span class="line">1541</span><br><span class="line">1542</span><br><span class="line">1543</span><br><span class="line">1544</span><br><span class="line">1545</span><br><span class="line">1546</span><br><span class="line">1547</span><br><span class="line">1548</span><br><span class="line">1549</span><br><span class="line">1550</span><br><span class="line">1551</span><br><span class="line">1552</span><br><span class="line">1553</span><br><span class="line">1554</span><br><span class="line">1555</span><br><span class="line">1556</span><br><span class="line">1557</span><br><span class="line">1558</span><br><span class="line">1559</span><br><span class="line">1560</span><br><span class="line">1561</span><br><span class="line">1562</span><br><span class="line">1563</span><br><span class="line">1564</span><br><span class="line">1565</span><br><span class="line">1566</span><br><span class="line">1567</span><br><span class="line">1568</span><br><span class="line">1569</span><br><span class="line">1570</span><br><span class="line">1571</span><br><span class="line">1572</span><br><span class="line">1573</span><br><span class="line">1574</span><br><span class="line">1575</span><br><span class="line">1576</span><br><span class="line">1577</span><br><span class="line">1578</span><br><span class="line">1579</span><br><span class="line">1580</span><br><span class="line">1581</span><br><span class="line">1582</span><br><span class="line">1583</span><br><span class="line">1584</span><br><span class="line">1585</span><br><span class="line">1586</span><br><span class="line">1587</span><br><span class="line">1588</span><br><span class="line">1589</span><br><span class="line">1590</span><br><span class="line">1591</span><br><span class="line">1592</span><br><span class="line">1593</span><br><span class="line">1594</span><br><span class="line">1595</span><br><span class="line">1596</span><br><span class="line">1597</span><br><span class="line">1598</span><br><span class="line">1599</span><br><span class="line">1600</span><br><span class="line">1601</span><br><span class="line">1602</span><br><span class="line">1603</span><br><span class="line">1604</span><br><span class="line">1605</span><br><span class="line">1606</span><br><span class="line">1607</span><br><span class="line">1608</span><br><span class="line">1609</span><br><span class="line">1610</span><br><span class="line">1611</span><br><span class="line">1612</span><br><span class="line">1613</span><br><span class="line">1614</span><br><span class="line">1615</span><br><span class="line">1616</span><br><span class="line">1617</span><br><span class="line">1618</span><br><span class="line">1619</span><br><span class="line">1620</span><br><span class="line">1621</span><br><span class="line">1622</span><br><span class="line">1623</span><br><span class="line">1624</span><br><span class="line">1625</span><br><span class="line">1626</span><br><span class="line">1627</span><br><span class="line">1628</span><br><span class="line">1629</span><br><span class="line">1630</span><br><span class="line">1631</span><br><span class="line">1632</span><br><span class="line">1633</span><br><span class="line">1634</span><br><span class="line">1635</span><br><span class="line">1636</span><br><span class="line">1637</span><br><span class="line">1638</span><br><span class="line">1639</span><br><span class="line">1640</span><br><span class="line">1641</span><br><span class="line">1642</span><br><span class="line">1643</span><br><span class="line">1644</span><br><span class="line">1645</span><br><span class="line">1646</span><br><span class="line">1647</span><br><span class="line">1648</span><br><span class="line">1649</span><br><span class="line">1650</span><br><span class="line">1651</span><br><span class="line">1652</span><br><span class="line">1653</span><br><span class="line">1654</span><br><span class="line">1655</span><br><span class="line">1656</span><br><span class="line">1657</span><br><span class="line">1658</span><br><span class="line">1659</span><br><span class="line">1660</span><br><span class="line">1661</span><br><span class="line">1662</span><br><span class="line">1663</span><br><span class="line">1664</span><br><span class="line">1665</span><br><span class="line">1666</span><br><span class="line">1667</span><br><span class="line">1668</span><br><span class="line">1669</span><br><span class="line">1670</span><br><span class="line">1671</span><br><span class="line">1672</span><br><span class="line">1673</span><br><span class="line">1674</span><br><span class="line">1675</span><br><span class="line">1676</span><br><span class="line">1677</span><br><span class="line">1678</span><br><span class="line">1679</span><br><span class="line">1680</span><br><span class="line">1681</span><br><span class="line">1682</span><br><span class="line">1683</span><br><span class="line">1684</span><br><span class="line">1685</span><br><span class="line">1686</span><br><span class="line">1687</span><br><span class="line">1688</span><br><span class="line">1689</span><br><span class="line">1690</span><br><span class="line">1691</span><br><span class="line">1692</span><br><span class="line">1693</span><br><span class="line">1694</span><br><span class="line">1695</span><br><span class="line">1696</span><br><span class="line">1697</span><br><span class="line">1698</span><br><span class="line">1699</span><br><span class="line">1700</span><br><span class="line">1701</span><br><span class="line">1702</span><br><span class="line">1703</span><br><span class="line">1704</span><br><span class="line">1705</span><br><span class="line">1706</span><br><span class="line">1707</span><br><span class="line">1708</span><br><span class="line">1709</span><br><span class="line">1710</span><br><span class="line">1711</span><br><span class="line">1712</span><br><span class="line">1713</span><br><span class="line">1714</span><br><span class="line">1715</span><br><span class="line">1716</span><br><span class="line">1717</span><br><span class="line">1718</span><br><span class="line">1719</span><br><span class="line">1720</span><br><span class="line">1721</span><br><span class="line">1722</span><br><span class="line">1723</span><br><span class="line">1724</span><br><span class="line">1725</span><br><span class="line">1726</span><br><span class="line">1727</span><br><span class="line">1728</span><br><span class="line">1729</span><br><span class="line">1730</span><br><span class="line">1731</span><br><span class="line">1732</span><br><span class="line">1733</span><br><span class="line">1734</span><br><span class="line">1735</span><br><span class="line">1736</span><br><span class="line">1737</span><br><span class="line">1738</span><br><span class="line">1739</span><br><span class="line">1740</span><br><span class="line">1741</span><br><span class="line">1742</span><br><span class="line">1743</span><br><span class="line">1744</span><br><span class="line">1745</span><br><span class="line">1746</span><br><span class="line">1747</span><br><span class="line">1748</span><br><span class="line">1749</span><br><span class="line">1750</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定容量大小调整到2的幂次方</span></span><br><span class="line"><span class="comment"> * 具体是调整到比该容量还大的最近2的幂次方</span></span><br><span class="line"><span class="comment"> * cap = 21 最终调整到 32</span></span><br><span class="line"><span class="comment"> * cap = 15 最终调整到 16</span></span><br><span class="line"><span class="comment"> * 若是2的幂次方则结果是原来的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cap 指定容量大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 2的幂次方</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定集合中的元素添加到哈希表中</span></span><br><span class="line"><span class="comment"> * 若哈希表为空，表达式s/loadFactor有可能出现带有小数的情况，比如1.6、1.4这样子的一种格式</span></span><br><span class="line"><span class="comment"> * 而后续的 + 1.0F 和 (int)ft 相当于是对小数点做一个向上取整，以尽可能的保证更大容量</span></span><br><span class="line"><span class="comment"> * 若哈希表不为空，则预先进行扩容一次，若没有预先进行扩容，而是等到后续添加元素达到阈值后才开始扩容，那个时候随着元素的增加扩容所消耗的时间也会增加，简单来说，减少了一定的时间成本</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 总结：</span></span><br><span class="line"><span class="comment"> * 若哈希表已初始化，则采用它自身的容量进行扩容</span></span><br><span class="line"><span class="comment"> * 若哈希表未初始化，则采用集合的容量作为哈希表的容量大小，前提是大于哈希表的容量大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取哈希表中的元素个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希表中的元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断哈希表是否为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希表是否为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定键查找节点</span></span><br><span class="line"><span class="comment"> * HashMap在插入节点时先通过hashCode进行比较，若两者相同在通过equals进行比较，若也相同则认为是重复，会进行相应的覆盖，若不相等则用链表或红黑树进行存储</span></span><br><span class="line"><span class="comment"> * 按照如此的思路，要查找某个节点，则hashCode与equals必须都相等，若有其中一个不相等则继续查找下一个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 键的哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定键对应的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定键计算哈希值</span></span><br><span class="line"><span class="comment"> * 至于为什么是这么计算的可参考一开始提到的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 哈希值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断指定类是否实现了Comparable，同时Comparable的泛型是它自身</span></span><br><span class="line"><span class="comment"> * 简单来说就是判断指定类C是否满足`class C implements Comparable&lt;C&gt;`这样子的一种格式，若满足则返回该类的class，否则返回null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 指定类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> x.getClass or null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">        Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;</span><br><span class="line">        <span class="keyword">if</span> ((c = x.getClass()) == String.class) <span class="comment">// bypass checks</span></span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        <span class="keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ts.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((t = ts[i]) <span class="keyword">instanceof</span> ParameterizedType) &amp;&amp;</span><br><span class="line">                    ((p = (ParameterizedType)t).getRawType() ==</span><br><span class="line">                     Comparable.class) &amp;&amp;</span><br><span class="line">                    (as = p.getActualTypeArguments()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    as.length == <span class="number">1</span> &amp;&amp; as[<span class="number">0</span>] == c) <span class="comment">// type arg is c</span></span><br><span class="line">                    <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 若x与kc的类型相同则比较x与k的大小，实际上k与kc的类类型是同一个，简单来说就是在比较k与x的大小，既然是比较，类类型是一样的才有意义</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> kc k的类类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 比较值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 另一个比较值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 比较结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareComparables</span><span class="params">(Class&lt;?&gt; kc, Object k, Object x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x == <span class="keyword">null</span> || x.getClass() != kc ? <span class="number">0</span> :</span><br><span class="line">            ((Comparable)k).compareTo(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否包含指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化哈希表或以两倍的大小进行扩容，扩容后进行重新散列-rehash</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * rehash机制：</span></span><br><span class="line"><span class="comment"> * 若指定索引上存在元素且没有链表或红黑树结构，则在新数组上重新计算索引并填充即可</span></span><br><span class="line"><span class="comment"> * 若指定索引上存在元素且结构是链表，将链表分成高低位两条链表并往新数组中填充，高位链表会存储在新索引上（原索引 + 旧容量大小），低位链表存储在原索引上</span></span><br><span class="line"><span class="comment"> * 若指定索引上存在元素且结构是红黑树，将红黑树分成高低位两棵树，低位这棵树中的长度若超过8，在判断高位那棵树是否存在，若不存在说明低位已经树形化过，若存在说明结构已经修改，低位需要重新树形化，若低位这棵树的长度不超过8则将这棵树转换* 成单向链表的结构，同理对于处理高位这棵树也是如此判断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length; <span class="comment">//旧容量</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold; <span class="comment">//旧阈值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>; <span class="comment">//新容量与新阈值</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123; <span class="comment">//旧容量超过最大容量时</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY) <span class="comment">//新容量是旧容量的两倍大小</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">//新阈值是旧阈值的两倍大小</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">//threshold大于0说明采用了自定义的初始容量大小，而一开始threshold存放了初始容量的大小</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">//threshold小于0说明采用默认初始容量大小与加载因子</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123; <span class="comment">//只有在采用自定义初始容量大小的情况下才会进入到该语句中</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap]; <span class="comment">//使用新容量创建新数组以便进行扩容</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>) <span class="comment">//哈希表指定索引上只有一个元素，也就是说该位置上不存在链表或者红黑树之类的数据结构</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e; <span class="comment">//将该位置上的元素按照新容量重新散列，也就是在新数组中重新计算索引并填充，至于为什么是这么计算的，最上面应该提到了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) <span class="comment">//哈希表指定索引上是红黑树，红黑树将自身拆解成高低位两棵树，具体可参见split方法</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; </span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 哈希表指定索引上是一条链表，根据哈希值将一条链表上的节点分成高位、低位两部分组成的两条链表（分组），将高低位两条链条填充到新数组中，高位填充到新索引（原索引 + 旧容量大小）处，而低位的索引保持不变</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * 首先应该明白oldCap是2的幂次方，它的二进制应该是0000 0000 0000 0000 0000 0000 0000 1000 这样子的一种格式</span></span><br><span class="line"><span class="comment">                         * e.hash &amp; oldCap：将结果大于0的节点构成一组链表，既然是链表就有头部节点与尾部节点，所以这就对应了上面的hiHead、hiTail，我们称作高位；同样的将结果小于0</span></span><br><span class="line"><span class="comment">                         * 的节点构成另外一组链表，对应着loHead、loTail，我们称作低位</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 为什么在新的哈希表中索引只可能出现在旧索引处或旧索引 + 旧容量大小处</span></span><br><span class="line"><span class="comment">                     * 首先索引的计算方式是：e.hash &amp; (capacity-1)，方便理解我们直接举例</span></span><br><span class="line"><span class="comment">                     * oldCapacity：16  newCapacity：32   node1：0000 0000 0000 0000 0000 1111 0000 1010  node2：0000 0000 0000 0000 0000 1111 0001 1010</span></span><br><span class="line"><span class="comment">                     *         node1 &amp; (oldCapacity -1)                                           node2 &amp; (oldCapacity -1)</span></span><br><span class="line"><span class="comment">                     * </span></span><br><span class="line"><span class="comment">                     *    0000 0000 0000 0000 0000 1111 0000 1010                        0000 0000 0000 0000 0000 1111 0001 1010     </span></span><br><span class="line"><span class="comment">                     * &amp;  0000 0000 0000 0000 0000 0000 0000 1111                   &amp;    0000 0000 0000 0000 0000 0000 0000 1111</span></span><br><span class="line"><span class="comment">                     * --------------------------------------------                    ------------------------------------------</span></span><br><span class="line"><span class="comment">                     *    0000 0000 0000 0000 0000 0000 0000 1010                        0000 0000 0000 0000 0000 0000 0000 1010</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     *         node1 &amp; (newCapacity -1)                                           node2 &amp; (newCapacity -1)</span></span><br><span class="line"><span class="comment">                     * </span></span><br><span class="line"><span class="comment">                     *    0000 0000 0000 0000 0000 1111 0000 1010                        0000 0000 0000 0000 0000 1111 0001 1010     </span></span><br><span class="line"><span class="comment">                     * &amp;  0000 0000 0000 0000 0000 0000 0001 1111                   &amp;    0000 0000 0000 0000 0000 0000 0001 1111</span></span><br><span class="line"><span class="comment">                     * --------------------------------------------                    ------------------------------------------</span></span><br><span class="line"><span class="comment">                     *    0000 0000 0000 0000 0000 0000 0000 1010                        0000 0000 0000 0000 0000 0000 0001 1010</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * 在旧容量当中索引取决于最后的4位，而在新容量当中索引取决于最后的5位，旧容量与新容量相比最大的差别在于倒数第5位上，而能造成它们索引不同的情况就要看hash值的倒数第5位上是否是1</span></span><br><span class="line"><span class="comment">                     * 若不是1，&amp;完之后结果自然为0，此时的新容量下的索引与旧容量下的索引是一致的；若是1，&amp;完之后结果自然是1，而正好该位置上是旧容量的大小（倒数第5位），如果转换成十进制的话，此时新容量下的索引是旧容量下的索引 +  * 旧容量大小，所以我们可以得出在新容量下的索引只可能出现在这两种情况下。而在计算当中采用 e.hash &amp; oldCap就是在判断倒数第5位是否是1，若是1则索引是旧容量下的索引 + 旧容量大小，若不是1，则还是原来的索引</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定索引上的单向链表结构转成红黑树 + 双向链表</span></span><br><span class="line"><span class="comment"> * 链表长度不仅要超过8，同时哈希表的长度要超过64，否则直接进行扩容</span></span><br><span class="line"><span class="comment"> * 为什么还要采用双向链表呢?</span></span><br><span class="line"><span class="comment"> * 因为在转成红黑树后需要将根节点移动到链表的头部，这就需要更改链表节点之间的关系，而单向链表中是不知道上一个节点是谁，若想知道的话就还需要从头遍历，所以采用双向链表</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tab 新数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 哈希值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123; <span class="comment">//将链表转成双向链表</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>); <span class="comment">//将节点信息变成红黑树节点</span></span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab); <span class="comment">//将双向链表转成红黑树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将节点信息转换成红黑树节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> next 下一个节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 红黑树节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 转换成普通的节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> next 下一个节点信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 普通节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表树形化</span></span><br><span class="line"><span class="comment"> * 单向链表 -&gt; 双向链表 + 红黑树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tab 哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="comment">//若根节点不存在则进行设置</span></span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            root = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123; <span class="comment">//存在根节点则要进行左右子树的比较来选择最终的存储点</span></span><br><span class="line">                <span class="keyword">int</span> dir, ph;</span><br><span class="line">                K pk = p.key;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h) <span class="comment">//通过比较hash值，此时说明x节点小于根节点，故应该在左子树</span></span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h) <span class="comment">//右子树上</span></span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp; <span class="comment">//若当前节点与另外一个节点的hash相等的话，就比较键值，若键值也相同的话就比较类名</span></span><br><span class="line">                            (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                            (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p; <span class="comment">//xp是p节点的父节点</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123; <span class="comment">//查找到叶子节点后说明后续已经没有节点了，可以进行插入了</span></span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    root = balanceInsertion(root, x); <span class="comment">//插入后仍然需要维持红黑树的平衡，通过左右旋转的方式来维持平衡</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    moveRootToFront(tab, root); <span class="comment">//将根节点移动到链表头部</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先比较两个对象的类名是否相等，若相等则比较两个对象的哈希值大小并返回结果，若不相等则返回结果</span></span><br><span class="line"><span class="comment"> * 若对象为空，则哈希值等于0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> b 另一个对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 比较结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tieBreakOrder</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span> ||</span><br><span class="line">        (d = a.getClass().getName().</span><br><span class="line">            compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">        d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span><br><span class="line">                -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树中插入节点后维持平衡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 插入节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * xp = x.parent    x的父节点</span></span><br><span class="line"><span class="comment">        * xpp = x.parent.parent x的爷爷节点</span></span><br><span class="line"><span class="comment">        * xppl = x.parent.parent.left  x的爷爷节点的左子树</span></span><br><span class="line"><span class="comment">        * xppr = x.parent.parent.right  x的爷爷节点的右子树</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    x.red = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123; <span class="comment">//1 x.parent == null 说明是根节点，将其变成黑色即可</span></span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>) <span class="comment">//2 xp = x.parent 说明x的父节点是黑色，不需要任何的操作</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123; <span class="comment">//3 x的父节点在x的爷爷节点的左子树上</span></span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123; <span class="comment">//4 x的父节点是红色，叔叔节点也是红色</span></span><br><span class="line">                xppr.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == xp.right) &#123; <span class="comment">//5 X的父节点在X的爷爷节点的左子树上，X在X的父节点的右子树上</span></span><br><span class="line">                    root = rotateLeft(root, x = xp);<span class="comment">//注意此时的x变成了原来x的父节点</span></span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123; <span class="comment">//6 X的父节点在X的爷爷节点的左子树上，X在X的父节点的左子树上</span></span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateRight(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//7 X的父节点在X的爷爷节点的右子树上</span></span><br><span class="line">            <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123; <span class="comment">//8 x的父节点是红色，叔叔节点也是红色</span></span><br><span class="line">                xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123; <span class="comment">//9 x的父节点在X的爷爷节点的右子树上，X在X的父节点的左子树上</span></span><br><span class="line">                    root = rotateRight(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123; <span class="comment">//10 x的父节点在X的爷爷节点的右子树上，X在X的父节点的右子树上</span></span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树中指定节点进行左旋</span></span><br><span class="line"><span class="comment"> * 过多的算法就不讨论了，可以参考红黑树、AVL树的文章</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 指定节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * r = p.right 当前节点的右子树</span></span><br><span class="line"><span class="comment">     * rl = r.left 当前节点的右子树的左子树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>)</span><br><span class="line">            rl.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">            (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">            pp.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = r;</span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树中指定节点进行右旋</span></span><br><span class="line"><span class="comment"> * 过多的算法就不讨论了，可以参考红黑树、AVL树的文章</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 指定节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (l = p.left) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="keyword">null</span>)</span><br><span class="line">            lr.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">            (root = l).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)</span><br><span class="line">            pp.right = l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.left = l;</span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将根节点移动到链表的头部</span></span><br><span class="line"><span class="comment"> * 看到这里我发现，它不仅保留了双向链表同时增加了红黑树，所以在查找的时候应该是使用的红黑树结构</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tab 哈希表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; tab != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; root.hash;</span><br><span class="line">        TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">        <span class="keyword">if</span> (root != first) &#123;</span><br><span class="line">            Node&lt;K,V&gt; rn;</span><br><span class="line">            tab[index] = root;</span><br><span class="line">            TreeNode&lt;K,V&gt; rp = root.prev;</span><br><span class="line">            <span class="keyword">if</span> ((rn = root.next) != <span class="keyword">null</span>)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)rn).prev = rp;</span><br><span class="line">            <span class="keyword">if</span> (rp != <span class="keyword">null</span>)</span><br><span class="line">                rp.next = rn;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                first.prev = root;</span><br><span class="line">            root.next = first;</span><br><span class="line">            root.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前节点作为查找的起始节点，查找其所有子节点中是否有匹配到指定节点，匹配必须是hash相同、equals相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h 哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 指定节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> kc 比较器的泛型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">        TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h) <span class="comment">//当前节点的hash大于指定节点的hash，后续应该从左子树进行下一轮比较</span></span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h) <span class="comment">//当前节点的hash小于指定节点的hash，后续应该从右子树进行下一轮比较</span></span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk))) <span class="comment">//当前节点的hash与指定节点的hash相同，同时equals也相等</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//执行到这里说明当前节点的hash与指定节点的hash相同，但是equals不相等，因为接下来不知道该从左子树还是右子树开始查找，所以要先判断是否存在左右子树</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>) <span class="comment">//若左子树为空，那只能从右子树开始进行下一轮比较</span></span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>) <span class="comment">// 若右子树为空，那只能从左子树开始进行下一轮比较</span></span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                    (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                    (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>) </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                * 若左右子树都不为空，那就必须定义一种规则了，通过comparable方法来比较key的大小</span></span><br><span class="line"><span class="comment">                * 首先得先检测是否实现了comparable才可以进行比较-comparableClassFor</span></span><br><span class="line"><span class="comment">                * 接着还得检测是否类型相同，否则也不具备可比性</span></span><br><span class="line"><span class="comment">                * 若满足以上两点则返回比较结果</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>) <span class="comment">//执行到这里说明无法通过comparable进行比较或者key在比较之后还是相等，只能先尝试从右子树开始查找</span></span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">//若右子树递归后还是未找到，那么就从左子树开始查找</span></span><br><span class="line">            p = pl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//最后未匹配的话就返回null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 将红黑树拆解成高低的两棵树，并根据判断来选择是转换成单向链表还是重新树形化</span></span><br><span class="line"><span class="comment"> * 若低位这棵树的长度不超过6，则将其转换成单向链表，同理高位这棵树也是这么判断的</span></span><br><span class="line"><span class="comment"> * 若低位这棵树的长度超过6，且另外一棵树高位不存在，说明红黑树并未将其拆解成两棵树，低位这棵树的结构仍是不变，故而不需要进行重新树形化，而若高位这棵树存在，则需要重新树形化，因为结构已经发生变化</span></span><br><span class="line"><span class="comment"> * 同理，高位也是如此判断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tab 新的哈希表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bit 旧的哈希表长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123; <span class="comment">//尝试将红黑树拆解成高低位的两棵树，至少何为高低位可参考上面的解释</span></span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">        e.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)  <span class="comment">//低位这棵树的长度小于链表的阈值则转换成链表结构</span></span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">//若hiHead为空，说明红黑树并未拆解成高低位两棵树，低位已经被树形化过了不需要重新树形化，若hiHead不为空，说明红黑树已经拆解成高低位两棵树，结构已经发生变化，低位需要重新树形化</span></span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树转换单向链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 链表的头部节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">        Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">            hd = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tl.next = p;</span><br><span class="line">        tl = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在哈希表中通过指定键移除节点</span></span><br><span class="line"><span class="comment"> * 返回值是null表示不存在移除的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定value，通过hash与equals找到节点后还要根据matchValue来判断是否需要判断value值相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> matchValue 标识是否需要判断value是否相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> movable 标识移除节点后是否需要移动其他节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 移除的节点或null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value, <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">//当前节点刚好是要移除的节点，链表的头部或红黑树的根节点</span></span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123; <span class="comment">//走到这里说明头部节点/根节点为匹配上，获取它的下一个节点，若有说明它的结构可能是红黑树或链表，若没有说明不存在移除的节点</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">//判断当前节点是否是红黑树结构</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);  <span class="comment">//从红黑树中查找节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123; <span class="comment">//从链表中查找节点</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e; <span class="comment">// 把当前节点p指向e，这一步是让p存储的永远下一次循环里e的父节点，如果下一次e匹配上了，那么p就是node的父节点</span></span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value || <span class="comment">//matchValue标识在找到节点后是否需要判断value值是否相等</span></span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode) <span class="comment">//从红黑树中移除节点</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p) <span class="comment">//说明头部节点刚好是要移除的节点，直接将它的下一个节点填充到哈希表中</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 说明链表中找到移除的节点，p是node的父节点，由于要删除node，所有只需要把p的下一个节点指向到node的下一个节点即可把node从链表中删除了</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在红黑树中通过指定键查找节点</span></span><br><span class="line"><span class="comment"> * 从根节点开始查找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h 哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树中移除当前节点</span></span><br><span class="line"><span class="comment"> * 调用该方法前当前节点必须存在</span></span><br><span class="line"><span class="comment"> * 作者说该方法的代码比典型的红黑删除代码更为混乱，因为红黑树在删除中会通过交换值的方式来删除，而在红黑树中还维护了一个双向链表，若是直接通过交换值会对双向链表中节点之间的关系造成错误，因此它采用了另外一种方式-交换树链接</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 交换树链接：当前节点与当前节点的右子树的最左节点进行交换，包括parent、left、right节点的关系都发生交换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tab 新的哈希表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> movable 标识移除节点后是否需要移动其他节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始处理链表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">    TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl; <span class="comment">//first、root：根节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev; <span class="comment">//succ：当前节点的下一个节点   pred：当前节点的上一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>) <span class="comment">//说明当前节点是根节点，直接将它的下一个节点作为根节点</span></span><br><span class="line">        tab[index] = first = succ;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//说明当前节点是某一个节点，移除当前节点时更改当前节点的上下节点的关系</span></span><br><span class="line">        pred.next = succ;</span><br><span class="line">    <span class="keyword">if</span> (succ != <span class="keyword">null</span>)</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span>) <span class="comment">//走到这里说明当前节点的下一个节点为空，即表明已经没有节点了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.parent != <span class="keyword">null</span>) </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * moveRootToFront是用来维持红黑树的根节点即为链表的头部，但是在该方法在调用moveRootToFront时会进行判断，也就是它可能不会被调用到，那么会造成红黑的根节点与链表的头部节点不一致</span></span><br><span class="line"><span class="comment">     * 这里获取的root指向的是链表的头部节点，并不是红黑树的根节点，故而还要往上查找根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        root = root.root();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.right == <span class="keyword">null</span> ||</span><br><span class="line">        (rl = root.left) == <span class="keyword">null</span> || rl.left == <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 通过root节点来判断此红黑树是否太小, 如果是则调用untreeify方法转为链表节点并返回，转链表后就无需再进行下面的红黑树处理，这比维持红黑树的平衡来说简单多了</span></span><br><span class="line"><span class="comment">         * 因为在删除节点后红黑树需要维持平衡，有可能根节点会发生变化，也有可能被置空（根节点与删除节点之间是父子节点的关系导致），而又由于没有调用moveRootToFront来更新根节点，导致下次在获取根节点时可能获取到的为空</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结束处理链表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开始处理红黑树</span></span><br><span class="line"></span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>, pl = left, pr = right, replacement; <span class="comment">//p：当前节点  pl：当前节点的左子树    pr：当前节点的右子树</span></span><br><span class="line">    <span class="comment">//1. 当前节点有两个子节点的情况下</span></span><br><span class="line">    <span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">        <span class="keyword">while</span> ((sl = s.left) != <span class="keyword">null</span>) <span class="comment">//找到当前节点的右子树的最左节点，即为s</span></span><br><span class="line">            s = sl;</span><br><span class="line">        <span class="keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="comment">//交换s与p的颜色，也就是交换当前节点与最左节点的颜色</span></span><br><span class="line">        TreeNode&lt;K,V&gt; sr = s.right;  <span class="comment">//最左节点的右子树，即为sr</span></span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;  <span class="comment">//当前节点的父节点，即为pp</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一次调整和第二次调整：将当前节点和最左节点进行了位置调换</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一次调整</span></span><br><span class="line">        <span class="keyword">if</span> (s == pr) &#123;  <span class="comment">//如果当前节点的右节点即为最左节点，则将当前节点的父节点赋值为最左节点，将最左节点的右节点赋值为当前节点</span></span><br><span class="line">            p.parent = s;</span><br><span class="line">            s.right = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; sp = s.parent; <span class="comment">//最左节点的父节点，即为sp</span></span><br><span class="line">            <span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123; <span class="comment">//将当前节点的父节点变成最左节点的父节点</span></span><br><span class="line">                <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                    sp.left = p; <span class="comment">//最左节点应该是在左子树上，这边的代码应该是会走进去，而不会走到else中；将最左节点的父节点的左子树变成当前节点</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sp.right = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>) <span class="comment">//最左节点的左子树必定为null，但有可能还有右子树，故而将它的右子树变成当前节点的右子树</span></span><br><span class="line">                pr.parent = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二次调整</span></span><br><span class="line">        p.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>)</span><br><span class="line">            sr.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>)</span><br><span class="line">            pl.parent = s;</span><br><span class="line">        <span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>)</span><br><span class="line">            root = s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = s;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = s;</span><br><span class="line">        <span class="keyword">if</span> (sr != <span class="keyword">null</span>) <span class="comment">//若最左节点的右子树不为空，则赋值replacement为最左节点的右子树</span></span><br><span class="line">            replacement = sr;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            replacement = p; <span class="comment">//若最左节点的右子树为空，则赋值replacement为当前节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 当前节点只有一个子节点且是左子树，replacement赋值当前节点的左子树</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)</span><br><span class="line">        replacement = pl;</span><br><span class="line">    <span class="comment">//3. 当前节点只有一个子节点且是右子树，replacement赋值为当前节点的右子树</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)</span><br><span class="line">        replacement = pr;</span><br><span class="line">    <span class="comment">//4. 当前节点无子节点，即本身是个叶子节点，replacement赋值为当前节点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        replacement = p;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第三次调整：使用replacement节点替换掉p节点的位置，将p节点移除</span></span><br><span class="line">    <span class="keyword">if</span> (replacement != p) &#123; <span class="comment">//这里说明当前节点不是叶子节点，直接用replacement代替当前节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent; <span class="comment">//获取当前节点的父节点</span></span><br><span class="line">        <span class="keyword">if</span> (pp == <span class="keyword">null</span>) <span class="comment">//说明当前节点是根节点</span></span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left) <span class="comment">//说明当前节点在父节点的左子树上</span></span><br><span class="line">            pp.left = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = replacement; <span class="comment">//说明当前节点在父节点的右子树上</span></span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>; <span class="comment">//当前节点已经被完整的替换为replacement, 将当前节点清空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若当前节点的颜色是红色，可以直接删除，因为删除一个红色并不会影响红黑树的平衡，否则需要进行红黑树的平衡调整，因为删除黑色会导致黑色数目不一致</span></span><br><span class="line">    TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">//说明当前节点是叶子节点，也就是说replacement是需要删除的节点，直接将replacement的关系清空即可</span></span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        p.parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                pp.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                pp.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (movable) <span class="comment">//判断是否将红黑树的根节点移动到链表的头部</span></span><br><span class="line">        moveRootToFront(tab, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调整红黑树的平衡</span></span><br><span class="line"><span class="comment"> * 该方法可以说是HashMap中最复杂的部分了，不过我认为它是跟算法有些关系，对于源码中的算法个人认为只要你清楚它在做什么即可，毕竟你的算法基本并不怎样，所以这里就不做深入研究了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 当前节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceDeletion</span><span class="params">(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * x：当前节点</span></span><br><span class="line"><span class="comment">     * xp：当前节点的父节点</span></span><br><span class="line"><span class="comment">     * xpl：当前节点的父节点的左子树</span></span><br><span class="line"><span class="comment">     * xpr：当前节点的父节点的右子树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpl, xpr;;)  &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span> || x == root)  <span class="comment">//当前节点是根节点的情况</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123; <span class="comment">//当前节点是根节点，染成黑色，直接返回，因为调整过后，root并不一定指向删除操作过后的根节点，如果之前删除的是root节点，则x将成为新的根节点）</span></span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x.red) &#123; <span class="comment">//如果x为红色，则无需调整</span></span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((xpl = xp.left) == x) &#123; <span class="comment">//当前节点为其父节点的左孩子</span></span><br><span class="line">            <span class="keyword">if</span> ((xpr = xp.right) != <span class="keyword">null</span> &amp;&amp; xpr.red) &#123; <span class="comment">//如果它有红色的兄弟节点xpr，那么它的父亲节点xp一定是黑色节点</span></span><br><span class="line">                xpr.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">true</span>;</span><br><span class="line">                root = rotateLeft(root, xp);</span><br><span class="line">                xpr = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果xpr为空，则向上继续调整，将x的父节点xp作为新的x继续循环</span></span><br><span class="line">            <span class="keyword">if</span> (xpr == <span class="keyword">null</span>)</span><br><span class="line">                x = xp;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</span><br><span class="line">                <span class="keyword">if</span> ((sr == <span class="keyword">null</span> || !sr.red) &amp;&amp;</span><br><span class="line">                    (sl == <span class="keyword">null</span> || !sl.red)) &#123; <span class="comment">//若sl和sr都为黑色或者不存在，即xpr没有红色孩子，则将xpr染红</span></span><br><span class="line">                    xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                    x = xp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sr == <span class="keyword">null</span> || !sr.red) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (sl != <span class="keyword">null</span>)</span><br><span class="line">                            sl.red = <span class="keyword">false</span>;</span><br><span class="line">                        xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateRight(root, xpr);</span><br><span class="line">                        xpr = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                            <span class="keyword">null</span> : xp.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpr.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                        <span class="keyword">if</span> ((sr = xpr.right) != <span class="keyword">null</span>)</span><br><span class="line">                            sr.red = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xp.red = <span class="keyword">false</span>;</span><br><span class="line">                        root = rotateLeft(root, xp);</span><br><span class="line">                    &#125;</span><br><span class="line">                    x = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// symmetric</span></span><br><span class="line">            <span class="keyword">if</span> (xpl != <span class="keyword">null</span> &amp;&amp; xpl.red) &#123;</span><br><span class="line">                xpl.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">true</span>;</span><br><span class="line">                root = rotateRight(root, xp);</span><br><span class="line">                xpl = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (xpl == <span class="keyword">null</span>)</span><br><span class="line">                x = xp;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;</span><br><span class="line">                <span class="keyword">if</span> ((sl == <span class="keyword">null</span> || !sl.red) &amp;&amp;</span><br><span class="line">                    (sr == <span class="keyword">null</span> || !sr.red)) &#123;</span><br><span class="line">                    xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                    x = xp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sl == <span class="keyword">null</span> || !sl.red) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                            sr.red = <span class="keyword">false</span>;</span><br><span class="line">                        xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpl);</span><br><span class="line">                        xpl = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                            <span class="keyword">null</span> : xp.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xpl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpl.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                        <span class="keyword">if</span> ((sl = xpl.left) != <span class="keyword">null</span>)</span><br><span class="line">                            sl.red = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xp.red = <span class="keyword">false</span>;</span><br><span class="line">                        root = rotateRight(root, xp);</span><br><span class="line">                    &#125;</span><br><span class="line">                    x = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空哈希表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表中是否包含指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                    (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有键的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有键的Set集合 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Set&lt;K&gt; ks = keySet;</span><br><span class="line">    <span class="keyword">if</span> (ks == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ks = <span class="keyword">new</span> KeySet();</span><br><span class="line">        keySet = ks;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含哈希表中所有键的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取哈希表的大小，共存储了多少节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 哈希表的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空哈希表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取包含所有键的迭代器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 包含所有键的迭代器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希表中是否包含指定键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 指定键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否包含指定键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsKey(o); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据指定键移除节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取分割迭代器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;K&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KeySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历所有键并执行指定动作</span></span><br><span class="line"><span class="comment">     * 遍历过程中不允许HashMap调用任何会修改结构的方法，否则最后会抛出异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> action 指定动作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有值的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有值的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Collection&lt;V&gt; vs = values;</span><br><span class="line">    <span class="keyword">if</span> (vs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        vs = <span class="keyword">new</span> Values();</span><br><span class="line">        values = vs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含所有值的对象</span></span><br><span class="line"><span class="comment"> * 和上面的集合类似，就不做介绍了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Values</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ValueIterator(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsValue(o); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;V&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ValueSpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e.value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取包含所有键值对的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有键值对的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> EntrySet()) : es;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含所有键值对的集合</span></span><br><span class="line"><span class="comment"> * 和上面的代码大同小异，不讲解了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">        Object key = e.getKey();</span><br><span class="line">        Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class="line">        <span class="keyword">return</span> candidate != <span class="keyword">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">            Object key = e.getKey();</span><br><span class="line">            Object value = e.getValue();</span><br><span class="line">            <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>; <span class="comment">//注意这里，倒数第二个参数matchValue为true，说明删除的时候还要比较value值是否相同</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EntrySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过指定键获取节点并替换值</span></span><br><span class="line"><span class="comment"> * 该方法会比较旧值是否与获取到的节点的值相同，只有相同的情况下才会替换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> oldValue 旧值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newValue 新值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否替换成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e; V v;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        ((v = e.value) == oldValue || (v != <span class="keyword">null</span> &amp;&amp; v.equals(oldValue)))) &#123;</span><br><span class="line">        e.value = newValue;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过指定键获取节点并替换值</span></span><br><span class="line"><span class="comment"> * 该方法不会比较值是否相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 新值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧值或null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        V oldValue = e.value;</span><br><span class="line">        e.value = value;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过指定键获取节点并执行指定动作</span></span><br><span class="line"><span class="comment"> * 获取到的节点若不为空同时值不为空，则不会执行指定动作</span></span><br><span class="line"><span class="comment"> * 否则执行指定动作获取新值，若新值为空直接返回，若新值不为空则继续</span></span><br><span class="line"><span class="comment"> * 若是节点不为空，说明是值为空，则用新值代替</span></span><br><span class="line"><span class="comment"> * 若是节点为空，则判断当前位置是否是红黑树结构，若是则采用红黑树的方式新增节点，若不是则采用头插法（将新增的节点插入到链表的头部），同时还要判断链表的长度是否超过8，超过则转换成红黑树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键值、</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mappingFunction 指定动作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧值或执行指定动作后的新值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">computeIfAbsent</span><span class="params">(K key, Function&lt;? <span class="keyword">super</span> K, ? extends V&gt; mappingFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mappingFunction == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; t = <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;K,V&gt; old = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="keyword">null</span> ||</span><br><span class="line">        (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length; <span class="comment">//初始化容量大小或扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                    old = e;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++binCount;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        V oldValue;</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span> &amp;&amp; (oldValue = old.value) != <span class="keyword">null</span>) &#123; <span class="comment">//通过键获取到的节点若不为空同时值不为空，则不会执行指定动作</span></span><br><span class="line">            afterNodeAccess(old);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    V v = mappingFunction.apply(key);</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123; <span class="comment">//走到这里说明节点的值为空，替换成新值</span></span><br><span class="line">        old.value = v;</span><br><span class="line">        afterNodeAccess(old);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t != <span class="keyword">null</span>) <span class="comment">//当前位置的结构是红黑树</span></span><br><span class="line">        t.putTreeVal(<span class="keyword">this</span>, tab, hash, key, v);</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">//采用头插法</span></span><br><span class="line">        tab[i] = newNode(hash, key, v, first);</span><br><span class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    ++size;</span><br><span class="line">    afterNodeInsertion(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过指定键获取节点并执行指定动作</span></span><br><span class="line"><span class="comment"> * 若是节点为空或节点的值为空，则直接返回</span></span><br><span class="line"><span class="comment"> * 若是节点不为空同时值不为空，执行指定动作获取新值，若新值为空则删除当前节点，否则替换当前节点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mappingFunction 指定动作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或执行指定动作后的新值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">computeIfPresent</span><span class="params">(K key, BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (remappingFunction == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Node&lt;K,V&gt; e; V oldValue;</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash, key)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (oldValue = e.value) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        V v = remappingFunction.apply(key, oldValue);</span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = v;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            removeNode(hash, key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过指定键获取节点并执行指定动作</span></span><br><span class="line"><span class="comment"> * 不管节点是否为空，都会执行指定动作获取新址</span></span><br><span class="line"><span class="comment"> * 若节点不为空且新值不为空，则进行替换</span></span><br><span class="line"><span class="comment"> * 若节点不为空且新值为空，则移除当前节点</span></span><br><span class="line"><span class="comment"> * 若节点为空且新值不为空，则新增节点，当前位置是红黑树结构则采用红黑树的新增方式，否则采用头插法来新增节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> remappingFunction 指定动作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 执行指定动作后的新值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(K key, BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (remappingFunction == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; t = <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;K,V&gt; old = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="keyword">null</span> ||</span><br><span class="line">        (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode) <span class="comment">//在红黑树中查找</span></span><br><span class="line">            old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                    old = e;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++binCount;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    V oldValue = (old == <span class="keyword">null</span>) ? <span class="keyword">null</span> : old.value;</span><br><span class="line">    V v = remappingFunction.apply(key, oldValue);</span><br><span class="line">    <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">            old.value = v;</span><br><span class="line">            afterNodeAccess(old);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            removeNode(hash, key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) <span class="comment">//当前位置是红黑树结构</span></span><br><span class="line">            t.putTreeVal(<span class="keyword">this</span>, tab, hash, key, v);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//采用头插法</span></span><br><span class="line">            tab[i] = newNode(hash, key, v, first);</span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        ++size;</span><br><span class="line">        afterNodeInsertion(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过指定键获取节点并执行指定动作</span></span><br><span class="line"><span class="comment"> * 若节点不为空且值不为空，则执行指定动作获取新值</span></span><br><span class="line"><span class="comment"> * 若节点不为空且值为空，则采用默认值（value）作为新值</span></span><br><span class="line"><span class="comment"> * 若新值为空则移除节点，若移除不为空则替换</span></span><br><span class="line"><span class="comment"> * 若节点为空且新值不为空，则新增节点，当前位置是红黑树结构则采用红黑树的新增方式，否则采用头插法来新增节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 默认值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> remappingFunction 指定动作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 执行指定动作后的新值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">merge</span><span class="params">(K key, V value, BiFunction&lt;? <span class="keyword">super</span> V, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (remappingFunction == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; t = <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;K,V&gt; old = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="keyword">null</span> ||</span><br><span class="line">        (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                    old = e;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++binCount;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">        V v;</span><br><span class="line">        <span class="keyword">if</span> (old.value != <span class="keyword">null</span>)</span><br><span class="line">            v = remappingFunction.apply(old.value, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            v = value;</span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">            old.value = v;</span><br><span class="line">            afterNodeAccess(old);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            removeNode(hash, key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">            t.putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[i] = newNode(hash, key, value, first);</span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        ++size;</span><br><span class="line">        afterNodeInsertion(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历哈希表并执行指定动作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action 指定动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> mc = modCount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                action.accept(e.key, e.value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历哈希表并执行指定动作后获取新值，利用新值替换所有节点的旧值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> function 指定动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; function)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">if</span> (function == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> mc = modCount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                e.value = function.apply(e.key, e.value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 浅拷贝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 克隆后的新对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HashMap&lt;K,V&gt; result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = (HashMap&lt;K,V&gt;)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">    result.reinitialize(); <span class="comment">//恢复到初始化</span></span><br><span class="line">    <span class="comment">//恢复到初始化后需要重新设置节点，明明一开始已经设置节点了为什么还要恢复初始化后再设置呢?个人认为是因为某些成员属性需要被恢复到初始化，克隆后的对象有可能会被使用到，不能在与克隆前的对象有所关联，初始化便需要重新设置</span></span><br><span class="line">    result.putMapEntries(<span class="keyword">this</span>, <span class="keyword">false</span>); </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取加载因子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 加载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">float</span> <span class="title">loadFactor</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> loadFactor; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取容量大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (table != <span class="keyword">null</span>) ? table.length :</span><br><span class="line">        (threshold &gt; <span class="number">0</span>) ? threshold :</span><br><span class="line">        DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义序列化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 输出流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> buckets = capacity();</span><br><span class="line">    <span class="comment">// Write out the threshold, loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    s.writeInt(buckets);</span><br><span class="line">    s.writeInt(size);</span><br><span class="line">    internalWriteEntries(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将键值对存储到流中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 输出流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">internalWriteEntries</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                s.writeObject(e.key);</span><br><span class="line">                s.writeObject(e.value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义反序列化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 输入流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    reinitialize();</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                         loadFactor);</span><br><span class="line">    s.readInt();                <span class="comment">// 读取buckets</span></span><br><span class="line">    <span class="keyword">int</span> mappings = s.readInt(); <span class="comment">// 读取size</span></span><br><span class="line">    <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Illegal mappings count: "</span> +</span><br><span class="line">                                         mappings);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123; <span class="comment">// (if zero, use defaults)</span></span><br><span class="line">        <span class="comment">// Size the table using given load factor only if within</span></span><br><span class="line">        <span class="comment">// range of 0.25...4.0</span></span><br><span class="line">        <span class="keyword">float</span> lf = Math.min(Math.max(<span class="number">0.25f</span>, loadFactor), <span class="number">4.0f</span>);</span><br><span class="line">        <span class="keyword">float</span> fc = (<span class="keyword">float</span>)mappings / lf + <span class="number">1.0f</span>; <span class="comment">//向上取整获取初始容量，尽可能的获取到更大的容量以便减少resize的调用</span></span><br><span class="line">        <span class="keyword">int</span> cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                   DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                   (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor((<span class="keyword">int</span>)fc));</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)cap * lf;</span><br><span class="line">        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check Map.Entry[].class since it's the nearest public type to</span></span><br><span class="line">        <span class="comment">// what we're actually creating.</span></span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap);</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[cap];</span><br><span class="line">        table = tab;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                K key = (K) s.readObject();</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                V value = (V) s.readObject();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代器基类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">    <span class="comment">//下一个节点</span></span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">    <span class="comment">//当前节点        </span></span><br><span class="line">    Node&lt;K,V&gt; current;</span><br><span class="line">    <span class="comment">//记录修改次数</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount;</span><br><span class="line">    <span class="comment">//当前位置</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     * 提前准备好第一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HashIterator() &#123;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        Node&lt;K,V&gt;[] t = table;</span><br><span class="line">        current = next = <span class="keyword">null</span>;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否存在下一个节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否存在下一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] t;</span><br><span class="line">        Node&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除当前节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; p = current;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        current = <span class="keyword">null</span>;</span><br><span class="line">        K key = p.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含所有键的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().key; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含所有值的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含所有键值对的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建普通节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将红黑树节点转换成普通节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建红黑树节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">newTreeNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将普通节点节点转换成红黑树节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 恢复到初始状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reinitialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    table = <span class="keyword">null</span>;</span><br><span class="line">    entrySet = <span class="keyword">null</span>;</span><br><span class="line">    keySet = <span class="keyword">null</span>;</span><br><span class="line">    values = <span class="keyword">null</span>;</span><br><span class="line">    modCount = <span class="number">0</span>;</span><br><span class="line">    threshold = <span class="number">0</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问节点后的动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入节点后的动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除节点后的动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        r = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 校验红黑树的基本特性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否是红黑树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">checkInvariants</span><span class="params">(TreeNode&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right,</span><br><span class="line">        tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next;</span><br><span class="line">    <span class="keyword">if</span> (tb != <span class="keyword">null</span> &amp;&amp; tb.next != t)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tn != <span class="keyword">null</span> &amp;&amp; tn.prev != t)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tp != <span class="keyword">null</span> &amp;&amp; t != tp.left &amp;&amp; t != tp.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tl != <span class="keyword">null</span> &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tr != <span class="keyword">null</span> &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (t.red &amp;&amp; tl != <span class="keyword">null</span> &amp;&amp; tl.red &amp;&amp; tr != <span class="keyword">null</span> &amp;&amp; tr.red)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tl != <span class="keyword">null</span> &amp;&amp; !checkInvariants(tl))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tr != <span class="keyword">null</span> &amp;&amp; !checkInvariants(tr))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过键获取对应的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 键对应的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过键获取对应的值</span></span><br><span class="line"><span class="comment"> * 因为哈希表允许存放null,若获取的值为null则采用默认值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> defaultValue 默认值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 键对应的值或默认值 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? defaultValue : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定键值对</span></span><br><span class="line"><span class="comment"> * 与putIfAbsent相比该方法的修改一定会生效，不管值是否为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧值或null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定节点到哈希表中</span></span><br><span class="line"><span class="comment"> * 有可能会发生重复添加节点，若发生重复的话会更新指定节点的最新值，若不重复则添加即可，以下的添加方式大同小异，区别在于红黑树可能要做一些调整来维持红黑树的特性</span></span><br><span class="line"><span class="comment"> * 若索引上不存在任何节点直接添加即可</span></span><br><span class="line"><span class="comment"> * 若索引上已经存在节点且结构是链表，若链表长度不超过8则往链表上添加即可，若超过8则执行树形化操作</span></span><br><span class="line"><span class="comment"> * 若索引上已经存在节点且结构是红黑树，调用红黑树的添加节点方法</span></span><br><span class="line"><span class="comment"> * 返回值是null表示没有重复添加，返回具体值表示发生重复添加</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 旧值或null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent 在键值对存在的情况下发生重复添加是否不允许修改值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict 模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧值或null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length; <span class="comment">//初始化容量大小</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">//指定索引上未存放元素，直接存放即可</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p; <span class="comment">//通过hash与equals来判断是否是重复的节点，若是则先记录下当前节点以便后续替换值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value); <span class="comment">//以红黑树的方式进行添加节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//不重复的节点但在同一个索引处下有两种可能：hash不同、hash相同但equals不相同</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// 当链表长度超过8</span></span><br><span class="line">                        treeifyBin(tab, hash); <span class="comment">//树形化操作</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// 新增节点时存在重复的节点，将该节点更新成最新的值</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold) <span class="comment">//超过阈值时就需要进行扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树中插入节点</span></span><br><span class="line"><span class="comment"> * 插入过程中会判断是否重复插入，从根节点开始查找</span></span><br><span class="line"><span class="comment"> * 若是返回null表示新增了一个节点，若是返回重复的节点则后续会将这个节点的值修改成最新的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map map对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tab 哈希表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h 指定节点的哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 指定节点的键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> v 指定节点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或重复的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h) <span class="comment">//当前节点的hash值大于指定节点的hash，后续应该从左子树开始查找</span></span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h) <span class="comment">//当前节点的hash值小于指定节点的hash，后续应该从右子树开始查找</span></span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk))) <span class="comment">//当前节点的hash值与指定节点的hash值相同、equals也相等，此时的节点就是重复的节点，直接返回即可</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//走到这里说明当前节点的hash值与指定节点的hash值相同，但是equals不相等，而后续不知道该从左子树还是右子树开始查找，故而要指定具体规则，通过comparable来比较当前节点的键与指定节点的键</span></span><br><span class="line">        <span class="comment">//但前提是要先检测是否实现了comparable才能比较</span></span><br><span class="line">        <span class="comment">//继而还要检测两个键值的类型是否相同，否则也不具备可比性</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                    (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                * 走到这里的话说明不具备比较器或者比较之后还是相等或者两个键值的类型不同，那么还是无法决定是要从左子树还是右子树开始查找，所以没办法只能先尝试查抄左子树在查找右子树，个个去尝试下</span></span><br><span class="line"><span class="comment">                * searched：标识已经遍历过当前节点的所有子节点，包括子孙节点，为false说明还没有过，那么就递归遍历对比，看是否能够查找到equals相等的节点，如果查找到了，也就是查找到了重复节点，直接返回即可</span></span><br><span class="line"><span class="comment">                * 如果查找不到，说明应该新增一个节点</span></span><br><span class="line"><span class="comment">                * 在查找过后就修改此值，标识已经遍历过了后续就不用再遍历了</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 不知道查找左子树还是右子树的情况下，只能一个一个去尝试了</span></span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//走到这里说明遍历了整个红黑树都没有找到键值相等的节点，说明该新增一个节点了，那就要思考要新增到左子树上还是右子树上呢?</span></span><br><span class="line">            <span class="comment">//而该方法就是决定胜负的那个方法，必须要抉择出是左子树还是右子树</span></span><br><span class="line">            <span class="comment">//先比较键的类名是否相等，若相等则比较哈希值并返回结果，若不相等则返回结果，这样子就能决定是新增到左子树还是右子树上</span></span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//走到这里说明要新增一个节点，而新增一个节点应该先找到叶子节点才能实现最后的插入，找到叶子节点并插入后就是调整节点之间的关系，比较容易理解</span></span><br><span class="line">        <span class="comment">//若dir小于或等于0且当前节点的左子树是否为空，若不为空则继续查找，若为空则说明新增的节点可以作为当前节点的左子树</span></span><br><span class="line">        <span class="comment">//若dir大于0且当前节点的右子树是否为空，若不为空则继续查找，若为空则说明新增的节点可以作为当前节点的右子树</span></span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">            TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);<span class="comment">//创建一个新的红黑树节点</span></span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x;</span><br><span class="line">            xp.next = x;</span><br><span class="line">            x.parent = x.prev = xp;</span><br><span class="line">            <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">            moveRootToFront(tab, balanceInsertion(root, x));<span class="comment">//新增节点后有可能会导致红黑树失去平衡、根节点的变化，故要做调整以及更新根节点到链表的头部</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量添加节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    putMapEntries(m, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定键值对</span></span><br><span class="line"><span class="comment"> * 与put相比该方法的修改只有在值为空的情况下才会生效</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧值或null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="移除节点"><a href="#移除节点" class="headerlink" title="移除节点"></a>移除节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过指定键移除节点</span></span><br><span class="line"><span class="comment"> * matchVaue = false，故移除过程中不会比较值是否相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 移除节点的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过指定键移除节点</span></span><br><span class="line"><span class="comment"> * matchVaue = true，故移除过程中还会比较值是否相等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>e.hash &amp; oldCap：其结果不为0个人称之为高位，等于0个人称之为低位。实际上它是在判断新容量下节点的索引位置应该是保持不变还是变成原先的索引（旧容量下的索引位置） + 旧容量大小，至于为什么是这两种可以看上面具体方法的解释。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p><code>当前位置不存在节点时新增节点</code>：直接添加</p></li><li><p><code>当前位置存在节点且是红黑树结构下新增节点</code>：直接添加，添加后可能需要旋转并移动根节点</p></li><li><p><code>当前位置存在节点且是链表结构下新增节点</code>：直接添加，添加后检测是否超过红黑树的阈值（8）和当前哈希表的长度是否超过一定容量大小（64），若这两者都满足则先将其单向链表转换成双向链表，遍历双向链表后变成红黑树，此时红黑树中的节点具有prev、next、lef、right、parent信息</p></li><li><p><code>当前位置只有一个节点且不存在链表或红黑树结构下进行扩容</code>：在新的哈希表中重新计算位置并填充即可</p></li><li><p><code>当前位置有多个节点且是红黑树结构下进行扩容</code>：将红黑树尝试分成高低位两棵树（何为高低位可参考上面的解释），低位这棵树先检测长度是否超过链表的阈值（6），若超过说明要进行树形化，接着检测是否已经树形化过，实际上就是判断高位的那棵树是否为空即可知道低位是否已经树形化过，若是高位那棵树为空，说明红黑树并未分成高低位两棵树，所以最终是将红黑树填充到新的哈希表中；同样的，若是高位那棵树存在，说明红黑树确实分成了两棵树，结构已经发生了变化，低位需要重新树形化；若低位这棵树的长度不超过链表的阈值（6）则要将其转换成单向链表结构并填充到新的哈希表中。高位那棵树的做法和低位是类似的，只不过最终填充到新的哈希表中时索引不一致，低位的索引是原先的索引（保持不变），高位的索引是原来的索引 + 旧的哈希表的容量大小。</p></li><li><p><code>当前位置有多个节点且是链表结构下进行扩容</code>：将链表尝试分成高低位两条链表并填充到新的哈希表中，低位的索引是原先的索引（保持不变），高位的索引是原来的索引 + 旧的哈希表的容量大小</p></li><li><p><code>当前位置存在节点且是红黑树结构下删除节点</code>：查找到指定节点后先调整双向链表，若此时红黑树的长度过小则直接将其转换成单向链表，若不是则利用交换树链接的方式来移除并调整平衡。该内容涉及到比较多的算法，建议对于算法只要懂的它做什么即可，后续想研究算法的话可以在回过头来！</p></li><li><p>HashMap的键与值都允许存放Null</p></li><li><p>HashMap是无序不可重复、非线程安全</p></li><li><p>HashMap的容量大小必须是2的幂次方</p></li><li><p>HashMap默认初始容量16、默认加载因子0.75</p></li><li><p>HashMap中索引的计算方式：hash &amp; (capacity - 1)</p></li><li><p>HashMap扩容时会以<code>2倍大小</code>进行增长，旧数组中的节点重新散列到新数组中，而在新数组中索引可能出现在原索引位置或原索引位置 + 旧数组容量大小</p></li><li><p>红黑树的根节点不一定是链表的头节点</p></li><li><p>JDK1.7在扩容时会出现死循环，而JDK1.8不会</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>单向链表转成红黑树</code>  <code>红黑树转成单向链表</code> <code>rehash</code> <code>默认初始容量与加载因子</code> <code>hash值与索引的计算方式</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;探索&lt;code&gt;HashMap&lt;/code&gt;底层实现是基于&lt;code&gt;JDK1.8&lt;/code&gt;，看代码之前翻了一下别人写的博客我才知道&lt;code&gt;JDK1.7&lt;/code&gt;版本的HashMap是由&lt;code&gt;数组 + 链表&lt;/code&gt;的数据结构组成，而对于JDK1.8是由&lt;code&gt;数组 + 链表 + 红黑树&lt;/code&gt;的数据结构组成，所以我又去了解了什么是二叉树、平衡二叉树、红黑树，为的就是能做个铺垫。既然是由数组、链表、红黑树组成，加上平时我们了解过的一些细节，可以猜到它的数据结构应该是这样子的，如图所示：&lt;/p&gt;
&lt;p class=&quot;customize-img&quot;&gt;&lt;img src=&quot;/assets/blogImg/java/hashmap/hashmap-data-structure.png&quot; alt=&quot;HashMap数据结构&quot;&gt;&lt;/p&gt;
&lt;p&gt;长的虽然有点丑。下面我们就开始探索它吧，还是先从注释开始看！&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>初识红黑树</title>
    <link href="http://zlia.tech/2019/09/18/explain-binarytree-redblack/"/>
    <id>http://zlia.tech/2019/09/18/explain-binarytree-redblack/</id>
    <published>2019-09-18T14:19:58.000Z</published>
    <updated>2019-09-20T10:09:55.186Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>在认识红黑树之前，最好你已经认识并掌握了二叉树与平衡二叉树（AVL）。AVL树是高度平衡的二叉树，它的时间复杂度大约是O(log<sub>2</sub>n)，即使在最坏的情况下也是。其实AVL树最复杂的地方在于删除节点重新平衡时的处理，有可能需要多次旋转节点。而红黑树相对于AVL树<code>降低了平衡要求</code>，它使用<code>红黑两种颜色来标记节点</code>，并对颜色进行要求（限制），在插入删除操作后对不符合的情况进行调整以满足要求，从而实现自我平衡。这些所谓的要求即是红黑树的特性：</p><ul><li><p>每个节点要么是红色要么是黑色。</p></li><li><p>根节点是黑色。</p></li><li><p>叶节点（值为Nil或Null的节点）是黑色。</p></li><li><p>如果一个节点是红色，那么它的子节点是黑色，相当于父子节点之间不能出现连续的红色节点。</p></li><li><p>从任意节点出发到任意叶节点的所有路径上均包含相同数目的黑色节点。</p></li></ul><a id="more"></a><p>通过上面的要求保证了<code>任意节点到叶节点的所有路径中，没有一条路径会大于其他路径的两倍长（最大是两倍</code>）。可以想象某条路径上有3个连续的黑色节点，而另外一条路径上它能达到的最长也就是红黑相间，所以最长是6个节点，3个黑色3个红色。由于红黑树降低了平衡的要求，也就是说它在插入删除时可能不需要任何的操作，也可能只需要改变下颜色即可，最糟糕的情况下才是旋转，相比AVL树只能通过旋转去达到平衡，所以说<code>红黑树的插入删除效率比AVL树要高</code>，而AVL树对于平衡要求较高导致了<code>它的查询效率比红黑树高</code>，但实际上差别并不是很大！最终看一下红黑树的效果图：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-1.png" alt="红黑树结构"></p><h3 id="了解旋转"><a href="#了解旋转" class="headerlink" title="了解旋转"></a><div><span>了解旋转</span></div></h3><p>在继续讲解红黑树之前，<code>旋转</code>是必须要掌握的。在上一篇<a href="http://zlia.tech/2019/09/15/explain-binarytree-avl">AVL平衡二叉树</a>中我们详细说明了什么是旋转、旋转的几种情况，希望不懂的同学可以先去了解下，毕竟这是前提，这里只是简单帮助同学回忆下。</p><h4 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h4><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-2.png" alt="左旋"></p><p>节点8左旋之后，由一开始节点8的右子树为节点10变成了节点10的左子树为节点8，同时根节点变成了节点10。</p><h4 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h4><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-3.png" alt="右旋"></p><p>节点8右旋之后，由一开始节点8的左子树为节点6变成了节点6的右子树为节点8，同时根节点变成了节点6。</p><h3 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a><div><span>红黑树的插入</span></div></h3><p>上面说了节点要么是红色要么是黑色，对于新插入的节点来说也是如此。假设新插入的节点是黑色，那么某条路径上便会多出来一个黑色节点，除了将其改成红色之外其余的方式，包括左旋、右旋，都无法改变会多出来一个黑色节点，所以它完全满足不了红黑树的第五特性，那么留下来的只有红色了，故而<code>新插入的节点颜色是红色的</code>！在想想，若新插入的节点是红色的话，会造成哪里不平衡，也就是说会违背哪些特性：</p><ul><li><p>每个节点要么是红色要么是黑色。</p></li><li><p>根节点是黑色。</p></li><li><p>叶节点是黑色。</p></li><li><p>如果一个节点是红色，那么它的子节点是黑色，相当于父子节点之间不能出现连续的红色节点。</p></li><li><p>从任意节点出发到任意叶节点的所有路径上均包含相同数目的黑色节点。</p></li></ul><p>第一条显然没有违背；对于空树来说，新插入的红色节点违背了该条，不过调整起来很简单，并不是关键点；新插入的节点并未来影响到叶节点；新插入的红色节点有可能它的父节点也是红色，故违背了该条，接下来的内容是针对此情况进行重点分析；新插入的节点为红色正是为了不违背该条。</p><h4 id="插入情况分析"><a href="#插入情况分析" class="headerlink" title="插入情况分析"></a>插入情况分析</h4><p>现在来分析新插入的红色节点可能出现的情况，以及它们的处理措施，这里我们<code>假设新插入的红色节点为X</code>：</p><ul><li><p>若X是根节点，将其变成黑色皆可。</p></li><li><p>若X的父节点是黑色，则不需要任何黑色。</p></li><li><p>若X的父节点是红色，叔叔节点（隶属于同一个父节点）也是红色，解决方案如下：</p><ul><li><p>将X的父节点与叔叔节点变成黑色。</p></li><li><p>将X的爷爷节点变成红色。</p></li><li><p>X的爷爷节点变成红色后，有可能会出现连续红色节点的冲突，若有的话则将X的爷爷节点当作是新插入的节点，继续重复31、32操作，直到当前节点是根节点，最后将根节点变成黑色。</p></li></ul></li></ul><p>如图所示红黑树：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-insert-1.png" alt="红黑树插入-1"></p><p><code>新插入的红色节点X为125</code>，如图所示红黑树：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-insert-2.png" alt="红黑树插入-2"></p><p><code>节点125和其父节点130都是红色节点，违背了第四点要求</code>，所以将节点125的父节点130与叔叔节点150变成黑色，同时将节点125的爷爷节点140变成红色，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-insert-3.png" alt="红黑树插入-3"></p><p><code>节点140和其父节点120都是红色节点，也违背了第四点要求</code>，我们可以将节点140看成是新插入的节点。所以将节点140的父节点120与叔叔节点60变成黑色，同时将节点140的爷爷节点90变成红色，由于节点90是根节点，又将其节点90变成了黑色，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-insert-4.png" alt="红黑树插入-4"></p><p>到这里，新插入的红色节点125一开始不满足红黑树的特性到所作的一系列调整，最终变成了标准的红黑树！</p><ul><li><p>若X的父节点是红色，叔叔节点是黑色（空），解决方案如下：</p><ul><li><p>X和X的父节点在X的爷爷节点的左子树上（左左情况）。</p></li><li><p>X和X的父节点在X的爷爷节点的右子树上（右右情况）。</p></li><li><p>以上的两种情况（4142）都是同一个处理措施，只不过旋转的方向不一致。</p><ul><li><p>将X的父节点与X的爷爷节点进行颜色互换。</p></li><li><p>将X的爷爷节点进行左/右旋，左左情况是右旋，右右情况是左旋。</p></li></ul></li></ul></li></ul><p>如图所示红黑树（左左情况）：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-insert-5.png" alt="红黑树插入-5"></p><p><code>新插入的红色节点X为25</code>，如图所示红黑树：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-insert-6.png" alt="红黑树插入-6"></p><p>节点25的父节点30为红色，叔叔节点为黑色，且节点25与父节点30都是节点50的左子树，所以将节点30与节点50进行颜色互换，同时将节点50进行右旋，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-insert-7.png" alt="红黑树插入-7"></p><p>以上是左左情况下该如何处理，右右情况的话只需要左旋即可，很简单！这边提下为啥要进行旋转，单是颜色互换其实你会发现90-&gt;60-&gt;50-&gt;null这条路径上少了一个黑色节点数目，它并不满足第五点要求，所以旋转是必须的。</p><ul><li><p>若X的父节点是红色，叔叔节点是黑色（空），该情况与上面的第四点有些类似，解决方案如下：</p><ul><li><p>X的父节点在X的爷爷节点的左子树上，X在X的父节点的右子树上（左右情况）。</p></li><li><p>X的父节点在X的爷爷节点的右子树上，X在X的父节点的左子树上（右左情况）。</p></li><li><p>以上的两种情况（5152）都是同一个处理措施，只不过旋转的方式不一样。</p><ul><li><p>将X的父节点进行左/右旋，左右情况是左旋，右左情况是右旋。</p></li><li><p>注意旋转后，X将会变化，将X的父节点与X的爷爷节点进行颜色互换。</p></li><li><p>将X的爷爷节点进行左/右旋，左右情况是右，右左情况是左旋，因为前面已经旋转过一次了，故后面是另外一个旋转，就比如左右，先左旋在右旋。</p></li></ul></li></ul></li></ul><p>如图所示红黑树（左右情况）：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-insert-8.png" alt="红黑树插入-8"></p><p><code>新插入的红色节点X为126</code>，如图所示红黑树：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-insert-9.png" alt="红黑树插入-9"></p><p>节点126的父节点125为红色，叔叔节点为黑色，且节点125在节点130的左子树上，节点126在节点125的右子树上，所以将节点125进行左旋，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-insert-10.png" alt="红黑树插入-10"></p><p>不知道发现没有，旋转后的红黑树跟第四点提到的情景是一样的，故处理方式也是一直。此时的X应该是节点125，故将节点126与节点130进行颜色互换，同时将节点130进行右旋，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-insert-11.png" alt="红黑树插入-11"></p><p>最终也是一颗标准的红黑树！以上是左右情况下该如何处理，右左情况的话也是差不多，不过多介绍了！</p><h4 id="插入情况总结"><a href="#插入情况总结" class="headerlink" title="插入情况总结"></a>插入情况总结</h4><p>整理下插入节点的情况及措施，假设新插入的节点为X：</p><ul><li><p>X是根节点：将其变成黑色即可。</p></li><li><p>X的父节点为黑色：不需要任何操作。</p></li><li><p>X的父节点为红色：</p><ul><li><p>叔叔节点为红色：将X的父节点与叔叔节点变成黑色；将X的爷爷节点变成红色；X的爷爷节点变成红色后，有可能会出现连续红色节点的冲突，若有的话则将X的爷爷节点当作是新插入的节点，继续重复上面的操作，直到当前节点是根节点，最后将根节点变成黑色。</p></li><li><p>叔叔节点为黑色：</p><ul><li><p>X在左子树上，父节点也在左子树上（左左情况） || X在右子树上，父节点也在右子树上（右右情况）：将X的父节点与X的爷爷节点进行颜色互换，将X的爷爷节点进行左/右旋，左左情况是右旋，右右情况是左旋。</p></li><li><p>父节点在左子树上，X在右子树上（左右情况） || 父节点在右子树上，X在左子树上（右左情况）：将X的父节点进行左/右旋，左右情况是左旋，右左情况是右旋，旋转后会发现与321的情况一样，然后按照321的情况继续处理，因为已经旋转过一次了，所以左右情况是右旋，右左情况是左旋。</p></li></ul></li></ul></li></ul><p>了解完以上的所有情况后，不知道你们会不会觉得有点难。实际上每一种情况对应着一种处理方式，你只需对应上即可，不过关键还是要去理解它！</p><h3 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a><div><span>红黑树的删除</span></div></h3><p>删除节点很容易，复杂的是删除节点后如何调整平衡，请同学们一定要耐心的看，仔细看，加上自己的理解！参考了其他人的文章，将删除节点的子节点个数分为以下情况，这里我们<code>假设删除节点为X</code>：</p><ul><li><p>X没有子节点的情况：</p><ul><li><p>X为红色。</p></li><li><p>X为黑色，X的兄弟节点没有子节点。</p></li><li><p>X为黑色，X的兄弟节点只有一个子节点。</p><ul><li><p>X的兄弟节点与X的兄弟节点的子节点在左子树上（左左情况）。</p></li><li><p>X的兄弟节点与X的兄弟节点的子节点在右子树上（右右情况）。</p></li><li><p>X的兄弟节点在左子树上，X的兄弟节点的子节点在右子树上（左右情况）。</p></li><li><p>X的兄弟节点在右子树上，X的兄弟节点的子节点在左子树上（右左情况）。</p></li></ul></li><li><p>X为黑色，X的兄弟节点有两个子节点。</p></li></ul></li><li><p>X只有一个子节点的情况（左右无所谓）：</p><ul><li><p>X为红色，其子节点只能为黑色。</p></li><li><p>X为黑色，其子节点为红色。</p></li><li><p>X为黑色，其子节点为黑色。</p></li></ul></li><li><p>X有两个子节点的情况是将其简化成以上的两种情况后再处理，有以下两种简化方式（根据业务需求自行选择其中一种）：</p><ul><li><p>找到X的右子树中最左的节点，将两个节点的值进行交换，就变成了删除最左的节点，不过删除的值依然还是原来的值，相当于X换了个位置。由于是最左的节点，那么它肯定没有左子树，所以它要么是没有子节点要么是只有一个子节点。</p></li><li><p>找到X的左子树中最右的节点，将两个节点的值进行交换。由于是最右的节点，那么它肯定没有右子树，所以它要么是没有子节点要么是只有一个子节点。</p></li></ul></li></ul><p>情况有点多，接下来一一分析！</p><h4 id="删除节点没有子节点"><a href="#删除节点没有子节点" class="headerlink" title="删除节点没有子节点"></a>删除节点没有子节点</h4><ul><li>X为红色。</li></ul><p>如图所示红黑树：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-1.png" alt="红黑树删除-1"></p><p><code>删除节点X为126</code>，如图所示红黑树：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-2.png" alt="红黑树删除-2"></p><p>直接删除即可，因为删除的是红色节点，并不会影响黑色节点的数目。</p><ul><li>X为黑色，X的兄弟节点没有子节点，此时X的兄弟节点必定为黑色。</li></ul><p>如图所示红黑树：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-3.png" alt="红黑树删除-3"></p><p><code>删除节点X为110</code>，它为黑色，且兄弟节点140没有子节点。由于X为黑色，那么它的兄弟节点必定为黑色（否则就违背了黑色数目不一致），如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-4.png" alt="红黑树删除-4"></p><p>图中删除后的节点用虚线白字表示，方便讲解。在删除节点110后，90-&gt;120-&gt;110的路径上明显少了一个黑色数目，采取的措施是将删除节点X的兄弟节点变成红色，X的父节点变成黑色，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-5.png" alt="红黑树删除-5"></p><p>最终每条路径上的黑色数目一样。</p><ul><li><p>X为黑色，X的兄弟节点只有一个子节点</p><ul><li><p>X的兄弟节点与X的兄弟节点的子节点在左子树上（左左情况）</p></li><li><p>X的兄弟节点与X的兄弟节点的子节点在右子树上（右右情况）</p></li><li><p>以上的两种情况都是同一个处理措施，只不过旋转的方式不一样。</p></li></ul></li></ul><p>如图所示红黑树（左左情况）：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-6.png" alt="红黑树删除-6"></p><p><code>删除节点X为140</code>，它为黑色，且兄弟节点110（左子树上）只有一个子节点100（左子树上），如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-7.png" alt="红黑树删除-7"></p><p>在删除节点140后，90-&gt;120-&gt;140的路径上少了一个黑色数目，采取的措施是将X的父节点与X的兄弟节点进行颜色互换，将X的父节点变成黑色，将X的兄弟节点的子节点变成黑色，最后将X的父节点进行左/右旋，左左情况是右旋，右右情况是左旋，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-8.png" alt="红黑树删除-8"></p><p>最终每条路径上的黑色数目一样。</p><ul><li><p>X为黑色，X的兄弟节点只有一个子节点</p><ul><li><p>X的兄弟节点在左子树上，X的兄弟节点的子节点在右子树上（左右情况）</p></li><li><p>X的兄弟节点在右子树上，X的兄弟节点的子节点在左子树上（右左情况）</p></li><li><p>以上的两种情况都是同一个处理措施，只不过旋转的方式不一样。</p></li></ul></li></ul><p>如图所示红黑树（左右情况）：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-9.png" alt="红黑树删除-9"></p><p><code>删除节点X为140</code>，它为黑色，且兄弟节点110（左子树上）只有一个子节点115（右子树上），如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-10.png" alt="红黑树删除-10"></p><p>在删除节点140后，90-&gt;120-&gt;110-&gt;115的路径上少了一个黑色数目，采取的措施是将X的兄弟节点与X的兄弟节点的子节点进行颜色互换，将X的兄弟节点进行左/右旋，左右情况是左旋，右左情况是右旋，将X的父节点进行左/右旋，左右情况是右，右左情况是左旋，因为前面已经旋转过一次了，后面是另外一个旋转，就比如左右，先左旋在右旋，将X的父节点与X的兄弟节点变成黑色，将X的父节点的父节点变成红色，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-11.png" alt="红黑树删除-11"></p><p>最终每条路径上的黑色数目一样。</p><ul><li><p>X为黑色，X的兄弟节点有两个子节点（若是叶节点则和上面的第2点没啥区别，所以这里不是叶节点）</p><ul><li>X的兄弟节点为黑色，那么它的两个子节点必定是红色（因为X没有子节点，这种情况不用考虑兄弟节点的子节点，因为即使旋转了红色的节点并不会影响黑色数目），这样子才能保证黑色数目一致</li></ul></li></ul><p>如图所示红黑树：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-12.png" alt="红黑树删除-12"></p><p><code>删除节点X为140</code>，它为黑色，且兄弟节点110也为黑色，有两个子节点，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-13.png" alt="红黑树删除-13"></p><p>在删除节点140后，90-&gt;120-&gt;140的路径上少了一个黑色数目，采取的措施是将X的父节点进行左/右旋，X在左子树是左旋，X在右子树是右旋，将X的父节点与X的兄弟节点的左/右子节点变成黑色，X在左子树上就将右子节点变成黑色，X在右子树上就将左子节点变成黑色，将X的兄弟节点变成红色（若X的兄弟节点是根节点则不需要变化），如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-14.png" alt="红黑树删除-14"></p><p>最终每条路径上的黑色数目一样。</p><ul><li><p>X为黑色，X的兄弟节点有两个子节点</p><ul><li><p>X的兄弟节点为红色，那么它的两个子节点只能为黑色，这样子才能保证黑色数目一样</p><ul><li>X的兄弟节点的子节点都无子节点</li></ul></li></ul></li></ul><p>如图所示红黑树：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-15.png" alt="红黑树删除-15"></p><p><code>删除节点X为30</code>，它为黑色，兄弟节点85为红色，有两个子节点（在无子节点），如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-16.png" alt="红黑树删除-16"></p><p>在删除节点30后，60-&gt;30的路径上少了一个黑色数目，由于该情况比较复杂，我们以X的父节点为目标（即使在移动后我们仍称为X的父节点）采取的措施是：</p><ul><li><p>删除X</p></li><li><p>X的父节点与X的兄弟节点颜色互换</p></li><li><p>X的父节点左/右旋，X在左子树是左旋，X在右子树是右旋</p></li><li><p>X的父节点与X的父节点的子节点（旋转过后的子节点）颜色互换</p></li></ul><p>如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-17.png" alt="红黑树删除-17"></p><p>最终每条路径上的黑色数目一样。</p><ul><li><p>X为黑色，X的兄弟节点有两个子节点</p><ul><li><p>X的兄弟节点为红色，那么它的两个子节点只能为黑色（只考虑X的兄弟节点的子节点与X同边，就比如X在左子树，那么只考虑X的兄弟节点的左子树，因为只有左子树才会在旋转之后移动到了X的那一侧，影响到了黑色数目，而右子树始终没有变动）</p><ul><li>X的兄弟节点的子节点的子节点只有一个，那么X的兄弟节点的子节点为黑色，那么X的兄弟节点的子节点的子节点必为红色（因为X无子节点）</li></ul></li></ul></li></ul><p>如图所示红黑树：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-18.png" alt="红黑树删除-18"></p><p><code>删除节点X为30</code>，它为黑色，兄弟节点85为红色，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-19.png" alt="红黑树删除-19"></p><p>在删除节点30后，60-&gt;30的路径上少了一个黑色数目，由于该情况比较复杂，我们以X的父节点为目标（即使在移动后我们仍称为X的父节点）采取的措施是：</p><ul><li><p>删除X</p></li><li><p>X的父节点左/右旋，X在左子树是左旋，X在右子树右旋</p></li><li><p>X的父节点与X的兄弟节点颜色互换</p></li><li><p>若X的父节点的左/右子树（旋转过后）的左/右子树与X同边，简单来说，若X在左/右子树，那么只考虑X的父节点的右/左子树的左/右子树，从14225开始执行，若是没对应上则从14227开始执行，同理X在右子树上</p></li><li><p>X在左/右子树，X的父节点的右/左子树进行右/左旋（14225）</p></li><li><p>X在左/右子树，X的父节点的右/左子树与X的父节点的右/左子树的右/左子树进行颜色互换（14226）</p></li><li><p>X的父节点左/右旋，x在左子树是左旋，x在右子树右旋（14227）</p></li><li><p>X的父节点与X的父节点的兄弟节点变成黑色，X的父节点的父节点变成红色（旋转过后）</p></li></ul><p>最终每条路径上的黑色数目一样。该情况很是复杂，希望同学们能耐心的理解并尝试动手，否则很难从中发现规律！</p><ul><li><p>X为黑色，X的兄弟节点有两个子节点</p><ul><li><p>X的兄弟节点为红色，那么它的两个子节点只能为黑色（和上面一样，只需考虑一侧）</p><ul><li>X的兄弟节点的子节点的子节点有两个，那么X的兄弟节点的子节点为黑色，那么X的兄弟节点的子节点的两个子节点都为红色</li></ul></li></ul></li></ul><p>如图所示红黑树：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-20.png" alt="红黑树删除-20"></p><p><code>删除节点X为30</code>，它为黑色，兄弟节点85为红色，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/redblack/rb-binarytree-delete-21.png" alt="红黑树删除-21"></p><p>在删除节点30后，60-&gt;30的路径上少了一个黑色数目，由于该情况比较复杂，我们以X的父节点为目标（即使在移动后我们仍称为X的父节点）采取的措施是：</p><ul><li><p>删除X</p></li><li><p>X的父节点左/右旋，X在左子树是左旋，X在右子树右旋</p></li><li><p>X的父节点与X的兄弟节点颜色互换</p></li><li><p>X的父节点左/右旋，X在左子树是左旋，X在右子树右旋</p></li><li><p>X的父节点与X的父节点的兄弟节点变成黑色，X的父节点的父节点变成红色（旋转过后）</p></li></ul><p>删除节点中最复杂的部分差不多都在这里了。说实话，我整理起来都耗费了很多精力与时间，同学们看不懂或者不理解的地方尝试多看几遍，多动手几次，说不定，当然了，也不排除我写错了，所以还是要自己动手比较好，加油吧！</p><h4 id="删除节点只有一个子节点"><a href="#删除节点只有一个子节点" class="headerlink" title="删除节点只有一个子节点"></a>删除节点只有一个子节点</h4><ul><li><p>X为红色，其子节点为黑色，不存在这样子的情况，要不然黑色数目就不一样了</p></li><li><p>X为黑色，其子节点为黑色，同样的道理，黑色数目还是不一样（X-&gt;Null路径上少了一个）</p></li><li><p>X为黑色，其子节点为红色（左右无所谓），这里就不上图片了，直接说处理措施：</p><ul><li><p>删除X</p></li><li><p>将X的子节点变成黑色，并作为X的父节点的子节点</p></li></ul></li></ul><h4 id="删除节点有两个子节点"><a href="#删除节点有两个子节点" class="headerlink" title="删除节点有两个子节点"></a>删除节点有两个子节点</h4><ul><li><p>找到X的右子树中最左的节点，将两个节点的值进行交换，就变成了删除最左的节点，不过删除的值依然还是原来的值，所以最左的节点要么没有子节点，要么只有一个子节点，是不是又回到上面的情况了，那处理情况自然也就是上面的内容了</p></li><li><p>找到X的左子树中最右的节点，将两个节点的值进行交换，所以最右的节点要么没有子节点，要么只有一个子节点，同理！</p></li></ul><h4 id="删除情况总结"><a href="#删除情况总结" class="headerlink" title="删除情况总结"></a>删除情况总结</h4><ul><li><p>X没有子节点的情况</p><ul><li><p>X为红色，不需要任何处理，直接删除即可</p></li><li><p>X为黑色，X的兄弟节点没有子节点</p><ul><li><p>那么X的兄弟节点肯定也为黑色</p></li><li><p>删除X</p></li><li><p>将X的兄弟节点变成红色，X的父节点变成黑色</p></li></ul></li><li><p>X为黑色，X的兄弟节点只有一个子节点</p><ul><li><p>X的兄弟节点与X的兄弟节点的子节点在左子树上（左左情况） || X的兄弟节点与X的兄弟节点的子节点在右子树上（右右情况）</p><ul><li><p>删除X</p></li><li><p>将X的父节点与X的兄弟节点进行颜色互换</p></li><li><p>将X的父节点变成黑色</p></li><li><p>将X的兄弟节点的子节点变成黑色</p></li><li><p>将X的父节点进行左/右旋，左左情况是右旋，右右情况是左旋</p></li></ul></li><li><p>X的兄弟节点在左子树上，X的兄弟节点的子节点在右子树上（左右情况） || X的兄弟节点在右子树上，X的兄弟节点的子节点在左子树上（右左情况）</p><ul><li><p>删除X</p></li><li><p>将X的兄弟节点与X的兄弟节点的子节点进行颜色互换</p></li><li><p>将X的兄弟节点进行左/右旋，左右情况是左旋，右左情况是右旋</p></li><li><p>将X的父节点进行左/右旋，左右情况是右，右左情况是左旋，因为前面已经旋转过一次了，后面是另外一个旋转，就比如左右，先左旋在右旋</p></li><li><p>将X的父节点与X的兄弟节点变成黑色</p></li><li><p>将X的父节点的父节点变成红色</p></li></ul></li></ul></li><li><p>X为黑色，X的兄弟节点有两个子节点（若是叶子节点则和上面的12没什么区别，所以这里不是叶子节点）</p><ul><li><p>X的兄弟节点为黑色，那么它的两个子节点必定都是红色（因为X没有子节点，这种情况不用考虑子节点，因为即使旋转了红色的节点并不会影响黑色数目）</p><ul><li><p>删除X</p></li><li><p>X的父节点进行左/右旋，X在左子树是左旋，X在右子树是右旋</p></li><li><p>将X的父节点与X的兄弟节点的左/右子节点变成黑色，X在左子树上就将右子节点变成黑色，X在右子树上就将左子节点变成黑色</p></li><li><p>若X的兄弟节点是根节点则不需要变化，将X的兄弟节点变成红色</p></li></ul></li><li><p>X的兄弟节点为红色，那么它的两个子节点必定是黑色（只考虑X的兄弟节点的子节点与X同边，就比如X在左子树，那么只考虑X的兄弟节点的左子树，因为只有左子树才会在旋转之后移动到了X的那一侧，影响到了黑色数目，而右子树始终没有变动）</p><ul><li><p>X的兄弟节点的子节点都无子节点</p><ul><li><p>删除X</p></li><li><p>X的父节点与X的兄弟节点颜色互换</p></li><li><p>X的父节点左/右旋，X在左子树是左旋，X在右子树是右旋</p></li><li><p>X的父节点与X的父节点的子节点（旋转过后的子节点）颜色互换</p></li></ul></li><li><p>X的兄弟节点的子节点只有一个子节点，X的兄弟节点的子节点为黑色，那么X的兄弟节点的子节点的子节点必为红色</p><ul><li><p>删除X</p></li><li><p>x的父节点左/右旋，x在左子树是左旋，x在右子树右旋</p></li><li><p>x的父节点与X的兄弟节点颜色互换</p></li><li><p>若X的父节点的左/右子树（旋转过后）的左/右子树与X同边，简单来说，若X在左/右子树，那么只考虑X的父节点的右/左子树的左/右子树，先从14225开始执行，若是没对应上则先从14227开始执行，同理X在右子树上</p></li><li><p>X在左/右子树，X的父节点的右/左子树进行右/左旋</p></li><li><p>X在左/右子树，X的父节点的右/左子树与X的父节点的右/左子树的右/左子树进行颜色互换</p></li><li><p>X的父节点左/右旋，x在左子树是左旋，x在右子树右旋</p></li><li><p>X的父节点与X的父节点的兄弟节点变成黑色，X的父节点的父节点变成红色（旋转过后）</p></li></ul></li><li><p>X的兄弟节点的子节点有两个子节点，X的兄弟节点的子节点为黑色，那么X的兄弟节点的子节点的两个子节点都为红色</p><ul><li><p>删除X</p></li><li><p>x的父节点左/右旋，x在左子树是左旋，x在右子树右旋</p></li><li><p>x的父节点与X的兄弟节点颜色互换</p></li><li><p>x的父节点左/右旋，x在左子树是左旋，x在右子树右旋</p></li><li><p>X的父节点与X的父节点的兄弟节点变成黑色，X的父节点的父节点变成红色（旋转过后）</p></li></ul></li></ul></li></ul></li></ul></li><li><p>X只有一个子节点的情况</p><ul><li><p>X为黑色，其子节点只能为红色（左右都无所谓）</p><ul><li><p>删除X</p></li><li><p>将X的子节点变成黑色，并作为X的父节点的子节点</p></li></ul></li><li><p>X为红色，其子节点为黑色 || X为黑色，其子节点为黑色</p><ul><li>不存在这两种情况，黑叔数目不一样</li></ul></li></ul></li><li><p>X有两个子节点的情况</p><ul><li><p>找到X的右子树中最左的节点，将两个节点的值进行交换，就变成了删除最左的节点，不过删除的值依然还是原来的值，相当于X换了个位置。由于是最左的节点，那么它肯定没有左子树，所以它要么是没有子节点要么是只有一个子节点（右子树），最终变成了上面的处理情况。</p></li><li><p>找到X的左子树中最右的节点，将两个节点的值进行交换。由于是最右的节点，那么它肯定没有右子树，所以它要么是没有子节点要么是只有一个子节点（左子树），最终变成了上面的情况。</p></li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><div><span>总结</span></div></h3><p>红黑树的插入与删除较为复杂，过一段时间后容易忘记，特意整理了一份流程说明，有兴趣的同学可以去观摩-<a href="https://github.com/JulianHang/translate-article/blob/master/RedBlackTreeProcess.md" target="_blank" rel="noopener">红黑树插入与删除流程说明</a>，至于代码的设计实现上可能没有那么快给出，我也是个菜鸟啊，到时候要是不小心写出来了我就在新写一篇文章告知天下！这篇算是纯理论的红黑树，想学东西就要多去实践。最后推荐个<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">数据结构可视化网站</a>，可调试二叉树、AVL树、红黑树，估计还有其他我不知道的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;在认识红黑树之前，最好你已经认识并掌握了二叉树与平衡二叉树（AVL）。AVL树是高度平衡的二叉树，它的时间复杂度大约是O(log&lt;sub&gt;2&lt;/sub&gt;n)，即使在最坏的情况下也是。其实AVL树最复杂的地方在于删除节点重新平衡时的处理，有可能需要多次旋转节点。而红黑树相对于AVL树&lt;code&gt;降低了平衡要求&lt;/code&gt;，它使用&lt;code&gt;红黑两种颜色来标记节点&lt;/code&gt;，并对颜色进行要求（限制），在插入删除操作后对不符合的情况进行调整以满足要求，从而实现自我平衡。这些所谓的要求即是红黑树的特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;每个节点要么是红色要么是黑色。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;根节点是黑色。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;叶节点（值为Nil或Null的节点）是黑色。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果一个节点是红色，那么它的子节点是黑色，相当于父子节点之间不能出现连续的红色节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从任意节点出发到任意叶节点的所有路径上均包含相同数目的黑色节点。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="algorithm" scheme="http://zlia.tech/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>初识平衡二叉树-AVL</title>
    <link href="http://zlia.tech/2019/09/15/explain-binarytree-avl/"/>
    <id>http://zlia.tech/2019/09/15/explain-binarytree-avl/</id>
    <published>2019-09-15T11:23:55.000Z</published>
    <updated>2019-09-16T02:35:27.539Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>上一篇文章只是简单地认识下<code>二叉树</code>，并未提到它的<code>缺陷</code>。数据结构的好坏取决于<code>时间复杂度</code>，由于每次操作（插入、删除、查找）需要与节点比较来选择进入到左子树还是右子树，也就是说每次比较都会排除一些可能（选择左右其中一侧），当然了这是对于随机均匀分布的二叉树来说，它的时间复杂度是O（log<sub>2</sub>n），但是对于只有单向的左子树或右子树来说，它的时间复杂度就变成了O(n)，每次操作都会从头到尾所有节点比较一遍。总的来说，二叉树的时间复杂度区间是在O(log<sub>2</sub>n) ~ O(n)之间，这完全取决于二叉树的结构！如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/avl/single-binarytree.png" alt="单向二叉树结构"></p><p>随着单向二叉树越来越长，所消耗的时间也会越来越多，这已经跟单链表没有什么区别了。因此，为了解决单链表的情况，将时间复杂度降低至O（log<sub>2</sub>n），衍生出了<code>平衡二叉树</code>。</p><a id="more"></a><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><div><span>平衡二叉树</span></div></h3><p>通过上面的分析看出，只要将节点均匀分布在两侧即可完成目的，而这也正是平衡二叉树所要做的事，因此它要求<code>任何节点的左右子树的高度相差不超过1</code>，实际上就是计算同一层中<code>最大的高度值与最小的高度值相差不超过1</code>，解释下高度的含义：从叶子节点开始自底向上到指定节点的最长距离，叶子节点的高度为0，<code>空树的高度为-1</code>。对于AVL树来说，它只是平衡二叉树的其中一种，节点的左右子树高度差被称为<code>平衡因子</code>，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/avl/balance-binarytree-1.png" alt="平衡二叉树结构"></p><p>图中左侧为平衡二叉树，每一层的高度差值都不会超过1，图中右侧中出现高度差值超过1，故非平衡二叉树。仔细观察下，图中左右两个的二叉树无非就差了一个节点6，可以将这个多余的节点看成是新插入的节点，是该操作导致了二叉树失去平衡，更严格来说，只要是修改了树的结构，都有可能导致平衡失调，而能修改树结构的操作只有删除与插入。那么该如何才能让它继续保持平衡呢？很容易想到，只要稍微移动下树的结构就能使之平衡，这样子的操作被称为<code>旋转</code>，分为<code>单旋转</code>和<code>双旋转</code>。在想一想，图中右侧中左子树相对偏高，若是旋转的话应该将左子树的高度降低，相应的右子树也会增高，这样子就达到平衡了。</p><h3 id="AVL树旋转"><a href="#AVL树旋转" class="headerlink" title="AVL树旋转"></a><div><span>AVL树旋转</span></div></h3><p>上面提到只有删除与插入会导致二叉树不平衡，这里就举插入来介绍平衡二叉树的几种<code>旋转方式</code>。插入的话无非就以下几种方式：</p><h4 id="左左型"><a href="#左左型" class="headerlink" title="左左型"></a>左左型</h4><ul><li>插入到根节点的左子树的左子树上，称作<code>左左型LL（右旋转）</code>。该方式导致的不平衡是因为左子树上的节点增加了，所以旋转的话就应当将左子树的高度降低，而旋转的节点是插入的节点到根节点的路径上的节点都有可能旋转（这个很在编写代码中很关键），也就是说有可能旋转多次才能达到平衡，如图所示操作：</li></ul><p class="customize-img"><img src="/assets/blogImg/algorithm/avl/avl-binarytree-1.png" alt="avl平衡二叉树结构-1"></p><p>图中可见是节点7，我们知道向右旋转会导致左子树的高度降低，没错，旋转正确的话是使二叉树达到平衡。我们将节点7移动到根节点位置上，节点5、6紧随其后，而节点8变成了节点的右子树，节点9还是节点8的右子树，简单来说，随着某个节点的移动，其他节点也会相应的移动，这样子才能达到平衡。不知道你们发现没有，旋转过后，不仅符合二叉树的规则，同时也达到平衡，只不过根节点变化了，不过这丝毫不影响！这是比较简单的<code>左左型LL</code>，在来看另外一种情况：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/avl/avl-binarytree-2.png" alt="avl平衡二叉树结构-2"></p><p>此种情况比上面多了一个节点，不过这不是关键。我们发现节点X应该是比节点7大，而比节点8小，也就是说它可以当作节点7的右子树，也可以当作节点8的左子树，而随着节点7移动到根节点上，它已经有了节点5与节点8两个子节点，容不下第三个节点了，也就是说它已经做不了节点7的右子树了，那么这个时候节点X只能考虑去走另外一套方案了，让我称为节点8的左子树，所以最终旋转的结果如上图所示。理解了右旋转，左旋转也是一样的道理。</p><h4 id="右右型"><a href="#右右型" class="headerlink" title="右右型"></a>右右型</h4><ul><li>插入到根节点的右子树的右子树上，称作<code>右右型RR（左旋转）</code>。该方式导致的不平衡是因为右子树上的节点增加了，所以旋转的话就应当将右子树的高度降低，如图所示：</li></ul><p class="customize-img"><img src="/assets/blogImg/algorithm/avl/avl-binarytree-3.png" alt="avl平衡二叉树结构-3"></p><p>图中可见是节点9导致了二叉树的不平衡，那么应该左旋转来降低右子树的高度。将节点9移动到根节点位置上，节点10、11紧随其后，而节点8变成了节点9的左子树，重点在于节点X，发现节点X比节点8大，而比节点9小，随着节点9的移动，它已经做不了节点9的左子树了，所以结果它成了节点8的右子树。跟上面的右旋转有点类似！</p><h4 id="左右型"><a href="#左右型" class="headerlink" title="左右型"></a>左右型</h4><ul><li>插入到根节点的左子树的右子树上，称作<code>左右型LR（左右旋转）</code>。该方式的结构与上面的左左型稍微有点区别，因为最终插入的节点是落在了右子树上，所以首先应该先降低右子树的高度，应该左旋转，不过你会发现，随着右子树的移动，左子树的高度最终增加了，二叉树还是不平衡，不过不用担心，事情是往好的方向发展，你发现没有，左旋转后的结构与上面的左左型是一样的！也就是说只需要在向右旋转一次就能达到平衡，总共旋转了两次，所以称为左右旋转！如图所示：</li></ul><p class="customize-img"><img src="/assets/blogImg/algorithm/avl/avl-binarytree-4.png" alt="avl平衡二叉树结构-4"></p><p>我们知道若是直接移动节点7，最终还是不平衡，而咱们说从节点插入的地方到根节点的路径上都有可能需要旋转，那只有节点X了，那么应该通过左旋转来降低高度，不过随着节点X的移动，最终发现二叉树还是不平衡，不过你也应该发现了，这结构和左左型很像，所以最终还需要右旋转来达到平衡！</p><h4 id="右左型"><a href="#右左型" class="headerlink" title="右左型"></a>右左型</h4><ul><li>插入到根节点的右子树的左子树上，称作<code>右左型RL（右左旋转）</code>。该方式的结构与上面的右右型有些区别，最终插入的节点是落在了左子树上，所以首先应该先降低左子树的高度，那么应该右旋转，同理，随着旋转一次后发现还是不平衡，不过结构倒是很像右右型，接下来的操作就跟右右型一样了，就不做多阐述了！如图所示：</li></ul><p class="customize-img"><img src="/assets/blogImg/algorithm/avl/avl-binarytree-5.png" alt="avl平衡二叉树结构-5"></p><p>这几种类型不难理解，只要记住哪边高度多大就旋转哪边，需要注意的事可能要旋转多次，这也很简单，发现旋转后还是不平衡在继续旋转即可。</p><h3 id="平衡二叉树的设计与实现"><a href="#平衡二叉树的设计与实现" class="headerlink" title="平衡二叉树的设计与实现"></a><div><span>平衡二叉树的设计与实现</span></div></h3><p>掌握概念后，最重要的就是实战，我已经把代码写了一遍，不过中途是参考了别人的文章，这边也只是放出了代码图片，有兴趣的同学可以去github上观摩-<a href="https://github.com/JulianHang/little-java-project/blob/master/src/tech/zlia/interest/algorithm/tree/avl/AvlBalanceTree.java" target="_blank" rel="noopener">avl平衡二叉树代码设计与实现</a></p><p class="customize-img"><img src="/assets/blogImg/algorithm/avl/avl-binarytree-code.png" alt="avl平衡二叉树结构代码设计"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><div><span>总结</span></div></h3><p>平衡二叉树中的旋转较为复杂，最好能够结合场景去分析推敲，加油吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;上一篇文章只是简单地认识下&lt;code&gt;二叉树&lt;/code&gt;，并未提到它的&lt;code&gt;缺陷&lt;/code&gt;。数据结构的好坏取决于&lt;code&gt;时间复杂度&lt;/code&gt;，由于每次操作（插入、删除、查找）需要与节点比较来选择进入到左子树还是右子树，也就是说每次比较都会排除一些可能（选择左右其中一侧），当然了这是对于随机均匀分布的二叉树来说，它的时间复杂度是O（log&lt;sub&gt;2&lt;/sub&gt;n），但是对于只有单向的左子树或右子树来说，它的时间复杂度就变成了O(n)，每次操作都会从头到尾所有节点比较一遍。总的来说，二叉树的时间复杂度区间是在O(log&lt;sub&gt;2&lt;/sub&gt;n) ~ O(n)之间，这完全取决于二叉树的结构！如图所示：&lt;/p&gt;
&lt;p class=&quot;customize-img&quot;&gt;&lt;img src=&quot;/assets/blogImg/algorithm/avl/single-binarytree.png&quot; alt=&quot;单向二叉树结构&quot;&gt;&lt;/p&gt;
&lt;p&gt;随着单向二叉树越来越长，所消耗的时间也会越来越多，这已经跟单链表没有什么区别了。因此，为了解决单链表的情况，将时间复杂度降低至O（log&lt;sub&gt;2&lt;/sub&gt;n），衍生出了&lt;code&gt;平衡二叉树&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="algorithm" scheme="http://zlia.tech/tags/algorithm/"/>
    
  </entry>
  
</feed>
