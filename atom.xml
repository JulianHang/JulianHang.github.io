<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>奇思妙想</title>
  
  <subtitle>越努力越幸运！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zlia.tech/"/>
  <updated>2020-03-09T07:33:44.389Z</updated>
  <id>http://zlia.tech/</id>
  
  <author>
    <name>zlia</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>挖掘队列源码之PriorityBlockingQueue</title>
    <link href="http://zlia.tech/2020/03/09/explain-priorityblockingqueue-sourcecode/"/>
    <id>http://zlia.tech/2020/03/09/explain-priorityblockingqueue-sourcecode/</id>
    <published>2020-03-09T07:33:44.000Z</published>
    <updated>2020-03-09T07:33:44.389Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>探索PriorityBlockingQueue是基于<code>JDK1.8</code>，它是基于<code>二叉堆</code>的无界阻塞队列，二叉堆又可以分成最大堆与最小堆，很显然，既然是优先级队列，那么优先级高者自然比优先级低者优先出队列，PriorityBlockingQueue采用的是数值越小优先级越高，即最小堆，利用每个元素的优先级进行排序，所以这不在是按照先进先出顺序了！对于无界来说，就不会存在队列饱满的情况了，它会进行扩容，自然也就不会发生阻塞的情况了，这是与ArrayBlockingQueue/LinkedBlockingQueue最大的区别了，不过在空队列的情况下仍然会发生阻塞直到出现新元素才会被唤醒继续执行。对于优先级队列而言，自然是在添加的时候比较每个元素的优先级高低，所以它要求每个元素必须继承Comparable或自定义比较器，更不能添加null。最后在说一点，接下来的内容将不会着重介绍二叉堆，它较为简单且之前的文章也简单介绍过，所以读者可以先了解下，有助于理解其中的方法，接下来进入主题。</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其二叉堆的数据结构是数组，数组的默认初始容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 我们都知道定义一个数组的大小是 int 类型，那么也就意味着最大的数组大小应该是Integer.MAX_VALUE，但是这里为啥要减去8呢？</span></span><br><span class="line"><span class="comment">     * 查阅资源发现大部分的人都在说8个字节是用来存储数组的大小，半信半疑</span></span><br><span class="line"><span class="comment">     * 分配最大数组，某些VM会在数组中存储header word，按照上面的说法指的应该是数组的大小</span></span><br><span class="line"><span class="comment">     * 若尝试去分配更大的数组可能会造成 OutOfMemoryError: 定义的数组大小超过VM上限</span></span><br><span class="line"><span class="comment">     * 不同的操作系统对于不同的JDK可能分配的内存会有所差异，所以8这个数字可能是为了保险起见</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Object[] queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列中元素的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义比较器，若为null则要求元素继承Comparable进行比较</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可重入锁，防止多线程并发访问队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从空队列中获取元素导致阻塞直到新元素插入时被唤醒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列进行扩容时的标志，只会有一个线程扩容成功，扩容的前提是已经获取到锁了，那么在过程中会先释放其锁，让其他线程可以尽早获取元素，也就是说扩容与获取元素可以同时操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> allocationSpinLock;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化，采用默认数组容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化，自定义数组容量大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 数组容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化，自定义数组容量大小与比较器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 数组容量大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> comparator 自定义比较器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity, Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">this</span>.notEmpty = lock.newCondition();</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将集合中的元素放入到队列</span></span><br><span class="line"><span class="comment"> * 若指定集合是PriorityBlockingQueue，那么最终队列的顺序将会和集合一致，若是其他集合类，则最终队列将会进行排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityBlockingQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">this</span>.notEmpty = lock.newCondition();</span><br><span class="line">    <span class="keyword">boolean</span> heapify = <span class="keyword">true</span>; <span class="comment">// 如果集合未排序则标志为true，若c是PriorityBlockingQueu或SortedSet，说明已经排过序了</span></span><br><span class="line">    <span class="keyword">boolean</span> screen = <span class="keyword">true</span>;  <span class="comment">// 是否要判空的标志，若c本身就是PriorityBlockingQueue，就不需要判空，因为它本身就不允许添加null，而对于其他集合类来说是允许添加null</span></span><br><span class="line">    <span class="keyword">if</span> (c <span class="keyword">instanceof</span> SortedSet&lt;?&gt;) &#123;</span><br><span class="line">        SortedSet&lt;? extends E&gt; ss = (SortedSet&lt;? extends E&gt;) c;</span><br><span class="line">        <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) ss.comparator();</span><br><span class="line">        heapify = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c <span class="keyword">instanceof</span> PriorityBlockingQueue&lt;?&gt;) &#123;</span><br><span class="line">        PriorityBlockingQueue&lt;? extends E&gt; pq = (PriorityBlockingQueue&lt;? extends E&gt;) c;</span><br><span class="line">        <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) pq.comparator();</span><br><span class="line">        screen = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (pq.getClass() == PriorityBlockingQueue.class) <span class="comment">// exact match</span></span><br><span class="line">            heapify = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">if</span> (a.getClass() != Object[].class) <span class="comment">// 构建数组</span></span><br><span class="line">        a = Arrays.copyOf(a, n, Object[].class);</span><br><span class="line">    <span class="keyword">if</span> (screen &amp;&amp; (n == <span class="number">1</span> || <span class="keyword">this</span>.comparator != <span class="keyword">null</span>)) &#123; <span class="comment">// 判空操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (a[i] == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.queue = a;</span><br><span class="line">    <span class="keyword">this</span>.size = n;</span><br><span class="line">    <span class="keyword">if</span> (heapify)</span><br><span class="line">        heapify(); <span class="comment">// 对队列进行排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组扩容</span></span><br><span class="line"><span class="comment"> * 调用该方法的前提是已经获取了锁</span></span><br><span class="line"><span class="comment"> * oldCap &gt; 64的情况是以50%的速率进行扩容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 旧数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> oldCap 旧数组的容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryGrow</span><span class="params">(Object[] array, <span class="keyword">int</span> oldCap)</span> </span>&#123;</span><br><span class="line">    lock.unlock();  <span class="comment">// 调用此方法的前提是已经获取了锁，而这先是释放锁让其他线程可以去获取元素</span></span><br><span class="line">    Object[] newArray = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (allocationSpinLock == <span class="number">0</span> &amp;&amp; UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, allocationSpinLockOffset, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> newCap = oldCap + ((oldCap &lt; <span class="number">64</span>) ? (oldCap + <span class="number">2</span>) : (oldCap &gt;&gt; <span class="number">1</span>)); <span class="comment">// 计算新数组的容量大小，oldCap &gt; 64的情况是以50%的速率进行扩容</span></span><br><span class="line">            <span class="keyword">if</span> (newCap - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;    <span class="comment">// 防止溢出</span></span><br><span class="line">                <span class="keyword">int</span> minCap = oldCap + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (minCap &lt; <span class="number">0</span> || minCap &gt; MAX_ARRAY_SIZE)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">                newCap = MAX_ARRAY_SIZE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newCap &gt; oldCap &amp;&amp; queue == array)</span><br><span class="line">                newArray = <span class="keyword">new</span> Object[newCap]; <span class="comment">// 新数组</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            allocationSpinLock = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newArray == <span class="keyword">null</span>) <span class="comment">// newArray == null说明其他的线程也在调用扩容方法，不过有一个线程在扩容就可以了，所以让其放弃线程调度</span></span><br><span class="line">        Thread.yield();</span><br><span class="line">    lock.lock(); <span class="comment">// 由于新数组已经构建完成了，现在需要赋值了，为了避免多线程的干扰需要先上锁</span></span><br><span class="line">    <span class="keyword">if</span> (newArray != <span class="keyword">null</span> &amp;&amp; queue == array) &#123;</span><br><span class="line">        queue = newArray;</span><br><span class="line">        System.arraycopy(array, <span class="number">0</span>, newArray, <span class="number">0</span>, oldCap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 出队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Object[] array = queue;</span><br><span class="line">        E result = (E) array[<span class="number">0</span>];</span><br><span class="line">        E x = (E) array[n];</span><br><span class="line">        array[n] = <span class="keyword">null</span>;</span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> E&gt; cmp = comparator;</span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line">            siftDownComparable(<span class="number">0</span>, x, array, n); <span class="comment">// 下沉</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftDownUsingComparator(<span class="number">0</span>, x, array, n, cmp);</span><br><span class="line">        size = n;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上浮插入的元素以满足二叉堆的性质</span></span><br><span class="line"><span class="comment"> * 二叉堆的性质：PriorityBlockingQueue采用的是最小堆，即父元素的数值比子元素的数值要小</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 插入的元素的操作步骤一般如下：</span></span><br><span class="line"><span class="comment"> * 1. 将插入的元素放到数组的末尾</span></span><br><span class="line"><span class="comment"> * 2. 由于需要父元素的数组比子元素的数值要小，故要与父元素进行比较</span></span><br><span class="line"><span class="comment"> * 3. 若插入的元素比父元素小，则将插入的元素与父元素进行值交换，在交换后它又有了新的父元素，故而需要继续往上比较，直到堆顶或不在小于父元素，相当于在重复步骤2</span></span><br><span class="line"><span class="comment"> * 4. 若插入的元素比父元素大，直接结束</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 假设一个元素的索引为：N，其父元素的索引为：(N - 1)/2，左子元素的索引为：2N + 1，其右子元素的索引为：2N + 2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 插入的元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 插入的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable&lt;? <span class="keyword">super</span> T&gt;) x;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// 父节点的索引</span></span><br><span class="line">        Object e = array[parent];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((T) e) &gt;= <span class="number">0</span>) <span class="comment">//插入的节点与父节点进行比较，若大于则直接退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        array[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    array[k] = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同上，唯一的差别是在比较器上</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 插入的元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 插入的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cmp 比较器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftUpUsingComparator</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array, Comparator&lt;? <span class="keyword">super</span> T&gt; cmp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Object e = array[parent];</span><br><span class="line">        <span class="keyword">if</span> (cmp.compare(x, (T) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        array[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    array[k] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下沉元素以满足二叉堆的性质，下沉就是拿指定元素与其左右子元素进行比较</span></span><br><span class="line"><span class="comment"> * 思路：</span></span><br><span class="line"><span class="comment"> * - 不管移除的是哪个元素，拿数组末尾的元素是最少成本的，因为拿该元素的值去覆盖移除元素的值来使其还是一颗完全二叉树，所以最终只要让其满足二叉堆性质就可以了</span></span><br><span class="line"><span class="comment"> * - 针对移除元素来说，就相当于把移除元素的位置空出来了，因为是二叉堆要满足其性质，所以就要考虑是它的子节点还是末尾的节点更适合来做移除元素的位置（最大堆/最小堆）</span></span><br><span class="line"><span class="comment"> * - 因为末尾元素最终都会被移动到指定位置，故而先将末尾位置置null</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 针对要移除的元素分为两种情况（最小堆）：</span></span><br><span class="line"><span class="comment"> * 1. 移除的元素无子元素，也就是说是叶子节点，如下步骤：</span></span><br><span class="line"><span class="comment"> *       11. 直接将末尾的元素的值覆盖，同时将末尾位置设置成null，因为它并无子元素，所以不用考虑是否比子元素大，但是有一点要考虑是覆盖完后是否比父元素还要小</span></span><br><span class="line"><span class="comment"> *       12. 若比父元素还要小的话就要做上浮操作，即调用siftUpUsingComparator/siftUpComparable即可，最后退出</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. 删除的元素有子元素，如下步骤：</span></span><br><span class="line"><span class="comment"> *       21. 先比较两个子元素的值的大小，获取值最小的元素</span></span><br><span class="line"><span class="comment"> *       22. 在将值最小的元素与末尾的元素进行比较（若只有一个子元素的话，那么只能是左子元素，就直接比较大小）</span></span><br><span class="line"><span class="comment"> *       23. 若是末尾的元素更小的话，那么直接覆盖移除的元素的值即可，同时将末尾位置设置成null，最后退出</span></span><br><span class="line"><span class="comment"> *       24. 若是其子元素更小的话，那么用其值最小的元素覆盖到移除的元素的值，此时值最小的元素的位置就空出来了（相当于此时它被移除了），那么此时重复步骤12</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 假设一个元素的索引为：N，其父元素的索引为：(N - 1)/2，左子元素的索引为：2N + 1，其右子元素的索引为：2N + 2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 移除/指定元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 末尾/指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 数组的容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable&lt;? <span class="keyword">super</span> T&gt;)x;</span><br><span class="line">        <span class="keyword">int</span> half = n &gt;&gt;&gt; <span class="number">1</span>;          <span class="comment">// 通过该值来判断移除节点是否有子元素，可以画几个例子验证下，我也不懂怎么来的，只能说写算法的人牛逼</span></span><br><span class="line">        <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">            <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 移除元素的左子元素的索引</span></span><br><span class="line">            Object c = array[child];</span><br><span class="line">            <span class="keyword">int</span> right = child + <span class="number">1</span>; <span class="comment">// 移除元素的右子元素的索引</span></span><br><span class="line">            <span class="keyword">if</span> (right &lt; n &amp;&amp;  ((Comparable&lt;? <span class="keyword">super</span> T&gt;) c).compareTo((T) array[right]) &gt; <span class="number">0</span>) <span class="comment">// 先判断是否存在右子元素，若左右子元素都存在，那么要找出值最小的元素</span></span><br><span class="line">                c = array[child = right];</span><br><span class="line">            <span class="keyword">if</span> (key.compareTo((T) c) &lt;= <span class="number">0</span>) <span class="comment">// 末尾元素与值最小的元素进行比较</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            array[k] = c;</span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        array[k] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同上，唯一的差别是在比较器上</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 移除/指定元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 末尾/指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 数组的容量大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cmp 比较器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftDownUsingComparator</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array, <span class="keyword">int</span> n, Comparator&lt;? <span class="keyword">super</span> T&gt; cmp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> half = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">            <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            Object c = array[child];</span><br><span class="line">            <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; n &amp;&amp; cmp.compare((T) c, (T) array[right]) &gt; <span class="number">0</span>)</span><br><span class="line">                c = array[child = right];</span><br><span class="line">            <span class="keyword">if</span> (cmp.compare(x, (T) c) &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            array[k] = c;</span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        array[k] = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建二叉堆，实际上就是排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object[] array = queue;</span><br><span class="line">    <span class="keyword">int</span> n = size;</span><br><span class="line">    <span class="keyword">int</span> half = (n &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> E&gt; cmp = comparator;</span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="keyword">null</span>) &#123; <span class="comment">// 涉及到算法的内容我也不懂...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = half; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            siftDownComparable(i, (E) array[i], array, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = half; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            siftDownUsingComparator(i, (E) array[i], array, n, cmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入元素</span></span><br><span class="line"><span class="comment"> * 当队列饱满的情况下会发生扩容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout 指定时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">int</span> n, cap;</span><br><span class="line">    Object[] array;</span><br><span class="line">    <span class="keyword">while</span> ((n = size) &gt;= (cap = (array = queue).length))</span><br><span class="line">        tryGrow(array, cap); <span class="comment">// 扩容</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> E&gt; cmp = comparator;</span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line">            siftUpComparable(n, e, array); <span class="comment">// 上浮</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftUpUsingComparator(n, e, array, cmp);</span><br><span class="line">        size = n + <span class="number">1</span>;</span><br><span class="line">        notEmpty.signal(); <span class="comment">// 从空队列中获取元素导致阻塞直到新元素插入时被唤醒</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取元素</span></span><br><span class="line"><span class="comment"> * 当队列为空的情况下直接返回null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取元素</span></span><br><span class="line"><span class="comment"> * 当队列为空的情况下一直阻塞等待，直到被唤醒或被中断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    E result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> ( (result = dequeue()) == <span class="keyword">null</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取元素</span></span><br><span class="line"><span class="comment"> * 当队列为空的情况下阻塞等待指定时间，直到被唤醒或被中断或超时</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout 指定时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    E result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> ( (result = dequeue()) == <span class="keyword">null</span> &amp;&amp; nanos &gt; <span class="number">0</span>)</span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取元素</span></span><br><span class="line"><span class="comment"> * 与前面的三个方法较大不同，因为其不会导致元素出队列，所以该方法即使调用多次依然能获取到元素，而其他三个方法则不行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (size == <span class="number">0</span>) ? <span class="keyword">null</span> : (E) queue[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = indexOf(o);</span><br><span class="line">        <span class="keyword">if</span> (i == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        removeAt(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>PriorityBlockingQueue虽然提供了多个插入元素的方法，但实际上都调用的同一个方法，所以在队列饱满的情况下<code>插入</code>新元素会发生扩容从而继续执行，也就是<code>不会发生阻塞</code>；</p><ul><li><p>在队列为空的情况下<code>获取元素</code></p><ul><li><p>poll：直接返回null</p></li><li><p>take：一直被阻塞等待直到被唤醒或线程被中断</p></li><li><p>poll(time)：阻塞等待直到被唤醒或线程被中断或<code>超时</code></p></li><li><p>peek：直接返回null，该方法即使调用多次依然能获取到元素，而其余3个方法则不行</p></li></ul></li></ul><p>PriorityBlockingQueue最大的特点就是无界及二叉堆，关于二叉堆最好是能理解上浮与下沉的代码，说不定以后面试会考呢！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;探索PriorityBlockingQueue是基于&lt;code&gt;JDK1.8&lt;/code&gt;，它是基于&lt;code&gt;二叉堆&lt;/code&gt;的无界阻塞队列，二叉堆又可以分成最大堆与最小堆，很显然，既然是优先级队列，那么优先级高者自然比优先级低者优先出队列，PriorityBlockingQueue采用的是数值越小优先级越高，即最小堆，利用每个元素的优先级进行排序，所以这不在是按照先进先出顺序了！对于无界来说，就不会存在队列饱满的情况了，它会进行扩容，自然也就不会发生阻塞的情况了，这是与ArrayBlockingQueue/LinkedBlockingQueue最大的区别了，不过在空队列的情况下仍然会发生阻塞直到出现新元素才会被唤醒继续执行。对于优先级队列而言，自然是在添加的时候比较每个元素的优先级高低，所以它要求每个元素必须继承Comparable或自定义比较器，更不能添加null。最后在说一点，接下来的内容将不会着重介绍二叉堆，它较为简单且之前的文章也简单介绍过，所以读者可以先了解下，有助于理解其中的方法，接下来进入主题。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>挖掘队列源码之LinkedBlockingQueue</title>
    <link href="http://zlia.tech/2020/03/06/explain-linkedblockingqueue-sourcecode/"/>
    <id>http://zlia.tech/2020/03/06/explain-linkedblockingqueue-sourcecode/</id>
    <published>2020-03-06T08:28:38.000Z</published>
    <updated>2020-03-09T07:16:49.902Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>探索LinkedBlockingQueue是基于<code>JDK1.8</code>，由注释可知是基于<code>单链表</code>的阻塞队列，至于其队列是否有界取决于其队列的容量大小，从严格意义上来说，它是<code>有界</code>队列，按照先进先出的顺序访问，新元素被插入到队列的尾部，从队列头部获取元素，提供在将新元素放入到饱满的队列中会导致阻塞，直到队列出现新的位置才会被唤醒继续往下操作的方法，还支持在从空队列中获取元素会导致阻塞，直到队列出现元素才会被唤醒的方法，通常情况下LinkedBlockingQueue比ArrayBlockingQueue具有更高的吞吐量，因为其内部采用了两个锁，意味着<code>读写分离</code>，所以效率上更快，但这同时也造成了队列的可预测性较差，接下来进入到主题吧。</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列的容量大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列中元素的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列的头部元素，用于获取元素</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列的尾部元素，用于插入元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供获取元素时的锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从空队列中获取元素导致阻塞直到新元素插入时被唤醒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供插入元素时的锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新元素放入到饱满的队列中导致阻塞直到队列出现空位置时被唤醒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> * 构建一个Integer.MAX_VALUE容量大小的队列 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity 容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按顺序插入集合中的元素并初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">if</span> (n == capacity)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">            enqueue(<span class="keyword">new</span> Node&lt;E&gt;(e)); <span class="comment">// 入队列</span></span><br><span class="line">            ++n;</span><br><span class="line">        &#125;</span><br><span class="line">        count.set(n);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 唤醒阻塞，从空队列中获取元素导致阻塞直到新元素插入时被唤醒，所以该方法只会被put/offer调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 唤醒阻塞，新元素放入到饱满的队列中导致阻塞直到队列出现空位置时被唤醒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 入队列</span></span><br><span class="line"><span class="comment"> * 由于是按照先进先出的顺序访问，所以插入的元素放在末尾</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 出队列</span></span><br><span class="line"><span class="comment"> * LinkedBlockingQueue在初始化时head = new Node(null)，所以在出队列时应该获取其next下一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    Node&lt;E&gt; first = h.next;</span><br><span class="line">    h.next = h; <span class="comment">// help GC</span></span><br><span class="line">    head = first;</span><br><span class="line">    E x = first.item;</span><br><span class="line">    first.item = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同时上锁，因为要遍历队列，防止其他线程同时修改其数据结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fullyLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    takeLock.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fullyUnlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    takeLock.unlock();</span><br><span class="line">    putLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入元素</span></span><br><span class="line"><span class="comment"> * 当队列饱满的情况下会一直阻塞等待，直到被唤醒或被中断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 元素 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly(); <span class="comment">// 可中断的锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await(); <span class="comment">// 阻塞等待空位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(node);</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 通常情况下 notFull应该是在获取元素时去唤醒的，但是这里却出现了，以下是个人的理解</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 既然作者考虑了读写分离，那么在读或写的时候就不会出现另一种情况的锁，简单来说，在调用take方法时就不会出现putLock锁，在调用put时就不会出现takeLock锁</span></span><br><span class="line"><span class="comment">         * 但是不行啊，这样子不就无法正常唤醒了吗，是的，所以为了减少获取锁的次数，因为在调用signal之前必须要先获取对应的锁，不然会抛异常</span></span><br><span class="line"><span class="comment">         * 那么就设计成只获取一次或者说只出现一次获取锁，所以在take方法中就出现了这样子的代码</span></span><br><span class="line"><span class="comment">         *  if (c == capacity)</span></span><br><span class="line"><span class="comment">         *      signalNotFull();</span></span><br><span class="line"><span class="comment">         * 也就是说只有在饱满队列情况下去获取元素时我才会唤醒，其余情况下我压根就不管了，所以总结一点就是它只会唤醒一次，那这样子可不行啊，多个线程阻塞的情况下只会有一个线程被唤醒，其他线程可怎么办呢?</span></span><br><span class="line"><span class="comment">         * 所以就出现了如下的代码片段，在多次获取元素时count的值会改变，那么只要唤醒一次后，在put方法中就有机会执行下面的代码片段来唤醒其他的线程，所以这就解决问题了</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 总结：减少获取锁，实际上这也是因为读写分离所造成的代码，你看ArrayBlockingQueue就不需要</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="comment">// 跟take方法中的代码片段效果一样，只会唤醒一次notEmpty</span></span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入元素</span></span><br><span class="line"><span class="comment"> * 当队列饱满的情况下会阻塞等待指定时间，直到被唤醒或被中断或超时</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout 指定时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(<span class="keyword">new</span> Node&lt;E&gt;(e));</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity) <span class="comment">// 可参考put方法中的解释</span></span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入元素</span></span><br><span class="line"><span class="comment"> * 当队列饱满的情况下会返回false</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">if</span> (count.get() == capacity)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count.get() &lt; capacity) &#123;</span><br><span class="line">            enqueue(node);</span><br><span class="line">            c = count.getAndIncrement();</span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取元素</span></span><br><span class="line"><span class="comment"> * 当队列为空的情况下一直阻塞等待，直到被唤醒或被中断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>) <span class="comment">// 与put方法中的作用有异曲同工</span></span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取元素</span></span><br><span class="line"><span class="comment"> * 当队列为空的情况下阻塞等待指定时间，直到被唤醒或被中断或超时</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout 指定时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取元素</span></span><br><span class="line"><span class="comment"> * 当队列为空的情况下直接返回null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">if</span> (count.get() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    E x = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count.get() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = dequeue();</span><br><span class="line">            c = count.getAndDecrement();</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">                notEmpty.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取元素</span></span><br><span class="line"><span class="comment"> * 与前面的三个方法较大不同，因为其不会导致head指向发生改变，所以该方法即使调用多次依然能获取到元素，而其他三个方法则不行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count.get() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Node&lt;E&gt; first = head.next;</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> first.item;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除指定节点，解除关联关系</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 指定节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> trail 上一个节点 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlink</span><span class="params">(Node&lt;E&gt; p, Node&lt;E&gt; trail)</span> </span>&#123;</span><br><span class="line">    p.item = <span class="keyword">null</span>;</span><br><span class="line">    trail.next = p.next;</span><br><span class="line">    <span class="keyword">if</span> (last == p)</span><br><span class="line">        last = trail;</span><br><span class="line">    <span class="keyword">if</span> (count.getAndDecrement() == capacity)</span><br><span class="line">        notFull.signal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    fullyLock(); <span class="comment">// 由于后续要遍历队列，所以应该防止其他线程修改其数据结构，否则将造成数据不一致</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; trail = head, p = trail.next;</span><br><span class="line">             p != <span class="keyword">null</span>;</span><br><span class="line">             trail = p, p = p.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(p.item)) &#123;</span><br><span class="line">                unlink(p, trail);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fullyUnlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>LinkedBlockingQueue提供了多种插入/获取元素的方法，先简单说下区别：</p><ul><li><p>在队列饱满的情况下<code>插入新元素</code></p><ul><li><p>add：直接抛出异常</p></li><li><p>offer：直接返回false</p></li><li><p>put：一直阻塞等待直到被唤醒或线程被中断</p></li><li><p>offer(time)：阻塞等待指定时间，直到被唤醒或被中断或<code>超时</code></p></li></ul></li><li><p>在队列为空的情况下<code>获取元素</code></p><ul><li><p>poll：直接返回null</p></li><li><p>take：一直被阻塞等待直到被唤醒或线程被中断</p></li><li><p>poll(time)：阻塞等待直到被唤醒或线程被中断或<code>超时</code></p></li><li><p>peek：直接返回null，该方法即使调用多次依然能获取到元素，而其余3个方法则不行</p></li></ul></li></ul><p>与ArrayBlockingQueue完全一致…说下不同点吧，为了方便ArrayBlockingQueue将直接写成ABQ，LinkedBlockingQueue写成LBQ</p><ul><li><p>ABQ同一时间<code>要么是读要么写</code>，LBQ<code>读写分离</code>，所以LBQ的吞吐量比ABQ高，但预测性较差</p></li><li><p>ABQ数据结构是<code>数组</code>有界阻塞队列，LBQ数据结构是<code>单链表</code>有界阻塞队列</p></li></ul><p>关于LBQ读写分离的代码与ABQ有着较大的区别，读者最好去理解下！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;探索LinkedBlockingQueue是基于&lt;code&gt;JDK1.8&lt;/code&gt;，由注释可知是基于&lt;code&gt;单链表&lt;/code&gt;的阻塞队列，至于其队列是否有界取决于其队列的容量大小，从严格意义上来说，它是&lt;code&gt;有界&lt;/code&gt;队列，按照先进先出的顺序访问，新元素被插入到队列的尾部，从队列头部获取元素，提供在将新元素放入到饱满的队列中会导致阻塞，直到队列出现新的位置才会被唤醒继续往下操作的方法，还支持在从空队列中获取元素会导致阻塞，直到队列出现元素才会被唤醒的方法，通常情况下LinkedBlockingQueue比ArrayBlockingQueue具有更高的吞吐量，因为其内部采用了两个锁，意味着&lt;code&gt;读写分离&lt;/code&gt;，所以效率上更快，但这同时也造成了队列的可预测性较差，接下来进入到主题吧。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>挖掘队列源码之ArrayBlockingQueue</title>
    <link href="http://zlia.tech/2020/03/05/explain-arrayblockingqueue-sourcecode/"/>
    <id>http://zlia.tech/2020/03/05/explain-arrayblockingqueue-sourcecode/</id>
    <published>2020-03-05T07:15:49.000Z</published>
    <updated>2020-03-06T08:07:03.500Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>上一段时间一直在探索线程池的路上，如今准备踏入到队列，还是按照一开始的阅读方式。探索ArrayBlockingQueue是基于<code>JDK1.8</code>，从注释上可以得知是一个由<code>数组</code>支持的有界阻塞队列，按照先进先出的顺序，新元素被插入到队列的尾部，从队列头部获取元素，提供在将新元素放入到饱满的队列中会导致阻塞，直到队列出现新的位置才会被唤醒继续往下操作的方法，还支持在从空队列中获取元素会导致阻塞，直到队列出现元素才会被唤醒的方法。有一个点需要注意下，ArrayBlockingQueue在某些情况下插入新元素时会执行相当于循环的操作，怎么表述呢，当在数组的最后一个索引处上插入新元素后，那么插入下一个新元素的索引将会是0，有点类似循环，而由于LinkedBlockingQueue不同的数据结构并不会发生这种情况，还有一点就是ArrayBlockingQueue内部中只有一个锁，所以对于读写来说，同时只能有一个操作在执行，要么是读要么是写，而LinkedBlockingQueue采用的是两个锁的读写分离，好了，接下来直接进入主题吧。</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于存储插入的元素</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个获取的索引</span></span><br><span class="line">    <span class="keyword">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个插入的索引</span></span><br><span class="line">    <span class="keyword">int</span> putIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列中元素的个数</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可重入锁，防止多线程并发访问队列</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从空队列中获取元素导致阻塞直到新元素插入时被唤醒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新元素放入到饱满的队列中导致阻塞直到队列出现空位置时被唤醒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="keyword">transient</span> Itrs itrs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity 数组的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity 数组的大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair true：队列按照先进先出的顺序访问，false：不确定的顺序访问</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按顺序插入集合中的元素并初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity 数组的大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair true：队列按照先进先出的顺序访问，false：不确定的顺序访问</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(capacity, fair);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">                checkNotNull(e);</span><br><span class="line">                items[i++] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        count = i;</span><br><span class="line">        putIndex = (i == capacity) ? <span class="number">0</span> : i;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 循环递减i</span></span><br><span class="line"><span class="comment"> * 若 i = 0  -&gt; i = items.length - 1</span></span><br><span class="line"><span class="comment"> * 若 i &gt; 0  -&gt; i = i -1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 变量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i == <span class="number">0</span>) ? items.length : i) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取指定索引处的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> E <span class="title">itemAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) items[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.signal(); <span class="comment">// 已经插入元素了，应该唤醒等待获取元素的线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 出队列（获取元素）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    notFull.signal(); <span class="comment">// 已经有元素出队列了，应该唤醒等待插入新元素的线程</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除指定索引处的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> removeIndex</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeAt</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> removeIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 仔细观察可以发现 takeIndex ~ putIndex - 1 之间的元素都不为null，为了保证如此结构只有当removeIndex介于这两者之间时才需要将removeIndex后续的元素往前移动</span></span><br><span class="line"><span class="comment">     * 而其他情况如 removeIndex == takeIndex 或 removeIndex == putIndex - 1只要将其置为null即可</span></span><br><span class="line"><span class="comment">     * 但在else代码片段中不考虑其他调用代码的情况下还是有可能出现removeIndex &lt; takeIndex 或 removeIndex &gt; putIndex的情况，但这两种情况并不影响，实际上在调用代码中并未出现这两种情况</span></span><br><span class="line"><span class="comment">     * 所以实际上只判断了 takeIndex &lt; removeIndex &lt; putIndex </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (removeIndex == takeIndex) &#123; <span class="comment">// 当removeIndex == takeIndex时直接将其置为null即可</span></span><br><span class="line">        items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">            takeIndex = <span class="number">0</span>;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">            itrs.elementDequeued();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> putIndex = <span class="keyword">this</span>.putIndex;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = removeIndex;;) &#123; <span class="comment">// 在takeIndex &lt; removeIndex &lt; putIndex的情况下需要将removeIndex后续的元素往前移动</span></span><br><span class="line">            <span class="keyword">int</span> next = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (next == items.length)</span><br><span class="line">                next = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (next != putIndex) &#123;</span><br><span class="line">                items[i] = items[next];</span><br><span class="line">                i = next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                items[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">this</span>.putIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">            itrs.removedAt(removeIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    notFull.signal(); <span class="comment">// 已经有元素出队列了，应该唤醒等待插入新元素的线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入元素</span></span><br><span class="line"><span class="comment"> * 实际上调用了offer方法，当队列饱满的情况下会抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否插入成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.add(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入元素</span></span><br><span class="line"><span class="comment"> * 当队列饱满的情况下会返回false</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == items.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            enqueue(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入元素</span></span><br><span class="line"><span class="comment"> * 当队列饱满的情况下会一直阻塞等待，直到被唤醒或被中断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">// lock.lockInterruptibly与lock.lock的区别在于前者是可以发生中断的，也就是会直接抛出异常退出程序，而后者则不允许，两者都会锁住线程</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入元素</span></span><br><span class="line"><span class="comment"> * 当队列饱满的情况下会阻塞等待指定时间，直到被唤醒或被中断或超时</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout 指定时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">// 可中断的锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            nanos = notFull.awaitNanos(nanos); <span class="comment">// 阻塞等待指定时间</span></span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取元素</span></span><br><span class="line"><span class="comment"> * 当队列为空的情况下直接返回null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取元素</span></span><br><span class="line"><span class="comment"> * 当队列为空的情况下一直阻塞等待，直到被唤醒或被中断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取元素</span></span><br><span class="line"><span class="comment"> * 当队列为空的情况下阻塞等待指定时间，直到被唤醒或被中断或超时</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout 指定时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取元素</span></span><br><span class="line"><span class="comment"> * 与前面的三个方法较大不同，因为它调用的itemAt方法不会导致takeIndex索引自增，所以该方法即使调用多次依然能获取到元素，而其他三个方法则不行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> itemAt(takeIndex); <span class="comment">// null when queue is empty</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> putIndex = <span class="keyword">this</span>.putIndex;</span><br><span class="line">            <span class="keyword">int</span> i = takeIndex;</span><br><span class="line">            <span class="keyword">do</span> &#123; <span class="comment">// 遍历查找 takeIndex ~ putIndex -1 之间的元素</span></span><br><span class="line">                <span class="keyword">if</span> (o.equals(items[i])) &#123;</span><br><span class="line">                    removeAt(i);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (++i == items.length)</span><br><span class="line">                    i = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (i != putIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> k = count;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> putIndex = <span class="keyword">this</span>.putIndex;</span><br><span class="line">            <span class="keyword">int</span> i = takeIndex;</span><br><span class="line">            <span class="keyword">do</span> &#123; <span class="comment">// 遍历队列并清空</span></span><br><span class="line">                items[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (++i == items.length)</span><br><span class="line">                    i = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (i != putIndex);</span><br><span class="line">            takeIndex = putIndex; <span class="comment">// 细节部分，takeIndex = putIndex是为了下次插入新元素后可以获取到</span></span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">                itrs.queueIsEmpty();</span><br><span class="line">            <span class="keyword">for</span> (; k &gt; <span class="number">0</span> &amp;&amp; lock.hasWaiters(notFull); k--)</span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将队列中的元素添加到集合中，添加指定个数</span></span><br><span class="line"><span class="comment"> * 这些被添加到集合的元素将会使对应队列上的位置为null，相当于从队列拿出去了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxElements 指定元素个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span> </span>&#123;</span><br><span class="line">    checkNotNull(c);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (maxElements &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> n = Math.min(maxElements, count);  <span class="comment">// 将队列中的元素添加到集合的个数，最小值是maxElements，最大值是count</span></span><br><span class="line">        <span class="keyword">int</span> take = takeIndex;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n) &#123; <span class="comment">// 从takeIndex开始遍历获取元素</span></span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                E x = (E) items[take];</span><br><span class="line">                c.add(x); <span class="comment">// 即使add发生异常，那么发生异常之前添加的元素依然存在</span></span><br><span class="line">                items[take] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (++take == items.length)</span><br><span class="line">                    take = <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 队列中的元素被添加到集合后，该队列对应索引上的元素就会变成null，所以这里也要更新其索引与元素个数</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                count -= i;</span><br><span class="line">                takeIndex = take;</span><br><span class="line">                <span class="keyword">if</span> (itrs != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">                        itrs.queueIsEmpty();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; take)</span><br><span class="line">                        itrs.takeIndexWrapped();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (; i &gt; <span class="number">0</span> &amp;&amp; lock.hasWaiters(notFull); i--)</span><br><span class="line">                    notFull.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关于迭代器的内容就不做讲解了...</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>ArrayBlockingQueue提供了多种插入/获取元素的方法，先简单说下区别：</p><ul><li><p>在队列饱满的情况下<code>插入新元素</code></p><ul><li><p>add：直接抛出异常</p></li><li><p>offer：直接返回false</p></li><li><p>put：一直阻塞等待直到被唤醒或线程被中断</p></li><li><p>offer(time)：阻塞等待指定时间，直到被唤醒或被中断或<code>超时</code></p></li></ul></li><li><p>在队列为空的情况下<code>获取元素</code></p><ul><li><p>poll：直接返回null</p></li><li><p>take：一直被阻塞等待直到被唤醒或线程被中断</p></li><li><p>poll(time)：阻塞等待直到被唤醒或线程被中断或<code>超时</code></p></li><li><p>peek：直接返回null，该方法即使调用多次依然能获取到元素，而其余3个方法则不行</p></li></ul></li></ul><p>关于ArrayBlockingQueue的知识点并不是很多，很容易掌握！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;上一段时间一直在探索线程池的路上，如今准备踏入到队列，还是按照一开始的阅读方式。探索ArrayBlockingQueue是基于&lt;code&gt;JDK1.8&lt;/code&gt;，从注释上可以得知是一个由&lt;code&gt;数组&lt;/code&gt;支持的有界阻塞队列，按照先进先出的顺序，新元素被插入到队列的尾部，从队列头部获取元素，提供在将新元素放入到饱满的队列中会导致阻塞，直到队列出现新的位置才会被唤醒继续往下操作的方法，还支持在从空队列中获取元素会导致阻塞，直到队列出现元素才会被唤醒的方法。有一个点需要注意下，ArrayBlockingQueue在某些情况下插入新元素时会执行相当于循环的操作，怎么表述呢，当在数组的最后一个索引处上插入新元素后，那么插入下一个新元素的索引将会是0，有点类似循环，而由于LinkedBlockingQueue不同的数据结构并不会发生这种情况，还有一点就是ArrayBlockingQueue内部中只有一个锁，所以对于读写来说，同时只能有一个操作在执行，要么是读要么是写，而LinkedBlockingQueue采用的是两个锁的读写分离，好了，接下来直接进入主题吧。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>假装很懂CompletableFuture</title>
    <link href="http://zlia.tech/2020/03/03/explain-completablefuture-sourcecode/"/>
    <id>http://zlia.tech/2020/03/03/explain-completablefuture-sourcecode/</id>
    <published>2020-03-03T08:41:58.000Z</published>
    <updated>2020-03-03T08:41:58.053Z</updated>
    
    <content type="html"><![CDATA[<h3 id="正题"><a href="#正题" class="headerlink" title="正题"></a><div><span>正题</span></div></h3><p>CompletableFuture是<code>JDK1.8</code>才出现的，至于是否拥有很强大的功能其实我也未在工作上实践过，不过话说回来，即使实践过当时的我也是看不懂地，因为我现在才有时间来对它做一个了解，在此之前先来看看它的父接口-CompletionStage与Future。对于CompletionStage来说，它被认为是一个执行的<code>阶段</code>，可以是同步或异步，每一个阶段完成的同时有可能触发其他阶段，也就是说阶段之间是可以相互依赖的，好比是流水作业，虽然它可以执行各种计算，即使是复杂的链式计算也是手到擒来，但也存在一些弊端，比如无法探测计算是否完成或获取计算的结果或等待其阶段执行完成，所以为了使其更健壮，它又实现了Future接口，可它又与Future的实现类有着区别，比如对于cancel来说，它会当作是异常执行完成。CompletableFuture是两者的结合物，提供的方法有很多种，简单总结下。</p><blockquote><p><code>带有后缀名为Async的方法</code>表示以异步的方式执行任务，通常情况下使用ForkJoinPool公共线程池；<code>带有前缀名为then的方法</code>表示阶段之间具有依赖关系，需要上一个阶段执行完毕后才能触发下一个阶段；<code>带有后缀名为Either的方法</code>表示在多重依赖下只会依赖其中任何一个阶段，即任何一个阶段执行完成即可执行当前阶段；</p></blockquote><p>在阅读源码之前，读者最好能把CompletableFuture、Completion、UniCompletion等之间的数据结构画出来，清晰的结构关系能够帮助理解，在下面的代码中会提到一些个人对相关类的理解与称谓。</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><p>为了方便理解，将每个类都加上一个称谓，同时说明之间的关系：</p><ul><li><p>CompletableFuture：<code>阶段</code>，一个阶段自身只有一个步骤，一个阶段可以依赖另一个阶段，在这种情况下通常会将依赖阶段的步骤放入到被依赖阶段的链表中，等到被依赖阶段执行完成后会通知执行链表，以此来执行依赖阶段</p></li><li><p>Completion：<code>步骤</code>，当前步骤可以关联下一个步骤</p></li><li><p>UniApply：<code>步骤</code>，因为其是Completion的子类</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFuture</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">T</span>&gt;, <span class="title">CompletionStage</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行完成的结果</span></span><br><span class="line"><span class="comment">     * 若是正常执行且有设置结果的话则直接返回结果，若无设置结果则返回null </span></span><br><span class="line"><span class="comment">     * 若是异常完成则会抛出异常，通过AltResult对象来包装异常信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> Object result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 依赖于当前阶段的阶段的步骤</span></span><br><span class="line"><span class="comment">     * 只有在当前阶段执行完成后才会通知执行依赖阶段的步骤，否则就不具有依赖关系了，而通知的具体方法就是postComplete</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> Completion stack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示当前阶段是同步直接执行</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SYNC   =  <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示当前阶段是异步直接执行</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ASYNC  =  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示当前阶段是由嵌套引发执行，即postComplete引发执行</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NESTED = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 若公共线程池的并行数大于1，即工作线程数大于1，则使用公共线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> useCommonPool = (ForkJoinPool.getCommonPoolParallelism() &gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通常情况下使用公共线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor asyncPool = useCommonPool ? ForkJoinPool.commonPool() : <span class="keyword">new</span> ThreadPerTaskExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 包装执行结果为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> AltResult NIL = <span class="keyword">new</span> AltResult(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CompletableFuture</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> r 执行结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">CompletableFuture</span><span class="params">(Object r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.result = r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步执行任务并设置执行结果值，默认情况下的执行器是ForkJoinPool，即公共线程池</span></span><br><span class="line"><span class="comment"> * 每次调用该方法都会生成新的CompletableFuture对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> supplier 带有执行结果的任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> CompletableFuture新实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asyncSupplyStage(asyncPool, supplier);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用指定执行器异步执行任务并设置执行结果值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> supplier 带有执行结果的任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> executor 指定执行器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> CompletableFuture新实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asyncSupplyStage(screenExecutor(executor), supplier);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 校验执行器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 执行器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 执行器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Executor <span class="title">screenExecutor</span><span class="params">(Executor e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!useCommonPool &amp;&amp; e == ForkJoinPool.commonPool())</span><br><span class="line">        <span class="keyword">return</span> asyncPool;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用指定执行器异步执行任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定执行器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> f 带有执行结果的任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> CompletableFuture新实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">asyncSupplyStage</span><span class="params">(Executor e, Supplier&lt;U&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    CompletableFuture&lt;U&gt; d = <span class="keyword">new</span> CompletableFuture&lt;U&gt;();</span><br><span class="line">    e.execute(<span class="keyword">new</span> AsyncSupply&lt;U&gt;(d, f));</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncSupply</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">Void</span>&gt; <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">AsynchronousCompletionTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前阶段</span></span><br><span class="line">    CompletableFuture&lt;T&gt; dep;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前阶段的执行结果</span></span><br><span class="line">    Supplier&lt;T&gt; fn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dep 当前阶段</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fn 当前阶段的执行结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AsyncSupply(CompletableFuture&lt;T&gt; dep, Supplier&lt;T&gt; fn) &#123;</span><br><span class="line">        <span class="keyword">this</span>.dep = dep; </span><br><span class="line">        <span class="keyword">this</span>.fn = fn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通常情况下getRawResult/setRawResult是用于设置其正常执行的结果，但由于这里是自定义ForkJoinTask任务，加上CompletableFuture中已经有成员属性来存储其结果，故两个方法暂时没用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Void <span class="title">getRawResult</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setRawResult</span><span class="params">(Void v)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认情况下由ForkJoinPool来执行阶段，若是看过ForkJoinPool源码的同学应该知道该方法最终会被调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        run(); </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CompletableFuture&lt;T&gt; d; Supplier&lt;T&gt; f;</span><br><span class="line">        <span class="keyword">if</span> ((d = dep) != <span class="keyword">null</span> &amp;&amp; (f = fn) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dep = <span class="keyword">null</span>; fn = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (d.result == <span class="keyword">null</span>) &#123; <span class="comment">// 判断是否执行完成</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    d.completeValue(f.get()); <span class="comment">// 设置执行结果</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    d.completeThrowable(ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            d.postComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置正常执行完成的结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t 执行完成的结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">completeValue</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, RESULT, <span class="keyword">null</span>, (t == <span class="keyword">null</span>) ? NIL : t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置异常执行完成的结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 异常信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">completeThrowable</span><span class="params">(Throwable x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, RESULT, <span class="keyword">null</span>, encodeThrowable(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包装异常信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 异常信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包装后的实例 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> AltResult <span class="title">encodeThrowable</span><span class="params">(Throwable x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AltResult((x <span class="keyword">instanceof</span> CompletionException) ? x : <span class="keyword">new</span> CompletionException(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通知依赖阶段执行</span></span><br><span class="line"><span class="comment"> * 当阶段执行完毕后才会调用此方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">postComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;?&gt; f = <span class="keyword">this</span>; <span class="comment">// 当前阶段</span></span><br><span class="line">    Completion h; <span class="comment">// 依赖当前阶段的步骤</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 假设有阶段A、B，当前阶段是A，B依赖于A，A.stack = a1 -&gt; a2 -&gt; a3   B.stack = b1 -&gt; b2 -&gt; b3，a1步骤对应B阶段，a2、a3、b1、b2、b3没有依赖关系</span></span><br><span class="line"><span class="comment">     * 在A阶段执行完毕后，A.stack = b2 -&gt; b1 -&gt; a2 -&gt; a3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> ((h = f.stack) != <span class="keyword">null</span> || (f != <span class="keyword">this</span> &amp;&amp; (h = (f = <span class="keyword">this</span>).stack) != <span class="keyword">null</span>)) &#123; <span class="comment">// 由于在执行tryFire时会使f发生改变，所以当f.stack为空时说明并无依赖关系，使f重新指向A.stack去处理剩余的阶段</span></span><br><span class="line">        CompletableFuture&lt;?&gt; d; Completion t; <span class="comment">// d：步骤对应的阶段    t：下一个步骤      h：当前步骤</span></span><br><span class="line">        <span class="keyword">if</span> (f.casStack(h, t = h.next)) &#123; <span class="comment">// 更新stack指向下一个步骤</span></span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123; <span class="comment">// </span></span><br><span class="line">                <span class="keyword">if</span> (f != <span class="keyword">this</span>) &#123; <span class="comment">// f != this 说明f对应的阶段是B</span></span><br><span class="line">                    pushStack(h); <span class="comment">// 将B阶段的步骤放入到A阶段stack的第一个位置上</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                h.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 由于执行postComplete方法是在A阶段执行完毕之后才会调用，所以说其依赖阶段在正常情况下执行tryFire都会返回依赖阶段的实例，因为有可能另外的阶段依赖了实例，所以要接着判断stack</span></span><br><span class="line"><span class="comment">             * 这里有一点需要注意的是，在依赖关系中，B阶段stack链表中的最后一个步骤可能会直接执行（没有依赖关系，若有依赖关系，则也会添加到A阶段stack链表中），而不会添加到A阶段stack链表中，这跟 t != null有关系</span></span><br><span class="line"><span class="comment">             * 有些文章说是B阶段的所有步骤都会添加到A阶段中，愣是没看出来</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            f = (d = h.tryFire(NESTED)) == <span class="keyword">null</span> ? <span class="keyword">this</span> : d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步执行任务，默认情况下的执行器是ForkJoinPool，即公共线程池</span></span><br><span class="line"><span class="comment"> * 每次调用该方法都会生成新的CompletableFuture对象，该方法与supplyAsync的区别就在于是否有执行结果值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> runnable 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> CompletableFuture新实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asyncRunStage(asyncPool, runnable); <span class="comment">// 该方法的执行过程与asyncSupplyStage是类似的，就不在贴出来了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用指定执行器异步执行任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> runnable 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> executor 指定执行器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> CompletableFuture新实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asyncRunStage(screenExecutor(executor), runnable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置执行结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 执行结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> CompletableFuture新实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">completedFuture</span><span class="params">(U value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CompletableFuture&lt;U&gt;((value == <span class="keyword">null</span>) ? NIL : value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务是否执行完成，有可能是正常执行完成、异常执行完成、取消</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> result != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取执行结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    Object r;</span><br><span class="line">    <span class="keyword">return</span> reportGet((r = result) == <span class="keyword">null</span> ? waitingGet(<span class="keyword">true</span>) : r); <span class="comment">// 获取执行结果，若此时任务还未执行完成，则等待执行完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取执行结果，若是正常执行完成的话则返回执行结果，若是异常完成的话则抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> r 执行结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 执行结果或抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">reportGet</span><span class="params">(Object r)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (r <span class="keyword">instanceof</span> AltResult) &#123;</span><br><span class="line">        Throwable x, cause;</span><br><span class="line">        <span class="keyword">if</span> ((x = ((AltResult)r).ex) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> CancellationException)</span><br><span class="line">            <span class="keyword">throw</span> (CancellationException)x;</span><br><span class="line">        <span class="keyword">if</span> ((x <span class="keyword">instanceof</span> CompletionException) &amp;&amp;</span><br><span class="line">            (cause = x.getCause()) != <span class="keyword">null</span>)</span><br><span class="line">            x = cause;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) T t = (T) r;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用自旋 + 阻塞的方式等待执行完成</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> interruptible 是否可中断的标识</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值或null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">waitingGet</span><span class="params">(<span class="keyword">boolean</span> interruptible)</span> </span>&#123;</span><br><span class="line">    Signaller q = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> spins = -<span class="number">1</span>;</span><br><span class="line">    Object r;</span><br><span class="line">    <span class="keyword">while</span> ((r = result) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (spins &lt; <span class="number">0</span>)</span><br><span class="line">            spins = (Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span>) ?</span><br><span class="line">                <span class="number">1</span> &lt;&lt; <span class="number">8</span> : <span class="number">0</span>; <span class="comment">// 多处理器情况下使用自旋</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ThreadLocalRandom.nextSecondarySeed() &gt;= <span class="number">0</span>)</span><br><span class="line">                --spins;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">            q = <span class="keyword">new</span> Signaller(interruptible, <span class="number">0L</span>, <span class="number">0L</span>); <span class="comment">// 用于记录等待执行完成的线程，同时也在执行完成后对其唤醒</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            queued = tryPushStack(q); <span class="comment">// 将Signaller对象推入到stack上，也就是将该对象作为当前阶段的第一个步骤</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (interruptible &amp;&amp; q.interruptControl &lt; <span class="number">0</span>) &#123; <span class="comment">// q.interruptControl &lt; 0 表示当前线程已发生中断</span></span><br><span class="line">            q.thread = <span class="keyword">null</span>;</span><br><span class="line">            cleanStack(); <span class="comment">// 清除所有步骤中已经被中断或执行完成的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q.thread != <span class="keyword">null</span> &amp;&amp; result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ForkJoinPool.managedBlock(q); <span class="comment">// 阻塞当前线程</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                q.interruptControl = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (q != <span class="keyword">null</span>) &#123;</span><br><span class="line">        q.thread = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (q.interruptControl &lt; <span class="number">0</span>) &#123; <span class="comment">// q.interruptControl &lt; 0 表示当前线程已经发生中断</span></span><br><span class="line">            <span class="keyword">if</span> (interruptible)</span><br><span class="line">                r = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    postComplete();</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取执行结果，若未执行完成等待指定时间，若超过指定时间后还未执行完成则抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout 指定时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    Object r;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">return</span> reportGet((r = result) == <span class="keyword">null</span> ? timedGet(nanos) : r); <span class="comment">// timedGet方法与waitingGet类似，只不过没有加上自旋</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取执行结果，若此时任务还未执行完成，则等待执行完成</span></span><br><span class="line"><span class="comment"> * 外部调用get方法要加上try-catch，而该方法不用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object r;</span><br><span class="line">    <span class="keyword">return</span> reportJoin((r = result) == <span class="keyword">null</span> ? waitingGet(<span class="keyword">false</span>) : r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取执行结果，此方法不会等待</span></span><br><span class="line"><span class="comment"> * 若执行完成则返回执行结果或抛出异常</span></span><br><span class="line"><span class="comment"> * 若执行未完成则返回valueIfAbsent</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> valueIfAbsent 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getNow</span><span class="params">(T valueIfAbsent)</span> </span>&#123;</span><br><span class="line">    Object r;</span><br><span class="line">    <span class="keyword">return</span> ((r = result) == <span class="keyword">null</span>) ? valueIfAbsent : reportJoin(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置正常执行完成</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 执行结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">complete</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> triggered = completeValue(value);</span><br><span class="line">    postComplete();</span><br><span class="line">    <span class="keyword">return</span> triggered;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置异常执行完成</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ex 异常信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">completeExceptionally</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ex == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">boolean</span> triggered = internalComplete(<span class="keyword">new</span> AltResult(ex));</span><br><span class="line">    postComplete();</span><br><span class="line">    <span class="keyword">return</span> triggered;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行当前依赖阶段的指定步骤内容，依赖阶段的执行结果会被当前调用阶段的执行结果所影响</span></span><br><span class="line"><span class="comment"> * 每次调用该方法都会生成新的CompletableFuture对象</span></span><br><span class="line"><span class="comment"> * 总结：等A阶段执行完毕，B阶段的执行结果是依赖A阶段的执行结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fn 步骤函数，指具体执行步骤的内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Completable新实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenApply</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniApplyStage(<span class="keyword">null</span>, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步执行当前依赖阶段的指定步骤内容，依赖阶段的执行结果会被当前调用阶段的执行结果所影响</span></span><br><span class="line"><span class="comment"> * 每次调用该方法都会生成新的CompletableFuture对象</span></span><br><span class="line"><span class="comment"> * 总结：等A阶段执行完毕，B阶段的执行结果是依赖A阶段的执行结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fn 步骤函数，指具体执行步骤的内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Completable新实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenApplyAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniApplyStage(asyncPool, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行当前依赖阶段的指定步骤内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 执行器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> f 步骤函数，指具体执行步骤的内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 依赖阶段</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> &lt;V&gt; <span class="function">CompletableFuture&lt;V&gt; <span class="title">uniApplyStage</span><span class="params">(Executor e, Function&lt;? <span class="keyword">super</span> T,? extends V&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    CompletableFuture&lt;V&gt; d =  <span class="keyword">new</span> CompletableFuture&lt;V&gt;();</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> || !d.uniApply(<span class="keyword">this</span>, f, <span class="keyword">null</span>)) &#123; <span class="comment">// 若当前依赖阶段未能执行，则将依赖阶段的步骤推入到被依赖阶段的链条上</span></span><br><span class="line">        UniApply&lt;T,V&gt; c = <span class="keyword">new</span> UniApply&lt;T,V&gt;(e, d, <span class="keyword">this</span>, f);</span><br><span class="line">        push(c); <span class="comment">// 将被依赖阶段的步骤放入到链表上</span></span><br><span class="line">        c.tryFire(SYNC);  <span class="comment">// 在一次尝试执行依赖阶段</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d; <span class="comment">// 返回依赖阶段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行当前依赖阶段的指定步骤内容</span></span><br><span class="line"><span class="comment"> * 调用此方法说明当前A阶段依赖其他B阶段，所以必须要先看看B阶段是否执行完成了，为了方便说明，将A称之为依赖阶段，B称之为被依赖阶段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 被依赖阶段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> f 步骤函数，指具体执行步骤的内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 步骤</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 步骤是否执行完成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> &lt;S&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">uniApply</span><span class="params">(CompletableFuture&lt;S&gt; a, Function&lt;? <span class="keyword">super</span> S,? extends T&gt; f, UniApply&lt;S,T&gt; c)</span> </span>&#123;</span><br><span class="line">    Object r; Throwable x;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || (r = a.result) == <span class="keyword">null</span> || f == <span class="keyword">null</span>) <span class="comment">// 查看被依赖阶段是否执行完成了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    tryComplete: <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123; <span class="comment">// 依赖阶段还未执行</span></span><br><span class="line">        <span class="keyword">if</span> (r <span class="keyword">instanceof</span> AltResult) &#123; <span class="comment">// 判断被依赖阶段是否是异常执行完成，若是则当前依赖阶段将也是异常执行完成</span></span><br><span class="line">            <span class="keyword">if</span> ((x = ((AltResult)r).ex) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                completeThrowable(x, r); <span class="comment">// 当前依赖阶段也被设置成异常执行完成</span></span><br><span class="line">                <span class="keyword">break</span> tryComplete;</span><br><span class="line">            &#125;</span><br><span class="line">            r = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; !c.claim()) <span class="comment">// c.claim 判断当前步骤是否可以执行，有可能被取消了</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) S s = (S) r;</span><br><span class="line">            completeValue(f.apply(s)); <span class="comment">// 应用被依赖阶段的执行结果，执行依赖阶段的指定步骤内容</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            completeThrowable(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UniApply</span>&lt;<span class="title">T</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">UniCompletion</span>&lt;<span class="title">T</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤函数，指具体执行步骤的内容</span></span><br><span class="line">    Function&lt;? <span class="keyword">super</span> T,? extends V&gt; fn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> executor 执行器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dep 依赖阶段</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> src 被依赖阶段</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fn 步骤函数，指具体执行步骤的内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    UniApply(Executor executor, CompletableFuture&lt;V&gt; dep, CompletableFuture&lt;T&gt; src, Function&lt;? <span class="keyword">super</span> T,? extends V&gt; fn) &#123;</span><br><span class="line">        <span class="keyword">super</span>(executor, dep, src); </span><br><span class="line">        <span class="keyword">this</span>.fn = fn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试执行步骤内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mode 模式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前调用实例或null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> CompletableFuture&lt;V&gt; <span class="title">tryFire</span><span class="params">(<span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">        CompletableFuture&lt;V&gt; d; CompletableFuture&lt;T&gt; a;</span><br><span class="line">        <span class="keyword">if</span> ((d = dep) == <span class="keyword">null</span> || !d.uniApply(a = src, fn, mode &gt; <span class="number">0</span> ? <span class="keyword">null</span> : <span class="keyword">this</span>)) <span class="comment">// 尝试执行步骤内容</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        dep = <span class="keyword">null</span>; src = <span class="keyword">null</span>; fn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> d.postFire(a, mode); <span class="comment">// 当前步骤执行完毕后通知其依赖阶段的执行，记住了，所谓的依赖阶段与被依赖阶段都是相对的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UniCompletion</span>&lt;<span class="title">T</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Completion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行器</span></span><br><span class="line">    Executor executor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依赖阶段</span></span><br><span class="line">    CompletableFuture&lt;V&gt; dep; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被依赖阶段</span></span><br><span class="line">    CompletableFuture&lt;T&gt; src; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> executor 执行器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dep 依赖阶段</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> src 被依赖阶段</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fn 步骤函数，指具体执行步骤的内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    UniCompletion(Executor executor, CompletableFuture&lt;V&gt; dep, CompletableFuture&lt;T&gt; src) &#123;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor; <span class="keyword">this</span>.dep = dep; <span class="keyword">this</span>.src = src;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断当前步骤是否可以执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">claim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Executor e = executor;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetForkJoinTaskTag((<span class="keyword">short</span>)<span class="number">0</span>, (<span class="keyword">short</span>)<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            executor = <span class="keyword">null</span>;</span><br><span class="line">            e.execute(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断当前步骤是否未执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isLive</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> dep != <span class="keyword">null</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定步骤推入到当前阶段的第一个步骤</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 步骤</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(UniCompletion&lt;?,?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (result == <span class="keyword">null</span> &amp;&amp; !tryPushStack(c))</span><br><span class="line">            lazySetNext(c, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定步骤作为当前阶段的第一个步骤</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 步骤</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryPushStack</span><span class="params">(Completion c)</span> </span>&#123;</span><br><span class="line">    Completion h = stack; <span class="comment">// 获取当前阶段的第一个步骤</span></span><br><span class="line">    lazySetNext(c, h); <span class="comment">// 将当前阶段的第一个步骤与指定步骤进行关联</span></span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, STACK, h, c); <span class="comment">// 指定步骤c将作为当前阶段的第一个步骤</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关联步骤</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 上一个步骤</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> next 下一个步骤</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lazySetNext</span><span class="params">(Completion c, Completion next)</span> </span>&#123;</span><br><span class="line">    UNSAFE.putOrderedObject(c, NEXT, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前阶段已执行完毕了，需要去触发其依赖阶段的执行</span></span><br><span class="line"><span class="comment"> * 这里可能会有点绕，假设C依赖B，B依赖A，那么当A执行完毕后在触发B的执行，当B执行完毕后再触发C的执行，所以说所谓的依赖阶段与被依赖阶段都是相对的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 被依赖阶段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mode 模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 当前实例或null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> CompletableFuture&lt;T&gt; <span class="title">postFire</span><span class="params">(CompletableFuture&lt;?&gt; a, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span> &amp;&amp; a.stack != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mode &lt; <span class="number">0</span> || a.result == <span class="keyword">null</span>)</span><br><span class="line">            a.cleanStack();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a.postComplete(); <span class="comment">// 触发其依赖阶段的执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span> &amp;&amp; stack != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mode &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            postComplete(); <span class="comment">// 触发其依赖阶段的执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 很多相关方法与thenApply基本相同，就不贴代码了...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行当前依赖阶段的指定步骤内容，依赖阶段的执行结果为null</span></span><br><span class="line"><span class="comment"> * 每次调用该方法都会生成新的CompletableFuture对象</span></span><br><span class="line"><span class="comment"> * 总结：等A阶段执行完毕，B阶段的执行结果不依赖A阶段的执行结果，始终都是null，但是B阶段的执行过程需要A阶段的执行结果的参与</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action 步骤函数，指具体执行步骤的内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Completable新实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">thenAccept</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniAcceptStage(<span class="keyword">null</span>, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行当前依赖阶段的指定步骤内容，依赖阶段的执行结果为null</span></span><br><span class="line"><span class="comment"> * 每次调用该方法都会生成新的CompletableFuture对象</span></span><br><span class="line"><span class="comment"> * 总结：等A阶段执行完毕，B阶段的执行结果不依赖A阶段的执行结果，始终都是null，B阶段的执行过程不需要A阶段的执行结果的参与</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action 步骤函数，指具体执行步骤的内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Completable新实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">thenRun</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniRunStage(<span class="keyword">null</span>, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行当前依赖阶段的指定步骤内容，依赖阶段的执行结果会被当前调用阶段的执行结果所影响</span></span><br><span class="line"><span class="comment"> * 每次调用该方法都会生成新的CompletableFuture对象</span></span><br><span class="line"><span class="comment"> * 多层依赖关系，相当于C依赖A，C依赖B</span></span><br><span class="line"><span class="comment"> * 总结：等AB阶段执行完毕，C阶段的执行结果依赖AB阶段的执行结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> other 依赖阶段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fn 步骤函数，指具体执行步骤的内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Completable新实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;U,V&gt; <span class="function">CompletableFuture&lt;V&gt; <span class="title">thenCombine</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> biApplyStage(<span class="keyword">null</span>, other, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行当前依赖阶段的指定步骤内容，依赖阶段的执行结果为null</span></span><br><span class="line"><span class="comment"> * 每次调用该方法都会生成新的CompletableFuture对象</span></span><br><span class="line"><span class="comment"> * 多层依赖关系，相当于C依赖A，C依赖B</span></span><br><span class="line"><span class="comment"> * 总结：等AB阶段执行完毕，C阶段的执行结果不依赖AB阶段的执行结果，始终都是null，但是C阶段的执行过程需要AB阶段的执行结果的参与</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> other 依赖阶段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action 步骤函数，指具体执行步骤的内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Completable新实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;Void&gt; <span class="title">thenAcceptBoth</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> biAcceptStage(<span class="keyword">null</span>, other, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行当前依赖阶段的指定步骤内容，依赖阶段的执行结果为null</span></span><br><span class="line"><span class="comment"> * 每次调用该方法都会生成新的CompletableFuture对象</span></span><br><span class="line"><span class="comment"> * 多层依赖关系，相当于C依赖A，C依赖B</span></span><br><span class="line"><span class="comment"> * 总结：等AB阶段执行完毕，C阶段的执行结果不依赖AB阶段的执行结果，始终都是null，C阶段的执行过程不需要AB阶段的执行结果的参与</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> other 依赖阶段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action 步骤函数，指具体执行步骤的内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Completable新实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">runAfterBoth</span><span class="params">(CompletionStage&lt;?&gt; other, Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> biRunStage(<span class="keyword">null</span>, other, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行当前依赖阶段的指定步骤内容，依赖阶段的执行结果会被当前调用阶段的执行结果或另外的被依赖阶段所影响</span></span><br><span class="line"><span class="comment"> * 每次调用该方法都会生成新的CompletableFuture对象</span></span><br><span class="line"><span class="comment"> * 多层依赖关系，相当于C依赖A，C依赖B</span></span><br><span class="line"><span class="comment"> * 总结：等AB阶段中任何一个执行完毕，C阶段的执行结果依赖AB阶段中任何一个的执行结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> other 依赖阶段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fn 步骤函数，指具体执行步骤的内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Completable新实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">applyToEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="keyword">super</span> T, U&gt; fn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> orApplyStage(<span class="keyword">null</span>, other, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行当前依赖阶段的指定步骤内容，依赖阶段的执行结果为null</span></span><br><span class="line"><span class="comment"> * 每次调用该方法都会生成新的CompletableFuture对象</span></span><br><span class="line"><span class="comment"> * 多层依赖关系，相当于C依赖A，C依赖B</span></span><br><span class="line"><span class="comment"> * 总结：等AB阶段中任何一个执行完毕，C阶段的执行结果不依赖AB阶段的执行结果，始终都是null，但是C阶段的执行过程需要AB阶段中任何一个的执行结果的参与</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> other 依赖阶段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action 步骤函数，指具体执行步骤的内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Completable新实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">acceptEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> orAcceptStage(<span class="keyword">null</span>, other, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行当前依赖阶段的指定步骤内容，依赖阶段的执行结果为null</span></span><br><span class="line"><span class="comment"> * 每次调用该方法都会生成新的CompletableFuture对象</span></span><br><span class="line"><span class="comment"> * 多层依赖关系，相当于C依赖A，C依赖B</span></span><br><span class="line"><span class="comment"> * 总结：等AB阶段中任何一个执行完毕，C阶段的执行结果不依赖AB阶段的执行结果，始终都是null，C阶段的执行过程不需要AB阶段的执行结果的参与</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> other 依赖阶段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action 步骤函数，指具体执行步骤的内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Completable新实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">runAfterEither</span><span class="params">(CompletionStage&lt;?&gt; other, Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> orRunStage(<span class="keyword">null</span>, other, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行当前依赖阶段的指定步骤内容，依赖阶段的执行结果会被当前调用阶段的执行结果所影响</span></span><br><span class="line"><span class="comment"> * fn函数会返回新的CompletableFuture对象，与thenCompse返回的对象不是同一个</span></span><br><span class="line"><span class="comment"> * 组合CompletableFuture，个人感觉与thenApply差不多一个样</span></span><br><span class="line"><span class="comment"> * 总结：等A阶段执行完毕，B阶段的执行结果依赖A阶段的执行结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fn 步骤函数，指具体执行步骤的内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Completable新实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenCompose</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniComposeStage(<span class="keyword">null</span>, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当调用阶段执行完成后运行指定动作，不管调用阶段是正常执行完成还是异常执行完成都会调用</span></span><br><span class="line"><span class="comment"> * 每次调用该方法都会生成新的CompletableFuture对象，该对象的执行结果与调用阶段的执行结果一样</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action 指定动作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Completable新实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenComplete</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniWhenCompleteStage(<span class="keyword">null</span>, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当调用阶段执行完成后运行指定动作，不管调用阶段是正常执行完成还是异常执行完成都会调用</span></span><br><span class="line"><span class="comment"> * 每次调用该方法都会生成新的CompletableFuture对象，该对象的执行结果受调用阶段的执行结果所影响</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fn 步骤函数，指具体执行步骤的内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Completable新实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">handle</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T, Throwable, ? extends U&gt; fn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniHandleStage(<span class="keyword">null</span>, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待指定多重依赖阶段全部执行完毕后才能执行当前阶段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cfs 指定多重依赖</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Completable新实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">allOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> andTree(cfs, <span class="number">0</span>, cfs.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用此方法说明是一个阶段依赖多个阶段，而这多个阶段之间并没有依赖关系，这很关键</span></span><br><span class="line"><span class="comment"> * 由于依赖关系是通过回调来执行，它在多重依赖之间构建了多个虚拟依赖阶段，从而减少依赖阶段个数直到只有两个，这样子形成了二叉树，感觉讲的不是很明白，直接画吧</span></span><br><span class="line"><span class="comment"> * 假设 X -&gt; [A,B,C,D,E,F,G]  表示X阶段依赖ABCDEFG，构建虚拟依赖阶段</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *                  X</span></span><br><span class="line"><span class="comment"> *            /            \</span></span><br><span class="line"><span class="comment"> *           T1            T2</span></span><br><span class="line"><span class="comment"> *        /     \       /     \ </span></span><br><span class="line"><span class="comment"> *       Z1     Z2     Z3     Z4</span></span><br><span class="line"><span class="comment"> *      /  \   /  \   /  \   /</span></span><br><span class="line"><span class="comment"> *     A    B  C   D  E   F  G </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 其之间的依赖关系就是一颗二叉树，要执行X阶段就要等T1、T2执行完成，要执行T1、T2就要等Z1、Z2、Z3、Z4执行完成，所以最终还是要等ABCDEFG执行完成</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cfs 指定多重依赖</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lo 起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hi 结束索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Completable新实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">andTree</span><span class="params">(CompletableFuture&lt;?&gt;[] cfs, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; d = <span class="keyword">new</span> CompletableFuture&lt;Void&gt;();</span><br><span class="line">    <span class="keyword">if</span> (lo &gt; hi) <span class="comment">// empty</span></span><br><span class="line">        d.result = NIL;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        CompletableFuture&lt;?&gt; a, b;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ((a = (lo == mid ? cfs[lo] : andTree(cfs, lo, mid))) == <span class="keyword">null</span> ||</span><br><span class="line">            (b = (lo == hi ? a : (hi == mid+<span class="number">1</span>) ? cfs[hi] : andTree(cfs, mid+<span class="number">1</span>, hi)))  == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (!d.biRelay(a, b)) &#123;</span><br><span class="line">            BiRelay&lt;?,?&gt; c = <span class="keyword">new</span> BiRelay&lt;&gt;(d, a, b);</span><br><span class="line">            a.bipush(b, c);</span><br><span class="line">            c.tryFire(SYNC);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待指定多重依赖阶段中任何一个执行完毕后就可以执行当前阶段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cfs 指定多重依赖</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Completable新实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Object&gt; <span class="title">anyOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> orTree(cfs, <span class="number">0</span>, cfs.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取消当前调用阶段，前提是当前调用阶段还未执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mayInterruptIfRunning 暂未使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否取消成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> cancelled = (result == <span class="keyword">null</span>) &amp;&amp; internalComplete(<span class="keyword">new</span> AltResult(<span class="keyword">new</span> CancellationException()));</span><br><span class="line">    postComplete();</span><br><span class="line">    <span class="keyword">return</span> cancelled || isCancelled();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p>大致上看懂了CompletableFuture原理，基本上每个方法的原理都很类似，在概念上可能会容易混淆，最好是能有自己的理解，不过个人觉得其原理并不是重点，所以并没有很深入去分析，更多的是帮助读者能够清晰地知道每个方法的使用效果。CompletableFuture是一个工具类，方便开发者去执行计算，为了更方便使用，特意写了使用示例供参考，这份示例我也放在了github上-<a href="https://github.com/JulianHang/little-java-project/blob/master/src/tech/zlia/interest/example/CompletableFutureTest.java" target="_blank" rel="noopener">CompletableFuture使用示例</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">// 方法上的注释可能会有所变扭，所以读者最好能够自己执行一遍方能理解其中的含义</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        CompletableFutureTest completableFutureTest = <span class="keyword">new</span> CompletableFutureTest();</span><br><span class="line"><span class="comment">//        completableFutureTest.testThenApply();</span></span><br><span class="line"><span class="comment">//        completableFutureTest.testThenAccept();</span></span><br><span class="line"><span class="comment">//        completableFutureTest.testThenRun();</span></span><br><span class="line"><span class="comment">//        completableFutureTest.testThenCombine();</span></span><br><span class="line"><span class="comment">//        completableFutureTest.testThenAcceptBoth();</span></span><br><span class="line"><span class="comment">//        completableFutureTest.testRunAfterBoth();</span></span><br><span class="line"><span class="comment">//        completableFutureTest.testApplyToEither();</span></span><br><span class="line"><span class="comment">//        completableFutureTest.testAcceptEither();</span></span><br><span class="line"><span class="comment">//        completableFutureTest.testRunAfterEither();</span></span><br><span class="line"><span class="comment">//        completableFutureTest.testThenCompose();</span></span><br><span class="line"><span class="comment">//        completableFutureTest.testWhenComplete();</span></span><br><span class="line"><span class="comment">//        completableFutureTest.testHandle();</span></span><br><span class="line"><span class="comment">//        completableFutureTest.testAllOf();</span></span><br><span class="line"><span class="comment">//        completableFutureTest.testAnyOf();</span></span><br><span class="line">        completableFutureTest.testCancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  异步执行,有执行结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testSupplyAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CompletableFuture cf = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"执行任务"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"1"</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步执行，无执行结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testRunAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CompletableFuture cf = CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">"执行任务"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步执行，阶段之间具有依赖关系使阶段的执行结果会有所依赖</span></span><br><span class="line"><span class="comment">     * 异步执行也是同理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testThenApply</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; cf = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        cf.complete(<span class="string">"Hello"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时的t对应的是cf的执行结果值，即t = Hello，此时completableFuture1的执行结果受cf的执行结果所影响</span></span><br><span class="line">        CompletableFuture&lt;String&gt; completableFuture1 = cf.thenApply( t -&gt; t + <span class="string">"World"</span>);</span><br><span class="line">        System.out.println(completableFuture1.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时的t对应的是completableFuture1的执行结果，即Hello World,此时completableFuture2的执行结果受completableFuture1的执行结果所影响</span></span><br><span class="line">        CompletableFuture completableFuture2 = completableFuture1.thenApply( t -&gt; t + <span class="string">", I love China"</span>);</span><br><span class="line">        System.out.println(completableFuture2.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步执行，即使阶段之间具有依赖关系，但每个阶段的执行结果都是null</span></span><br><span class="line"><span class="comment">     * 异步执行也是同理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testThenAccept</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; cf = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        cf.complete(<span class="string">"Hello"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时的t对应的是cf的执行结果值，即t = Hello，但是completableFuture1的执行结果并不会被影响</span></span><br><span class="line">        CompletableFuture completableFuture1 = cf.thenAccept( t -&gt; System.out.println(t + <span class="string">"-执行任务"</span>));</span><br><span class="line">        System.out.println(completableFuture1.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步执行，即使阶段之间具有依赖关系，但每个阶段的执行结果都是null，且不依赖其入参</span></span><br><span class="line"><span class="comment">     * 异步执行也是同理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testThenRun</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; cf = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        cf.complete(<span class="string">"Hello"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时并无入参，但是要等cf执行完毕后才能执行该阶段</span></span><br><span class="line">        CompletableFuture completableFuture1 = cf.thenRun(() -&gt; System.out.println(<span class="string">"执行任务"</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(completableFuture1.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步执行，阶段之间具有多重依赖关系，使阶段的执行结果会有多重依赖</span></span><br><span class="line"><span class="comment">     * 异步执行也是同理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testThenCombine</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; cf = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        cf.complete(<span class="string">"Hello"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; cf1 = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        cf1.complete(<span class="string">"World"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时t1代表cf的执行结果，t2代表cf1的执行结果,此时completableFuture的执行结果受cf、cf1的执行结果所影响</span></span><br><span class="line">        CompletableFuture completableFuture = cf.thenCombine(cf1, (t1, t2) -&gt; t1 + t2 + <span class="string">", I love China"</span>);</span><br><span class="line">        System.out.println(completableFuture.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步执行，即使阶段之间具有多重依赖关系，但阶段的执行结果始终是null</span></span><br><span class="line"><span class="comment">     * 异步执行也是同理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testThenAcceptBoth</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; cf = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        cf.complete(<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; cf1 = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        cf1.complete(<span class="string">"2"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时t1代表cf的执行结果，t2代表cf1的执行结果,但是cf2的执行结果始终都是null</span></span><br><span class="line">        CompletableFuture cf2 = cf.thenAcceptBoth(cf1, (t1, t2) -&gt; System.out.println(t1 + t2 + <span class="string">", I love China"</span>));</span><br><span class="line">        System.out.println(cf2.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步执行，即使阶段之间具有多重依赖关系，但每个阶段的执行结果都是null，且不依赖其入参</span></span><br><span class="line"><span class="comment">     * 异步执行也是同理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testRunAfterBoth</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; cf = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        cf.complete(<span class="string">"3"</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; cf1 = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        cf1.complete(<span class="string">"4"</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture cf2 = cf.runAfterBoth(cf1, () -&gt; System.out.println(<span class="string">"I love China"</span>));</span><br><span class="line">        System.out.println(cf2.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步执行，阶段之间具有依赖关系使阶段的执行结果会有所依赖</span></span><br><span class="line"><span class="comment">     * 异步执行也是同理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testApplyToEither</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; cf = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        cf.complete(<span class="string">"5"</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; cf1 = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        cf1.complete(<span class="string">"6"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时t有可能是cf或cf1，就看谁先执行完毕就用谁的</span></span><br><span class="line">        CompletableFuture cf2 = cf.applyToEither(cf1, (t) -&gt; t + <span class="string">",I love China"</span>);</span><br><span class="line">        System.out.println(cf2.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步执行，即使阶段之间具有多重依赖关系，但阶段的执行结果始终是null</span></span><br><span class="line"><span class="comment">     * 异步执行也是同理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testAcceptEither</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; cf = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        cf.complete(<span class="string">"7"</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; cf1 = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        cf1.complete(<span class="string">"8"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时t有可能是cf或cf1，就看谁先执行完毕就用谁的</span></span><br><span class="line">        CompletableFuture cf2 = cf.acceptEither(cf1, (t) -&gt; System.out.println(t + <span class="string">",I love China"</span>));</span><br><span class="line">        System.out.println(cf2.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步执行，即使阶段之间具有多重依赖关系，但每个阶段的执行结果都是null，且不依赖其入参</span></span><br><span class="line"><span class="comment">     * 异步执行也是同理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testRunAfterEither</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; cf = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        cf.complete(<span class="string">"9"</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; cf1 = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        cf1.complete(<span class="string">"10"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时t有可能是cf或cf1，就看谁先执行完毕就用谁的</span></span><br><span class="line">        CompletableFuture cf2 = cf.runAfterEither(cf1, () -&gt; System.out.println(<span class="string">"I love China"</span>));</span><br><span class="line">        System.out.println(cf2.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 组合多个依赖</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testThenCompose</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; cf = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        cf.complete(<span class="string">"11"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时t是cf的执行结果</span></span><br><span class="line">        CompletableFuture cf2 = cf.thenCompose((t) -&gt; CompletableFuture.supplyAsync(() -&gt; t + <span class="string">"执行thenCompse"</span>));</span><br><span class="line">        System.out.println(cf2.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当阶段执行完成后运行指定动作，其执行结果与调用阶段的执行结果一样</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testWhenComplete</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; cf = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        CompletableFuture cf1 = cf.whenComplete((t, x) -&gt; &#123; <span class="comment">// t代表cf正常的执行结果，x代表cf异常的执行结果</span></span><br><span class="line">            System.out.println(<span class="string">"正常执行的信息："</span> + t);</span><br><span class="line">            System.out.println(<span class="string">"异常执行的信息："</span> + x);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        cf.complete("执行完成");</span></span><br><span class="line">        cf.completeExceptionally(<span class="keyword">new</span> RuntimeException(<span class="string">"异常执行"</span>));</span><br><span class="line">        System.out.println(cf1.get()); <span class="comment">// cf1的执行结果就是cf的执行结果，若是正常执行的话就是一样的结果，若是异常执行的话get就会抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当阶段执行完成后运行指定动作，其执行结果由自身定义</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testHandle</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; cf = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        CompletableFuture cf1 = cf.handle((t, x) -&gt; &#123; <span class="comment">// t代表cf正常的执行结果，x代表cf异常的执行结果</span></span><br><span class="line">            System.out.println(<span class="string">"正常执行的信息："</span> + t);</span><br><span class="line">            System.out.println(<span class="string">"异常执行的信息："</span> + x);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"我的结果由我自己做主"</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        cf.complete(<span class="string">"执行完成"</span>);</span><br><span class="line"><span class="comment">//        cf.completeExceptionally(new RuntimeException("异常执行"));</span></span><br><span class="line">        System.out.println(cf1.get()); <span class="comment">// cf1的执行结果由自己做主</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待指定多个阶段全部执行完毕后才能执行当前阶段，其执行结果始终都为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testAllOf</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; a = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        a.complete(<span class="string">"12"</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; b = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        b.complete(<span class="string">"13"</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; c = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        c.complete(<span class="string">"14"</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; d = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        d.complete(<span class="string">"15"</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; e = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        e.complete(<span class="string">"16"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(a.get());</span><br><span class="line">        System.out.println(b.get());</span><br><span class="line">        System.out.println(c.get());</span><br><span class="line">        System.out.println(d.get());</span><br><span class="line">        System.out.println(e.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 必须等待abcde执行完毕了才能执行，其执行结果始终为null</span></span><br><span class="line">        CompletableFuture cf = CompletableFuture.allOf(a, b, c, d, e);</span><br><span class="line">        System.out.println(cf.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待指定多个阶段中任何一个执行完毕后就可以执行当前阶段，其执行结果与任何一个阶段执行完成的执行结果一样</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testAnyOf</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; a = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line"><span class="comment">//        a.complete("17");</span></span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; b = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        b.complete(<span class="string">"18"</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; c = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line"><span class="comment">//        c.complete("19");</span></span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; d = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line"><span class="comment">//        d.complete("20");</span></span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; e = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line"><span class="comment">//        e.complete("21");</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待指定多个阶段中任何一个执行完毕后才能执行，其执行结果与任何一个阶段执行完成的执行结果一样</span></span><br><span class="line">        CompletableFuture cf = CompletableFuture.anyOf(a, b, c, d, e);</span><br><span class="line">        System.out.println(cf.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消当前调用阶段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testCancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; cf = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        cf.complete(<span class="string">"我已经执行完毕了"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> result = cf.cancel(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>CompletableFuture是一个提供快速计算的工具类，既然要使用它，那么肯定是对其方法的使用、效果有所掌握，这是关键，至于其原理个人觉得并不很重要，实际上也没啥原理…</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;正题&quot;&gt;&lt;a href=&quot;#正题&quot; class=&quot;headerlink&quot; title=&quot;正题&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;正题&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;CompletableFuture是&lt;code&gt;JDK1.8&lt;/code&gt;才出现的，至于是否拥有很强大的功能其实我也未在工作上实践过，不过话说回来，即使实践过当时的我也是看不懂地，因为我现在才有时间来对它做一个了解，在此之前先来看看它的父接口-CompletionStage与Future。对于CompletionStage来说，它被认为是一个执行的&lt;code&gt;阶段&lt;/code&gt;，可以是同步或异步，每一个阶段完成的同时有可能触发其他阶段，也就是说阶段之间是可以相互依赖的，好比是流水作业，虽然它可以执行各种计算，即使是复杂的链式计算也是手到擒来，但也存在一些弊端，比如无法探测计算是否完成或获取计算的结果或等待其阶段执行完成，所以为了使其更健壮，它又实现了Future接口，可它又与Future的实现类有着区别，比如对于cancel来说，它会当作是异常执行完成。CompletableFuture是两者的结合物，提供的方法有很多种，简单总结下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;带有后缀名为Async的方法&lt;/code&gt;表示以异步的方式执行任务，通常情况下使用ForkJoinPool公共线程池；&lt;code&gt;带有前缀名为then的方法&lt;/code&gt;表示阶段之间具有依赖关系，需要上一个阶段执行完毕后才能触发下一个阶段；&lt;code&gt;带有后缀名为Either的方法&lt;/code&gt;表示在多重依赖下只会依赖其中任何一个阶段，即任何一个阶段执行完成即可执行当前阶段；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在阅读源码之前，读者最好能把CompletableFuture、Completion、UniCompletion等之间的数据结构画出来，清晰的结构关系能够帮助理解，在下面的代码中会提到一些个人对相关类的理解与称谓。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>深入ForkJoinPool源码</title>
    <link href="http://zlia.tech/2020/02/21/explain-forkjoinpool-sourcecode/"/>
    <id>http://zlia.tech/2020/02/21/explain-forkjoinpool-sourcecode/</id>
    <published>2020-02-21T09:59:24.000Z</published>
    <updated>2020-02-21T10:01:35.387Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a><div><span>概念</span></div></h3><p>ForkJoin框架将一个大问题分解成若干个<code>相互独立且容易解决</code>的小问题，为了让这些小问题能够并行执行，同时减少线程间对资源的竞争，将这些小问题分别放入到<code>不同的队列</code>中，并为每个队列<code>创建一个线程</code>来执行队列中的小问题，这个过程就叫做Fork，中文称作<code>分支</code>，当所有的小问题都解决完之后，需要将每个结果进行汇总合并最终得出大问题的结果，这个过程叫做Join，中文称作<code>合并</code>，这就好比生活中建设大厦一般，值得注意的是在执行过程应用了一种叫做工作窃取的算法，如此思想在算法界中称作<code>分治</code>，分而治之。</p><blockquote><p><code>工作窃取</code>：一个线程对应一个队列，每个队列中有多个小任务，当其中一个线程执行完队列中的任务时，为了充分利用线程资源，该线程将从任意一个队列中窃取任务来执行，而该队列对应的线程也会从该队列中获取任务，所以为了减少自身队列对应的线程与窃取线程之间不必要的竞争，通常使用<code>双端队列</code>，约定自身线程从队列的尾部开始获取（LIFO），窃取线程从队列的头部开始获取（FIFO），当然了，有一种情况下还是避免不了竞争，队列中只有一个任务时，这个时候就需要加锁或CAS进行控制。</p></blockquote><p>ForkJoinPool与ExecutorService的主要区别便是工作窃取，其应用场景也不同，分而治之的思想无疑减少了程序的运行时间，提供了效率，但同时占用了更多的资源，以下提供图片帮助理解：</p><p class="customize-img"><img src="/assets/blogImg/java/forkjoin/forkjoin-mode.png" alt="ForkJoin原理图"></p><p>目前对ForkJoin框架有一定程度上的理解了，之前写的文章都是通过先阅读注释开始，但是ForkJoinPool类的注释实际上并无很重要的关键信息，有兴趣的读者可以尝试去阅读Doug Lea关于ForkJoin框架的理论或者ForkJoinPool内部的注释，接下来进入到源码环节。</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//直接继承AbstractExecutorService，说明它与ThreadPoolExecutor是并列关系，两者并无依赖关系，两个线程池所应用的场景不同</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPool</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 | 计算来保存线程池的并行数（parallelism）与模式（asyncMode）信息，低16位表示并行数，高16位表示模式</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 0000 0000 0000 0001 0000 0000 0000 0001</span></span><br><span class="line"><span class="comment">     * |      高16位      ||       低16位     |</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 并行数：简单来说就是工作线程的个数，相当于在指明可以创建多少个工作线程，一个工作线程对应一个队列，而队列中的任务可以被多个线程并行执行（工作窃取）</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 模式：该模式跟同步异步没有任何的关系，我们都知道一个线程对应一个队列，而队列采用的是双端队列，那么当线程要处理自身队列中的任务时，就该考虑任务是要以先进先出（FIFO）的顺序还是以先进后出(LIFO)的顺序呢?</span></span><br><span class="line"><span class="comment">     * 所以该模式旨在配置任务以哪种顺序出队列，若大于0（1 &lt;&lt; 16），表示以先进先出的顺序出队列，该模式下的线程池更适合处理基于事件类型的异步任务；默认情况下以先进后出（0）的顺序出队列；</span></span><br><span class="line"><span class="comment">     * 当线程以先进先出的顺序处理自身队列中的任务时，同时其他线程会去窃取其任务，也就是说多个线程去抢夺任务，资源竞争很是激烈，降低了任务的处理速度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 注意：队列中也有该属性名称，但表示的含义并不同</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> config;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该属性是long类型，故而它共有64位，很有意思，它将64位分成4部分（从1开始数位数，每部分都有16位）</span></span><br><span class="line"><span class="comment">     * 第一部分AC（49位 - 64位）：活跃的工作线程数减去并行数（至于为什么要减去一会下面说）, 该结果小于0时表明没有足够的活跃线程数</span></span><br><span class="line"><span class="comment">     * 第二部分TC（33位 - 48位）：所有的工作线程数减去并行数, 该结果小于0时表明没有足够的线程数</span></span><br><span class="line"><span class="comment">     * 第三部分SS（17位- 32位）：空闲队列的版本计数（空闲-&gt;活跃，活跃-&gt;空闲）与状态（空闲/活跃）</span></span><br><span class="line"><span class="comment">     * 第四部分ID（1位- 16位）：空闲队列在队列数组中的索引</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 当 1-32位，通常使用sp = (int)c来表示，当sp = 0 表示没有空闲线程 当sp &gt; 0 则表示有空闲线程</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 1. 解释下为什么要减去并行数?</span></span><br><span class="line"><span class="comment">     * 首先在一开始时我们指定了并行数，也就是表明将会创建指定个数的工作线程，所以一开始ctl#AC的值应该是负的并行数（这个时候还未添加任务），该结果可参考 (np &lt;&lt; AC_SHIFT) &amp; AC_MASK) 计算就可知道</span></span><br><span class="line"><span class="comment">     * 如果只是单纯地表示工作线程数，那么一开始也应该是对应到并行数，可是咱们还未开始添加任务就已经有活跃的工作线程数了是不是有点问题???</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 将其分成4个部分是为了以原子性的方式去添加/禁用队列，控制入队与出队，重新激活工作线程等，所以它相当于线程池的控制中心</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> ctl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池的运行状态</span></span><br><span class="line"><span class="comment">     * RSLOCK：线程池处于锁定状态，当有多个线程同时更新队列数组时只允许一个线程能够执行操作，否则将出现问题</span></span><br><span class="line"><span class="comment">     * STARTED：线程池处于已启动状态</span></span><br><span class="line"><span class="comment">     * RSIGNAL：标识线程池需要去唤醒其他线程</span></span><br><span class="line"><span class="comment">     * STOP：线程池处于已停止，此时还有执行中的任务，不过队列已清空</span></span><br><span class="line"><span class="comment">     * TERMINATED：线程池处于已终止</span></span><br><span class="line"><span class="comment">     * SHUTDOWN：线程池处于已关闭，此时还未执行任何清空操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> runState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于生成工作线程的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> indexSeed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列数组，存储所有队列用来获取自身与窃取其他队列的任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> WorkQueue[] workQueues;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作线程的工厂类，自定义创建工作线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> ForkJoinWorkerThreadFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作线程的默认工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ForkJoinWorkerThreadFactory defaultForkJoinWorkerThreadFactory = <span class="keyword">new</span> DefaultForkJoinWorkerThreadFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常未处理的自定义处理器，用于处理异常信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> UncaughtExceptionHandler ueh;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作线程的前缀名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> String workerNamePrefix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有两个作用：</span></span><br><span class="line"><span class="comment">     * 1. 当多个线程同时竞争线程池的使用权时，未抢到的线程可能被阻塞，而发生阻塞时需要先获取到锁，故而用于锁</span></span><br><span class="line"><span class="comment">     * 2. 表明当前已窃取的任务数量，要获取总共窃取的任务数量需要加上奇数索引下每个队列的nsteals值，参考getStealCount</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> AtomicLong stealCounter; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量池，通过 &amp; 计算并行数（工作线程的个数）/ 在队列数组中的索引值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SMASK = <span class="number">0xffff</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量值，限制工作线程的最大个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_CAP = <span class="number">0x7fff</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量值，通过 &amp; 使其结果呈现偶数</span></span><br><span class="line"><span class="comment">     * 通常情况下我们已经有一个队列数组了，那么只要将创建好的队列放入到数组中即可，但是它在这里将任务提交分两种情况，故而需要将队列分成两种情况来分析：</span></span><br><span class="line"><span class="comment">     * 1. 调用ForkJoinTask#fork的任务会被放到处于奇数索引的队列中，此队列被称作内部队列</span></span><br><span class="line"><span class="comment">     * 2. 利用线程池直接提交任务，比如execute/submit，这些任务会被放到处于偶数索引的队列中，此队列被称作共享队列</span></span><br><span class="line"><span class="comment">     *    多说两句，之所以称作共享队列，其实是有原因的，这些队列的任务并不会用执行线程去执行，而是会被多个线程窃取，一个一个地被窃取，表明谁都可以来拿这队列里的任务去执行</span></span><br><span class="line"><span class="comment">     *    所以才叫做共享队列，纯属个人理解哈</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 之所以这么做是为了简化处理与加速任务扫描窃取，要不然就要用两个队列数组分别存储，毕竟ForkJoinTask#fork的任务后续还需要进行join，那就必须要进行筛选</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EVENMASK = <span class="number">0xfffe</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量值，通过 &amp; 计算偶数索引，从0-126之间的所有偶数，共有64个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SQMASK = <span class="number">0x007e</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量值，通过 &amp; 与scanState计算队列是否处于运行中，scanState为奇数时表明队列在使用中，奇数 &amp; 1 还是奇数，偶数 &amp; 1还是偶数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SCANNING = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量值，标识队列处于空闲状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INACTIVE = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量值，空闲队列版本号的增量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SS_SEQ = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量值，通过 &amp; 计算队列是以先进先出（FIFO）的顺序还是以先进后出(LIFO)的顺序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK = <span class="number">0xffff</span> &lt;&lt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量池，标识先进后出模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LIFO_QUEUE = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量值，标识先进先出模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIFO_QUEUE = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列数组奇数索引处的队列称作内部队列（纯属个人理解），偶数索引处的队列称作共享队列</span></span><br><span class="line"><span class="comment">     * 那么共享队列其实只用一个存放任务的队列，不存在自身的线程去处理它，所以它的所有任务都将被窃取，被内部队列窃取，因为内部队列有自身的线程，它会去窃取其他队列的任务</span></span><br><span class="line"><span class="comment">     * 这也是其称作共享队列的缘由吧</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 常量值，标识共享队列，该队列不存在模式，只是被内部队列窃取任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_QUEUE = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公共线程池</span></span><br><span class="line"><span class="comment">     * 提供静态方法直接获取ForkJoinPool实例，该实例的运行状态不受调用shutdown或shutdownNow方法的影响，只有在程序关闭时才会关闭</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ForkJoinPool common;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公共线程池的并行数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> commonParallelism;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公共线程池的最大备用线程数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> commonMaxSpares;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池的序号，通过从线程的名称可知是第几个线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> poolNumberSequence;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量值，工作线程阻塞的时间，只有工作线程发生空闲时才阻塞</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> IDLE_TIMEOUT = <span class="number">2000L</span> * <span class="number">1000L</span> * <span class="number">1000L</span>; <span class="comment">// 2秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量值，猜测是阻塞时间的误差</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TIMEOUT_SLOP = <span class="number">20L</span> * <span class="number">1000L</span> * <span class="number">1000L</span>;  <span class="comment">// 20ms</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量池，公共线程池的默认备用线程数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_COMMON_MAX_SPARES = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自旋次数，该值必须是2的幂次方，至少是4（不理解为什么一定要是2的幂次方）</span></span><br><span class="line"><span class="comment">     * 一般发生自旋就是为了等待某种时刻的到来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SPINS = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量值，参与奇数索引的计算，防止发生碰撞</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SEED_INCREMENT = <span class="number">0x9e3779b9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量值，通过 &amp; 计算ctl变量1-32位的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SP_MASK = <span class="number">0xffffffffL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量值，通过 &amp; 计算ctl变量33-64位的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> UC_MASK = ~SP_MASK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量值，用于移位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  AC_SHIFT = <span class="number">48</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量值，活跃的工作线程数的增量，也就是想要增加工作线程数的数量直接加上该值即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> AC_UNIT = <span class="number">0x0001L</span> &lt;&lt; AC_SHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量值，通过 &amp; 计算活跃的工作线程数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> AC_MASK = <span class="number">0xffffL</span> &lt;&lt; AC_SHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量值，用于移位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  TC_SHIFT = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量值，工作线程数的增量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TC_UNIT = <span class="number">0x0001L</span> &lt;&lt; TC_SHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量值，通过 &amp; 计算所有工作线程数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TC_MASK = <span class="number">0xffffL</span> &lt;&lt; TC_SHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量值，活跃的工作线程数的增量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ADD_WORKER = <span class="number">0x0001L</span> &lt;&lt; (TC_SHIFT + <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量值，标识线程池处于锁定状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  RSLOCK = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量值，标识线程池需要唤醒其他线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  RSIGNAL = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量值，标识线程池处于已启动状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  STARTED    = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量值，标识线程池处于已停止状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  STOP       = <span class="number">1</span> &lt;&lt; <span class="number">29</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量值，标识线程池处于已终止状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  TERMINATED = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量值，标识线程池处于已关闭状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  SHUTDOWN   = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还有一些全局属性是通过Unsafe类来完成赋值的，实际上利用了CAS特性以原子化的方式去变更线程池的相关属性值，至于是如何使用的将会另外起文章介绍！！！</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态代码块</span></span><br><span class="line"><span class="comment"> * 构建公共线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// ... 省略一些Unsafe使用的方法</span></span><br><span class="line"></span><br><span class="line">    commonMaxSpares = DEFAULT_COMMON_MAX_SPARES;</span><br><span class="line">    defaultForkJoinWorkerThreadFactory = <span class="keyword">new</span> DefaultForkJoinWorkerThreadFactory();</span><br><span class="line">    modifyThreadPermission = <span class="keyword">new</span> RuntimePermission(<span class="string">"modifyThread"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建公共线程池， 并行数是可用的处理器数量，也就是工作线程的个数是可用的处理器数量，任务以先进后出的顺序被处理</span></span><br><span class="line">    common = java.security.AccessController.doPrivileged</span><br><span class="line">        (<span class="keyword">new</span> java.security.PrivilegedAction&lt;ForkJoinPool&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> ForkJoinPool <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">                <span class="keyword">return</span> makeCommonPool(); </span><br><span class="line">            &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> par = common.config &amp; SMASK; <span class="comment">// 获取公共线程池的并行数，即工作线程的个数</span></span><br><span class="line">    commonParallelism = par &gt; <span class="number">0</span> ? par : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化，任务以先进后出的顺序被处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForkJoinPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Math.min(MAX_CAP, Runtime.getRuntime().availableProcessors()), defaultForkJoinWorkerThreadFactory, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化，自定义并行数，任务以先进后出的顺序被处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parallelism 线程池的并行数，也就是工作线程的个数 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parallelism, defaultForkJoinWorkerThreadFactory, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parallelism 线程池的并行数，也就是工作线程的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> factory 工作线程的工厂类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler 异常未处理的默认处理器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> asyncMode 队列的模式，即任务要以先进先出还是先进后出的顺序被处理，true：先进先出 false：先进后出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism, ForkJoinWorkerThreadFactory factory, UncaughtExceptionHandler handler, <span class="keyword">boolean</span> asyncMode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(checkParallelism(parallelism), checkFactory(factory), handler, asyncMode ? FIFO_QUEUE : LIFO_QUEUE, <span class="string">"ForkJoinPool-"</span> + nextPoolId() + <span class="string">"-worker-"</span>);</span><br><span class="line">    checkPermission();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parallelism 线程池的并行数，也就是工作线程的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> factory 工作线程的工厂类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler 异常未处理的默认处理器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mode 队列的模式，即任务要以先进先出还是先进后出的顺序被处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> workerNamePrefix 工作线程的前缀名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism, ForkJoinWorkerThreadFactory factory, UncaughtExceptionHandler handler, <span class="keyword">int</span> mode, String workerNamePrefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.workerNamePrefix = workerNamePrefix;</span><br><span class="line">    <span class="keyword">this</span>.factory = factory; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">this</span>.ueh = handler;</span><br><span class="line">    <span class="keyword">this</span>.config = (parallelism &amp; SMASK) | mode;</span><br><span class="line">    <span class="keyword">long</span> np = (<span class="keyword">long</span>)(-parallelism);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上面介绍了该属性是线程池的控制中心</span></span><br><span class="line"><span class="comment">     * 该属性既有表示活跃的工作线程数也有表示所有的工作线程数，不过就目前来说咱们还未有任务提交自然不存在任何的工作线程，而在初始化时指定了并行数，所以这两个表示都应该为负并行数</span></span><br><span class="line"><span class="comment">     * 以下的计算即表示为负并行数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">this</span>.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br><span class="line">1319</span><br><span class="line">1320</span><br><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br><span class="line">1345</span><br><span class="line">1346</span><br><span class="line">1347</span><br><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br><span class="line">1366</span><br><span class="line">1367</span><br><span class="line">1368</span><br><span class="line">1369</span><br><span class="line">1370</span><br><span class="line">1371</span><br><span class="line">1372</span><br><span class="line">1373</span><br><span class="line">1374</span><br><span class="line">1375</span><br><span class="line">1376</span><br><span class="line">1377</span><br><span class="line">1378</span><br><span class="line">1379</span><br><span class="line">1380</span><br><span class="line">1381</span><br><span class="line">1382</span><br><span class="line">1383</span><br><span class="line">1384</span><br><span class="line">1385</span><br><span class="line">1386</span><br><span class="line">1387</span><br><span class="line">1388</span><br><span class="line">1389</span><br><span class="line">1390</span><br><span class="line">1391</span><br><span class="line">1392</span><br><span class="line">1393</span><br><span class="line">1394</span><br><span class="line">1395</span><br><span class="line">1396</span><br><span class="line">1397</span><br><span class="line">1398</span><br><span class="line">1399</span><br><span class="line">1400</span><br><span class="line">1401</span><br><span class="line">1402</span><br><span class="line">1403</span><br><span class="line">1404</span><br><span class="line">1405</span><br><span class="line">1406</span><br><span class="line">1407</span><br><span class="line">1408</span><br><span class="line">1409</span><br><span class="line">1410</span><br><span class="line">1411</span><br><span class="line">1412</span><br><span class="line">1413</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建公共线程池</span></span><br><span class="line"><span class="comment"> * 实际上先是获取参数随后初始化了线程池</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 公共线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ForkJoinPool <span class="title">makeCommonPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> parallelism = -<span class="number">1</span>;</span><br><span class="line">    ForkJoinWorkerThreadFactory factory = <span class="keyword">null</span>;</span><br><span class="line">    UncaughtExceptionHandler handler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        String pp = System.getProperty(<span class="string">"java.util.concurrent.ForkJoinPool.common.parallelism"</span>); <span class="comment">// 获取系统属性的并行数，默认情况下为null</span></span><br><span class="line">        String fp = System.getProperty(<span class="string">"java.util.concurrent.ForkJoinPool.common.threadFactory"</span>); <span class="comment">// 获取系统属性的工作线程的工厂类，默认情况下为null</span></span><br><span class="line">        String hp = System.getProperty(<span class="string">"java.util.concurrent.ForkJoinPool.common.exceptionHandler"</span>); <span class="comment">// 获取系统属性的异常未处理的默认处理器，默认情况下为null</span></span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="keyword">null</span>)</span><br><span class="line">            parallelism = Integer.parseInt(pp);</span><br><span class="line">        <span class="keyword">if</span> (fp != <span class="keyword">null</span>)</span><br><span class="line">            factory = ((ForkJoinWorkerThreadFactory)ClassLoader.getSystemClassLoader().loadClass(fp).newInstance());</span><br><span class="line">        <span class="keyword">if</span> (hp != <span class="keyword">null</span>)</span><br><span class="line">            handler = ((UncaughtExceptionHandler)ClassLoader.getSystemClassLoader().loadClass(hp).newInstance());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() == <span class="keyword">null</span>)</span><br><span class="line">            factory = defaultForkJoinWorkerThreadFactory;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// use security-managed default</span></span><br><span class="line">            factory = <span class="keyword">new</span> InnocuousForkJoinWorkerThreadFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parallelism &lt; <span class="number">0</span> &amp;&amp; (parallelism = Runtime.getRuntime().availableProcessors() - <span class="number">1</span>) &lt;= <span class="number">0</span>) <span class="comment">// Runtime.getRuntime().availableProcessors()获取可用处理器的数量，该数值绝不会小于1</span></span><br><span class="line">        parallelism = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (parallelism &gt; MAX_CAP) <span class="comment">// 限制并行数的大小，实际上就是在限制工作线程数的个数</span></span><br><span class="line">        parallelism = MAX_CAP;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool(parallelism, factory, handler, LIFO_QUEUE, <span class="string">"ForkJoinPool.commonPool-worker-"</span>); <span class="comment">// 工作线程处于自身队列中的任务时，任务以先进后出的顺序被处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代替已经从内部队列移除的任务</span></span><br><span class="line"><span class="comment"> * 只有调用ForkJoinTask#fork时，任务才会被放入到内部队列中</span></span><br><span class="line"><span class="comment"> * 这里只是提供了一种占位，除此之外什么都没有做</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EmptyTask</span> <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7721805057305804111L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     * 定义了任务正常执行的状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    EmptyTask() &#123; </span><br><span class="line">        status = ForkJoinTask.NORMAL; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取任务的执行结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 任务的执行结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Void <span class="title">getRawResult</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置任务的执行结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 任务的执行结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setRawResult</span><span class="params">(Void x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务是否执行成功</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 任务是否执行成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 校验并行数是否合理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parallelism 并行数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 并行数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">checkParallelism</span><span class="params">(<span class="keyword">int</span> parallelism)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parallelism &lt;= <span class="number">0</span> || parallelism &gt; MAX_CAP)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">return</span> parallelism;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    ForkJoinTask&lt;?&gt; job;</span><br><span class="line">    <span class="keyword">if</span> (task <span class="keyword">instanceof</span> ForkJoinTask&lt;?&gt;) <span class="comment">// avoid re-wrap</span></span><br><span class="line">        job = (ForkJoinTask&lt;?&gt;) task;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        job = <span class="keyword">new</span> ForkJoinTask.RunnableExecuteAction(task); <span class="comment">// 将其包装成指定任务类型</span></span><br><span class="line">    externalPush(job);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">externalPush</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    WorkQueue[] ws; WorkQueue q; <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> r = ThreadLocalRandom.getProbe(); <span class="comment">//该方式是在获取随机数，不过需要注意的是不同线程间除了第一次调用以外，该数值都将不同，实际上在多个线程同时提交任务时为了呈现随机性，而该值针对同一个线程是相同的</span></span><br><span class="line">    <span class="keyword">int</span> rs = runState;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上面提到对于提交的任务来说，应该放在偶数索引的队列中，故而 m &amp; r &amp; SQMASK 表明随机选择偶数索引</span></span><br><span class="line"><span class="comment">     * 但是这里有一个好奇的点就是取得最大的偶数索引是126，也就是说即使队列数组在大，最终也只能取到这么多，那么容量如此大的队列数组是否造成了内存的浪费???</span></span><br><span class="line"><span class="comment">     * 当获取到偶数索引的队列时，剩下的就是把该任务放入到队列中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 判断队列是否处于锁定状态，若是则说明有其他线程正在提交任务，为了减少冲突，则进入到externalSubmit方法中重新在随机选择</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (m = (ws.length - <span class="number">1</span>)) &gt;= <span class="number">0</span> &amp;&amp; (q = ws[m &amp; r &amp; SQMASK]) != <span class="keyword">null</span> &amp;&amp; r != <span class="number">0</span> &amp;&amp; rs &gt; <span class="number">0</span> &amp;&amp; U.compareAndSwapInt(q, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123; </span><br><span class="line">        ForkJoinTask&lt;?&gt;[] a; <span class="keyword">int</span> am, n, s;</span><br><span class="line">        <span class="keyword">if</span> ((a = q.array) != <span class="keyword">null</span> &amp;&amp; (am = a.length - <span class="number">1</span>) &gt; (n = (s = q.top) - q.base)) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = ((am &amp; s) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">            U.putOrderedObject(a, j, task); <span class="comment">// 简单点理解，putOrderedObject方法就是将 top = task</span></span><br><span class="line">            U.putOrderedInt(q, QTOP, s + <span class="number">1</span>); <span class="comment">// 更新下一个要存储务的索引</span></span><br><span class="line">            U.putIntVolatile(q, QLOCK, <span class="number">0</span>); <span class="comment">// 解锁队列</span></span><br><span class="line">            <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">                signalWork(ws, q); <span class="comment">// 任务量很少的情况下，线程会进入到空闲，所以当你提交新的任务进来时应该使线程活跃起来，唤醒它们要开始工作了</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        U.compareAndSwapInt(q, QLOCK, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    externalSubmit(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该方法做了以下几件事：</span></span><br><span class="line"><span class="comment"> * 1. 获取线程池的使用权，并初始化队列数组</span></span><br><span class="line"><span class="comment"> * 2. 获取线程池的使用权，随机获取偶数索引，在其位置上创建队列</span></span><br><span class="line"><span class="comment"> * 3. 由于并未修改线程池的队列数组，故而不需要其使用权，直接提交任务</span></span><br><span class="line"><span class="comment"> * 4. 在这过程中若未获取到线程池的使用权，则需要重新随机获取偶数索引处的队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">externalSubmit</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> ((r = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123; </span><br><span class="line">        ThreadLocalRandom.localInit(); <span class="comment">// 初始化随机数</span></span><br><span class="line">        r = ThreadLocalRandom.getProbe();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// ws：队列数组 q：偶数索引处的队列，有可能为null  rs：线程池的状态 m：队列数组最后位置的索引，通过 &amp; 计算用于随机获取偶数索引 k：偶数索引</span></span><br><span class="line">        WorkQueue[] ws; WorkQueue q; <span class="keyword">int</span> rs, m, k;</span><br><span class="line">        <span class="keyword">boolean</span> move = <span class="keyword">false</span>; <span class="comment">// 当偶数索引处的队列处于锁定状态时，针对新任务必须要重新随机获取队列，而该标识仅用于决定是否重新获取随机数</span></span><br><span class="line">        <span class="keyword">if</span> ((rs = runState) &lt; <span class="number">0</span>) &#123; <span class="comment">// runState表示线程池的状态，当小于0时表示线程池处于已关闭状态</span></span><br><span class="line">            tryTerminate(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(); <span class="comment">//直接抛出异常来拒绝任务的提交</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((rs &amp; STARTED) == <span class="number">0</span> || ((ws = workQueues) == <span class="keyword">null</span> || (m = ws.length - <span class="number">1</span>) &lt; <span class="number">0</span>)) &#123; <span class="comment">// 不考虑已关闭/已终止/已停止的情况下，若结果为true表明线程池尚未初始化</span></span><br><span class="line">            <span class="keyword">int</span> ns = <span class="number">0</span>;</span><br><span class="line">            rs = lockRunState(); <span class="comment">// 先让线程池处于锁定状态，以便进行后续的初始化</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((rs &amp; STARTED) == <span class="number">0</span>) &#123;</span><br><span class="line">                    U.compareAndSwapObject(<span class="keyword">this</span>, STEALCOUNTER, <span class="keyword">null</span>, <span class="keyword">new</span> AtomicLong()); <span class="comment">// 简单来说就是将 stealCounter = new AtomicLong</span></span><br><span class="line">                    <span class="keyword">int</span> p = config &amp; SMASK; <span class="comment">// ensure at least 2 slots</span></span><br><span class="line">                    <span class="keyword">int</span> n = (p &gt; <span class="number">1</span>) ? p - <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 这一段的计算很有意思，实验几个例子就能够猜到做了什么操作！！！</span></span><br><span class="line"><span class="comment">                     * 通过上面的计算我们知道 n 是代表队列数组的长度大小，（这里先给出结论）根据该类内部的注释我们可以知道该队列的长度应该是2的幂次方</span></span><br><span class="line"><span class="comment">                     * 那为什么是2的幂次方呢? 有一段注释如此写到：</span></span><br><span class="line"><span class="comment">                     * To simplify index-based operations, the array size is always a power of two, and all readers must tolerate null slots</span></span><br><span class="line"><span class="comment">                     * 所以我们可以知道这样子做是为了简化基于索引的操作</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * 回到正题，既然需要2的幂次方，有如此步骤：</span></span><br><span class="line"><span class="comment">                     * 1. 首先就需要将其对应的二进制全部变成1，有点难理解，我们举例子吧，假设 n = 0000 0000 0000 0000 0000 1001 1011 1101</span></span><br><span class="line"><span class="comment">                     *    那么按照我们的想法最终应该是变成 n = 0000 0000 0000 0000 0000 1111 1111 1111，即把最高位（从左到右以1开始的位）的后续所有数字全部变成1就可以了</span></span><br><span class="line"><span class="comment">                     *    所有 n |= n &gt;&gt;&gt; 1 - n |= n &gt;&gt;&gt; 16 就是为了变成上面的结果，当然了，上面的结果很明显不是2的幂次方，所以就有了接下来的内容</span></span><br><span class="line"><span class="comment">                     * 2. 对于 n = 0000 0000 0000 0000 0000 1111 1111 1111 这样子的数字在 + 1 后就变成了 n = n = 0000 0000 0000 0000 0001 0000 0000 0000， 这样子就变成了2的幂次方</span></span><br><span class="line"><span class="comment">                     *    这种计算方式在ArrayList中应该介绍过，既然已经是2的幂次方了，为什么后续还要左移1位呢，其实上面的注释也说了，确保至少有2个插槽，为什么要确保有2个插槽呢，因为该方法被调用表示已经有任务提交了</span></span><br><span class="line"><span class="comment">                     *    那么队列总不能为空吧，或者是2的0次幂方吧，所以队列的大小至少是2的1次幂方，故而又左移1位了</span></span><br><span class="line"><span class="comment">                     * </span></span><br><span class="line"><span class="comment">                     * 总结：该片段代码是为了使队列的长度大小形成2的幂次方，至少是2的1次幂方，如此行为是为了简化基于索引的操作</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    n |= n &gt;&gt;&gt; <span class="number">1</span>; </span><br><span class="line">                    n |= n &gt;&gt;&gt; <span class="number">2</span>;  </span><br><span class="line">                    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">                    n |= n &gt;&gt;&gt; <span class="number">8</span>; </span><br><span class="line">                    n |= n &gt;&gt;&gt; <span class="number">16</span>; </span><br><span class="line">                    n = (n + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                    workQueues = <span class="keyword">new</span> WorkQueue[n]; <span class="comment">// 构建队列数组，其最大值是SMASK</span></span><br><span class="line">                    ns = STARTED;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlockRunState(rs, (rs &amp; ~RSLOCK) | ns); <span class="comment">// 将线程池的状态由于RSLOCK更换成STARTED，相当于在说明线程池我已经使用完毕了，其他线程可以去抢占了，故在最后会唤醒其他线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((q = ws[k = r &amp; m &amp; SQMASK]) != <span class="keyword">null</span>) &#123; <span class="comment">// 走到这里说明线程池已经初始化过了，而能够调用externalSubmit方法的是提交了外部任务（执行execute/submit），这样子的行为需要查找偶数索引的队列，即共享队列</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 现在已经随机获取到偶数索引的队列，那么还要查看此队列是否处于锁定状态，即是否有任务正在提交</span></span><br><span class="line"><span class="comment">             * 若有任务正在提交中，则修改标志位move，以便在下次for循环时重新选择新的队列进行任务的提交</span></span><br><span class="line"><span class="comment">             * 若未有任务在使用该队列，那么先将其标志位修改成锁定状态，以便后续的继续执行</span></span><br><span class="line"><span class="comment">             * 查看队列是否处于锁定状态用qlock标志位</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (q.qlock == <span class="number">0</span> &amp;&amp; U.compareAndSwapInt(q, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123; <span class="comment">// 将此队列修改成锁定状态</span></span><br><span class="line">                ForkJoinTask&lt;?&gt;[] a = q.array;</span><br><span class="line">                <span class="keyword">int</span> s = q.top;</span><br><span class="line">                <span class="keyword">boolean</span> submitted = <span class="keyword">false</span>; <span class="comment">// initial submission or resizing</span></span><br><span class="line">                <span class="keyword">try</span> &#123;                      <span class="comment">// locked version of push</span></span><br><span class="line">                    <span class="keyword">if</span> ((a != <span class="keyword">null</span> &amp;&amp; a.length &gt; s + <span class="number">1</span> - q.base) || (a = q.growArray()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> j = (((a.length - <span class="number">1</span>) &amp; s) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                        U.putOrderedObject(a, j, task); <span class="comment">// 简单理解来说就是将该任务放到任务数组的top索引上</span></span><br><span class="line">                        U.putOrderedInt(q, QTOP, s + <span class="number">1</span>); <span class="comment">// 更新top值，以便存储下个任务</span></span><br><span class="line">                        submitted = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    U.compareAndSwapInt(q, QLOCK, <span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 任务已经填充完毕，应当解锁队列，以便其他任务可以使用该队列</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (submitted) &#123;</span><br><span class="line">                    signalWork(ws, q);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            move = <span class="keyword">true</span>;                   <span class="comment">// move on failure</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (((rs = runState) &amp; RSLOCK) == <span class="number">0</span>) &#123; <span class="comment">// 走到这里说明，偶数索引位置并未存在共享队列，故而需要创建一个，同时需要拥有线程池的使用权</span></span><br><span class="line">            q = <span class="keyword">new</span> WorkQueue(<span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">            q.hint = r;</span><br><span class="line">            q.config = k | SHARED_QUEUE; <span class="comment">// k：偶数索引 config：偶数索引 + 模式</span></span><br><span class="line">            q.scanState = INACTIVE;  <span class="comment">// 队列处于空闲状态</span></span><br><span class="line">            rs = lockRunState();           <span class="comment">// 获取线程池的使用权，因为后续要将该队列放入到队列数组中了</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt; <span class="number">0</span> &amp;&amp;  (ws = workQueues) != <span class="keyword">null</span> &amp;&amp; k &lt; ws.length &amp;&amp; ws[k] == <span class="keyword">null</span>)</span><br><span class="line">                ws[k] = q;</span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK); <span class="comment">// 线程池使用完毕，进行解锁，其他线程可以去抢占了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            move = <span class="keyword">true</span>; <span class="comment">// 未拥有线程池的使用权且偶数索引处的队列是null则需要重新随机获取偶数索引的队列</span></span><br><span class="line">        <span class="keyword">if</span> (move)</span><br><span class="line">            r = ThreadLocalRandom.advanceProbe(r); <span class="comment">// 简单理解就是重新取随机数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增或唤醒线程处理任务</span></span><br><span class="line"><span class="comment"> * 调用此方法说明当前队列中存在任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ws 队列数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> q 当前队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalWork</span><span class="params">(WorkQueue[] ws, WorkQueue q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> c; <span class="keyword">int</span> sp, i; WorkQueue v; Thread p;</span><br><span class="line">    <span class="keyword">while</span> ((c = ctl) &lt; <span class="number">0L</span>) &#123; <span class="comment">// ctl的值在初始化时进行赋值，若 ctl &lt; 0 表示活跃的工作线程数量过少，不满足并行数，所以必须要增加活跃的工作线程数量</span></span><br><span class="line">        <span class="keyword">if</span> ((sp = (<span class="keyword">int</span>)c) == <span class="number">0</span>) &#123; <span class="comment">//  强制转换类型取 1- 32位，根据ctrl的1-32位可知是空闲队列的版本计数与空闲队列的索引</span></span><br><span class="line">            <span class="keyword">if</span> ((c &amp; ADD_WORKER) != <span class="number">0L</span>)  <span class="comment">// ctl &amp; ADD_WORKER 相当于在获取所有的工作线程数，若该结果是1则表示所有的工作线程数过少，若结果是0则说明所有的工作线程数已足够，所以不等于0就相当于在判断是否过少</span></span><br><span class="line">                tryAddWorker(c); <span class="comment">// 若所有的工作线程数过少则必须要进行添加</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 走到这里说明有空闲队列</span></span><br><span class="line">        <span class="keyword">if</span> (ws == <span class="keyword">null</span>)                            <span class="comment">// 个人认为这么不会发生，因为 ws 引用的是 workQueues 对象，而在全部的代码中并未找到其赋成null值</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws.length &lt;= (i = sp &amp; SMASK))         <span class="comment">// sp &amp; SMASK是在获取空闲队列的索引，ws.length &lt;= i 只有在线程池已关闭的情况下才会发生，因为关闭时清空了队列数组</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ((v = ws[i]) == <span class="keyword">null</span>)                   <span class="comment">// 关闭时清空了队列数组，导致为null</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> vs = (sp + SS_SEQ) &amp; ~INACTIVE;        <span class="comment">// 计算空闲队列的版本计数与活跃状态</span></span><br><span class="line">        <span class="keyword">int</span> d = sp - v.scanState;                  <span class="comment">// 判断空闲队列的行为是否发生了，行为指的是版本计数和状态，若发生了改变则需要重新计算</span></span><br><span class="line">        <span class="keyword">long</span> nc = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; v.stackPred); <span class="comment">// 活跃的工作线程数加1，计算上一个最新的空闲队列</span></span><br><span class="line">        <span class="keyword">if</span> (d == <span class="number">0</span> &amp;&amp; U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc)) &#123;</span><br><span class="line">            v.scanState = vs;                      <span class="comment">// 使空闲队列变成活跃状态</span></span><br><span class="line">            <span class="keyword">if</span> ((p = v.parker) != <span class="keyword">null</span>)            <span class="comment">// 若此时空闲队列处于阻塞中，则立即唤醒，告诉它起来干活了</span></span><br><span class="line">                U.unpark(p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span> &amp;&amp; q.base == q.top)          <span class="comment">// base == top 时表明队列中的所有任务都处理完毕了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增一个或多个工作线程，使其满足并行数，即所有的工作线程数应该等于并行数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c ctl值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryAddWorker</span><span class="params">(<span class="keyword">long</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> add = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> nc = ((AC_MASK &amp; (c + AC_UNIT)) | (TC_MASK &amp; (c + TC_UNIT))); <span class="comment">// 添加新的工作线程，所以ctl对应的值应该有所变化，通过移位的方式进行增加，最终活跃的工作线程数与所有的工作线程数都加上1</span></span><br><span class="line">        <span class="keyword">if</span> (ctl == c) &#123; <span class="comment">// 这里加上判断是为了在多线程下ctl发生改变，而造成c != ctl ，所以必须要拿到最新的ctl之后在进行计算，即在while当中进行赋值后重新计算</span></span><br><span class="line">            <span class="keyword">int</span> rs, stop;</span><br><span class="line">            <span class="keyword">if</span> ((stop = (rs = lockRunState()) &amp; STOP) == <span class="number">0</span>) <span class="comment">// 先将线程池置于锁定状态下，同时判断当前线程池是否处于已关闭状态下（STOP），若是则结果false，随后退出循环，若不处于已关闭状态下，则修改ctl = nc</span></span><br><span class="line">                add = U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc);</span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK); <span class="comment">// ctl的值已修改完毕，进行解锁</span></span><br><span class="line">            <span class="keyword">if</span> (stop != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (add) &#123;</span><br><span class="line">                createWorker(); <span class="comment">// 创建新的工作线程并启动</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先判断所有的工作线程数是否满足并行数，若不满足还要判断线程池是否很忙碌，即是否存在空闲线程</span></span><br><span class="line"><span class="comment">     * 若存在则说明不忙碌，就没必要在创建新的工作线程了，不然要浪费资源了</span></span><br><span class="line"><span class="comment">     * 若不存在则说明很忙碌，需要创建多个工作线程来同时工作，以提供工作效率</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (((c = ctl) &amp; ADD_WORKER) != <span class="number">0L</span> &amp;&amp; (<span class="keyword">int</span>)c == <span class="number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建工作线程并开启</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">createWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ForkJoinWorkerThreadFactory fac = factory; <span class="comment">// 工作线程的工厂类在初始化就已经赋值了</span></span><br><span class="line">    Throwable ex = <span class="keyword">null</span>;</span><br><span class="line">    ForkJoinWorkerThread wt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fac != <span class="keyword">null</span> &amp;&amp; (wt = fac.newThread(<span class="keyword">this</span>)) != <span class="keyword">null</span>) &#123; <span class="comment">// 创建工作线程</span></span><br><span class="line">            wt.start();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">        ex = rex;</span><br><span class="line">    &#125;</span><br><span class="line">    deregisterWorker(wt, ex); <span class="comment">// 若工作线程创建或启动失败的话，则废弃掉已创建的对应的队列，在根据满足条件选择要唤醒空闲线程或重新创建工作线程，但最终都会抛出异常</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为新创建的工作线程设置对应的队列，该队列处于队列数组的奇数索引上</span></span><br><span class="line"><span class="comment"> * 该方法只会在ForkWokerThread初始化时调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> wt 工作线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 奇数索引上的队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> WorkQueue <span class="title">registerWorker</span><span class="params">(ForkJoinWorkerThread wt)</span> </span>&#123;</span><br><span class="line">    UncaughtExceptionHandler handler;</span><br><span class="line">    wt.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> ((handler = ueh) != <span class="keyword">null</span>)</span><br><span class="line">        wt.setUncaughtExceptionHandler(handler);</span><br><span class="line">    WorkQueue w = <span class="keyword">new</span> WorkQueue(<span class="keyword">this</span>, wt);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mode = config &amp; MODE_MASK; <span class="comment">// 获取模式，即要以FIFO还是LIFO</span></span><br><span class="line">    <span class="keyword">int</span> rs = lockRunState();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        WorkQueue[] ws; <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (n = ws.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = indexSeed += SEED_INCREMENT;  <span class="comment">// 这里就不过多猜想它为什么这么做，感觉像是在做随机化</span></span><br><span class="line">            <span class="keyword">int</span> m = n - <span class="number">1</span>;</span><br><span class="line">            i = ((s &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>) &amp; m;               <span class="comment">// 随机获取奇数索引</span></span><br><span class="line">            <span class="keyword">if</span> (ws[i] != <span class="keyword">null</span>) &#123;                  <span class="comment">// 判断奇数索引是否已经有存在队列了，若是有队列的话，则需要重新获取</span></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 计算step，用于后续重新获取奇数索引，相当于在原来获取到的奇数索引上往前移动计算后的step，即让其往前推</span></span><br><span class="line"><span class="comment">                 * 该step的结果一定是偶数，因为只有这样子才能使得 奇数 + 偶数的结果还是奇数，其step大约是队列数组的一半</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * 但是在往前推的过程中，有可能出现队列数组的大部分奇数索引都存在队列，导致要一直重复性查找，这样子说明现有的队列数组过小</span></span><br><span class="line"><span class="comment">                 * 所以使用了probes作为其标识，当其重复查找的次数大于队列数组的容量时，就将其进行扩容，用这个标准主要是说明它循环过一次队列数组了，但还是找不到适合的索引处，建议还是直接扩容吧</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">int</span> probes = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> step = (n &lt;= <span class="number">4</span>) ? <span class="number">2</span> : ((n &gt;&gt;&gt; <span class="number">1</span>) &amp; EVENMASK) + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span> (ws[i = (i + step) &amp; m] != <span class="keyword">null</span>) &#123; <span class="comment">// </span></span><br><span class="line">                    <span class="keyword">if</span> (++probes &gt;= n) &#123;</span><br><span class="line">                        workQueues = ws = Arrays.copyOf(ws, n &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">                        m = n - <span class="number">1</span>;</span><br><span class="line">                        probes = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            w.hint = s;</span><br><span class="line">            w.config = i | mode;</span><br><span class="line">            w.scanState = i; <span class="comment">// 队列处于运行中</span></span><br><span class="line">            ws[i] = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">    &#125;</span><br><span class="line">    wt.setName(workerNamePrefix.concat(Integer.toString(i &gt;&gt;&gt; <span class="number">1</span>)));</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注销工作线程</span></span><br><span class="line"><span class="comment"> * 该方法会在创建工作线程失败或启动失败时或关闭活跃的工作线程时被调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> wt 工作线程，可能null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ex 异常信息，可能为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">deregisterWorker</span><span class="params">(ForkJoinWorkerThread wt, Throwable ex)</span> </span>&#123;</span><br><span class="line">    WorkQueue w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (wt != <span class="keyword">null</span> &amp;&amp; (w = wt.workQueue) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        WorkQueue[] ws;                         </span><br><span class="line">        <span class="keyword">int</span> idx = w.config &amp; SMASK; <span class="comment">// 获取工作线程对应的队列的奇数索引，以便从队列数组中移除</span></span><br><span class="line">        <span class="keyword">int</span> rs = lockRunState();</span><br><span class="line">        <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; ws.length &gt; idx &amp;&amp; ws[idx] == w)</span><br><span class="line">            ws[idx] = <span class="keyword">null</span>;</span><br><span class="line">        unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> c;</span><br><span class="line">    <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (!U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c = ctl, ((AC_MASK &amp; (c - AC_UNIT)) | (TC_MASK &amp; (c - TC_UNIT)) | (SP_MASK &amp; c)))); <span class="comment">// 将活跃的工作线程数与所有的工作线程数都减去1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (w != <span class="keyword">null</span>) &#123; <span class="comment">// 既然要注销工作线程，其对应的队列应该被废弃掉</span></span><br><span class="line">        w.qlock = -<span class="number">1</span>; <span class="comment">// 标识队列被废弃</span></span><br><span class="line">        w.transferStealCount(<span class="keyword">this</span>); <span class="comment">// 更新已窃取的任务数量</span></span><br><span class="line">        w.cancelAll(); <span class="comment">// 取消所有任务，包括窃取的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;      </span><br><span class="line">        WorkQueue[] ws; <span class="keyword">int</span> m, sp;</span><br><span class="line">        <span class="comment">// 判断线程池是否正在被关闭，若是正在被关闭则没必要新增工作线程或唤醒空闲队列</span></span><br><span class="line">        <span class="keyword">if</span> (tryTerminate(<span class="keyword">false</span>, <span class="keyword">false</span>) || w == <span class="keyword">null</span> || w.array == <span class="keyword">null</span> || (runState &amp; STOP) != <span class="number">0</span> || (ws = workQueues) == <span class="keyword">null</span> || (m = ws.length - <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ((sp = (<span class="keyword">int</span>)(c = ctl)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tryRelease(c, ws[sp &amp; m], AC_UNIT)) <span class="comment">// 尝试唤醒最新的空闲队列</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ex != <span class="keyword">null</span> &amp;&amp; (c &amp; ADD_WORKER) != <span class="number">0L</span>) &#123; <span class="comment">// 若不存在空闲的工作队列说明线程池可能处于忙碌中，接着判断是否满足并行数，不满足则添加新的工作线程来提高任务的处理速度</span></span><br><span class="line">            tryAddWorker(c);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ex == <span class="keyword">null</span>)                               </span><br><span class="line">        ForkJoinTask.helpExpungeStaleExceptions(); <span class="comment">// 成功关闭活跃的工作线程时会走到这里，关于ForkJoinTask的方法将会另外新起文章进行介绍 </span></span><br><span class="line">    <span class="keyword">else</span>                                      </span><br><span class="line">        ForkJoinTask.rethrow(ex); <span class="comment">// 创建工作线程或启动失败将会抛出异常，既然失败了但是我们已经尝试重新创建，但它最终还是会抛出异常，没太想明白...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行窃取的任务、自身队列的任务，当没有任务的情况下阻塞空闲线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w 当前队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(WorkQueue w)</span> </span>&#123;</span><br><span class="line">    w.growArray();                   <span class="comment">// 初始化或扩容任务数组</span></span><br><span class="line">    <span class="keyword">int</span> seed = w.hint;              </span><br><span class="line">    <span class="keyword">int</span> r = (seed == <span class="number">0</span>) ? <span class="number">1</span> : seed;  <span class="comment">// 随机数</span></span><br><span class="line">    <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((t = scan(w, r)) != <span class="keyword">null</span>) <span class="comment">// 尝试窃取任务</span></span><br><span class="line">            w.runTask(t); <span class="comment">// 运行</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!awaitWork(w, r)) <span class="comment">// 阻塞空闲线程，若在阻塞过程中有任务，则会被唤醒</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        r ^= r &lt;&lt; <span class="number">13</span>; r ^= r &gt;&gt;&gt; <span class="number">17</span>; r ^= r &lt;&lt; <span class="number">5</span>; <span class="comment">// 随机数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 随机窃取队列的任务，有可能窃取到的任务是自身队列的任务</span></span><br><span class="line"><span class="comment"> * 多次尝试窃取任务，若没有窃取到任务则将当前队列置为空闲状态并再次遍历一次队列数组尝试着窃取任务，若还是没有的话就返回null，若有任务可以被窃取则需要唤醒最新的空闲线程，由于多线程的缘故可能不是当前队列对应的线程</span></span><br><span class="line"><span class="comment"> * 所以有可能到头来又为其他线程做了嫁衣</span></span><br><span class="line"><span class="comment"> * 且当中会检查是否存在多个任务，则会唤醒空闲线程或新增工作线程</span></span><br><span class="line"><span class="comment"> * 关联每个空闲队列，通过空闲队列能获取到空闲线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w 当前队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> r 随机数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 窃取到的任务或null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ForkJoinTask&lt;?&gt; scan(WorkQueue w, <span class="keyword">int</span> r) &#123;</span><br><span class="line">    WorkQueue[] ws; <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (m = ws.length - <span class="number">1</span>) &gt; <span class="number">0</span> &amp;&amp; w != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ss = w.scanState; <span class="comment">// 队列在队列数组所处的奇数索引</span></span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * r：随机数  </span></span><br><span class="line"><span class="comment">          * origin：起始查找的索引值  </span></span><br><span class="line"><span class="comment">          * k：当前查找的索引值 当k == origin说明已经遍历完整个队列数组 </span></span><br><span class="line"><span class="comment">          * oldSum：上一次遍历的索引数量</span></span><br><span class="line"><span class="comment">          * checkSum：遍历的索引值，每获取一个不为空的队列，该数值都会增加</span></span><br><span class="line"><span class="comment">          * 1. 当遍历完整个队列数组后，会比较 oldSum 与 checkSum 是否相等，若相等则说明并未有任务可以被窃取，则将 oldSum = checkSum，checkSum = 0， 接着会在遍历一次，再次确认是否有任务可以被窃取</span></span><br><span class="line"><span class="comment">          *     1.1 若没有则将当前队列置为空闲状态，不去窃取了，而在置完之后还会再去遍历一次，如果这个时候恰好有任务了，则会重新开始窃取并唤醒空闲线程，若还是没有任务，则最终当前队列对应的线程将变成空闲线程</span></span><br><span class="line"><span class="comment">          * 2. 若不相等则说明有任务可以窃取，继续遍历</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> origin = r &amp; m, k = origin, oldSum = <span class="number">0</span>, checkSum = <span class="number">0</span>;;) &#123;</span><br><span class="line">            WorkQueue q; ForkJoinTask&lt;?&gt;[] a; ForkJoinTask&lt;?&gt; t;  <span class="comment">// q：队列  a：队列中的任务数组   t：任务</span></span><br><span class="line">            <span class="keyword">int</span> b, n; <span class="keyword">long</span> c; <span class="comment">// b：q.base   n:q.base - q.top  c：ctl</span></span><br><span class="line">            <span class="keyword">if</span> ((q = ws[k]) != <span class="keyword">null</span>) &#123; <span class="comment">// 查看当前索引位置是否有队列，若有则进入，若没有则继续找下一个连续索引，即假设当前索引是1，那么下一个应该找索引为2</span></span><br><span class="line">                <span class="keyword">if</span> ((n = (b = q.base) - q.top) &lt; <span class="number">0</span> &amp;&amp; (a = q.array) != <span class="keyword">null</span>) &#123; <span class="comment">// 判断队列中是否有任务存在，若top &gt; base 说明有任务存在</span></span><br><span class="line">                    <span class="keyword">long</span> i = (((a.length - <span class="number">1</span>) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                    <span class="keyword">if</span> ((t = ((ForkJoinTask&lt;?&gt;) U.getObjectVolatile(a, i))) != <span class="keyword">null</span> &amp;&amp; q.base == b) &#123; <span class="comment">// 获取任务, 当base != b时说明其他线程正在窃取该任务，为了降低冲突，选择重新开始随机窃取</span></span><br><span class="line">                        <span class="keyword">if</span> (ss &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (U.compareAndSwapObject(a, i, t, <span class="keyword">null</span>)) &#123; <span class="comment">// 将队列数组中的任务置为null</span></span><br><span class="line">                                q.base = b + <span class="number">1</span>;</span><br><span class="line">                                <span class="keyword">if</span> (n &lt; -<span class="number">1</span>)       <span class="comment">// 当 n &lt; -1 时表示有多个任务，需要去新增工作线程或唤醒空闲线程</span></span><br><span class="line">                                    signalWork(ws, q);</span><br><span class="line">                                <span class="keyword">return</span> t;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (oldSum == <span class="number">0</span> &amp;&amp; w.scanState &lt; <span class="number">0</span>)</span><br><span class="line">                            <span class="comment">// 唤醒最新的空闲线程，即对应到最新的队列，每个队列之间用stackPred关联，个人认为先唤醒最新的空闲线程是因为其等待的时间最长，减少等待时间，提高窃取任务的效率</span></span><br><span class="line">                            tryRelease(c = ctl, ws[m &amp; (<span class="keyword">int</span>)c], AC_UNIT); </span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (ss &lt; <span class="number">0</span>)</span><br><span class="line">                        ss = w.scanState;</span><br><span class="line">                    r ^= r &lt;&lt; <span class="number">1</span>; r ^= r &gt;&gt;&gt; <span class="number">3</span>; r ^= r &lt;&lt; <span class="number">10</span>;</span><br><span class="line">                    origin = k = r &amp; m;  <span class="comment">// 重新开始窃取任务</span></span><br><span class="line">                    oldSum = checkSum = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                checkSum += b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((k = (k + <span class="number">1</span>) &amp; m) == origin) &#123;    <span class="comment">// 当 k == origin 表明已经遍历了整个任务数组都没有发现任务</span></span><br><span class="line">                <span class="keyword">if</span> ((ss &gt;= <span class="number">0</span> || (ss == (ss = w.scanState))) &amp;&amp;  oldSum == (oldSum = checkSum)) &#123; <span class="comment">// 若队列已经处于空闲状态，则没必要在处理了，若队列处于运行中，在多次尝试窃取不到任务后说明没有任务，队列要进入空闲状态</span></span><br><span class="line">                    <span class="keyword">if</span> (ss &lt; <span class="number">0</span> || w.qlock &lt; <span class="number">0</span>) <span class="comment">// 在多次窃取不到任务后会从这里退出循环并返回null</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">int</span> ns = ss | INACTIVE;       <span class="comment">// 索引 + INACTIVE &lt; 0 </span></span><br><span class="line">                    <span class="keyword">long</span> nc = ((SP_MASK &amp; ns) | (UC_MASK &amp; ((c = ctl) - AC_UNIT))); <span class="comment">// 活跃的工作线程数减去1</span></span><br><span class="line">                    w.stackPred = (<span class="keyword">int</span>)c;         <span class="comment">// 关联当前的空闲队列（通过空闲队列可以找到空闲线程-parker），以便在后续可以唤醒最新的空闲线程</span></span><br><span class="line">                    U.putInt(w, QSCANSTATE, ns); <span class="comment">// 使队列处于空闲状态</span></span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc)) <span class="comment">// 更新ctl值，其中修改了活跃的工作线程数、空闲队列在队列数组中的索引及状态（1-32位)</span></span><br><span class="line">                        ss = ns;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        w.scanState = ss;</span><br><span class="line">                &#125;</span><br><span class="line">                checkSum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待任务-阻塞最新的空闲线程</span></span><br><span class="line"><span class="comment"> * 当阻塞一定时间后仍然没有任务的话，则会注销最新的空闲线程，并更新最新的空闲线程引用</span></span><br><span class="line"><span class="comment"> * 当阻塞一定时间后有任务了，则跳出循环去获取任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w 当前空闲队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> r 随机数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> false：关闭当前队列对应的线程 true：不能关闭</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">awaitWork</span><span class="params">(WorkQueue w, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w == <span class="keyword">null</span> || w.qlock &lt; <span class="number">0</span>) <span class="comment">// 队列处于终止状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pred = w.stackPred, spins = SPINS, ss;;) &#123; <span class="comment">// pred：上一个最新的空闲线程   spins = 自旋次数</span></span><br><span class="line">        <span class="keyword">if</span> ((ss = w.scanState) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123; <span class="comment">// 默认情况下SPINS = 0，若SPINS &gt; 0 则通过自旋的方式来阻塞空闲线程，而当空闲线程变成活跃后才会退出循环</span></span><br><span class="line">            r ^= r &lt;&lt; <span class="number">6</span>; r ^= r &gt;&gt;&gt; <span class="number">21</span>; r ^= r &lt;&lt; <span class="number">7</span>;</span><br><span class="line">            <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; --spins == <span class="number">0</span>) &#123;</span><br><span class="line">                WorkQueue v; WorkQueue[] ws; <span class="keyword">int</span> s, j; AtomicLong sc;</span><br><span class="line">                <span class="keyword">if</span> (pred != <span class="number">0</span> &amp;&amp; (ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (j = pred &amp; SMASK) &lt; ws.length &amp;&amp;</span><br><span class="line">                    (v = ws[j]) != <span class="keyword">null</span> &amp;&amp; (v.parker == <span class="keyword">null</span> || v.scanState &gt;= <span class="number">0</span>))</span><br><span class="line">                    spins = SPINS; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (w.qlock &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">long</span> c, prevctl, parkTime, deadline;</span><br><span class="line">            <span class="keyword">int</span> ac = (<span class="keyword">int</span>)((c = ctl) &gt;&gt; AC_SHIFT) + (config &amp; SMASK);  <span class="comment">// 活跃的工作线程数</span></span><br><span class="line">            <span class="keyword">if</span> ((ac &lt;= <span class="number">0</span> &amp;&amp; tryTerminate(<span class="keyword">false</span>, <span class="keyword">false</span>)) || (runState &amp; STOP) != <span class="number">0</span>) <span class="comment">// 当活跃的工作线程数不足时，判断线程池是否处于关闭状态或正在关闭（SHUTDOWN/STOP/TERMINAED），若是的话就没必要进行后续的阻塞了</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (ac &lt;= <span class="number">0</span> &amp;&amp; ss == (<span class="keyword">int</span>)c) &#123;        <span class="comment">// 当前空闲线程是否是最新的空闲线程，即表示刚使其空闲</span></span><br><span class="line">                prevctl = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; pred); <span class="comment">// 上一个最新的ctl</span></span><br><span class="line">                <span class="keyword">int</span> t = (<span class="keyword">short</span>)(c &gt;&gt;&gt; TC_SHIFT);  <span class="comment">// 计算所有的工作线程数</span></span><br><span class="line">                <span class="keyword">if</span> (t &gt; <span class="number">2</span> &amp;&amp; U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, prevctl)) <span class="comment">// 若工作线程数过多，加上此时还是空闲的线程，则应该关闭一些线程</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;                 <span class="comment">// else use timed wait</span></span><br><span class="line">                parkTime = IDLE_TIMEOUT * ((t &gt;= <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">1</span> - t); <span class="comment">// 计算当前空闲线程的阻塞时间</span></span><br><span class="line">                deadline = System.nanoTime() + parkTime - TIMEOUT_SLOP; <span class="comment">// 计算当前的阻塞时间</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                prevctl = parkTime = deadline = <span class="number">0L</span>;</span><br><span class="line">            Thread wt = Thread.currentThread();</span><br><span class="line">            U.putObject(wt, PARKBLOCKER, <span class="keyword">this</span>);</span><br><span class="line">            w.parker = wt;</span><br><span class="line">            <span class="keyword">if</span> (w.scanState &lt; <span class="number">0</span> &amp;&amp; ctl == c)</span><br><span class="line">                U.park(<span class="keyword">false</span>, parkTime); <span class="comment">// 发生阻塞</span></span><br><span class="line">            U.putOrderedObject(w, QPARKER, <span class="keyword">null</span>);</span><br><span class="line">            U.putObject(wt, PARKBLOCKER, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (w.scanState &gt;= <span class="number">0</span>) <span class="comment">// 阻塞一段时间后，若有任务会被唤醒，需要去处理任务了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (parkTime != <span class="number">0L</span> &amp;&amp; ctl == c &amp;&amp; deadline - System.nanoTime() &lt;= <span class="number">0L</span> &amp;&amp; U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, prevctl)) <span class="comment">// 阻塞一段时间后仍然没有任务，且当前空闲线程是最新的空闲线程，返回false减少线程</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阻塞等待指定任务完成或超时</span></span><br><span class="line"><span class="comment"> * 该方法由ForkJoinTask#join -&gt; ForkJoinTask#doJoin中调用</span></span><br><span class="line"><span class="comment"> * 提醒一下，对于ForkJoinTask#fork和ForkJoinTask#join同一个任务来说，可根据其任务的状态来判断任务是否完成</span></span><br><span class="line"><span class="comment"> * 当任务的状态小于0时表示处理完毕，当然可能是被取消了、抛出异常了、正常处理，所以在业务上最好还要在判断下，不用担心，ForkJoinTask提供了方法isCompletedAbnormally</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w 当前队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task 指定任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> deadline 阻塞等待时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 任务执行结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">awaitJoin</span><span class="params">(WorkQueue w, ForkJoinTask&lt;?&gt; task, <span class="keyword">long</span> deadline)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (task != <span class="keyword">null</span> &amp;&amp; w != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt; prevJoin = w.currentJoin;</span><br><span class="line">        U.putOrderedObject(w, QCURRENTJOIN, task);</span><br><span class="line">        CountedCompleter&lt;?&gt; cc = (task <span class="keyword">instanceof</span> CountedCompleter) ? (CountedCompleter&lt;?&gt;)task : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((s = task.status) &lt; <span class="number">0</span>) <span class="comment">// status &lt; 0 表示任务已处理完毕</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (cc != <span class="keyword">null</span>)</span><br><span class="line">                helpComplete(w, cc, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (w.base == w.top || w.tryRemoveAndExec(task)) <span class="comment">// 表示任务数组为空，说明指定任务被其他线程窃取了，当前线程只能干等着，于其如此还不如去窃取其他线程，帮帮忙，哈哈哈，等窃取的任务执行完毕了在回过头来看看</span></span><br><span class="line">                helpStealer(w, task); <span class="comment">// 窃取任务并执行</span></span><br><span class="line">            <span class="keyword">if</span> ((s = task.status) &lt; <span class="number">0</span>) <span class="comment">// 判断指定任务是否处理完毕</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">long</span> ms, ns;</span><br><span class="line">            <span class="keyword">if</span> (deadline == <span class="number">0L</span>)</span><br><span class="line">                ms = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((ns = deadline - System.nanoTime()) &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((ms = TimeUnit.NANOSECONDS.toMillis(ns)) &lt;= <span class="number">0L</span>)</span><br><span class="line">                ms = <span class="number">1L</span>;</span><br><span class="line">            <span class="keyword">if</span> (tryCompensate(w)) &#123; <span class="comment">// 为了保证阻塞等待的任务能够被线程及时处理，那么一定要有线程处于活跃中，若是补偿的话（叫补偿感觉有点变扭），要么是唤醒空闲线程要么是新增工作线程，而不补偿的话说明本身就存在工作线程</span></span><br><span class="line">                task.internalWait(ms); <span class="comment">// 内部使用了Object#wait使其处于阻塞等待，当任务完成后会超过指定时间后会被唤醒</span></span><br><span class="line">                U.getAndAddLong(<span class="keyword">this</span>, CTL, AC_UNIT); <span class="comment">// 既然补偿了，那么就要增加活跃的工作线程数了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        U.putOrderedObject(w, QCURRENTJOIN, prevJoin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否需要补偿工作线程，简单来说就是保证阻塞等待的任务能够被线程及时处理</span></span><br><span class="line"><span class="comment"> * 补偿可以通过唤醒空闲线程，也可以是创建新线程，而不需要补偿说明本身就存在有使用中的线程（奇数索引上队列处于运行中状态）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w 当前队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否需要补偿</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">tryCompensate</span><span class="params">(WorkQueue w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> canBlock;</span><br><span class="line">    WorkQueue[] ws; <span class="keyword">long</span> c; <span class="keyword">int</span> m, pc, sp;</span><br><span class="line">    <span class="keyword">if</span> (w == <span class="keyword">null</span> || w.qlock &lt; <span class="number">0</span> || (ws = workQueues) == <span class="keyword">null</span> || (m = ws.length - <span class="number">1</span>) &lt;= <span class="number">0</span> || (pc = config &amp; SMASK) == <span class="number">0</span>)</span><br><span class="line">        canBlock = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((sp = (<span class="keyword">int</span>)(c = ctl)) != <span class="number">0</span>)</span><br><span class="line">        canBlock = tryRelease(c, ws[sp &amp; m], <span class="number">0L</span>); <span class="comment">// 唤醒空闲线程去处理任务</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ac = (<span class="keyword">int</span>)(c &gt;&gt; AC_SHIFT) + pc;</span><br><span class="line">        <span class="keyword">int</span> tc = (<span class="keyword">short</span>)(c &gt;&gt; TC_SHIFT) + pc; <span class="comment">// pc：并行数，工作线程数  (short)(c &gt;&gt; TC_SHIFT)：线程池所有的工作线程数，不满足并行数情况下是个负数，满足的情况是正数，所以为了方便理解，可以将tc也看作是并行数，即 tc == pc</span></span><br><span class="line">        <span class="keyword">int</span> nbusy = <span class="number">0</span>;                        <span class="comment">// 计算队列处于忙碌状态的个数，偶数索引上队列的状态是INACTIVE，奇数索引上队列的状态不确定，所以在遍历过程中只要判断奇数索引上队列的状态即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            WorkQueue v;</span><br><span class="line">            <span class="keyword">if</span> ((v = ws[((i &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>) &amp; m]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((v.scanState &amp; SCANNING) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ++nbusy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * nbusy的最大值是队列数组的长度- 1，即ws.lenght - 1</span></span><br><span class="line"><span class="comment">         * tc &lt;&lt; 1的计算也是队列数组的长度 - 1，从externalSubmit方法初始化队列数组中得知并行数与队列数组的长度 - 1呈现 2 倍关系</span></span><br><span class="line"><span class="comment">         * 所以如果两者不相等的话说明nbusy没达到最大值，即存在至少一个奇数索引上队列处于运行中状态，表明有线程去处理任务，不用创建新线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (nbusy != (tc &lt;&lt; <span class="number">1</span>) || ctl != c)</span><br><span class="line">            canBlock = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// tc &gt; pc， 说明 (short)(c &gt;&gt; TC_SHIFT) &gt; 0 ，这不就造成所有的工作线程数大于并行数了吗? 那么势必会调用createWorker，也在源码中也只有tryCompensate方法会造成所有的工作线程数直接增加，而不经过是否大于并行数的判断</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tc &gt;= pc &amp;&amp; ac &gt; <span class="number">1</span> &amp;&amp; w.isEmpty()) &#123; <span class="comment">// 队列都为空了，没必要补偿活跃的工作线程了</span></span><br><span class="line">            <span class="keyword">long</span> nc = ((AC_MASK &amp; (c - AC_UNIT)) | (~AC_MASK &amp; c));       <span class="comment">// uncompensated</span></span><br><span class="line">            canBlock = U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tc &gt;= MAX_CAP || (<span class="keyword">this</span> == common &amp;&amp; tc &gt;= pc + commonMaxSpares)) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Thread limit exceeded replacing blocked worker"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;                                <span class="comment">// 走到这里说明没有空闲线程或所有线程都处于忙碌中，但是必须保证有线程去及时处理等待中的任务，所以要新增一个线程</span></span><br><span class="line">            <span class="keyword">boolean</span> add = <span class="keyword">false</span>; <span class="keyword">int</span> rs;</span><br><span class="line">            <span class="keyword">long</span> nc = ((AC_MASK &amp; c) | (TC_MASK &amp; (c + TC_UNIT))); <span class="comment">// 所有的工作线程数加1</span></span><br><span class="line">            <span class="keyword">if</span> (((rs = lockRunState()) &amp; STOP) == <span class="number">0</span>)</span><br><span class="line">                add = U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc);</span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">            canBlock = add &amp;&amp; createWorker(); <span class="comment">// 增加工作线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> canBlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在指定时间内使公共线程池处于静止下</span></span><br><span class="line"><span class="comment"> * 静止：所有的工作线程处于空闲或者说没有活跃的工作线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timout 指定时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 公共线程处处于静止  false：未在指定时间内使公共线程池处于静止下</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">awaitQuiescence</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    ForkJoinWorkerThread wt;</span><br><span class="line">    Thread thread = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> ((thread <span class="keyword">instanceof</span> ForkJoinWorkerThread) &amp;&amp;</span><br><span class="line">        (wt = (ForkJoinWorkerThread)thread).pool == <span class="keyword">this</span>) &#123;</span><br><span class="line">        helpQuiescePool(wt.workQueue); <span class="comment">// 该方法就不做解释了，有点绕，简单理解就是执行队列自身的任务，并窃取其他队列的任务</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">    WorkQueue[] ws;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, m;</span><br><span class="line">    <span class="keyword">boolean</span> found = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isQuiescent() &amp;&amp; (ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (m = ws.length - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((System.nanoTime() - startTime) &gt; nanos)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Thread.yield(); <span class="comment">// cannot block</span></span><br><span class="line">        &#125;</span><br><span class="line">        found = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = (m + <span class="number">1</span>) &lt;&lt; <span class="number">2</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            ForkJoinTask&lt;?&gt; t; WorkQueue q; <span class="keyword">int</span> b, k;</span><br><span class="line">            <span class="keyword">if</span> ((k = r++ &amp; m) &lt;= m &amp;&amp; k &gt;= <span class="number">0</span> &amp;&amp; (q = ws[k]) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (b = q.base) - q.top &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                found = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> ((t = q.pollAt(b)) != <span class="keyword">null</span>)</span><br><span class="line">                    t.doExec(); <span class="comment">// 帮助窃取任务并执行</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关闭线程池</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> noew 是否是无条件关闭线程池</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> enable 是否允许关闭线程池</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程池是否关闭成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">tryTerminate</span><span class="params">(<span class="keyword">boolean</span> now, <span class="keyword">boolean</span> enable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rs;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == common) <span class="comment">// 公共线程池不受状态的影响，只会随着程序的关闭而关闭</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> ((rs = runState) &gt;= <span class="number">0</span>) &#123; <span class="comment">// runState &gt; 0 说明线程池处于启动中</span></span><br><span class="line">        <span class="keyword">if</span> (!enable) <span class="comment">// enable表示是否允许关闭线程池</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        rs = lockRunState();                  <span class="comment">// 若是允许关闭线程的话，就将其状态 + SHUTDOWN，此时的状态 &lt; 0 </span></span><br><span class="line">        unlockRunState(rs, (rs &amp; ~RSLOCK) | SHUTDOWN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((rs &amp; STOP) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!now) &#123; <span class="comment">// now表示是否是无条件关闭线程池，是有条件关闭线程池的话说明是没有任务或无活跃的工作线程</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> oldSum = <span class="number">0L</span>;;) &#123;        <span class="comment">// repeat until stable</span></span><br><span class="line">                WorkQueue[] ws; WorkQueue w; <span class="keyword">int</span> m, b; <span class="keyword">long</span> c;</span><br><span class="line">                <span class="keyword">long</span> checkSum = ctl;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">int</span>)(checkSum &gt;&gt; AC_SHIFT) + (config &amp; SMASK) &gt; <span class="number">0</span>) <span class="comment">// &gt; 0 表示仍然有活跃的工作线程</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> ((ws = workQueues) == <span class="keyword">null</span> || (m = ws.length - <span class="number">1</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((w = ws[i]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((b = w.base) != w.top || w.scanState &gt;= <span class="number">0</span> || w.currentSteal != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            tryRelease(c = ctl, ws[m &amp; (<span class="keyword">int</span>)c], AC_UNIT);</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        checkSum += b;</span><br><span class="line">                        <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">0</span>) <span class="comment">// 为偶数索引上的队列做标记</span></span><br><span class="line">                            w.qlock = -<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (oldSum == (oldSum = checkSum))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((runState &amp; STOP) == <span class="number">0</span>) &#123;</span><br><span class="line">            rs = lockRunState();              <span class="comment">// 状态 + SHUTDOWN + STOP</span></span><br><span class="line">            unlockRunState(rs, (rs &amp; ~RSLOCK) | STOP);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pass = <span class="number">0</span>;                             <span class="comment">// 使用3个步骤来帮助关闭线程池</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> oldSum = <span class="number">0L</span>;;) &#123;</span><br><span class="line">        WorkQueue[] ws; WorkQueue w; ForkJoinWorkerThread wt; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">long</span> checkSum = ctl;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">short</span>)(checkSum &gt;&gt;&gt; TC_SHIFT) + (config &amp; SMASK) &lt;= <span class="number">0</span> || (ws = workQueues) == <span class="keyword">null</span> || (m = ws.length - <span class="number">1</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((runState &amp; TERMINATED) == <span class="number">0</span>) &#123;</span><br><span class="line">                rs = lockRunState();          <span class="comment">// done</span></span><br><span class="line">                unlockRunState(rs, (rs &amp; ~RSLOCK) | TERMINATED); <span class="comment">// 状态 + SHUTDOWN + STOP + TERMINATED</span></span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; notifyAll(); &#125; <span class="comment">// for awaitTermination</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((w = ws[i]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                checkSum += w.base;</span><br><span class="line">                w.qlock = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (pass &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    w.cancelAll();            <span class="comment">// 清空队列的任务</span></span><br><span class="line">                    <span class="keyword">if</span> (pass &gt; <span class="number">1</span> &amp;&amp; (wt = w.owner) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!wt.isInterrupted()) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;             </span><br><span class="line">                                wt.interrupt(); <span class="comment">// 中断awaitJoin中发生的阻塞等待</span></span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (w.scanState &lt; <span class="number">0</span>)</span><br><span class="line">                            U.unpark(wt);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (checkSum != oldSum) &#123;</span><br><span class="line">            oldSum = checkSum;</span><br><span class="line">            pass = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pass &gt; <span class="number">3</span> &amp;&amp; pass &gt; m) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++pass &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> c; <span class="keyword">int</span> j = <span class="number">0</span>, sp;</span><br><span class="line">            <span class="keyword">while</span> (j++ &lt;= m &amp;&amp; (sp = (<span class="keyword">int</span>)(c = ctl)) != <span class="number">0</span>) <span class="comment">// 因为空闲线程会造成程序的阻塞，所以在线程池要关闭的情况下将其唤醒，释放线程</span></span><br><span class="line">                tryRelease(c, ws[sp &amp; m], AC_UNIT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程池的使用权，即使线程池处于锁定状态</span></span><br><span class="line"><span class="comment"> * 若线程池处于已经处于锁定状态，那么当前线程将通过自旋 + 阻塞的方式一直获取</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程池的状态（锁定状态 + 已有的状态 STARTED/STOP/TERMINATED/SHUTDOWN）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lockRunState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rs;</span><br><span class="line">    <span class="keyword">return</span> ((((rs = runState) &amp; RSLOCK) != <span class="number">0</span> || !U.compareAndSwapInt(<span class="keyword">this</span>, RUNSTATE, rs, rs |= RSLOCK)) ? awaitRunStateLock() : rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程池的使用权，通过自旋 + 阻塞的方式直到获取到</span></span><br><span class="line"><span class="comment"> * 该方法只会在线程池处于锁定状态（RSLOCK）或CAS失败的情况下调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程池处于锁定的状态值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitRunStateLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object lock;</span><br><span class="line">    <span class="keyword">boolean</span> wasInterrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> spins = SPINS, r = <span class="number">0</span>, rs, ns;;) &#123; <span class="comment">// 通过自旋 + 阻塞的方式等待线程池的使用权，即获取线程池的锁定状态</span></span><br><span class="line">        <span class="keyword">if</span> (((rs = runState) &amp; RSLOCK) == <span class="number">0</span>) &#123; <span class="comment">// 表示线程池未锁定，那么当前线程可以获取到线程池的使用权了</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, RUNSTATE, rs, ns = rs | RSLOCK)) &#123; <span class="comment">// 既然当前线程可以拥有线程池的使用权了，防止其他线程介入应当更改其状态为RSLOCK</span></span><br><span class="line">                <span class="keyword">if</span> (wasInterrupted) &#123; <span class="comment">// 此判断用于在当前线程发生阻塞时而被中断，即后续的lock.wait代码片段，发生中断会抛出异常并清除中断状态，所以这里的代码只是恢复中断状态</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ns;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">0</span>)</span><br><span class="line">            r = ThreadLocalRandom.nextSecondarySeed(); <span class="comment">//每次自旋后都重新获取随机数，目的就是为了下面的计算实现随机化</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 默认情况下SPINS为0，减少CPU的使用，也就是说当有多个线程同时在抢占线程池的使用权时，未抢到的线程应该不在执行任何逻辑操作，相当于等待，至于为什么要抢占线程池的使用权是因为这些线程会同时更新线程池的队列数组</span></span><br><span class="line"><span class="comment">         * 有一点比较好奇，并未提供对SPINS属性的修改方法，所以这里的判断语句压根就不会被执行...</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123; </span><br><span class="line">            r ^= r &lt;&lt; <span class="number">6</span>; r ^= r &gt;&gt;&gt; <span class="number">21</span>; r ^= r &lt;&lt; <span class="number">7</span>; <span class="comment">// 此算法不知道做了什么操作，通过阅读注释可知是在做随机化</span></span><br><span class="line">            <span class="keyword">if</span> (r &gt;= <span class="number">0</span>)</span><br><span class="line">                --spins;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((rs &amp; STARTED) == <span class="number">0</span> || (lock = stealCounter) == <span class="keyword">null</span>) </span><br><span class="line">            Thread.yield();   <span class="comment">// 不考虑线程池已关闭/已终止/已停止的状态下，说明线程池处于锁定状态（RSLOCK）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, RUNSTATE, rs, rs | RSIGNAL)) &#123; </span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">// 不考虑线程池已关闭/已终止/已停止的状态下，说明线程池处于已开启状态（STARTED），以及标识其他线程正在等待中</span></span><br><span class="line">                <span class="keyword">if</span> ((runState &amp; RSIGNAL) != <span class="number">0</span>) &#123; <span class="comment">// 再次判断线程池的状态，此时只会有一个线程进入到该代码片段中，而对于其他线程来说，经过短暂的获取锁时有可能线程池的状态已经发生改变</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!(Thread.currentThread() <span class="keyword">instanceof</span> ForkJoinWorkerThread))</span><br><span class="line">                            wasInterrupted = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    lock.notifyAll(); <span class="comment">// 走到这里说明线程池的状态已经发生变更，有可能已经解除锁定状态，故而提醒其他线程去抢占线程池的使用权</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取公共线程池实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 公共线程池实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ForkJoinPool <span class="title">commonPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert common != null : "static init error";</span></span><br><span class="line">    <span class="keyword">return</span> common;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行任务并获取结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task 指定任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 任务的执行结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invoke</span><span class="params">(ForkJoinTask&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    externalPush(task);</span><br><span class="line">    <span class="keyword">return</span> task.join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提交任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task 指定任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    externalPush(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提交任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task 指定任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    ForkJoinTask&lt;?&gt; job;</span><br><span class="line">    <span class="keyword">if</span> (task <span class="keyword">instanceof</span> ForkJoinTask&lt;?&gt;) <span class="comment">// avoid re-wrap</span></span><br><span class="line">        job = (ForkJoinTask&lt;?&gt;) task;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        job = <span class="keyword">new</span> ForkJoinTask.RunnableExecuteAction(task);</span><br><span class="line">    externalPush(job);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提交任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task 指定任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ForkJoinTask&lt;T&gt; <span class="title">submit</span><span class="params">(ForkJoinTask&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    externalPush(task);</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提交任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task 指定任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> result 任务的执行结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ForkJoinTask&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;T&gt; job = <span class="keyword">new</span> ForkJoinTask.AdaptedRunnable&lt;T&gt;(task, result);</span><br><span class="line">    externalPush(job);</span><br><span class="line">    <span class="keyword">return</span> job;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提交任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task 指定任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ForkJoinTask&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    ForkJoinTask&lt;?&gt; job;</span><br><span class="line">    <span class="keyword">if</span> (task <span class="keyword">instanceof</span> ForkJoinTask&lt;?&gt;) <span class="comment">// avoid re-wrap</span></span><br><span class="line">        job = (ForkJoinTask&lt;?&gt;) task;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        job = <span class="keyword">new</span> ForkJoinTask.AdaptedRunnableAction(task);</span><br><span class="line">    externalPush(job);</span><br><span class="line">    <span class="keyword">return</span> job;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新线程池的状态，实际上是将状态从 RSLOCK -&gt; newRunState</span></span><br><span class="line"><span class="comment"> * 能够调用该方法的前提是获得了线程池的使用权，即让线程池处于RSLOCK状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> oldRunState 线程池的当前状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newRunState 线程池的新状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlockRunState</span><span class="params">(<span class="keyword">int</span> oldRunState, <span class="keyword">int</span> newRunState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通常情况下该判断语句的结果是false，说明线程池的状态未发生改变，所以进入到代码片段中手动将其更改（注意此时还未唤醒其他线程），并在最后将其他线程唤醒，因为此时线程池已经处于新的状态下</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!U.compareAndSwapInt(<span class="keyword">this</span>, RUNSTATE, oldRunState, newRunState)) &#123;</span><br><span class="line">        Object lock = stealCounter;</span><br><span class="line">        runState = newRunState; <span class="comment">// 将其标识位RSIGNAL删除，并在后续唤醒其他所有线程</span></span><br><span class="line">        <span class="keyword">if</span> (lock != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123; </span><br><span class="line">                lock.notifyAll(); <span class="comment">// 唤醒其他所有线程</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有条件关闭线程池</span></span><br><span class="line"><span class="comment"> * 有条件：没有活跃的工作线程或任务都执行完毕</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkPermission();</span><br><span class="line">    tryTerminate(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无条件关闭线程池，尝试取消所有任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkPermission();</span><br><span class="line">    tryTerminate(<span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池是否已终止</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (runState &amp; TERMINATED) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池是否已关闭</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTerminating</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rs = runState;</span><br><span class="line">    <span class="keyword">return</span> (rs &amp; STOP) != <span class="number">0</span> &amp;&amp; (rs &amp; TERMINATED) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列的默认容量大小，必须是2的幂次方</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_QUEUE_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列的最大容量大小，必须是2的幂次方，至于为什么是2的幂次方是为了简化基于索引的操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_QUEUE_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列的运行状态</span></span><br><span class="line"><span class="comment">     * &lt; 0：表示队列处于空闲状态</span></span><br><span class="line"><span class="comment">     * 奇数：表示队列处于运行中</span></span><br><span class="line"><span class="comment">     * 偶数：表示队列处于忙碌中，正在执行任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> scanState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关联上一个最新的空闲线程，虽然其值是ctl，但会通过 &amp; 与SP_MASK计算获取上一个空闲线程，包括其版本计数、处于空闲状态、索引值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> stackPred;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 窃取到任务的数量，源码中未看到何种情况下会为负数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> nsteals;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> hint;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 | 计算来保存队列的索引与模式信息，低16位表示索引，高16位表示模式</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 0000 0000 0000 0001 0000 0000 0000 0001</span></span><br><span class="line"><span class="comment">     * |      高16位      ||       低16位     |</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 索引：在上面中我们提到有内部队列与共享队列，这两种队列分别存放在奇数与偶数索引位置上</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 模式：该名词解释同上面的含义一致</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> config;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列的使用状态，不用过多纠结与scanState的区别，只要明白每个值的意思即可</span></span><br><span class="line"><span class="comment">     * 1：队列处于锁定状态，其表明当多个任务同时提交到同一个队列时，只允许其中一个任务进行提交</span></span><br><span class="line"><span class="comment">     * -1：队列处于终止，当工作线程启动失败或终止时，其对应的队列遭到废弃</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> qlock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上面说到队列属于双端队列，该队列会被自身线程去处理，同时也会被其他线程窃取，那么为了减少多线程之间的资源竞争，故而规定这两种方式分别从两边开始获取任务</span></span><br><span class="line"><span class="comment">     * 对于其他线程窃取来说，通常调用poll方法，当任务被窃取后索引自然会变更</span></span><br><span class="line"><span class="comment">     * 所以该属性是记录下一个被窃取的任务的索引，默认情况下对于窃取来说，按照先进先出的顺序开始获取任务，即对于任务数组来说，该索引是呈现递增的趋势，即 base, base + 1, base + 2 ...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> base;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对于自身线程去处理任务时，通常调用push/pop方法，所以该属性是记录下一个要存储的任务的索引，若要获取最后存储的任务则应该是 top - 1</span></span><br><span class="line"><span class="comment">     * 默认情况下对于自身任务来说，按照先进后出的顺序开始获取任务，即对于任务数组来说，该索引呈现递减的趋势，即top - 1 , top -2 ...</span></span><br><span class="line"><span class="comment">     * 当且仅当 base == top 时表示任务数组中的所有任务全部处理完毕 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储队列中的任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ForkJoinTask&lt;?&gt;[] array;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> ForkJoinPool pool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列对应的工作线程，针对共享队列时该值为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> ForkJoinWorkerThread owner;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用指向当前工作线程，用于空闲队列的阻塞与唤醒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread parker;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用join方法的任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> ForkJoinTask&lt;?&gt; currentJoin;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 窃取到的任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> ForkJoinTask&lt;?&gt; currentSteal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WorkQueue(ForkJoinPool pool, ForkJoinWorkerThread owner) &#123;</span><br><span class="line">        <span class="keyword">this</span>.pool = pool;</span><br><span class="line">        <span class="keyword">this</span>.owner = owner;</span><br><span class="line">        base = top = INITIAL_QUEUE_CAPACITY &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">//初始化时将两个索引置为数组的中心</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取队列的索引</span></span><br><span class="line"><span class="comment">     * 原本config &amp; 0xffff就是其索引的值，但不太明白为什么还要除以2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 队列的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPoolIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (config &amp; <span class="number">0xffff</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取任务的个数，其结果只是个大约值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 任务的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">queueSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = base - top;</span><br><span class="line">        <span class="keyword">return</span> (n &gt;= <span class="number">0</span>) ? <span class="number">0</span> : -n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断任务数组是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt;[] a; <span class="keyword">int</span> n, m, s;</span><br><span class="line">        <span class="keyword">return</span> ((n = base - (s = top)) &gt;= <span class="number">0</span> || (n == -<span class="number">1</span> &amp;&amp; ((a = array) == <span class="keyword">null</span> || (m = a.length - <span class="number">1</span>) &lt; <span class="number">0</span> || U.getObject(a, (<span class="keyword">long</span>)((m &amp; (s - <span class="number">1</span>)) &lt;&lt; ASHIFT) + ABASE) == <span class="keyword">null</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加任务</span></span><br><span class="line"><span class="comment">     * 该方法通常由ForkJoinTask#fork中调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task 任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt;[] a; ForkJoinPool p;</span><br><span class="line">        <span class="keyword">int</span> b = base, s = top, n;</span><br><span class="line">        <span class="keyword">if</span> ((a = array) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = a.length - <span class="number">1</span>;</span><br><span class="line">            U.putOrderedObject(a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, task);</span><br><span class="line">            U.putOrderedInt(<span class="keyword">this</span>, QTOP, s + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> ((n = s - b) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((p = pool) != <span class="keyword">null</span>)</span><br><span class="line">                    p.signalWork(p.workQueues, <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= m) <span class="comment">// 想不明白什么情况下 n &gt;= m，就算发生了扩容，但其base、top的值还是原来的</span></span><br><span class="line">                growArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行窃取到的任务及自身队列的所有任务</span></span><br><span class="line"><span class="comment">     * 在执行自身队列的所有任务时，默认以LIFO的顺序开始获取任务并执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task 窃取到的任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runTask</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task != <span class="keyword">null</span>) &#123;</span><br><span class="line">            scanState &amp;= ~SCANNING;  <span class="comment">// 使队列处于忙碌中，偶数数值，因为 ~SCANNING是个偶数，故而 &amp; 后的结果仍然是偶数</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 执行窃取到的任务   doExec -&gt; exec -&gt; compute 执行业务方法</span></span><br><span class="line"><span class="comment">             * 若在业务方法中执行了ForkJoinTask#fork方法，接着调用WorkQueue#push，最终该任务落到了该队列上，也就是说窃取到的任务会落到窃取的队列上，这点和执行自身任务有所区别！！！</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            (currentSteal = task).doExec(); </span><br><span class="line">            U.putOrderedObject(<span class="keyword">this</span>, QCURRENTSTEAL, <span class="keyword">null</span>); <span class="comment">// currentSteal = null</span></span><br><span class="line">            execLocalTasks(); <span class="comment">// 自身线程执行队列中任务</span></span><br><span class="line">            ForkJoinWorkerThread thread = owner; <span class="comment">// 获取自身线程</span></span><br><span class="line">            <span class="keyword">if</span> (++nsteals &lt; <span class="number">0</span>) </span><br><span class="line">                transferStealCount(pool);</span><br><span class="line">            scanState |= SCANNING; <span class="comment">// 执行完自身队列的任务后，该去窃取其他线程的任务，所以更换成运行中状态</span></span><br><span class="line">            <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">                thread.afterTopLevelExec();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自身线程执行队列中的任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">execLocalTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = base, m, s;</span><br><span class="line">        ForkJoinTask&lt;?&gt;[] a = array;</span><br><span class="line">        <span class="keyword">if</span> (b - (s = top - <span class="number">1</span>) &lt;= <span class="number">0</span> &amp;&amp; a != <span class="keyword">null</span> &amp;&amp; (m = a.length - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123; <span class="comment">// 判断自身队列中是否还有任务，上面提到队列中的任务一个会被自身线程执行，一个会被其他线程窃取执行</span></span><br><span class="line">            <span class="keyword">if</span> ((config &amp; FIFO_QUEUE) == <span class="number">0</span>) &#123; <span class="comment">// 自身队列要以哪一个顺序开始获取任务并执行，若 config &amp; FIFO_QUEUE == 0 成立的话，说明以先进后出的顺序（LIFO），则从top处开始获取任务，否则执行 pollAndExecAll</span></span><br><span class="line">                <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t;;) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((t = (ForkJoinTask&lt;?&gt;)U.getAndSetObject(a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, <span class="keyword">null</span>)) == <span class="keyword">null</span>) <span class="comment">// 从top呈现递减的趋势开始获取任务，若获取到的任务为null表明没有任务了</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    U.putOrderedInt(<span class="keyword">this</span>, QTOP, s); <span class="comment">// 更新top的值</span></span><br><span class="line">                    t.doExec(); <span class="comment">// 执行任务，doExec -&gt; exec -&gt; compute 执行业务方法，若在业务方法中执行了ForkJoinTask#fork方法，接着调用WorkQueue#push，最终该任务落到了同一个队列上，可参看push方法</span></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 对于双端队列来说，base 呈现递增的趋势，即 base, base + 1, base + 2 ，而 top呈现递减的趋势，即 top, top -1, top-2，</span></span><br><span class="line"><span class="comment">                     * 所以当base &gt; top -1 时说明队列中的所有任务都执行完毕了，而当 base == top-1 时表明窃取线程与自身线程都落到了最后同一个任务上，但由于采用的是CAS，原子化特性保证最终只会有一个线程能获取到</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (base - (s = top - <span class="number">1</span>) &gt; <span class="number">0</span>) </span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pollAndExecAll(); <span class="comment">// 自身线程以FIFO(先进先出)顺序开始获取队列中的任务并执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自身线程以FIFO(先进先出)顺序开始获取队列中的任务并执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">pollAndExecAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t; (t = poll()) != <span class="keyword">null</span>;)</span><br><span class="line">            t.doExec();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自身线程以FIFO(先进先出)顺序开始获取队列中的任务</span></span><br><span class="line"><span class="comment">     * 注意：上面我们提到窃取线程也会从base处开始获取任务，而此方法也会从base，这无疑就加重了多线程之间的冲突，即在任务很多的情况下要频繁判断base的值是否发生了变化，所以在没必要的情况最好还是使用默认的LIFO顺序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 获取的任务或null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> ForkJoinTask&lt;?&gt; poll() &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt;[] a; <span class="keyword">int</span> b; ForkJoinTask&lt;?&gt; t;</span><br><span class="line">        <span class="keyword">while</span> ((b = base) - top &lt; <span class="number">0</span> &amp;&amp; (a = array) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = (((a.length - <span class="number">1</span>) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">            t = (ForkJoinTask&lt;?&gt;)U.getObjectVolatile(a, j);</span><br><span class="line">            <span class="keyword">if</span> (base == b) &#123; <span class="comment">// 判断base是否发生了改变，若改变的话就要重新在判断</span></span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapObject(a, j, t, <span class="keyword">null</span>)) &#123; <span class="comment">// 再次判断是否能够获取到任务</span></span><br><span class="line">                        base = b + <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">return</span> t;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (b + <span class="number">1</span> == top) <span class="comment">// 当base == top - 1表明执行到了最后一个任务，但到底被窃取了还是自身执行了呢? 因为 t = null，表明自身队列未能获取到最后一个任务</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化任务数组或对其2倍大小的扩容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 任务数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> ForkJoinTask&lt;?&gt;[] growArray() &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt;[] oldA = array;</span><br><span class="line">        <span class="keyword">int</span> size = oldA != <span class="keyword">null</span> ? oldA.length &lt;&lt; <span class="number">1</span> : INITIAL_QUEUE_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; MAXIMUM_QUEUE_CAPACITY)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Queue capacity exceeded"</span>);</span><br><span class="line">        <span class="keyword">int</span> oldMask, t, b;</span><br><span class="line">        ForkJoinTask&lt;?&gt;[] a = array = <span class="keyword">new</span> ForkJoinTask&lt;?&gt;[size];</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 下面的代码片段表示任务数组要进行扩容</span></span><br><span class="line"><span class="comment">         * 扩容无非就是将旧数组中未执行的任务移动到新数组中</span></span><br><span class="line"><span class="comment">         * 而base、top的值并未发生改变</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (oldA != <span class="keyword">null</span> &amp;&amp; (oldMask = oldA.length - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp; (t = top) - (b = base) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mask = size - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                ForkJoinTask&lt;?&gt; x;</span><br><span class="line">                <span class="keyword">int</span> oldj = ((b &amp; oldMask) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                <span class="keyword">int</span> j    = ((b &amp;    mask) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                x = (ForkJoinTask&lt;?&gt;)U.getObjectVolatile(oldA, oldj);</span><br><span class="line">                <span class="keyword">if</span> (x != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    U.compareAndSwapObject(oldA, oldj, x, <span class="keyword">null</span>))</span><br><span class="line">                    U.putObjectVolatile(a, j, x);</span><br><span class="line">            &#125; <span class="keyword">while</span> (++b != t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自身线程以LIFO(先进后出)顺序开始获取队列中的任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 任务或null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> ForkJoinTask&lt;?&gt; pop() &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt;[] a; ForkJoinTask&lt;?&gt; t; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">if</span> ((a = array) != <span class="keyword">null</span> &amp;&amp; (m = a.length - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s; (s = top - <span class="number">1</span>) - base &gt;= <span class="number">0</span>;) &#123; <span class="comment">// top -1 &gt;= base 说明至少有一个任务</span></span><br><span class="line">                <span class="keyword">long</span> j = ((m &amp; s) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                <span class="keyword">if</span> ((t = (ForkJoinTask&lt;?&gt;)U.getObject(a, j)) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapObject(a, j, t, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    U.putOrderedInt(<span class="keyword">this</span>, QTOP, s);</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取base索引上的任务</span></span><br><span class="line"><span class="comment">     * 其实我感觉都没必要传入参数b了，直接拿base上的任务不就可以了吗..</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b 要求其值要等于base</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 任务或null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> ForkJoinTask&lt;?&gt; pollAt(<span class="keyword">int</span> b) &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt; t; ForkJoinTask&lt;?&gt;[] a;</span><br><span class="line">        <span class="keyword">if</span> ((a = array) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = (((a.length - <span class="number">1</span>) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">            <span class="keyword">if</span> ((t = (ForkJoinTask&lt;?&gt;)U.getObjectVolatile(a, j)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                base == b &amp;&amp; U.compareAndSwapObject(a, j, t, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                base = b + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按照指定模式获取自身队列的下一个任务</span></span><br><span class="line"><span class="comment">     * FIFO（先进先出）：poll</span></span><br><span class="line"><span class="comment">     * LIFO（先进后出）：pop</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 任务或null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> ForkJoinTask&lt;?&gt; nextLocalTask() &#123;</span><br><span class="line">        <span class="keyword">return</span> (config &amp; FIFO_QUEUE) == <span class="number">0</span> ? pop() : poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按照指定模式获取自身队列的下一个任务</span></span><br><span class="line"><span class="comment">     * FIFO（先进先出）：base</span></span><br><span class="line"><span class="comment">     * LIFO（先进后出）：top - 1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 任务或null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> ForkJoinTask&lt;?&gt; peek() &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt;[] a = array; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || (m = a.length - <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> i = (config &amp; FIFO_QUEUE) == <span class="number">0</span> ? top - <span class="number">1</span> : base;</span><br><span class="line">        <span class="keyword">int</span> j = ((i &amp; m) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">        <span class="keyword">return</span> (ForkJoinTask&lt;?&gt;)U.getObjectVolatile(a, j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * top - 1索引上的任务是否移除成功（最后一个任务），要求入参t必须与top - 1上的任务的引用相同</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t 指定任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryUnpush</span><span class="params">(ForkJoinTask&lt;?&gt; t)</span> </span>&#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt;[] a; <span class="keyword">int</span> s;</span><br><span class="line">        <span class="keyword">if</span> ((a = array) != <span class="keyword">null</span> &amp;&amp; (s = top) != base &amp;&amp;</span><br><span class="line">            U.compareAndSwapObject</span><br><span class="line">            (a, (((a.length - <span class="number">1</span>) &amp; --s) &lt;&lt; ASHIFT) + ABASE, t, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            U.putOrderedInt(<span class="keyword">this</span>, QTOP, s);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消任务数组中的所有任务，此取消只是改变了任务的状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">cancelAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt; t;</span><br><span class="line">        <span class="keyword">if</span> ((t = currentJoin) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            currentJoin = <span class="keyword">null</span>;</span><br><span class="line">            ForkJoinTask.cancelIgnoringExceptions(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((t = currentSteal) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            currentSteal = <span class="keyword">null</span>;</span><br><span class="line">            ForkJoinTask.cancelIgnoringExceptions(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ((t = poll()) != <span class="keyword">null</span>)</span><br><span class="line">            ForkJoinTask.cancelIgnoringExceptions(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新线程池中已窃取的任务数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p 线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transferStealCount</span><span class="params">(ForkJoinPool p)</span> </span>&#123;</span><br><span class="line">        AtomicLong sc;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (sc = p.stealCounter) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = nsteals;</span><br><span class="line">            nsteals = <span class="number">0</span>;</span><br><span class="line">            sc.getAndAdd((<span class="keyword">long</span>)(s &lt; <span class="number">0</span> ? Integer.MAX_VALUE : s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行指定任务并移除或移除已取消的任务</span></span><br><span class="line"><span class="comment">     * 该方法会在join时被调用，而在调用join时自身线程没有处理自身队列的任务（因为在执行join方法可能会发生阻塞等待），所以该队列里的任务只能被其他线程窃取</span></span><br><span class="line"><span class="comment">     * 移除的任务只允许是处于base或top-1上的任务，否则就会造成任务数组断断续续的出现null</span></span><br><span class="line"><span class="comment">     * 当方法返回true时说明任务数组为空，表明任务被其他线程窃取了，那么这个时候该线程只能干等着，于其如此还不如帮忙去窃取其他线程的任务，哈哈哈，然后窃取一个任务执行完成后就去看看任务完成了没有</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task 指定任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true：任务数组为空   false：队列中存在任务或指定任务处理完毕</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRemoveAndExec</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt;[] a; <span class="keyword">int</span> m, s, b, n;</span><br><span class="line">        <span class="keyword">if</span> ((a = array) != <span class="keyword">null</span> &amp;&amp; (m = a.length - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp;  task != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> ((n = (s = top) - (b = base)) &gt; <span class="number">0</span>) &#123; <span class="comment">// top - base &gt; 0 说明有任务存在</span></span><br><span class="line">                <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t;;) &#123;      <span class="comment">// 遍历任务数组，从(top -1) 到 base，执行指定任务并移除或移除已取消的任务，能移除的任务只允许是处于base或top-1上的任务，否则就会造成任务数组断断续续的出现null</span></span><br><span class="line">                    <span class="keyword">long</span> j = ((--s &amp; m) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                    <span class="keyword">if</span> ((t = (ForkJoinTask&lt;?&gt;)U.getObject(a, j)) == <span class="keyword">null</span>) <span class="comment">// 判断此时位置的任务是否为空，因为有可能早已被其他线程窃取了</span></span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * 随着多次遍历s一直在发生改变，而当某个位置的任务为空时，其 s + 1 并不等于 top，这就说明了存在着任务</span></span><br><span class="line"><span class="comment">                         * 要出现true的情况是任务数组是空的</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="keyword">return</span> s + <span class="number">1</span> == top;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (t == task) &#123; <span class="comment">// 尝试去执行任务并从任务数组中移除，而能移除的任务只允许是处于base或top-1上的任务，否则就会造成任务数组断断续续的出现null</span></span><br><span class="line">                        <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">if</span> (s + <span class="number">1</span> == top) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (U.compareAndSwapObject(a, j, task, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                                U.putOrderedInt(<span class="keyword">this</span>, QTOP, s);</span><br><span class="line">                                removed = <span class="keyword">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (base == b) <span class="comment">// 虽然这里将base位置上的任务更换成EmptyTask，但实际上什么都没做，个人觉得如此做不用再去修改base的值，不用让窃取线程在调用scan方法时重新遍历一次</span></span><br><span class="line">                            removed = U.compareAndSwapObject(a, j, task, <span class="keyword">new</span> EmptyTask());</span><br><span class="line">                        <span class="keyword">if</span> (removed)</span><br><span class="line">                            task.doExec(); <span class="comment">// 尝试执行任务，其方法会判断任务的状态</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (t.status &lt; <span class="number">0</span> &amp;&amp; s + <span class="number">1</span> == top) &#123; <span class="comment">// 能走到这里说明任务还未被处理，由于status &lt; 0 有可能是正常处理（不能被取消）、未处理被取消了、处理中抛出异常这些情况，所以这里说明top -1 处的任务被取消了</span></span><br><span class="line">                        <span class="keyword">if</span> (U.compareAndSwapObject(a, j, t, <span class="keyword">null</span>))</span><br><span class="line">                            U.putOrderedInt(<span class="keyword">this</span>, QTOP, s);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (--n == <span class="number">0</span>) <span class="comment">// 队列数组中没有与之匹配的任务，比如直接调用join而没有调用fork，不过最好不要这样子做...</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (task.status &lt; <span class="number">0</span>) <span class="comment">// status &lt; 0 表示任务处理结束，有可能是正常处理，也有可能是被取消了</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h4><p>ForkJoinPool的代码又多又繁琐，看了第一遍之后再也不想看第二遍了，所以准备总结下提交任务的一个运行流程，如下图所示：</p><p class="customize-img"><img src="/assets/blogImg/java/forkjoin/forkjoin-run-process.png" alt="ForkJoin运行流程图"></p><p>如若运行流程图不理解，可参看后面的使用示例或许能帮助其理解。</p><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p>为什么要写使用示例呢？因为笔者在工作中其实也没有遇到过使用ForkJoinPool的场景，此篇文章光是把源码看懂了一遍，实际上到头来还是很多人不知道怎么使用ForkJoinPool，当然了我也是如此，所以这里贴出了使用实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPoolTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        ForkJoinPool forkJoinPool = ForkJoinPool.commonPool();</span><br><span class="line">        CountTaskForkJoinTest countTaskForkJoinTest = <span class="keyword">new</span> CountTaskForkJoinTest(<span class="number">0</span>, <span class="number">100</span>); <span class="comment">// 大任务</span></span><br><span class="line">        forkJoinPool.submit(countTaskForkJoinTest); <span class="comment">// 提交任务</span></span><br><span class="line"></span><br><span class="line">        Long result = countTaskForkJoinTest.get(); <span class="comment">// 获取结果</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RecursiveTask是ForkJoinTask的一个子类，其中还有RecursiveAction子类</span></span><br><span class="line"><span class="comment"> * RecursiveTask在执行任务后提供了返回值</span></span><br><span class="line"><span class="comment"> * RecursiveAction只负责执行</span></span><br><span class="line"><span class="comment"> * 区分以上两个类的使用场景就很容易写了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountTaskForkJoinTest</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> threshold = <span class="number">100</span>;<span class="comment">//临界值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountTaskForkJoinTest</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 重写compute方法，判断是否将任务进行拆分计算</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断是否是拆分完毕</span></span><br><span class="line">        <span class="keyword">boolean</span> canCompute = (end - start) &lt;= threshold;</span><br><span class="line">        <span class="keyword">if</span> (canCompute) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将任务拆分成子任务</span></span><br><span class="line">            <span class="keyword">long</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            CountTaskForkJoinTest task1 = <span class="keyword">new</span> CountTaskForkJoinTest(start, middle);</span><br><span class="line">            CountTaskForkJoinTest task2 = <span class="keyword">new</span> CountTaskForkJoinTest(middle, end);</span><br><span class="line"></span><br><span class="line">            task1.fork();</span><br><span class="line">            task2.fork();</span><br><span class="line"></span><br><span class="line">            sum = task1.join() + task2.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>ForkJoinPool适合任务执行时间小且任务数量多的场景，其核心思想是每个线程对应一个队列，当线程将自身队列的任务处理完毕后尝试去窃取其他队列的任务，而只有把窃取的任务执行完成了之后才能继续去窃取下一个，虽然代码内部中分为共享队列与内部队列，实际上共享队列只是单纯地存储任务并没有分配线程去处理，所以它的任务都是被一个一个地窃取，通过外部提交的任务会被放入到共享队列中，由于自身线程会去执行任务，其他线程也会窃取该队列的任务，为了降低线程之间的竞争，采用了双端队列，基于两个索引进行操作。源码中涉及到较多的计算，也较难理解，笔者断断续续差不多花费了2-3个月时间才算告一段落，事后觉得计算部分只要能明白意思即可，不用做太多的深入，感觉意义也不是很大，其核心概念理解就差不多了。顺便在提一点，源码提到了公共线程池，为了方便开发者的使用，可以在不理解ForkJoinPool的基础上直接使用公共线程池，其最大的特性就是不会随着shutdown/shutdownNow方法的调用而关闭，只会等到程序结束了才关闭，对于同一个程序来说，始终只有一个公共线程池！</p><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>工作窃取</code> <code>双端队列</code> <code>使用示例</code> <code>公共线程池</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;概念&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;ForkJoin框架将一个大问题分解成若干个&lt;code&gt;相互独立且容易解决&lt;/code&gt;的小问题，为了让这些小问题能够并行执行，同时减少线程间对资源的竞争，将这些小问题分别放入到&lt;code&gt;不同的队列&lt;/code&gt;中，并为每个队列&lt;code&gt;创建一个线程&lt;/code&gt;来执行队列中的小问题，这个过程就叫做Fork，中文称作&lt;code&gt;分支&lt;/code&gt;，当所有的小问题都解决完之后，需要将每个结果进行汇总合并最终得出大问题的结果，这个过程叫做Join，中文称作&lt;code&gt;合并&lt;/code&gt;，这就好比生活中建设大厦一般，值得注意的是在执行过程应用了一种叫做工作窃取的算法，如此思想在算法界中称作&lt;code&gt;分治&lt;/code&gt;，分而治之。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;工作窃取&lt;/code&gt;：一个线程对应一个队列，每个队列中有多个小任务，当其中一个线程执行完队列中的任务时，为了充分利用线程资源，该线程将从任意一个队列中窃取任务来执行，而该队列对应的线程也会从该队列中获取任务，所以为了减少自身队列对应的线程与窃取线程之间不必要的竞争，通常使用&lt;code&gt;双端队列&lt;/code&gt;，约定自身线程从队列的尾部开始获取（LIFO），窃取线程从队列的头部开始获取（FIFO），当然了，有一种情况下还是避免不了竞争，队列中只有一个任务时，这个时候就需要加锁或CAS进行控制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ForkJoinPool与ExecutorService的主要区别便是工作窃取，其应用场景也不同，分而治之的思想无疑减少了程序的运行时间，提供了效率，但同时占用了更多的资源，以下提供图片帮助理解：&lt;/p&gt;
&lt;p class=&quot;customize-img&quot;&gt;&lt;img src=&quot;/assets/blogImg/java/forkjoin/forkjoin-mode.png&quot; alt=&quot;ForkJoin原理图&quot;&gt;&lt;/p&gt;
&lt;p&gt;目前对ForkJoin框架有一定程度上的理解了，之前写的文章都是通过先阅读注释开始，但是ForkJoinPool类的注释实际上并无很重要的关键信息，有兴趣的读者可以尝试去阅读Doug Lea关于ForkJoin框架的理论或者ForkJoinPool内部的注释，接下来进入到源码环节。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>2020年疫情下的思考</title>
    <link href="http://zlia.tech/2020/02/10/thinking-under-epidemic/"/>
    <id>http://zlia.tech/2020/02/10/thinking-under-epidemic/</id>
    <published>2020-02-10T12:42:14.000Z</published>
    <updated>2020-02-10T12:42:14.364Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>还在2019年时我就已经做好了未来2020年的整体个人规划，满打满算，可惜还是不敌突如其来的暴风雨-新冠状肺炎。笔者不是要来预测疫情要持续到何时，也不是要谈论什么八卦，更不是为了申诉各种不满的遭遇，于我而言，我是非常坚信我们能够战胜此次疫情，希望能够早日听到胜利的喜悦！我看过几篇关于疫情下公司的财务状况而导致员工如何的文章，这与笔者要讲的有那么一点关联，但更多的是引起读者<code>自身的思考</code>。</p><a id="more"></a><h3 id="从公司的角度出发"><a href="#从公司的角度出发" class="headerlink" title="从公司的角度出发"></a><div><span>从公司的角度出发</span></div></h3><p>尝试着先从公司的角度作为出发点，为什么是尝试，而不是直接说呢？因为我也是一名员工，上班也才3年不到，更别谈什么开公司之类的，所以只能是尽可能地说一些自己认为的观点，考虑不周到的地方请忽略！前一段时间要求2月3号才开始正式上班，其实私底下很多企业早在1月31号就已经上班了，虽然我没办法举例，但我相信一定有，很多创业公司和小公司，为了能够尽量地活下来，否则他们何必死撑呢，如果公司破产了，那将会是一批接一批的员工解散或被开除，没有了收入来源，而在这非常时期下新工作显得也不是那么容易，当然了，如果你可以保证自己不会被开除，那说明你很强，可你手底下的员工就不一定了，他们走了，谁替你做事，临时找人也不是那么容易。所以出现了这样的一种现象：有员工打电话举报公司不按规定提前上班，导致公司被迫暂停，而这也最终影响了公司应对此局面的措施，只能是裁员了…所以这样子做的意义何在，对于大公司或许能够撑住一两个月，前提是你在大公司或你身居何职。当然了，提前上班是可以，但是必须要和员工说明情况，实实在在的道出情况，而不是画饼，鼓励员工我们一定可以战胜病毒，只要大家保持好卫生，戴好口罩，这些还用公司来说吗？我指的是应该跟员工道出公司的难处，显的更真诚，员工也更愿意去接受，能留的留，没办法的那就只能再续前缘了，最让人讨厌的是公司明明很大，年前也盈利了不少，还要提前上班，称为自愿上班，给员工说一些鼓舞的话，要笑死人了。以上的思考是片面的，不认可的当作是笑话即可。</p><h3 id="从个人的角度出发"><a href="#从个人的角度出发" class="headerlink" title="从个人的角度出发"></a><div><span>从个人的角度出发</span></div></h3><p>疫情下每个企业可能多少都会有一些影响，今天我就迎来了领导的谈话，直白地说出了当下公司的现金流，以及一些应对措施，收入多少都会有些影响，口头承诺后续会弥补。听完这个电话后，我的第一个反应是糟了我忘记录音了，光顾着问问题了却忘记留下证据，口头承诺最好是能有一个证据，冷静下来思考后，只能等离职时在跟公司提及了，这算是我第一次面对这种场景，我并不紧张，采取的措施几乎是无，所以建议以后在面对此场景时最好要录音，谁也说不准以后会发生什么时，不是说是针对谁，这以后可能也关乎到自身的利益，所以最好是录音。当然了， 这不是最重要的点，坐着椅子上我冷静了下来，突然意识到此时此刻的应急资金是多么的重要，及其重要，假设原本你每个月的收入完全能够应付每个月的支出，比如房贷、车贷、信用卡，当你的收入遭遇滑坡时，这些就会出现问题，此时要是没有应急资金的话，我想你动用的可能不止是一个人的口袋了，所以它真的很重要，虽然你平时觉得某件事很重要，但当你真正遇到时它会让你更加深刻，就像我一样，所以我写了这篇文章以此来告诉未来的自己要注重这件事，在有经济的基础上一定要规划好，由这件事引发的是理财，也是非常建议的！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><div><span>总结</span></div></h3><p>此次疫情可能还会持续一段时间，面对公司的措施，我们应该提前做好规划，而不是等着危险来临时却只能袖手旁观、默默无闻，那人生也一定将会是失败的！所以我打算好好想想接下来该如何应对，庆幸的是，平时的我一直在努力学习知识，所以我并不害怕面对被裁之后的场景，我可以等到疫情后在出来找工作，只是学习不能落下，只有坚持学习你才能理解三年与五年的差异性在哪里，好了好了，我要去学习了，好长一段时间没发文了，在家里也没能静下心来学习！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;还在2019年时我就已经做好了未来2020年的整体个人规划，满打满算，可惜还是不敌突如其来的暴风雨-新冠状肺炎。笔者不是要来预测疫情要持续到何时，也不是要谈论什么八卦，更不是为了申诉各种不满的遭遇，于我而言，我是非常坚信我们能够战胜此次疫情，希望能够早日听到胜利的喜悦！我看过几篇关于疫情下公司的财务状况而导致员工如何的文章，这与笔者要讲的有那么一点关联，但更多的是引起读者&lt;code&gt;自身的思考&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="essays" scheme="http://zlia.tech/categories/essays/"/>
    
    
      <category term="talk" scheme="http://zlia.tech/tags/talk/"/>
    
  </entry>
  
  <entry>
    <title>分析Executor家族成员</title>
    <link href="http://zlia.tech/2020/01/13/explain-executor-sourcecode/"/>
    <id>http://zlia.tech/2020/01/13/explain-executor-sourcecode/</id>
    <published>2020-01-13T15:32:50.000Z</published>
    <updated>2020-03-09T03:16:56.884Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前奏"><a href="#前奏" class="headerlink" title="前奏"></a><div><span>前奏</span></div></h3><p><code>Executor</code>是家族中的老大，其下还有ExecutorService、Executors、ThreadPoolExecutor、ScheduledThreadPoolExecutor和ForkJoinPool，对于ForkJoinPool是在JDK1.7中新增的，其中可能还涉及到诸多理论，故而打算会另起文章进行说明。不管是在工作还是面试中，难免会耳闻线程池，简单说下个人对线程池的理解，后续将对Executor的家族成员做一一介绍，让我们开始旅程吧，此次探索基于<code>JDK1.8</code>。</p><blockquote><p><code>线程池</code>：将创建好的线程放到一个池中进行使用、调度及管理，等到任务一提交后就可以直接运行了，省去了创建线程的时间，同时使用者不必考虑如何管理线程，让使用者更加专注于任务。线程池中会涉及到核心线程数（corePoolSize）、最大线程数（maximumPoolSize）、队列，假设线程个数小于核心线程数，对于新提交的任务会直接创建新线程，当线程个数超过核心线程数且队列未满时，将新任务放入到队列中，等到空闲线程后再去执行，万一要是队列满了且线程数不超过最大线程数时，则会创建新线程执行任务，哪天要是大于最大线程数，则任务将被拒绝，对于拒绝可指定不同的策略，后续将会详细介绍。</p></blockquote><h3 id="家族成员"><a href="#家族成员" class="headerlink" title="家族成员"></a><div><span>家族成员</span></div></h3><p class="customize-img"><img src="/assets/blogImg/java/executor/executor-class-structure.png" alt="Executor家族成员"></p><p>每个成员的地位很明确了，我们从Executors开始入手。</p><a id="more"></a><h4 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h4><p><code>Executors</code>是其家族成员的工厂类，是个便利的工具，使用常用的配置调用方法来创建ExecutorService、ScheduledExecutorService、ThreadFactory对象，工作中经常使用此方式来完成作业。</p><h5 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无法构造该对象实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executors</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无法构造该对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Executors</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建具有固定线程数的线程池</span></span><br><span class="line"><span class="comment">     * 该线程池采用的队列是无界队列，无界队列很容易理解，没有边界、没有上限、无限制添加，在我们熟悉的数据结构当中，内部采用的应该是链条式结构</span></span><br><span class="line"><span class="comment">     * 线程个数小于核心线程数时，对于新提交的任务直接创建新线程执行，当线程个数超过核心线程数时，对于新提交的任务就被放入到队列当中了</span></span><br><span class="line"><span class="comment">     * 恰好是个无界队列，也就是说万一要是没有空闲的线程的话，那此队列中的任务数量将会无限增大，或者说当任务的提交速速远大于任务的处理速度时，队列中的任务数量也会无限增大</span></span><br><span class="line"><span class="comment">     * 这也最终导致了线程池中最多只会有核心线程数的线程，最大线程数没啥用了，线程池中的线程在创建后即使空闲下来了也不会被关闭，除非主动调用shutdown方法</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 使用场景：</span></span><br><span class="line"><span class="comment">     * 由于任务有可能出现队列中进行等待，故而执行中的任务与等待中的任务不能有依赖关系，该种方式能够消除短暂的大量任务提交</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nThreads 核心线程数/最大线程数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 线程池对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">////////// ForkJoinPool将会新起文章进行讲解 /////////</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建具有固定线程数的线程池，线程由使用者自定义创建</span></span><br><span class="line"><span class="comment">     * 默认情况下，由Executors＃defaultThreadFactory来帮助使用者创建线程，所有的线程都位于同一个线程组中，并且拥有相同的优先级和非守护线程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 使用场景：</span></span><br><span class="line"><span class="comment">     * 1. 由于任务有可能出现队列中进行等待，故而执行中的任务与等待中的任务不能有依赖关系，该种方式能够消除短暂的大量任务提交</span></span><br><span class="line"><span class="comment">     * 2. 通过指定线程的工厂类来自定义线程的创建过程，可自定义每个线程的具有不同的优先级、线程组、线程的名称</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nThreads 核心线程数/最大线程数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threadFactory 线程的工厂类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 线程池对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建具有单个线程的线程池，也就是池中只有一个线程</span></span><br><span class="line"><span class="comment">     * 该线程池采用的无界队列，很可惜，对于多任务来说，只能有一个任务在执行，其他的任务都需要等待，这也保证了任务按顺序执行</span></span><br><span class="line"><span class="comment">     * 线程池中的线程在创建后即使空闲下来了也不会被关闭，除非主动调用shutdown方法</span></span><br><span class="line"><span class="comment">     * newSingleThreadExecutor与newFixedThreadPool(1)的区别：对于newFixedThreadPool方法来说，它是可以调用指定方法来重新配置线程的个数，而对于newSingleThreadExecutor来说，它的实现类并未拥有这种类型的方法，所以说它是不可配置* 的，也就是真正意义上的single</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 使用场景：</span></span><br><span class="line"><span class="comment">     * 1. 由于任务有可能出现队列中进行等待，故而执行中的任务与等待中的任务不能有依赖关系，该种方式能够消除短暂的大量任务提交</span></span><br><span class="line"><span class="comment">     * 2. 可用于执行优先级较低的任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 线程池对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建具有单个线程的线程池，线程由使用者自定义创建</span></span><br><span class="line"><span class="comment">     * 默认情况下，由Executors＃defaultThreadFactory来帮助使用者创建线程，所有的线程都位于同一个线程组中，并且拥有相同的优先级和非守护线程</span></span><br><span class="line"><span class="comment">     * 线程池中的线程在创建后即使空闲下来了也不会被关闭，除非主动调用shutdown方法</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 使用场景：</span></span><br><span class="line"><span class="comment">     * 1. 由于任务有可能出现队列中进行等待，故而执行中的任务与等待中的任务不能有依赖关系，该种方式能够消除短暂的大量任务提交</span></span><br><span class="line"><span class="comment">     * 2. 可用于执行优先级较低的任务</span></span><br><span class="line"><span class="comment">     * 3. 通过指定线程的工厂类来自定义线程的创建过程，可自定义每个线程的具有不同的优先级、线程组、线程的名称</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threadFactory 线程的工厂类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建无限制线程个数的线程池</span></span><br><span class="line"><span class="comment">     * 该线程池采用的是直接交接，简单理解就是提交的任务被直接交给线程，如果没有空闲的线程来运行任务的话，那么就创建一个新线程来执行它</span></span><br><span class="line"><span class="comment">     * 由于最大线程数是无限制，所以当任务的提交速速远大于任务的处理速速时，将会造成线程的无限增长</span></span><br><span class="line"><span class="comment">     * 当任务被处理完后，当前的线程就处于空闲状态，当空闲时间超过60s后该线程将被回收，若中途有其他任务则重复使用该线程，因此即使线程池长时间不使用的话也不会造成资源的浪费，因为线程都被回收了</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 使用场景:</span></span><br><span class="line"><span class="comment">     * 1. 由于没有等待队列，所以可以用来处理任务之间具有依赖关系的情况</span></span><br><span class="line"><span class="comment">     * 2. 处理大量小型异步任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 线程池对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建无限制线程个数的线程池，线程由使用者自定义创建</span></span><br><span class="line"><span class="comment">     * 默认情况下，由Executors＃defaultThreadFactory来帮助使用者创建线程，所有的线程都位于同一个线程组中，并且拥有相同的优先级和非守护线程</span></span><br><span class="line"><span class="comment">     * 线程池中的线程空闲超过60s后将被回收</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 使用场景：</span></span><br><span class="line"><span class="comment">     * 1. 由于没有等待队列，所以可以用来处理任务之间具有依赖关系的情况</span></span><br><span class="line"><span class="comment">     * 2. 处理大量小型任务</span></span><br><span class="line"><span class="comment">     * 3. 通过指定线程的工厂类来自定义线程的创建过程，可自定义每个线程的具有不同的优先级、线程组、线程的名称</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threadFactory 线程的工厂类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 线程池对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建具有单个定时线程的线程池</span></span><br><span class="line"><span class="comment">     * 定时线程：在指定的延迟后或周期性运行</span></span><br><span class="line"><span class="comment">     * 该线程池采用的延迟队列，内部采用数组来存储任务，采用Condition进行延迟操作，对于多任务来说，只能有一个任务在执行，其他的任务都需要等待，这也保证了任务按顺序执行</span></span><br><span class="line"><span class="comment">     * 线程池中的线程在创建后即使空闲下来了也不会被关闭，除非主动调用shutdown方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 使用场景：</span></span><br><span class="line"><span class="comment">     * 1. 延迟或周期性的优先级较低的任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 线程池对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建具有单个定时线程的线程池</span></span><br><span class="line"><span class="comment">     * 定时线程：在指定的延迟后或周期性运行</span></span><br><span class="line"><span class="comment">     * 默认情况下，由Executors＃defaultThreadFactory来帮助使用者创建线程，所有的线程都位于同一个线程组中，并且拥有相同的优先级和非守护线程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 使用场景：</span></span><br><span class="line"><span class="comment">     * 1. 延迟或周期性的优先级较低的任务</span></span><br><span class="line"><span class="comment">     * 2. 通过指定线程的工厂类来自定义线程的创建过程，可自定义每个线程的具有不同的优先级、线程组、线程的名称</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threadFactory 线程的工厂类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 线程池对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>, threadFactory));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建具有固定定时线程数的线程池</span></span><br><span class="line"><span class="comment">     * 定时线程：在指定的延迟后或周期性运行</span></span><br><span class="line"><span class="comment">     * 若corePoolSize &gt; 1, 对于多任务来说，可以有多个任务同时执行，不会按照顺序执行</span></span><br><span class="line"><span class="comment">     * 线程池中的线程在创建后即使空闲下来了也不会被关闭，除非主动调用shutdown方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 使用场景：</span></span><br><span class="line"><span class="comment">     * 1. 延迟或周期性的多任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> corePoolSize 核心线程数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 线程池对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建具有固定定时线程数的线程池</span></span><br><span class="line"><span class="comment">     * 定时线程：在指定的延迟后或周期性运行</span></span><br><span class="line"><span class="comment">     * 若corePoolSize &gt; 1, 对于多任务来说，可以有多个任务同时执行，不会按照顺序执行</span></span><br><span class="line"><span class="comment">     * 默认情况下，由Executors＃defaultThreadFactory来帮助使用者创建线程，所有的线程都位于同一个线程组中，并且拥有相同的优先级和非守护线程</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 使用场景：</span></span><br><span class="line"><span class="comment">     * 1. 延迟或周期性的多任务</span></span><br><span class="line"><span class="comment">     * 2. 通过指定线程的工厂类来自定义线程的创建过程，可自定义每个线程的具有不同的优先级、线程组、线程的名称</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> corePoolSize 核心线程数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threadFactory 线程的工厂类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 线程池对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义线程池，窄化了线程池中的方法，也就是说线程池中的一些方法是不可调用的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> executor 自定义线程池</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 窄化后的线程池对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">unconfigurableExecutorService</span><span class="params">(ExecutorService executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (executor == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DelegatedExecutorService(executor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义线程池（定时线程），窄化了线程池中的方法，也就是说线程池中的一些方法是不可调用的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> executor 自定义线程池</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 窄化后的线程池对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">unconfigurableScheduledExecutorService</span><span class="params">(ScheduledExecutorService executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (executor == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的线程工厂类，用于创建线程</span></span><br><span class="line"><span class="comment">     * 创建的线程将属于同一个线程组，拥有同样的优先级5和非守护线程，线程的名称：pool-poolNumberSequence-thread-threadNumberSequence</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 默认的线程工厂类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadFactory <span class="title">defaultThreadFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultThreadFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的线程工厂类，区别在于具备了与当前调用线程相同的权限，并且为每个线程设置了类加载器与访问控制上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 默认的线程工厂类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadFactory <span class="title">privilegedThreadFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PrivilegedThreadFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回Callable对象</span></span><br><span class="line"><span class="comment">     * RunnableAdapter#call只是单纯的调用run方法，并未启动线程</span></span><br><span class="line"><span class="comment">     * Callable与Runnable相比，可以有返回值</span></span><br><span class="line"><span class="comment">     * 不过即使run方法中抛出异常，该方法也捕捉不到，毕竟run方法无法抛出</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task 任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result 结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Callable对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回Callable对象</span></span><br><span class="line"><span class="comment">     * RunnableAdapter#call只是单纯的调用run方法，并未启动线程</span></span><br><span class="line"><span class="comment">     * Callable与Runnable相比，可以有返回值</span></span><br><span class="line"><span class="comment">     * 不过即使run方法中抛出异常，该方法也捕捉不到，毕竟run方法无法抛出</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task 任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Callable对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Object&gt; <span class="title">callable</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;Object&gt;(task, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回Callable对象</span></span><br><span class="line"><span class="comment">     * Callable与Runnable相比，可以有返回值</span></span><br><span class="line"><span class="comment">     * PrivilegedAction#run方法也是无法抛出异常，故该方法也是捕捉不到异常信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> action 任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Callable对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Object&gt; <span class="title">callable</span><span class="params">(<span class="keyword">final</span> PrivilegedAction&lt;?&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Callable&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> </span>&#123; </span><br><span class="line">                <span class="keyword">return</span> action.run(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回Callable对象</span></span><br><span class="line"><span class="comment">     * Callable与Runnable相比，可以有返回值</span></span><br><span class="line"><span class="comment">     * PrivilegedExceptionAction#run方法可以抛出异常，故而该方法可以捕捉异常信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> action 任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Callable对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Object&gt; <span class="title">callable</span><span class="params">(<span class="keyword">final</span> PrivilegedExceptionAction&lt;?&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Callable&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">                <span class="keyword">return</span> action.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回Callable对象，在特权环境下执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callable Callable对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Callable对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">privilegedCallable</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PrivilegedCallable&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回Callable对象，在特权环境下执行，拥有当前线程的访问控制权限与类加载器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callable Callable对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Callable对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">privilegedCallableUsingCurrentClassLoader</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PrivilegedCallableUsingCurrentClassLoader&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义Callable对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//任务</span></span><br><span class="line">        <span class="keyword">final</span> Runnable task;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用结果</span></span><br><span class="line">        <span class="keyword">final</span> T result;</span><br><span class="line">        RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">            <span class="keyword">this</span>.result = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            task.run(); <span class="comment">//只是单纯的调用run方法，并未开始线程</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///////其他类似的Callable对象就不做展示了///////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的线程工厂类，用于创建新线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自定义序列号，相同的数字表示同一个线程池对象</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程组</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自定义序列号，数字表示创建了多少个线程</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">        DefaultThreadFactory() &#123;</span><br><span class="line">            SecurityManager s = System.getSecurityManager();</span><br><span class="line">            group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();</span><br><span class="line">            namePrefix = <span class="string">"pool-"</span> + poolNumber.getAndIncrement() + <span class="string">"-thread-"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(group, r, namePrefix + threadNumber.getAndIncrement(), <span class="number">0</span>); <span class="comment">//创建的线程都属于同一个线程组，线程的名称根据线程的个数来区别</span></span><br><span class="line">            <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">                t.setDaemon(<span class="keyword">false</span>); <span class="comment">//创建的线程都属于非守护线程</span></span><br><span class="line">            <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">                t.setPriority(Thread.NORM_PRIORITY); <span class="comment">//创建的线程的优先级都是5</span></span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">////////其他ExecutorService也不做展示了////////</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li><p>newFixedThreadPool：创建具体<code>固定线程数</code>的线程池，内部采用<code>无界队列</code>。当线程个数小于核心线程数时，对于新提交的任务直接创建线程执行，当线程个数大于核心线程数时，对于新提交的任务就被放入到队列中。由于是个无界队列，也就是说当没有空闲的线程时，随着任务的不断提交队列将无限增大，或者说当任务的提交速度远大于任务的处理速度时，队列也会无限增大。正如方法名一样，线程池中的线程个数最多只有核心线程数，最大线程数没有起到作用，线程池中的线程即使空闲了也<code>不会被关闭</code>，除非主动调用shutdown方法。该方法还可以指定自定义线程工厂类，由使用者自己去决定如何创建线程，以及线程的名称、优先级、县线程组等。</p></li><li><p>newSingleThreadExecutor：创建具有<code>单个线程</code>的线程池，也就是说池中只有一个线程供使用，内部同样采用<code>无界队列</code>。由于只有一个线程处于活跃状态，只能有一个任务在执行，其余的任务只能在队列中等待着，这保证了它可以按<code>顺序</code>执行任务。线程池中的线程即使空闲了也<code>不会被关闭</code>，除非主动调用shutdown方法，该方法同样可以指定自定义线程工厂类。该方法与newFixedThreadPool(1)（简称nft）的区别在于，nft可以调用指定方法来重新配置核心线程数的值，而对于该方法而言，它的实现类并未拥有这种功能的方法，所有它是不可配置的，真正意义上的single。</p></li><li><p>newCachedThreadPool：创建<code>无限制线程个数</code>的线程池，内部采用<code>直接交接</code>的形式，很容易理解，来一个新任务我直接用取一个线程取执行，不管是复用还是新创建的线程，反正是不用等。由于线程个数是无限制的，也就是说当没有可以复用的空闲线程时，随着任务的不断提交线程池中的线程将无限增长。线程池中的线程一旦空闲下来的时间超过指定的保活时间（默认60s）将被<code>回收</code>，若中途有提交新任务则<code>复用</code>线程，因此线程池中的线程即使长时间不使用也不会造成资源的浪费，都被回收了。该方法同样可以指定自定义线程工厂类。</p></li><li><p>newSingleThreadScheduledExecutor：创建具有<code>单个定时线程</code>的线程池，所谓的定时线程是指延迟或周期性执行，内部采用<code>延迟队列</code>，该队列内部使用数组来存储任务，使用Condition进行延迟操作。由于只有一个线程处于活跃状态，只能有一个任务在执行，其余的任务只能在队列中等待着，这保证了它可以按<code>顺序</code>执行任务。线程池中的线程即使空闲了也<code>不会被关闭</code>，除非主动调用shutdown方法。该方法同样可以指定自定义线程工厂类。</p></li><li><p>newScheduledThreadPool：创建具有<code>固定定时线程数</code>的线程池，同样采用<code>延迟队列</code>。若核心线程数大于1，对于多任务来说可以同时运行多个。线程池中的线程即使空闲了也<code>不会被关闭</code>，除非主动调用shutdown方法。该方法同样可以指定自定义线程工厂类。</p></li><li><p>每个方法的使用场景可看具体方法。</p></li></ul><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p><code>ThreadPoolExecutor</code>是家族中的核心成员，担负了家族中的重要工作，简单来说底层就是使用该类对线程进行创建与管理，以及执行任务，内部维护了线程池的各种状态。</p><ul><li><p>运行中（RUNNING）：接收新任务并处理队列中的任务</p></li><li><p>关闭（SHUTDOWN）：不接收新任务，而是处理队列中的任务</p></li><li><p>停止（STOP）：不接受新任务，不处理队列中的任务及中断进行中的任务</p></li><li><p>终止中（TIDYING）：所有任务都已终止，工作线程为0</p></li><li><p>已终止（TERMINATED）：terminated方法执行完成</p></li></ul><p class="customize-img"><img src="/assets/blogImg/java/executor/thread-pool-state.png" alt="线程池状态图"></p><p>以上每个状态的中文解释可能不太准确，更多的是想帮助大家去理解，若觉得不适应或者晦涩难懂可以忽略，接着介绍下线程池的<code>拒绝任务策略</code>。</p><ul><li><p>ThreadPoolExecutor.AbortPolicy：当线程池拒绝任务时，采用直接抛出RejectedExecutionException异常</p></li><li><p>ThreadPoolExecutor.CallerRunsPolicy：当线程池拒绝任务时，采用只要线程池未关闭，由调用execute的线程运行任务，这提供了一种反馈机制，而若线程池已关闭，则任务将被丢弃</p></li><li><p>ThreadPoolExecutor.DiscardPolicy：当线程池拒绝任务时，采用直接丢弃了任务，相当于直接不执行任务了，很干脆</p></li><li><p>ThreaPollExecutor.DiscardOldestPolicy：当线程池拒绝任务时，采用只要线程池未关闭，则将丢弃队列中头部位置的任务（最早入队列的任务），然后重复执行指定任务（调用execute方法，有可能再次被拒绝导致又重复执行）</p></li></ul><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ctl包装了工作线程的数量（workerCount）与线程池的状态（runState），也就是说通过该变量既可以获取到工作线程的数量，也可以获取到线程池的状态，有点厉害啊！</span></span><br><span class="line"><span class="comment">     * 其中将工作线程的数量限制到 2^29 -1，简单来说，一个32位的int类型来说，后29位表示工作线程的数量，剩余3位表示线程池的状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过移位区分工作线程的数量与线程池的状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示工作线程的数量的最大值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * TERMINATED &gt; TIDYING &gt; STOP &gt; SHUTDOWN &gt; RUNNING</span></span><br><span class="line"><span class="comment">     * 由于工作线程取的是后29位，所以我们可以知道：TIDYING &gt; STOP + CAPACITY（这两者就差1）</span></span><br><span class="line"><span class="comment">     * 所以我们更能得出：TERMINATED &gt; TIDYING + CAPACITY &gt; TIDYING &gt; STOP + CAPACITY &gt; STOP &gt; SHUTDOWN + CAPACITY &gt; SHUTDOWN &gt; RUNNING + CAPACITY &gt; RUNNING</span></span><br><span class="line"><span class="comment">     * 而我们知道ctl代表着工作线程 + 线程池的状态，故而简化为：TERMINATED &gt; ctl（TIDYING） &gt; TIDYING &gt; ctl(STOP) &gt; STOP &gt; ctl(SHUTDOWN) &gt; SHUTDOWN &gt; ctl(RUNNING) &gt; RUNNING</span></span><br><span class="line"><span class="comment">     * 所以我们要想知道线程池处于哪个状态区间，则可以直接比较ctl与状态值，比如ctl &gt; STOP，则说明线程池处于TERMINATED或TIDYING</span></span><br><span class="line"><span class="comment">     * 这样子ctl就不用为了获取状态值而进行拆解，为什么要分析这东西呢，因为后面有方法涉及到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池处于运行中状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池处于关闭状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池处于停止状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池处于终止中状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池处于已终止状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储任务，工作线程从队列中获取任务并处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 目前只需要知道是锁就可以了，至于什么类型的锁以后会新起文章进行详细介绍</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储线程池中的所有工作线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 条件等待，与Lock组合使用，用于代替Synchronized与对象锁，以后也会新起文章进行讲解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition termination = mainLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池的最大线程数，简单来说就是线程池中有多少个线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 已完成任务的数量，该变量只会在工作线程结束后进行更新</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程的工厂类，用于创建线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拒绝任务的策略，当线程池达到最大线程数或关闭/停止状态时就会拒绝任务的提交</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当线程池中的线程个数大于核心线程数时，其空闲线程的存活时间，超过该时间后将被回收，若线程个数小于核心线程数则不会在回收空闲线程</span></span><br><span class="line"><span class="comment">     * 或者设置了allowCoreThreadTimeOut = true，表示所有线程的空闲时间超过指定时间后将被回收</span></span><br><span class="line"><span class="comment">     * 执行任务中的线程不算空闲线程，等待任务的线程是空闲线程，简单来说，空闲线程就是没事做</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 若未设置存活时间，即默认是0，表示永远不会回收线程，即使线程个数超过了核心线程数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认情况下是false，表示核心线程即使空闲了也不会被回收</span></span><br><span class="line"><span class="comment">     * 若为true，表示所有线程的空闲时间超过keepAliveTime后将被回收</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 核心线程数</span></span><br><span class="line"><span class="comment">     * allowCoreThreadTimeOut = false，最终可以保留核心线程数的工作线程</span></span><br><span class="line"><span class="comment">     * allowCoreThreadTimeOut = true，最终工作线程将为0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大线程数</span></span><br><span class="line"><span class="comment">     * 该数值受CAPACITY限制，也就是说最大是CAPACITY</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拒绝任务的默认策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler defaultHandler = <span class="keyword">new</span> AbortPolicy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化，采用默认拒绝任务的策略、默认的线程工厂类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize 核心线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maximumPoolSize 最大线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keepAliveTime 保活时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> workQueue 队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化，采用默认拒绝任务的策略、自定义线程工厂类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize 核心线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maximumPoolSize 最大线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keepAliveTime 保活时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> workQueue 队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory 线程的工厂类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化，采用默认的线程工厂类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize 核心线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maximumPoolSize 最大线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keepAliveTime 保活时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> workQueue 队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler 拒绝任务的策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize 核心线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maximumPoolSize 最大线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keepAliveTime 保活时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> workQueue 队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory 线程的工厂类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler 拒绝任务的策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> || maximumPoolSize &lt;= <span class="number">0</span> || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ? <span class="keyword">null</span> : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime); <span class="comment">//将时间转换成纳秒</span></span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="简单方法-1"><a href="#简单方法-1" class="headerlink" title="简单方法"></a>简单方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br><span class="line">1319</span><br><span class="line">1320</span><br><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br><span class="line">1345</span><br><span class="line">1346</span><br><span class="line">1347</span><br><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br><span class="line">1366</span><br><span class="line">1367</span><br><span class="line">1368</span><br><span class="line">1369</span><br><span class="line">1370</span><br><span class="line">1371</span><br><span class="line">1372</span><br><span class="line">1373</span><br><span class="line">1374</span><br><span class="line">1375</span><br><span class="line">1376</span><br><span class="line">1377</span><br><span class="line">1378</span><br><span class="line">1379</span><br><span class="line">1380</span><br><span class="line">1381</span><br><span class="line">1382</span><br><span class="line">1383</span><br><span class="line">1384</span><br><span class="line">1385</span><br><span class="line">1386</span><br><span class="line">1387</span><br><span class="line">1388</span><br><span class="line">1389</span><br><span class="line">1390</span><br><span class="line">1391</span><br><span class="line">1392</span><br><span class="line">1393</span><br><span class="line">1394</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过ctl原子变量获取线程池的状态</span></span><br><span class="line"><span class="comment"> * ~CAPACITY：对于取反运算符，只要先获取到CAPACITY的补码后对其进行取反（0变成1，1变成0）即可获取到结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ctl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> c &amp; ~CAPACITY; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过ctl原子变量获取工作线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c ctl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> c &amp; CAPACITY; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新ctl原子变量的值，即当线程池的状态或工作线程的数量发生变化时就会调用该方法</span></span><br><span class="line"><span class="comment"> * 在更新完ctl的值后就可以调用runStateOf方法获取线程池的状态，或调用workerCountOf方法获取工作线程的数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rs 线程池的状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> wc 工作线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> rs | wc; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工作线程，包装了提交的任务与线程</span></span><br><span class="line"><span class="comment"> * 执行路径：thread -&gt; worker -&gt; task</span></span><br><span class="line"><span class="comment"> * 该类实现了AQS，虽然对AQS还不了解，但并不影响我们看源码</span></span><br><span class="line"><span class="comment"> * 该类中定义了三种状态：-1表示工作线程还未启动  0表示工作线程未上锁   1表示工作线程上锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新创建的线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//任务</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当前工作线程完成的任务数量</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化工作线程</span></span><br><span class="line"><span class="comment">     * 此时工作线程的状态为-1，表示还未启动</span></span><br><span class="line"><span class="comment">     * 每一个新的工作线程会创建新线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstTask 任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">//该状态会在工作线程启动后将其变成1</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>); <span class="comment">//创建新线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动工作线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前工作线程是否上锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 工作线程是否上锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unused 未使用到</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否获取到锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试释放锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unused 未使用到</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取锁，一定会获取到锁，只不过可能需要阻塞等待，更多的知识以后会新起文章进行深入分析</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        acquire(<span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取锁，获取不到就直接返回了，不会阻塞等待</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否获取到锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        release(<span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前工作线程是否上锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 工作线程是否上锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> isHeldExclusively(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中断已启动的工作线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 比较当前线程池的状态是否小于指定状态值</span></span><br><span class="line"><span class="comment"> * 简单来说就是为了知道线程池处于哪个状态区间</span></span><br><span class="line"><span class="comment"> * 更为具体的分析可看最上面</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c ctl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 指定状态值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateLessThan</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 比较当前线程池的状态是否大于指定状态值</span></span><br><span class="line"><span class="comment"> * 简单来说就是为了知道线程池处于哪个状态区间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c ctl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 指定状态值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateAtLeast</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前线程池是否处于运行中状态（RUNNING）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c ctl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以原子化的方式增加工作线程的数量，这里利用CAS，以后也会新起文章进行讲解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expect 预期值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值，false表示实际值与预期值不同导致更新值失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndIncrementWorkerCount</span><span class="params">(<span class="keyword">int</span> expect)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ctl.compareAndSet(expect, expect + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以原子化的方式减少工作线程的数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expect 预期值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值，false表示实际值与预期值不同导致更新值失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndDecrementWorkerCount</span><span class="params">(<span class="keyword">int</span> expect)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ctl.compareAndSet(expect, expect - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decrementWorkerCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (! compareAndDecrementWorkerCount(ctl.get()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关闭或停止线程池时会调用此方法</span></span><br><span class="line"><span class="comment"> * 若线程池的当前状态大于指定状态，则不做任何操作，否则将其置为指定状态并更新工作线程的数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetState 指定状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">advanceRunState</span><span class="params">(<span class="keyword">int</span> targetState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (runStateAtLeast(c, targetState) ||</span><br><span class="line">            ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试终止线程池</span></span><br><span class="line"><span class="comment"> * 回收线程</span></span><br><span class="line"><span class="comment"> * 从TIDYING过渡到TERMINATED状态</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * STOP(线程池为空)：TIDYING</span></span><br><span class="line"><span class="comment"> * SHUTDOWN(线程池和队列为空)：TIDYING</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1. 从上面的线程池状态图可知，RUNNING是不可能直接过渡到TERMINATED，只能从TIDYING过渡到TERMINATED</span></span><br><span class="line"><span class="comment">         * 2. 满足TIDYING状态只能是STOP且线程池为空或SHUTDOWN且线程池和队列为空</span></span><br><span class="line"><span class="comment">         * 3. 当调用shutdown方法时，线程池的状态是SHUTDOWN，但是当队列中还有任务未执行时，回收所有空闲的工作线程！！！（有些空闲线程在被中断时因为队列中有任务而变成不是空闲），这正好符合我们说SHUTDOWN状态下的线程池会去处理队列中*    的任务，当队列中的任务执行完毕后在回收所有线程！！！</span></span><br><span class="line"><span class="comment">         * 4. 当调用shutdownNow方法时，线程池的状态是STOP，此时队列中的任务将会被清空，同时回收所有线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) || runStateAtLeast(c, TIDYING) || (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">//工作线程数大于0</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE); <span class="comment">//中断其中一个空闲线程，即使只是中断一个空闲线程，后续还会继续去中断其他空闲线程</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;  <span class="comment">//将线程池的状态变成TIDYING状态</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    terminated();<span class="comment">//调用terminated方法，交给每个子类去实现</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>)); <span class="comment">//将线程池的状态变成TERMINATED状态</span></span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定值判断是中断所有空闲线程还是只中断其中一个</span></span><br><span class="line"><span class="comment"> * 即使是只中断一个空闲线程，后续也会因为再次调用tryTerminate#interruptIdleWorkers在中断其他空闲线程，所以并不影响</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyOne 标志</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123; <span class="comment">//若工作线程被上锁了，说明工作线程正在执行任务，不能去中断，不属于空闲线程</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中断所有工作线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">            w.interruptIfStarted();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接拒绝新任务提交的策略</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> command 任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    handler.rejectedExecution(command, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定值决定是要判断线程池是处于RUNNING还是SHUTDOWN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> shutdownOK true表示要判断线程池是否处于SHUTDOWN，若是则返回true</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isRunningOrShutdown</span><span class="params">(<span class="keyword">boolean</span> shutdownOK)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">    <span class="keyword">return</span> rs == RUNNING || (rs == SHUTDOWN &amp;&amp; shutdownOK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除队列中的所有任务，并将其放入到数组中</span></span><br><span class="line"><span class="comment"> * 通常使用drainTo将任务放入到数组中. 但是，如果队列是DelayQueue或其他类型的队列，poll或drainTo可能无法删除某些元素，则将它们逐个删除.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 存放任务的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Runnable&gt; <span class="title">drainQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; q = workQueue;</span><br><span class="line">    ArrayList&lt;Runnable&gt; taskList = <span class="keyword">new</span> ArrayList&lt;Runnable&gt;();</span><br><span class="line">    q.drainTo(taskList);</span><br><span class="line">    <span class="keyword">if</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Runnable r : q.toArray(<span class="keyword">new</span> Runnable[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.remove(r))</span><br><span class="line">                taskList.add(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> taskList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行任务</span></span><br><span class="line"><span class="comment"> * 有可能是创建新线程去执行任务，也有可能是复用线程去执行任务</span></span><br><span class="line"><span class="comment"> * 若线程池已经关闭或者线程池饱和（线程个数达到最大线程数且队列已满）则会执行拒绝任务的策略，默认情况下是抛出异常，其他情况下都会正常执行任务</span></span><br><span class="line"><span class="comment"> * 注意：若线程池在关闭前就已经将任务入队列且没有remove成功，那么最终还是要正常执行</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 总结：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 线程池的状态处于RUNNING下：</span></span><br><span class="line"><span class="comment"> * 1. 对于新提交的任务，线程个数小于核心线程数，则新创建线程进行处理 （size &lt; corePoolSize）</span></span><br><span class="line"><span class="comment"> * 2. 对于新提交的任务，线程个数大于核心线程小于最大线程数，则尝试放入到队列中 （corePoolSize &lt; size &lt; maximumPoolSize）</span></span><br><span class="line"><span class="comment"> *    21. 若此时队列未满，则放入成功，后续会正常执行</span></span><br><span class="line"><span class="comment"> *    22. 若此时队列已满（放入失败），则直接创建新线程去执行</span></span><br><span class="line"><span class="comment"> * 3. 对于新提交的任务，线程个数大于核心线程数且等于最大线程数，则尝试放入到队列中，若队列已经满了，这时的线程池已经饱和了，只能拒绝任务，若队列未满，则加入到队列中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 线程处的状态已经关闭，这里有个点需要注意下，应该采用的双重检查，所以以下的分析会说是第一次检查时关闭还是第二次检查时关闭</span></span><br><span class="line"><span class="comment"> * 1. 对于新提交的任务，线程个数小于核心线程数，拒绝任务</span></span><br><span class="line"><span class="comment"> * 2. 对于新提交的任务，线程个数大于核心线程数小于最大线程数，第一次检查时线程池已关闭，说明还未入队列中，拒绝任务</span></span><br><span class="line"><span class="comment"> * 2. 对于新提交的任务，线程个数大于核心线程数小于最大线程数，第一检查处于RUNNING，入队列中，第二次检查时关闭了，去移除任务，要是移除失败了，那么最终还是会去正常执行任务，若移除成功了，则拒绝任务</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> command 任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">     * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">     * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">     * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">     * threads when it shouldn't, by returning false.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">     * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">     * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">     * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">     * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">     * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">     * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">     * and so reject the task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 若线程池中的线程个数小于核心线程数，则创建一个新线程去执行任务，新线程中包含有任务</span></span><br><span class="line"><span class="comment">     * 2. 若线程个数大于核心线程数，则判断线程池是否处于RUNNING，且尝试去入队列，这里要注意下双重检查的处理</span></span><br><span class="line"><span class="comment">     *    21. 若第二次检查时线程池关闭了，照道理应该remove任务，不过有可能移除失败，没办法还是必须去处理它</span></span><br><span class="line"><span class="comment">     *    22. 若线程池处于RUNNING，则正常处理</span></span><br><span class="line"><span class="comment">     * 3. 若线程池并不处于RUNNING，即第一次检查时就关闭了，不好意思了，拒绝任务</span></span><br><span class="line"><span class="comment">     * 4. 若线程池处于RUNNING，但是入队列失败了，那么判断是否有多余的线程，若没有，则说明线程池达到饱和，只能拒绝任务了，若有则创建新线程去执行任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123; <span class="comment">//1</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>)) <span class="comment">//若创建新线程失败或抛出异常，则返回false，addWorker方法中会判断线程池的状态是否处于RUNNING</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<span class="comment">//2 workQueue.offer返回true表示入队列成功</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 双重检查，上面的注释说的是：线程池在第一次检查之后就被关闭了，有可能是多线程下导致的，若是第二次检查中线程池已经关闭了，那么就要把之前入队列时的任务移除掉，并使用了拒绝策略</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command)) </span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 双重检查，此时有两种情况：</span></span><br><span class="line"><span class="comment">         * 1. 线程池的状态处于RUNNING，但是却没有工作线程，那么队列中还有刚才添加的任务没处理呢，所以只能在创建一个新线程来处理任务了</span></span><br><span class="line"><span class="comment">         * 2. 线程池已经关闭了，那么照道理应该移除掉队列中的任务，但是要是没移除掉呢，也就是remove返回false，那它还是会新创建一个线程去处理队列中的任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此时有两种情况：</span></span><br><span class="line"><span class="comment">     * 1. 线程池的状态处于SHUNDOWN/STOP/TIDYING/TERMINATED，说明线程池已经关闭了，那么该任务已经是没有入到队列中，所以最终会返回false，所以直接执行拒绝策略</span></span><br><span class="line"><span class="comment">     * 2. 线程池的状态处于RUNNING，但是任务入队列失败了，有可能是队列满了，也有可能是异常发生了，那么它会在addWorker中判断是否有多余的线程可以创建（与最大线程数比较），若有则正常执行任务，若没有，不好意思了，拒绝任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))<span class="comment">//3,4 </span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建工作线程</span></span><br><span class="line"><span class="comment"> * 若线程池处于SHUTDOWN或STOP，则返回false</span></span><br><span class="line"><span class="comment"> * 若线程工程类创建线程失败或返回null或抛出异常，则返回false</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> firstTask 工作线程的首个任务，若firstTask = null表示只是为了创建一个新线程去处理队列中的任务，若firstTask != null表示正是为了处理指定任务而创建的新线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> core true表示使用核心线程数作为判断线程个数的标准，false表示使用最大线程数作为判断线程个数的标准</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否成功创建工作线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1. 若线程池已经关闭且队列中已经没有任务了，那么应该返回false</span></span><br><span class="line"><span class="comment">         * 2. 若线程池已经关闭但队列中还有任务，那么应该创建新线程去执行，这种情况下是没有工作线程下才会调用此方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span> &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) <span class="comment">//若线程个数已经超过标准了，是不会在创建了，直接返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c)) <span class="comment">//增加工作线程的数量</span></span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs) <span class="comment">//走到这里说明，线程池的状态或者工作线程个数发生了改变</span></span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask); <span class="comment">//创建工作线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//双重检查</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 此时有两种情况：</span></span><br><span class="line"><span class="comment">                 * 1. 线程池的状态处于RUNNING，为了执行任务而创建新的线程</span></span><br><span class="line"><span class="comment">                 * 2. 线程池已经关闭，但是队列中还有任务（若队列中没任务了则在上面就已经返回false了），所以必须要创建一个新线程去执行队列中的任务（此时的情况是没有工作线程了必须要创建一个，若还存在工作线程，压根就不会调用此方法）</span></span><br><span class="line"><span class="comment">                 * 3. 线程池已经关闭，firstTask != null表示要执行新提交的任务，那么这个时候是拒绝的，而若firstTask = null表示创建新线程是为了执行队列中的任务，如第2点</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive())</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>; <span class="comment">//表示创建工作线程成功</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start(); <span class="comment">//通过该方式去启动工作线程</span></span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted) <span class="comment">//线程工程类创建线程失败或返回null或抛出异常，线程池已关闭拒绝新提交的任务，线程启动失败</span></span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理创建工作线程失败后的动作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w 工作线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">            workers.remove(w); <span class="comment">//移除指定工作线程</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        tryTerminate();<span class="comment">//</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 回收工作线程</span></span><br><span class="line"><span class="comment"> * 有可能是线程池处于RUNNING却因为工作线程突发异常导致被回收，有可能是因为关闭了线程池导致回收线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w 工作线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> completedAbruptly 工作线程是否发生异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">//若突发异常导致工作线程发生异常，该值为true，应该主动调用方法去减少工作线程的数量，正常情况下工作线程在被回收时会在指定方法中调用getTask -&gt; decrementWorkerCount</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        workers.remove(w); <span class="comment">//移除指定工作线程</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tryTerminate(); <span class="comment">//尝试去终止线程池</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123; <span class="comment">//线程池的状态处于SHUTDONW/RUNNING</span></span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty()) <span class="comment">//不存在工作线程，但队列中还有任务未处理</span></span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min) <span class="comment">//若线程个数满足上面的条件则不需要创建新线程了</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 有可能因为工作线程发生异常导致被回收，线程池中不存在工作线程，但此时队列中还有任务，所以必须要创建新线程去处理队列中的任务</span></span><br><span class="line"><span class="comment">         * 按照线程池的策略，原先线程个数大于核心线程数在被回收到导致变成了小于，那么它会弥补新的一个线程，同样的原先线程个数小于核心线程数，它也会弥补新的一个线程，但若是即使被回收了也仍是大于，则不会新增了</span></span><br><span class="line"><span class="comment">         * 按照我的理解它是为了保证不会降低效率</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取队列中的任务</span></span><br><span class="line"><span class="comment"> * 工作线程一直处理阻塞或阻塞指定时间</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 总结：</span></span><br><span class="line"><span class="comment"> * 1. 线程个数超过最大线程数（重新调用setMaximumPoolSize），会返回null</span></span><br><span class="line"><span class="comment"> * 2. 线程池处于SHUTDOWN且队列为空，返回null</span></span><br><span class="line"><span class="comment"> * 3. 线程池处于STOP，返回null</span></span><br><span class="line"><span class="comment"> * 4. 线程个数小于最大线程数，线程池处于RUNNING</span></span><br><span class="line"><span class="comment"> *    41. 若设置了allowCoreThreadTimeOut = true，所有工作线程的空闲时间超过保活时间后会被回收</span></span><br><span class="line"><span class="comment"> *    42. 若设置了allowCoreThreadTimeOut = false，且线程个数大于核心线程数的工作线程的空闲时间超过保活时间会被回收，即最终只有核心线程数的工作线程存在，通过调用shutdown回收最后的工作线程</span></span><br><span class="line"><span class="comment"> * 5. 若队列中还有任务存在，不管是哪一种情况至少都会有一个工作线程存在</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">//表示工作线程的空闲时间是否超过了指定时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1. 线程池处于SHUTDOWN，但是队列中还有任务（我还要工作），但如果队列为空，说明已经没有任务了，该工作线程可以被回收了</span></span><br><span class="line"><span class="comment">         * 2. 线程池处于STOP，队列中的任务实际上已经被清空了，也不会允许任务的提交，该工作线程也可以被回收了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);<span class="comment">//获取线程个数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 线程池处于RUNNING，那么就该考虑怎么回收工作线程了，注意keepAliveTime &gt; 0 否则不管如何都回收不了工作线程</span></span><br><span class="line"><span class="comment">         * 1. 若设置allowCoreThreadTimeOut = true，则当所有的工作线程的空闲时间超过指定时间后会被回收，即所有的工作线程都会被回收</span></span><br><span class="line"><span class="comment">         * 2. 若设置allowCoreThreadTimeOut = false，线程个数大于核心线程数的工作线程的空闲时间超过指定时间后会被回收，即最终的工作线程个数等于核心线程数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1. 工作线程数超过最大线程数，自然要被回收了，工作线程太多了</span></span><br><span class="line"><span class="comment">         * 2. 线程个数小于最大线程数，工作线程的空闲时间是否超过了指定时间，若没超过则不会进入if语句中了，表示当前的工作线程要继续干活</span></span><br><span class="line"><span class="comment">         *    若超过指定时间了，那么还要确认下自己是否是最后一个工作线程，若是最后一个工作线程就要判断队列中是否还有任务，毕竟不能所有工作线程都被回收了，总要有人留下来处理任务吧，若不存在任务则被回收，若存在就要留下来为队列中的任*    务服务了，有点难受了，若不是最后一个线程，先走为妙，总有人要留下来背锅的，哈哈哈，所以也会被回收</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c)) <span class="comment">//工作线程被回收时要减少数量</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 这里涉及到两种策略：注意keepAliveTime &gt; 0 否则不管如何都回收不了工作线程</span></span><br><span class="line"><span class="comment">             * 1. 工作线程要受保活时间的限制进行回收，这种情况下有两个可能，第一种是设置了allowCoreThreadTimeOut = true，即所有的线程都要受保活时间的限制，另外一种是allowCoreThreadTimeOut = false，且线程个数大于核心线程数</span></span><br><span class="line"><span class="comment">             *    了，有些工作线程需要被回收，这两种的线程都会被回收，即timed = true，poll方法表示我只等指定长时间，超过后就返回了（阻塞指定时间）</span></span><br><span class="line"><span class="comment">             * 2. 工作线程不受保活时间的限制，allowCoreThreadTimeOut = false，且线程个数小于核心线程数，此时timed = false，take会一直阻塞，直到被中断</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); <span class="comment">//从队列中获取任务，若获取到直接返回，若获取不到任务，则会阻塞一段时间或一直阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) </span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>; <span class="comment">//走到这里说明阻塞一点时间后仍没有任务，继续循环判断是否要被回收还要是继续等待</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123; <span class="comment">//工作线程阻塞时被中断了</span></span><br><span class="line">            timedOut = <span class="keyword">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行工作线程</span></span><br><span class="line"><span class="comment"> * 若getTask返回null会跳出循环导致工作线程被回收</span></span><br><span class="line"><span class="comment"> * 可能因为抛出异常导致工作线程被回收，如beforeExecute/afterExecute</span></span><br><span class="line"><span class="comment"> * 通过afterExecute/UncaughtExceptionHandler可知道任务发生异常的信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w 工作线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock();</span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>; <span class="comment">//是否因为发生异常导致工作线程被回收</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//重复从队列中获取任务去执行，若当前工作线程已经执行完自身的任务就要帮忙去处理队列中的任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">    </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 双重检查</span></span><br><span class="line"><span class="comment">             * 在第一次检查STOP时，线程池的状态处于STOP，既然后续外部代码改变了中断状态，这里的代码也会再次判断，总而言之结果都会中断</span></span><br><span class="line"><span class="comment">             * 在第一次检查STOP时，线程池的状态处于RUNNING/SHUTDOWN，Thread.interrupted这个语句是必须要有的，假设外部代码会改变中断状态，当你调用shutdown##interruptIdleWorkers时可能会出现线程从来都没有被中断过（中断被清除）* 那么将导致一直阻塞，所以这里加上Thread.interrupted是为了消除外部代码的干扰，这也导致了工作线程的中断状态被重置了，对于此时线程池处于STOP，它的中断状态就不对了，所以又做了第二次检查就是将其修改成中断状态</span></span><br><span class="line"><span class="comment">             * 以上的解释纯属个人理解！！！</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task); <span class="comment">//若该方法发生异常将直接导致工作线程被回收，没办法收集异常信息</span></span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown); <span class="comment">//收集执行任务时发生的异常，该方法也有可能会发生异常</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly); <span class="comment">//回收工作线程，有可能是因为发生异常，有可能是设置了保活时间等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关闭线程池</span></span><br><span class="line"><span class="comment"> * 有可能该方法已经调用结束了但任务还未执行完，不过这不影响</span></span><br><span class="line"><span class="comment"> * 队列中的任务会继续被执行，但是会拒绝新任务的提交</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(SHUTDOWN); <span class="comment">//将线程池的状态设置为SHUTDOWN</span></span><br><span class="line">        interruptIdleWorkers(); <span class="comment">//中断所有空闲线程，相当于一直阻塞代码将不会继续阻塞了</span></span><br><span class="line">        onShutdown();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();<span class="comment">//回收所有空闲线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 停止线程池并返回队列中的任务（未执行的任务）</span></span><br><span class="line"><span class="comment"> * 尽最大的努力去中断所有正在执行的任务，同时移除队列中的任务，拒绝新任务的提交</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 队列中的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(STOP); <span class="comment">//将线程池的状态设置为STOP</span></span><br><span class="line">        interruptWorkers(); <span class="comment">//中断所有工作线程</span></span><br><span class="line">        tasks = drainQueue(); <span class="comment">//移除队列中的任务</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();<span class="comment">//回收线程</span></span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池是否处于STOP或SHUTDOWN</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ! isRunning(ctl.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程处是否处于SHUTDOWN/STOP/TIDYING</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTerminating</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">return</span> ! isRunning(c) &amp;&amp; runStateLessThan(c, TERMINATED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池是否处于TERMINATED</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> runStateAtLeast(ctl.get(), TERMINATED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 允许等待指定时间后获取线程池是否处于TERMINATED</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout 等待时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (runStateAtLeast(ctl.get(), TERMINATED)) <span class="comment">//线程池是否处于TERMINATED</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            nanos = termination.awaitNanos(nanos); <span class="comment">//等待指定时间</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当线程池不在被引用/使用和没有工作线程的情况下调用shutdown</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm == <span class="keyword">null</span> || acc == <span class="keyword">null</span>) &#123;</span><br><span class="line">        shutdown();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PrivilegedAction&lt;Void&gt; pa = () -&gt; &#123; shutdown(); <span class="keyword">return</span> <span class="keyword">null</span>; &#125;;</span><br><span class="line">        AccessController.doPrivileged(pa, acc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置线程的工厂类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory 线程的工厂类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setThreadFactory</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (threadFactory == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程的工厂类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程的工厂类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ThreadFactory <span class="title">getThreadFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> threadFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置拒绝任务的策略</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler 策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRejectedExecutionHandler</span><span class="params">(RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取拒绝任务的策略</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RejectedExecutionHandler <span class="title">getRejectedExecutionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置核心线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize 核心线程数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCorePoolSize</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> delta = corePoolSize - <span class="keyword">this</span>.corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(ctl.get()) &gt; corePoolSize) <span class="comment">//若当前线程池的线程个数超过指定的核心线程数，则回收所有空闲线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delta &gt; <span class="number">0</span>) &#123; <span class="comment">// 若当前线程池的线程个数小于指定的核心线程数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 新增工作线程无非就是为了能够帮忙处理队列中的任务，所以当队列中任务个数小于要新增的线程个数时，那就不要新增那么多工作线程了，这是要浪费的节奏</span></span><br><span class="line"><span class="comment">         * 当队列中的任务个数大于要新增的线程个数时，不好意思了，最多只能增加到指定的核心线程数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> k = Math.min(delta, workQueue.size());</span><br><span class="line">        <span class="keyword">while</span> (k-- &gt; <span class="number">0</span> &amp;&amp; addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (workQueue.isEmpty())<span class="comment">//当队列被清空了，就不需要再新增工作线程了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取核心线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 核心线程数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCorePoolSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> corePoolSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 预先创建并开启线程，等待任务到来</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> false表示所有核心线程都已开启，true表示已经创建并开启一个线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">prestartCoreThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> workerCountOf(ctl.get()) &lt; corePoolSize &amp;&amp;</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 预先创建并开启至少一个线程，即使核心线程数是0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ensurePrestart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> wc = workerCountOf(ctl.get());</span><br><span class="line">    <span class="keyword">if</span> (wc &lt; corePoolSize)</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wc == <span class="number">0</span>)</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 预先创建并开启所有核心线程数的工作线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 创建并开启线程的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prestartAllCoreThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>))</span><br><span class="line">        ++n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取是否所有线程都受保活时间的限制</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否所有线程都受保活时间的限制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">allowsCoreThreadTimeOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> allowCoreThreadTimeOut;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置是否所有线程都受保活时间的限制</span></span><br><span class="line"><span class="comment"> * 若为false表示核心线程个数的线程不会受保活时间的限制，但若线程个数超过了核心线程个数就会受到限制，直到线程个数降低到核心线程个数</span></span><br><span class="line"><span class="comment"> * 若为true表示所有的线程都受保活时间的限制，即线程的空闲时间超过保活时间则会被回收</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">allowCoreThreadTimeOut</span><span class="params">(<span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; keepAliveTime &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Core threads must have nonzero keep alive times"</span>);</span><br><span class="line">    <span class="keyword">if</span> (value != allowCoreThreadTimeOut) &#123;</span><br><span class="line">        allowCoreThreadTimeOut = value;</span><br><span class="line">        <span class="keyword">if</span> (value)</span><br><span class="line">            interruptIdleWorkers(); <span class="comment">//回收空闲线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置最大线程数</span></span><br><span class="line"><span class="comment"> * 若线程池中的线程个数大于指定的最大线程数，则它们会在下次空闲时被回收</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maximumPoolSize 最大线程数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaximumPoolSize</span><span class="params">(<span class="keyword">int</span> maximumPoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maximumPoolSize &lt;= <span class="number">0</span> || maximumPoolSize &lt; corePoolSize)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(ctl.get()) &gt; maximumPoolSize)</span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取最大线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最大线程数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaximumPoolSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maximumPoolSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置空闲线程的保活时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> time 时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKeepAliveTime</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (time &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (time == <span class="number">0</span> &amp;&amp; allowsCoreThreadTimeOut())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Core threads must have nonzero keep alive times"</span>);</span><br><span class="line">    <span class="keyword">long</span> keepAliveTime = unit.toNanos(time);</span><br><span class="line">    <span class="keyword">long</span> delta = keepAliveTime - <span class="keyword">this</span>.keepAliveTime;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = keepAliveTime;</span><br><span class="line">    <span class="keyword">if</span> (delta &lt; <span class="number">0</span>)</span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取保活时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 保活时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getKeepAliveTime</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unit.convert(keepAliveTime, TimeUnit.NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取队列</span></span><br><span class="line"><span class="comment"> * 获取队列主要是为了调试与监控，该队列一直在变化着</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BlockingQueue&lt;Runnable&gt; <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> workQueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从队列中移除指定任务</span></span><br><span class="line"><span class="comment"> * 有些情况下队列中并不是直接存放任务，有可能任务被包装进另外一种形式的对象中，然后在将该对象放入队列中，这种情况下不能使用该方法去移除，而应该是purgee方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = workQueue.remove(task);</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从队列中移除已取消的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">purge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; q = workQueue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Iterator&lt;Runnable&gt; it = q.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            Runnable r = it.next();</span><br><span class="line">            <span class="keyword">if</span> (r <span class="keyword">instanceof</span> Future&lt;?&gt; &amp;&amp; ((Future&lt;?&gt;)r).isCancelled())</span><br><span class="line">                it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ConcurrentModificationException fallThrough) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object r : q.toArray())</span><br><span class="line">            <span class="keyword">if</span> (r <span class="keyword">instanceof</span> Future&lt;?&gt; &amp;&amp; ((Future&lt;?&gt;)r).isCancelled())</span><br><span class="line">                q.remove(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程池中工作线程的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 工作线程的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPoolSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Remove rare and surprising possibility of</span></span><br><span class="line">        <span class="comment">// isTerminated() &amp;&amp; getPoolSize() &gt; 0</span></span><br><span class="line">        <span class="keyword">return</span> runStateAtLeast(ctl.get(), TIDYING) ? <span class="number">0</span> : workers.size();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取正在执行任务的工作线程的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 正在执行任务的工作线程的个数</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getActiveCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">            <span class="keyword">if</span> (w.isLocked()) <span class="comment">//工作线程上锁表示正在执行任务</span></span><br><span class="line">                ++n;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程池中曾经存在的最大线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLargestPoolSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> largestPoolSize;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程池中所有任务的个数，任务包括已执行、正在执行、未执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTaskCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> n = completedTaskCount;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            n += w.completedTasks;</span><br><span class="line">            <span class="keyword">if</span> (w.isLocked())</span><br><span class="line">                ++n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + workQueue.size();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程池中已执行的任务的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCompletedTaskCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> n = completedTaskCount;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">            n += w.completedTasks;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当线程池拒绝任务时，采用只要线程池未关闭，由调用execute的线程运行任务，若线程池已关闭，则任务将被丢弃</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只要线程池未关闭，由调用execute的线程运行任务，若线程池已关闭，则任务将被丢弃</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r 任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 线程池对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            r.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当线程池拒绝任务时，直接抛出RejectedExecutionException异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接抛出异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r 任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 线程池对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException always</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() + <span class="string">" rejected from "</span> + e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当线程池拒绝任务时，直接丢弃任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接丢弃任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r 任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 线程池对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当线程池拒绝任务时，采用只要线程池未关闭，则将丢弃队列中头部位置的任务（最早入队列的任务），然后重复执行指定任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只要线程池未关闭，则将丢弃队列中头部位置的任务（最早入队列的任务），然后重复执行指定任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r 任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 线程池对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            e.getQueue().poll();</span><br><span class="line">            e.execute(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同下，此方法会一直阻塞直到有任务完成，所有照道理不会cathc到TimeoutException异常才对</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tasks 任务列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timed 是否等待一段时间，false：将会一直等待有任务完成</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nanos 等待时间，以纳秒为时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> doInvokeAny(tasks, <span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException cannotHappen) &#123;</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行集合中的任务，出现以下的情况将不会在执行剩余的任务，也就是说，至始至终只会有一个任务会完成，若一直没有任务完成且未设置等待时间，则一直等待</span></span><br><span class="line"><span class="comment"> * 1、其中一个任务完成，则取消其他执行中的任务</span></span><br><span class="line"><span class="comment"> * 2、等待一段时间后退出并取消任务</span></span><br><span class="line"><span class="comment"> * 3、所有的任务都抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tasks 任务列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timed 是否等待一段时间，false：将会一直等待有任务完成</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nanos 等待时间，以纳秒为时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">doInvokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tasks == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> ntasks = tasks.size();</span><br><span class="line">    <span class="keyword">if</span> (ntasks == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(ntasks);</span><br><span class="line">    ExecutorCompletionService&lt;T&gt; ecs = <span class="keyword">new</span> ExecutorCompletionService&lt;T&gt;(<span class="keyword">this</span>); <span class="comment">//该类没什么特别，只是将已完成的任务放到队列中，以便可以获取，底层实际上还是靠线程池去执行任务</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        ExecutionException ee = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">        Iterator&lt;? extends Callable&lt;T&gt;&gt; it = tasks.iterator();</span><br><span class="line"></span><br><span class="line">        futures.add(ecs.submit(it.next())); <span class="comment">//先尝试提交一个任务</span></span><br><span class="line">        --ntasks; <span class="comment">//未提交的任务个数</span></span><br><span class="line">        <span class="keyword">int</span> active = <span class="number">1</span>;<span class="comment">//执行中的任务个数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Future&lt;T&gt; f = ecs.poll(); <span class="comment">//尝试获取之前提交的任务是否完成，若是已完成则f将不会空，若未完成则f为空</span></span><br><span class="line">            <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ntasks &gt; <span class="number">0</span>) &#123; <span class="comment">//是否还有未提交的任务，在尝试提交一个</span></span><br><span class="line">                    --ntasks;</span><br><span class="line">                    futures.add(ecs.submit(it.next()));</span><br><span class="line">                    ++active;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (active == <span class="number">0</span>) <span class="comment">//若已经不存在执行中的任务，说明从一开始到现在都没有任务完成或任务都抛出异常了，已经没有未提交的任务了，也不存在执行中的任务了，直接退出</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123; <span class="comment">//是否尝试等待一段时间去获取已完成的任务</span></span><br><span class="line">                    <span class="comment">// 走到这里说明已没有未提交的任务了，现在就等着执行中的任务执行完成，不过它不是一直等着，而是等待一段时间后若任务还是未完成，那么将抛出异常来直接退出，不在等待了</span></span><br><span class="line">                    f = ecs.poll(nanos, TimeUnit.NANOSECONDS);</span><br><span class="line">                    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">                    nanos = deadline - System.nanoTime();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f = ecs.take(); <span class="comment">//走到这里说明已经没有未提交的任务了，现在就一直等着执行中的任务执行完成，然后获取它就可以了，简单来说就是这里会被阻塞住，直到队列中添加了已完成的任务</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123; <span class="comment">//说明有任务已经完成</span></span><br><span class="line">                --active;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> f.get(); <span class="comment">//直接获取结果</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException eex) &#123; <span class="comment">//记录异常信息</span></span><br><span class="line">                    ee = eex;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException rex) &#123;</span><br><span class="line">                    ee = <span class="keyword">new</span> ExecutionException(rex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ee == <span class="keyword">null</span>)</span><br><span class="line">            ee = <span class="keyword">new</span> ExecutionException(); <span class="comment">//走到这里说明所有的任务都抛出异常了</span></span><br><span class="line">        <span class="keyword">throw</span> ee;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++)</span><br><span class="line">            futures.get(i).cancel(<span class="keyword">true</span>); <span class="comment">//1、有任务已完成，取消剩余的执行中的任务  2、所有的任务都抛出异常了  3、等待一段时间后而退出的，则取消任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同下，此方法会阻塞一段时间，有可能抛出TimeoutException异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tasks 任务列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timed 是否等待一段时间，false：将会一直等待有任务完成</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nanos 等待时间，以纳秒为时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doInvokeAny(tasks, <span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行集合中的所有任务，若有一个任务被中断，则取消所有任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tasks 任务列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值，若是抛出异常则说明任务被中断了，若没有抛出异常则说明所有任务都正常完成了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (tasks == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size()); <span class="comment">//保存所有任务</span></span><br><span class="line">    <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Callable&lt;T&gt; t : tasks) &#123;</span><br><span class="line">            RunnableFuture&lt;T&gt; f = newTaskFor(t);</span><br><span class="line">            futures.add(f);</span><br><span class="line">            execute(f); <span class="comment">//执行任务</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++) &#123;</span><br><span class="line">            Future&lt;T&gt; f = futures.get(i);</span><br><span class="line">            <span class="keyword">if</span> (!f.isDone()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    f.get();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (CancellationException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        done = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> futures;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!done)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++) <span class="comment">//走到这里的话说明有任务被中断了，取消所有任务，已完成的任务没办法取消，这块内容跟Future有关</span></span><br><span class="line">                futures.get(i).cancel(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行集合中的所有任务，若有一个任务被中断或等待超时了，则取消任务，已完成的任务没办法取消</span></span><br><span class="line"><span class="comment"> * 参数中的时间包括提交任务的时间 + 等待任务的时间</span></span><br><span class="line"><span class="comment"> * 该方法有可能因为等待超时而返回、也有可能因为被中断而返回、也有可能正常返回，对于中断我们可以在外层通过catch判断，但是剩下的两个情况我们没办法判断是否任务正常完成了，除非自己在调用isCancelled去一个一个判断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tasks 任务列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout 等待时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TimeUnit unit) <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (tasks == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());<span class="comment">//保存所有任务</span></span><br><span class="line">    <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Callable&lt;T&gt; t : tasks)</span><br><span class="line">            futures.add(newTaskFor(t));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanos;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = futures.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            execute((Runnable)futures.get(i));</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> futures;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            Future&lt;T&gt; f = futures.get(i);</span><br><span class="line">            <span class="keyword">if</span> (!f.isDone()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> futures;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    f.get(nanos, TimeUnit.NANOSECONDS); <span class="comment">//等待一段时间</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (CancellationException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">                    <span class="keyword">return</span> futures;</span><br><span class="line">                &#125;</span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        done = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> futures;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!done)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++) <span class="comment">//走到这里说明有任务被中断了或等待时间超时了</span></span><br><span class="line">                futures.get(i).cancel(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成异步形式的任务，为了异步获取结果</span></span><br><span class="line"><span class="comment"> * 关于Future的知识点将会另外新起文章进行讲解</span></span><br><span class="line"><span class="comment"> * 这里为啥会多一个value呢? 与下面的重载方法相比，Runnable并不存在返回值，故提供了此值，相当于Runnable + value = Callable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> runnable 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 结果值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 异步形式的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成异步形式的任务，为了异步获取结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> callable 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 异步形式的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提交任务并执行，返回异步对象来获取结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 异步对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提交任务并执行，返回异步对象来获取结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> result 结果值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 异步对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提交任务并执行，返回异步对象来获取结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 异步对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><ul><li><p>线程池的状态处于<code>RUNNING</code>下：</p><ul><li><p>对于新提交的任务，<code>线程个数小于核心线程数</code>，则新创建线程进行处理 （size &lt; corePoolSize）</p></li><li><p>对于新提交的任务，<code>线程个数大于核心线程小于最大线程数</code>，则尝试放入到队列中 （corePoolSize &lt; size &lt; maximumPoolSize）</p><ul><li><p>若此时队列未满，则放入成功，后续会正常执行</p></li><li><p>若此时队列已满（放入失败），则直接创建新线程去执行</p></li></ul></li><li><p>对于新提交的任务，<code>线程个数大于核心线程数且等于最大线程数</code>，则尝试放入到队列中，若队列已经满了，这时的线程池已经饱和了，只能拒绝任务，若队列未满，则加入到队列中</p></li></ul></li><li><p>线程个数小于最大线程数，线程池处于RUNNING</p><ul><li><p>若设置了allowCoreThreadTimeOut = true，所有工作线程的空闲时间超过保活时间后会被回收</p></li><li><p>若设置了allowCoreThreadTimeOut = false，且线程个数大于核心线程数的工作线程的空闲时间超过保活时间会被回收，即最终只有核心线程数的工作线程存在，通过调用shutdown回收最后的工作线程</p></li></ul></li><li><p>若队列中还有任务存在，不管是哪一种情况至少都会有一个工作线程存在</p></li><li><p>线程池的状态——RUNNING/SHUTDONW/STOP/TIDYING/TERMINATED</p></li><li><p>线程池<code>拒绝任务</code>的策略：</p><ul><li><p>ThreadPoolExecutor.AbortPolicy：当线程池拒绝任务时，采用直接抛出RejectedExecutionException异常</p></li><li><p>ThreadPoolExecutor.CallerRunsPolicy：当线程池拒绝任务时，采用只要线程池未关闭，由调用execute的线程运行任务，这提供了一种反馈机制，而若线程池已关闭，则任务将被丢弃</p></li><li><p>ThreadPoolExecutor.DiscardPolicy：当线程池拒绝任务时，采用直接丢弃了任务，相当于直接不执行任务了，很干脆</p></li><li><p>ThreaPollExecutor.DiscardOldestPolicy：当线程池拒绝任务时，采用只要线程池未关闭，则将丢弃队列中头部位置的任务（最早入队列的任务），然后重复执行指定任务（调用execute方法，有可能再次被拒绝导致又重复执行）</p></li></ul></li><li><p>invokeAny与invokeAll的使用与区别</p></li></ul><h4 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h4><p><code>ScheduledThreadPoolExecutor</code>是家族中的第二骨干，能够延迟或周期性执行任务，由于其继承了ThreadPoolExecutor类，故而它也拥有线程池状态的概念！//TODO</p><h5 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">implements</span> <span class="title">ScheduledExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当线程池处于SHUTDOWN状态时是否继续执行周期性任务-scheduleWithFixedDelay/scheduleAtFixedRate</span></span><br><span class="line"><span class="comment">     * 默认情况是false，表示不会继续执行周期性任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> continueExistingPeriodicTasksAfterShutdown;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当线程池处于SHUTDOWN状态时是否执行延迟任务</span></span><br><span class="line"><span class="comment">     * 默认情况下是true，表示会执行延迟任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> executeExistingDelayedTasksAfterShutdown = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当任务被成功取消时是否立即从队列中删除此任务</span></span><br><span class="line"><span class="comment">     * 默认情况是false，表示已取消的任务不会马上从队列中删除，只有在关闭线程池的时候才会清除，所以建议将其设置成true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> removeOnCancel = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每个任务的序号，依次呈现递增</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong sequencer = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化，采用延迟队列，该队列中使用了数组作为其数据结构，会自动扩容，所以相当于是个无界队列，设置最大线程池没效果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize 核心线程数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS, <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化，采用延迟队列，自定义线程的工厂类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize 核心线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory 线程的工厂类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS, <span class="keyword">new</span> DelayedWorkQueue(), threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化，采用延迟队列，设置拒绝任务的策略</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize 核心线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler 拒绝任务的策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS, <span class="keyword">new</span> DelayedWorkQueue(), handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化，采用延迟队列，设置拒绝任务的策略，自定义线程的工厂类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> corePoolSize 核心线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory 线程的工厂类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler 拒绝任务的策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS, <span class="keyword">new</span> DelayedWorkQueue(), threadFactory, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="简单方法-2"><a href="#简单方法-2" class="headerlink" title="简单方法"></a>简单方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 立即执行任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> command 任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    schedule(command, <span class="number">0</span>, NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 延迟指定的时间后执行任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> command 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delay 延迟时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 异步任务对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="keyword">long</span> delay, TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableScheduledFuture&lt;?&gt; t = decorateTask(command, <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command, <span class="keyword">null</span>, triggerTime(delay, unit))); <span class="comment">//可根据需需求自定义任务，即可自行包装任务，通过覆写decorateTask方法即可</span></span><br><span class="line">    delayedExecute(t); <span class="comment">//将任务放到队列中</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 延迟指定的时间后执行任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> command 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delay 延迟时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 异步任务对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable, <span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableScheduledFuture&lt;V&gt; t = decorateTask(callable, <span class="keyword">new</span> ScheduledFutureTask&lt;V&gt;(callable, triggerTime(delay, unit)));</span><br><span class="line">    delayedExecute(t); <span class="comment">//将任务放到队列中</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以固定的频率重复执行任务，注重频率</span></span><br><span class="line"><span class="comment"> * 下一个任务的执行时间为上一个任务开始执行的时间加上period</span></span><br><span class="line"><span class="comment"> * 注意一下, 延迟initialDelay时间后开始执行任务，而后续的任务将以固有频率（period）执行</span></span><br><span class="line"><span class="comment"> * 若下一个任务的执行时间到了，但上一个任务还未执行完毕，则当上一个任务执行完毕后下一个任务立即被执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> command 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialDelay 延迟时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> period 固有频率</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 异步对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    ScheduledFutureTask&lt;Void&gt; sft = <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command, <span class="keyword">null</span>, triggerTime(initialDelay, unit), unit.toNanos(period));</span><br><span class="line">    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);</span><br><span class="line">    sft.outerTask = t;</span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以固定的周期重复执行任务，注重周期</span></span><br><span class="line"><span class="comment"> * 下一个任务的执行时间为上一个任务执行完毕后的时间加上period，所以每个任务的执行时间依赖于上一个任务的执行时间，导致每个任务的执行时间不固定</span></span><br><span class="line"><span class="comment"> * 注意一下, 延迟initialDelay时间后开始执行任务，而后续的任务将以固有频率（period）执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> command 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialDelay 延迟时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> period 固有频率</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 异步对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> delay, TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    ScheduledFutureTask&lt;Void&gt; sft =</span><br><span class="line">        <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command, <span class="keyword">null</span>, triggerTime(initialDelay, unit), unit.toNanos(-delay));</span><br><span class="line">    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);</span><br><span class="line">    sft.outerTask = t;</span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包装任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> runnable 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task 包装对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包装对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> &lt;V&gt; <span class="function">RunnableScheduledFuture&lt;V&gt; <span class="title">decorateTask</span><span class="params">(Runnable runnable, RunnableScheduledFuture&lt;V&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包装任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> runnable 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task 包装对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包装对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> &lt;V&gt; <span class="function">RunnableScheduledFuture&lt;V&gt; <span class="title">decorateTask</span><span class="params">(Callable&lt;V&gt; callable, RunnableScheduledFuture&lt;V&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将任务放入到队列中</span></span><br><span class="line"><span class="comment"> * 在第一次检查时线程池处于SHUTDOWN状态时，则直接拒绝任务</span></span><br><span class="line"><span class="comment"> * 在第二次检查时线程池处于SHUTDOWN状态时，则根据属性来决定是否要处理队列中的任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task 任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">delayedExecute</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isShutdown()) <span class="comment">//第一次检查，若此时线程池处于SHUTDOWN状态（或者比SHUTDOWN更大的状态值），则直接拒绝任务，默认情况下会抛出异常</span></span><br><span class="line">        reject(task);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.getQueue().add(task);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 走到这里说明任务已经放入队列中</span></span><br><span class="line"><span class="comment">         * 第二次检查，若此时线程池处于SHUTDOWN状态，则判断是否是重复执行的任务，在根据其continueExistingPeriodicTasksAfterShutdown/executeExistingDelayedTasksAfterShutdown参数来决定是否要处理队列中的任务</span></span><br><span class="line"><span class="comment">         * 默认情况下，针对非重复执行的任务会处理队列中的任务，即canRunInCurrentRunState返回true，最终将不会移除任务</span></span><br><span class="line"><span class="comment">         * 默认情况下，针对重复执行的任务将不会处理队列中的任务，即canRunInCurrentRunState返回false，最终将移除任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp; !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp; remove(task))</span><br><span class="line">            task.cancel(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ensurePrestart();<span class="comment">//因为队列中已经存在任务了，为了防止因为线程池处于SHUTDOWN状态导致不存在任何的工作线程去处理队列中的任务，所以这里必须至少要有一个工作线程存在</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取任务的具体执行时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delay 任务的延迟时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 任务的具体执行时间 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">triggerTime</span><span class="params">(<span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> triggerTime(unit.toNanos((delay &lt; <span class="number">0</span>) ? <span class="number">0</span> : delay));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取任务的具体执行时间，防止任务之间通过compareTo方法比较时溢出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delay 任务的延迟时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 任务的具体执行时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">triggerTime</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> now() + ((delay &lt; (Long.MAX_VALUE &gt;&gt; <span class="number">1</span>)) ? delay : overflowFree(delay));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 约束队列中所有任务的延迟时间在Long.MAX_VALUE之内，避免任务之间通过compareTo方法比较时溢出，简单来说就是防止任务的排序出现错误顺序</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 假设如果没有调用overflowFree，那么会造成什么后果呢？以下的场景参考自网友的文章：</span></span><br><span class="line"><span class="comment"> * 为了方便说明，会采用假设的手法，假设当前时间：100，即：000 0110 0100</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 按照注释中的说法应该是下一个任务已经达到了延迟时间，但却因为上一个任务还未结束导致无法执行下一个任务，简单来说就是下一个任务被延误了，所以它的执行时间会小于当前时间，假设是95</span></span><br><span class="line"><span class="comment"> * 这个时候又加入了新的任务，而新任务的执行时间设置为Long.MAX_VALUE = 1023，即：0011 1111 1111，在生成任务对象时会调用triggerTime方法计算time，即 100 + 1023 = -925，即：111 1001 1101</span></span><br><span class="line"><span class="comment"> * 紧接着调用siftUp方法进行排序，在siftUp中会调用compareTo进行任务之间的比较，在compareTo方法中使用long diff = time - x.time = -925 - 95 = -1020，那么将返回-1，-1说明新任务的延迟时间比队列中任务的延迟时间更短，可是显然不是* 的，正常情况下应该返回1</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 若是执行了overflowFree又会怎么样呢? </span></span><br><span class="line"><span class="comment"> * long headDelay = 95 - 100 = -5 , 此时的delay = 1023，显然 delay - headDelay = 1023 - (-5) 必然是个负数，就不做计算了，紧接着 delay = 1023 -5 = 1018，同样执行triggerTime计算time，即 1018 + 100 = -930</span></span><br><span class="line"><span class="comment"> * 同样执行long diff = time - x.time = -930 - 95 = 1023 &gt; 0，所以会返回1，符合正常的预期（-930：100 0101 1110  -95：111 1010 0001）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 所以，overflowFree方法中把延误的时间给减去，就是为了避免在compareTo方法中出现溢出情况，说实话，这段代码我也看的很痛苦，要不是参考了网友写的文章，我还真看不明白了！</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delay 任务的延迟时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 任务的延迟时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">overflowFree</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;</span><br><span class="line">    Delayed head = (Delayed) <span class="keyword">super</span>.getQueue().peek();</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> headDelay = head.getDelay(NANOSECONDS);</span><br><span class="line">        <span class="keyword">if</span> (headDelay &lt; <span class="number">0</span> &amp;&amp; (delay - headDelay &lt; <span class="number">0</span>))</span><br><span class="line">            delay = Long.MAX_VALUE + headDelay;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> delay;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前时间，以纳秒为单位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">now</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> System.nanoTime();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以异步的形式包装任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledFutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableScheduledFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任务的序号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行任务的具体时间，以纳秒为单位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义重复执行任务的周期或延迟时间</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 1. 正数表示执行任务的周期，主要针对scheduleAtFixedRate方法，注意一下该方法是在上一个任务开始执行的时间加上周期来决定下一个任务的开始执行时间，所以有可能出现下一个任务已经到达了开始执行的时间，而上一个任务还未执行完毕</span></span><br><span class="line"><span class="comment">     *    这个时候说明下一个任务会被延迟执行了，不过绝不会出现下一个任务与上一个任务重叠执行，会等上一个任务执行后才执行</span></span><br><span class="line"><span class="comment">     * 2. 负数表示执行任务的延迟时间，主要针对scheduleWithFixedDelay方法，注意一下该方法是在上一个任务执行完毕后延迟多少时间后才开始执行下一个任务</span></span><br><span class="line"><span class="comment">     * 3. 0表示不会重复执行任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> period;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示当前任务对象，用于重复执行任务，当上一个任务执行完毕后，更新指定属性并重新将该对象重新放入到队列中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RunnableScheduledFuture&lt;V&gt; outerTask = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置索引，用于快速取消</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> heapIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化，设置任务、执行任务的结果、第一次执行任务的延迟时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r 任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result 结果值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ns 延迟时间，以毫秒为单位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns) &#123;</span><br><span class="line">        <span class="keyword">super</span>(r, result);</span><br><span class="line">        <span class="keyword">this</span>.time = ns;</span><br><span class="line">        <span class="keyword">this</span>.period = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化，设置任务、执行任务的结果、第一次执行任务的延迟时间、任务的执行周期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r 任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result 结果值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ns 延迟时间，以毫秒为单位 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> period 任务的执行周期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns, <span class="keyword">long</span> period) &#123;</span><br><span class="line">        <span class="keyword">super</span>(r, result);</span><br><span class="line">        <span class="keyword">this</span>.time = ns;</span><br><span class="line">        <span class="keyword">this</span>.period = period;</span><br><span class="line">        <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化，设置任务、第一次执行任务的延迟时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ScheduledFutureTask(Callable&lt;V&gt; callable, <span class="keyword">long</span> ns) &#123;</span><br><span class="line">        <span class="keyword">super</span>(callable);</span><br><span class="line">        <span class="keyword">this</span>.time = ns;</span><br><span class="line">        <span class="keyword">this</span>.period = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下次执行任务的时间与当前时间的间隔</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit 时间格式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unit.convert(time - now(), NANOSECONDS); <span class="comment">//将指定时间转换成指定格式的时间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将任务进行排序，以便将执行时间更小的任务排到队列的前头</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> other 另外一个任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (other == <span class="keyword">this</span>) <span class="comment">// compare zero if same object</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (other <span class="keyword">instanceof</span> ScheduledFutureTask) &#123;</span><br><span class="line">            ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;</span><br><span class="line">            <span class="keyword">long</span> diff = time - x.time;</span><br><span class="line">            <span class="keyword">if</span> (diff &lt; <span class="number">0</span>) <span class="comment">//比较任务的具体执行时间</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sequenceNumber &lt; x.sequenceNumber) <span class="comment">//若任务的执行时间相同则比较序号</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> diff = getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);</span><br><span class="line">        <span class="keyword">return</span> (diff &lt; <span class="number">0</span>) ? -<span class="number">1</span> : (diff &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前任务是否重复执行，不管是周期性还是延迟执行时间，对应了scheduleAtFixedRate与scheduleWithFixedDelay方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前任务是否重复执行，true表示是重复执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPeriodic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> period != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为重复执行的任务设置下次执行的具体时间，该方法只会在上一个任务执行完毕后调用，只有是重复执行的任务才会调用该方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setNextRunTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> p = period;</span><br><span class="line">        <span class="keyword">if</span> (p &gt; <span class="number">0</span>) <span class="comment">//正数表示重复执行的周期</span></span><br><span class="line">            time += p;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//负数表示重复执行的延迟时间，等到上一个任务执行完毕后延迟指定时间后才开始执行下一个任务</span></span><br><span class="line">            time = triggerTime(-p); <span class="comment">//原本p是个负数，-p就变成了正数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否成功取消任务</span></span><br><span class="line"><span class="comment">     * 1. 若任务还未执行，任务的状态为NEW，调用该方法时，任务的状态将根据mayInterruptIfRunning值变更成INTERRUPTING/CANCELLED</span></span><br><span class="line"><span class="comment">     *    因为任务还未运行，所以mayInterruptIfRunning的值应该为false，所以最终super.cancel返回true</span></span><br><span class="line"><span class="comment">     * 2. 若任务正在运行中，任务的状态还是为NEW，调用该方法时，任务的状态将根据mayInterruptIfRunning值变更成INTERRUPTING/CANCELLED</span></span><br><span class="line"><span class="comment">     *    由于任务正在运行，所以mayInterruptIfRunning的值有可能为true，也有可能为false</span></span><br><span class="line"><span class="comment">     * 21. 若mayInterruptIfRunning = true，任务的状态将变成INTERRUPTING，同时中断正在运行任务的线程，此时要注意一下，要看下线程是否响应了中断，比如出现wait、join、slepp、I/O阻塞才会响应中断而抛出中断异常，其他情况</span></span><br><span class="line"><span class="comment">     *     下只是简单地设置了中断状态，并未抛出异常，最终又将任务的状态变成INTERRUPTED，同时返回true，可实际上任务还是如实完成了</span></span><br><span class="line"><span class="comment">     * 22. 若mayInterruptIfRunning = false，任务的状态将变成CANCELLED，同时返回true，可实际上任务还是如实完成了</span></span><br><span class="line"><span class="comment">     * 3. 若任务已执行完成了，自然是无非取消的</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 综上所述：只有两种情况下任务会被成功取消/中断</span></span><br><span class="line"><span class="comment">     * 1. 任务还未开始执行可以成功取消</span></span><br><span class="line"><span class="comment">     * 2. 运行中的任务在响应中断的情况下会抛出异常，这个时候可根据业务来抉择是否取消继续运行</span></span><br><span class="line"><span class="comment">     * 3. 其他情况下虽然会返回true，但任务还是会如是地运行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mayInterruptIfRunning 是否中断正在运行任务的线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否成功取消任务，此结果值无法决定任务是否真正被取消了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> cancelled = <span class="keyword">super</span>.cancel(mayInterruptIfRunning);</span><br><span class="line">        <span class="keyword">if</span> (cancelled &amp;&amp; removeOnCancel &amp;&amp; heapIndex &gt;= <span class="number">0</span>) <span class="comment">//即使返回cancelled = true，任务还是有可能如实地运行，此时的队列移除更多的是针对未开始执行的任务</span></span><br><span class="line">            remove(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> cancelled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Overrides FutureTask version so as to reset/requeue if periodic.</span></span><br><span class="line"><span class="comment">     * 执行任务</span></span><br><span class="line"><span class="comment">     * 针对非重复执行的任务来说，直接执行即可</span></span><br><span class="line"><span class="comment">     * 针对重复执行的任务来说，在执行完任务后，又将该任务放入到队列中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> periodic = isPeriodic(); <span class="comment">//是否是重复执行的任务</span></span><br><span class="line">        <span class="keyword">if</span> (!canRunInCurrentRunState(periodic)) <span class="comment">//查看当前线程池的状态是否允许运行任务</span></span><br><span class="line">            cancel(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!periodic) <span class="comment">//若不是重复执行的任务，则直接运行任务</span></span><br><span class="line">            ScheduledFutureTask.<span class="keyword">super</span>.run();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 在runAndReset方法中运行任务，若任务运行失败了或被取消了，则返回false，导致周期性运行任务不在执行</span></span><br><span class="line"><span class="comment">         * FutureTask#runAndReset中并未设置任务的结果</span></span><br><span class="line"><span class="comment">         * 注意一下，将runner设置null是为了防止周期任务使用同一个线程，按道理来说，一个任务执行完毕了，该线程的任务也就即使了，等到下一个任务开始执行时，又会是另外一个线程</span></span><br><span class="line"><span class="comment">         * 从outerTask变量我们可以看出它保存了任务的信息，不管是对于上一个任务还是下一个任务来说都是同一个对象，所以我们有必要去更新runner变量的引用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ScheduledFutureTask.<span class="keyword">super</span>.runAndReset()) &#123;</span><br><span class="line">            setNextRunTime(); <span class="comment">//下一个执行的具体时间</span></span><br><span class="line">            reExecutePeriodic(outerTask); <span class="comment">//将重复执行的任务又放入到队列中等待下次执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将重复执行的任务放入到队列中</span></span><br><span class="line"><span class="comment"> * 注意一下，该方法只会被重复执行的任务所调用</span></span><br><span class="line"><span class="comment"> * 该方法与delayedExecute作用类似，在线程池处于SHUTDOWN状态下，添加任务到队列时会被直接拒绝，这很符合ThreadPoolExecutor的特性，而该方法添加任务时会根据参数来决定是否入队列，毕竟它已经执行过一次了</span></span><br><span class="line"><span class="comment"> * 所以ScheduledThreadPoolExecutor与ThreadPoolExecutor在这点的策略上会有所不同</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task 重复执行的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reExecutePeriodic</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//双重检查相当于在说明两件事，放不放到队列中是一回事，处不处理队列中的任务又是一个回事</span></span><br><span class="line">    <span class="keyword">if</span> (canRunInCurrentRunState(<span class="keyword">true</span>)) &#123; <span class="comment">//第一次检查，若此时线程池处于SHUTDOWN状态，则根据continueExistingPeriodicTasksAfterShutdown参数来决定是否继续执行任务</span></span><br><span class="line">        <span class="keyword">super</span>.getQueue().add(task);</span><br><span class="line">        <span class="keyword">if</span> (!canRunInCurrentRunState(<span class="keyword">true</span>) &amp;&amp; remove(task)) <span class="comment">//在第二次检查，走到这里说明任务已经放入到队列中了，此时若线程池处于SHUNTDOWN状态，则判断是否要处理队列中的任务，若不处理则移除</span></span><br><span class="line">            task.cancel(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ensurePrestart(); <span class="comment">//因为队列中已经存在任务了，为了防止因为线程池处于SHUTDOWN状态导致不存在任何的工作线程去处理队列中的任务，所以这里必须至少要有一个工作线程存在</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据当前线程池的状态决定是否允许执行任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> periodic 当前任务是否属于重复执行任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否允许执行任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canRunInCurrentRunState</span><span class="params">(<span class="keyword">boolean</span> periodic)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isRunningOrShutdown(periodic ? continueExistingPeriodicTasksAfterShutdown : executeExistingDelayedTasksAfterShutdown);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关闭线程池时清理队列中不执行的任务</span></span><br><span class="line"><span class="comment"> * 该方法是在关闭线程池时被调用，参看ThreadPoolExecutor#shutdown</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; q = <span class="keyword">super</span>.getQueue();</span><br><span class="line">    <span class="keyword">boolean</span> keepDelayed = getExecuteExistingDelayedTasksAfterShutdownPolicy(); <span class="comment">//当线程池处于SHUTDOWN状态时，是否继续执行非周期性任务</span></span><br><span class="line">    <span class="keyword">boolean</span> keepPeriodic = getContinueExistingPeriodicTasksAfterShutdownPolicy();<span class="comment">//当线程池处于SHUTDOWN状态时，是否继续执行周期性任务</span></span><br><span class="line">    <span class="keyword">if</span> (!keepDelayed &amp;&amp; !keepPeriodic) &#123; <span class="comment">//若两个都是false，则清空队列并更改任务的状态</span></span><br><span class="line">        <span class="keyword">for</span> (Object e : q.toArray())</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RunnableScheduledFuture&lt;?&gt;)</span><br><span class="line">                ((RunnableScheduledFuture&lt;?&gt;) e).cancel(<span class="keyword">false</span>);</span><br><span class="line">        q.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object e : q.toArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RunnableScheduledFuture) &#123;</span><br><span class="line">                RunnableScheduledFuture&lt;?&gt; t = (RunnableScheduledFuture&lt;?&gt;)e;</span><br><span class="line">                <span class="comment">//队列中不执行的任务将被移除</span></span><br><span class="line">                <span class="keyword">if</span> ((t.isPeriodic() ? !keepPeriodic : !keepDelayed) || t.isCancelled()) &#123; <span class="comment">// also remove if already cancelled</span></span><br><span class="line">                    <span class="keyword">if</span> (q.remove(t))</span><br><span class="line">                        t.cancel(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate(); <span class="comment">//尝试去终止线程池</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 立即执行任务，返回异步对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 异步对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">return</span> schedule(task, <span class="number">0</span>, NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 立即执行任务，返回异常对象，可获取任务的返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 异步对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> schedule(Executors.callable(task, result), <span class="number">0</span>, NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 立即执行任务，返回异步对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 异步对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> schedule(task, <span class="number">0</span>, NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当关闭线程池时，设置是否继续执行周期性任务的属性</span></span><br><span class="line"><span class="comment"> * 若是立即关闭线程池（shutdownNow）或此属性设置成false，则周期性任务不会被执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 关闭线程池时，是否继续执行周期性任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContinueExistingPeriodicTasksAfterShutdownPolicy</span><span class="params">(<span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">    continueExistingPeriodicTasksAfterShutdown = value;</span><br><span class="line">    <span class="keyword">if</span> (!value &amp;&amp; isShutdown())</span><br><span class="line">        onShutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当关闭线程时是否继续执行周期性任务的属性值，默认情况下是false</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 属性值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getContinueExistingPeriodicTasksAfterShutdownPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> continueExistingPeriodicTasksAfterShutdown;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当关闭线程池时，设置是否继续执行非周期性任务（延迟任务）的属性</span></span><br><span class="line"><span class="comment"> * 若是立即关闭线程池（shutdownNow）或此属性设置成false，则非周期性任务不会被执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 关闭线程池时，是否继续执行非周期性任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExecuteExistingDelayedTasksAfterShutdownPolicy</span><span class="params">(<span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">    executeExistingDelayedTasksAfterShutdown = value;</span><br><span class="line">    <span class="keyword">if</span> (!value &amp;&amp; isShutdown())</span><br><span class="line">        onShutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当关闭线程时是否继续执行非周期性任务的属性值，默认情况下是true</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 属性值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getExecuteExistingDelayedTasksAfterShutdownPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> executeExistingDelayedTasksAfterShutdown;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当任务被取消时，设置是否立即移除该任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 当任务被取消时，是否立即移除任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRemoveOnCancelPolicy</span><span class="params">(<span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">    removeOnCancel = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当任务被取消时，是否立即移除该任务，默认情况是false，建议设置成true</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 属性值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getRemoveOnCancelPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeOnCancel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该队列是基于二叉堆的数据结构，堆中分为最大堆与最小堆，它采用了最小堆，可参看之前的文章http://zlia.tech/2020/01/10/explain-binary-heap</span></span><br><span class="line"><span class="comment"> * 该队列会将执行时间较小的任务排列到前头，但是注意一下它只保证父节点的执行时间比子节点的执行时间小，而子节点之间的关系并不一定是有序的</span></span><br><span class="line"><span class="comment"> * 若对堆不熟悉或者不认识的读者最好先去了解下，因为本章不会详细介绍二叉堆的知识点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedWorkQueue</span> <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">Runnable</span>&gt; <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">Runnable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组的初始容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义数组用于存储二叉堆的所有节点，由于是数组故而需要扩容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> RunnableScheduledFuture&lt;?&gt;[] queue = <span class="keyword">new</span> RunnableScheduledFuture&lt;?&gt;[INITIAL_CAPACITY];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 防止并发</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉堆中所有节点的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Leader-Follower模型的变体，何为Leader-Follower自行搜索即可</span></span><br><span class="line"><span class="comment">     * 最小化不必要的等待时间</span></span><br><span class="line"><span class="comment">     * 若当前线程是个Leader（一种标识），始终都只有一个Leader线程，Leader线程只会等待任务执行的延迟时间，而其他的Follower线程处于一直等待状态，这就是所谓的Leader-Follower模型的变体</span></span><br><span class="line"><span class="comment">     * Leader线程在return之前必须去唤醒其他的线程，因为其他线程都处于等待状态下</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Thread leader = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 条件锁</span></span><br><span class="line"><span class="comment">     * 添加新任务时或线程成为Leader线程时，该锁会被唤醒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition available = lock.newCondition();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置索引</span></span><br><span class="line"><span class="comment">     * heapIndex用于快速取消，当取消一个任务时，该任务的索引会被设置成-1，且该索引处变成了null，如果在cancel方法中不加上heapIndex的判断，remove依然会走完</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setIndex</span><span class="params">(RunnableScheduledFuture&lt;?&gt; f, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ScheduledFutureTask)</span><br><span class="line">            ((ScheduledFutureTask)f).heapIndex = idx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上浮插入的节点以满足二叉堆的性质</span></span><br><span class="line"><span class="comment">     * 二叉堆的性质：ScheduledThreadPoolExecutor#DelayWorkQueue中采用的是最小堆，即父节点的时间比子节点的时间要小</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 插入的节点的操作步骤一般如下：</span></span><br><span class="line"><span class="comment">     * 1. 将插入的节点放到数组的末尾</span></span><br><span class="line"><span class="comment">     * 2. 由于需要父节点的时间比子节点的时间要小，故要与父节点进行比较</span></span><br><span class="line"><span class="comment">     * 3. 若插入的节点比父节点小，则将插入的节点与父节点进行值交换，在交换后它又有了新的父节点，故而需要继续往上比较，直到到底堆顶或不在小于父节点，相当于在重复步骤2</span></span><br><span class="line"><span class="comment">     * 4. 若插入的节点比父节点大，直接结束</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 假设一个节点的索引为：N，其父节点的索引为：(N - 1)/2，左子节点的索引为：2N + 1，其右子节点的索引为：2N + 2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k 插入的节点的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 插入的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, RunnableScheduledFuture&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">//父节点的索引</span></span><br><span class="line">            RunnableScheduledFuture&lt;?&gt; e = queue[parent]; <span class="comment">//父节点</span></span><br><span class="line">            <span class="keyword">if</span> (key.compareTo(e) &gt;= <span class="number">0</span>) <span class="comment">//插入的节点与父节点进行比较，若大于则直接退出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 走到这里说明插入节点的值小于父节点的值，不过它不是急于将插入节点的值直接放入到父节点的位置上，因为即使在交换后它仍然还有父节点，还需要在往上进行比较</span></span><br><span class="line"><span class="comment">             * 所以能确定的是将父节点放到插入节点的位置上，而对于插入的节点等最终比较完毕了在放入，即while循环后续的代码</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            queue[k] = e;</span><br><span class="line">            setIndex(e, k);</span><br><span class="line">            k = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = key;</span><br><span class="line">        setIndex(key, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下沉节点以满足二叉堆的性质</span></span><br><span class="line"><span class="comment">     * 思路：</span></span><br><span class="line"><span class="comment">     * - 不管移除的是哪个节点，拿数组末尾的节点是最少成本的，因为拿该节点的值去覆盖移除节点的值来使其还是一颗完全二叉树，所以最终只要让其满足二叉堆性质就可以了</span></span><br><span class="line"><span class="comment">     * - 针对移除节点来说，就相当于把移除节点的位置空出来了，因为是二叉堆要满足其性质，所以就要考虑是它的子节点还是末尾的节点更适合来做移除节点的位置（最大堆/最小堆）</span></span><br><span class="line"><span class="comment">     * - 因为末尾元素最终都会被移动到指定位置，故而先将末尾位置置null</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 针对要移除的节点分为两种情况（最小堆）：</span></span><br><span class="line"><span class="comment">     * 1. 移除的节点无子节点，也就是说是叶子节点，如下步骤：</span></span><br><span class="line"><span class="comment">     *       11. 直接将末尾的节点的值覆盖，同时将末尾位置设置成null，因为它并无节点，所以不用考虑是否比子节点大，但是有一点要考虑是覆盖完后是否比父节点还要小</span></span><br><span class="line"><span class="comment">     *       12. 若比父节点还要小的话就要做上浮操作，即调用siftUp即可，最后退出</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. 删除的节点有子节点，如下步骤：</span></span><br><span class="line"><span class="comment">     *       21. 先比较两个子节点的值的大小，获取值最小的节点</span></span><br><span class="line"><span class="comment">     *       22. 在将值最小的节点与末尾的节点进行比较（若只有一个子节点的话，那么只能是左子节点，就直接比较大小）</span></span><br><span class="line"><span class="comment">     *       23. 若是末尾的节点更小的话，那么直接覆盖移除的节点的值即可，同时将末尾位置设置成null，最后退出</span></span><br><span class="line"><span class="comment">     *       24. 若是其子节点更小的话，那么用其值最小的节点覆盖到移除的节点的值，此时值最小的节点的位置就空出来了（相当于此时它被移除了），那么此时重复步骤12</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 假设一个节点的索引为：N，其父节点的索引为：(N - 1)/2，左子节点的索引为：2N + 1，其右子节点的索引为：2N + 2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k 移除节点的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 末尾节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, RunnableScheduledFuture&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">//通过该值来判断移除节点是否有子节点，可以画几个例子验证下，我也不懂怎么来的，只能说写算法的人牛逼</span></span><br><span class="line">        <span class="keyword">while</span> (k &lt; half) &#123; <span class="comment">//若是进入循环说明移除节点是存在子节点的，有可能是存在左右子节点，也有可能只存在左子节点</span></span><br><span class="line">            <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">//移除节点的左子节点的索引</span></span><br><span class="line">            RunnableScheduledFuture&lt;?&gt; c = queue[child]; <span class="comment">//左子节点的值</span></span><br><span class="line">            <span class="keyword">int</span> right = child + <span class="number">1</span>;<span class="comment">//移除节点的右子节点的索引</span></span><br><span class="line">            <span class="keyword">if</span> (right &lt; size &amp;&amp; c.compareTo(queue[right]) &gt; <span class="number">0</span>) <span class="comment">//先判断是否存在右子节点，若左右子节点都存在，那么要找出值最小的节点</span></span><br><span class="line">                c = queue[child = right];</span><br><span class="line">            <span class="keyword">if</span> (key.compareTo(c) &lt;= <span class="number">0</span>) <span class="comment">//末尾节点与值最小的节点进行比较</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = c; <span class="comment">//这里的操作与siftUp同理</span></span><br><span class="line">            setIndex(c, k);</span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = key;</span><br><span class="line">        setIndex(key, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列以50%的速率进行扩容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = queue.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">// grow 50%</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            newCapacity = Integer.MAX_VALUE;</span><br><span class="line">        queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取队列中指定任务的索引</span></span><br><span class="line"><span class="comment">     * 若不存在指定任务则返回-1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 指定任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 指定任务的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x <span class="keyword">instanceof</span> ScheduledFutureTask) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = ((ScheduledFutureTask) x).heapIndex;</span><br><span class="line">                <span class="comment">// Sanity check; x could conceivably be a</span></span><br><span class="line">                <span class="comment">// ScheduledFutureTask from some other pool.</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; size &amp;&amp; queue[i] == x)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                    <span class="keyword">if</span> (x.equals(queue[i]))</span><br><span class="line">                        <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取队列中是否包含指定任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 指定任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否包含指定任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> indexOf(x) != -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取队列中是否成功移除指定任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 指定任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = indexOf(x);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            setIndex(queue[i], -<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> s = --size;</span><br><span class="line">            RunnableScheduledFuture&lt;?&gt; replacement = queue[s]; <span class="comment">//获取末尾的节点</span></span><br><span class="line">            queue[s] = <span class="keyword">null</span>; <span class="comment">//预先将末尾的节点置null，因为末尾的节点会移动到其他位置上</span></span><br><span class="line">            <span class="keyword">if</span> (s != i) &#123; <span class="comment">//若为true，说明移除的节点不是末尾节点</span></span><br><span class="line">                siftDown(i, replacement);<span class="comment">//下沉只是以移除节点为起始段往下开始比较，但它的上部分并未比较，所以有可能出现移动完毕的节点比父节点的值还大</span></span><br><span class="line">                <span class="keyword">if</span> (queue[i] == replacement) <span class="comment">//走到这里说明下沉结束，表示末尾的节点已经移动完成，移动后有可能出现末尾节点的值比父节点的值还小，针对siftDown方法注释中的11-12点</span></span><br><span class="line">                    siftUp(i, replacement);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取队列中的第一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; peek() &#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列中插入指定任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 指定任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(Runnable x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;)x;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = size;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">                grow(); <span class="comment">//队列扩容</span></span><br><span class="line">            size = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                queue[<span class="number">0</span>] = e;</span><br><span class="line">                setIndex(e, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                siftUp(i, e); <span class="comment">//插入节点后进行上浮操作</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (queue[<span class="number">0</span>] == e) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 这里需要注意下！！！</span></span><br><span class="line"><span class="comment">                 * 走到这里表明队列中的堆顶节点已经换成插入的节点，简单来说就是队列更新了，在这个过程中有可能已经在执行take方法中的 available.awaitNanos(delay) 语句，那么此时的等待时间已经没有意义了</span></span><br><span class="line"><span class="comment">                 * 所以执行了available.signal（个人觉得还应该去判断是否堆顶节点改变了，但不一定是插入的节点成为了新的堆顶节点），因为队列的堆顶节点都更新了，需要重新获取并等待，由于可能存在多个线程，故将leader设置成null，让线程* 之间去竞争谁成为Leader线程</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                leader = <span class="keyword">null</span>;</span><br><span class="line">                available.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除堆顶节点</span></span><br><span class="line"><span class="comment">     * 执行该方法说明已经到达任务的执行时间，需要将该节点从队列中移除掉，就相当于了移除掉了堆顶节点，按照siftDown的思路我们知道拿末尾节点是最小成本的</span></span><br><span class="line"><span class="comment">     * 在remove方法中还调用了siftUp，但由于是这里是从堆顶开始比较，所以无需在往上比较了</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> f 堆顶节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 堆顶节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> RunnableScheduledFuture&lt;?&gt; finishPoll(RunnableScheduledFuture&lt;?&gt; f) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = --size;</span><br><span class="line">        RunnableScheduledFuture&lt;?&gt; x = queue[s];</span><br><span class="line">        queue[s] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">            siftDown(<span class="number">0</span>, x);</span><br><span class="line">        setIndex(f, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 立即获取可执行的堆顶节点</span></span><br><span class="line"><span class="comment">     * 可执行表示已到达执行任务的时间，若还未到达则返回null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 堆顶节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; poll() &#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span> || first.getDelay(NANOSECONDS) &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> finishPoll(first);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取可执行的堆顶节点</span></span><br><span class="line"><span class="comment">     * 可执行表示已到达执行任务的时间，若未到达则会进行等待</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 这里使用了Leader-Follower模型的变体，简单来说，多个线程会同时去抢夺队列中的堆顶节点，谁抢到了谁就成为Leader线程，而其他线程要一直阻塞着，这些线程成为Follower线程</span></span><br><span class="line"><span class="comment">     * 1. 假设A线程抢到了，那么最终会执行到 available.awaitNanos(delay) 等待一定的时间，注意一下，该方法是会释放锁的！！！当初也是因为没注意到该点也花费了很多时间</span></span><br><span class="line"><span class="comment">     * 2. 既然释放了锁，那么其他Follower线程也就可以进行来了，陆续执行到 available.await() 语句上进行阻塞</span></span><br><span class="line"><span class="comment">     * 3. 想象一下，如果不对其他线程进行阻塞，同样执行到 available.awaitNanos(delay) 语句，A线程已经执行完毕了早就返回了，而你这个时候的等待时间就相当于是白费了，所以它直接采用了一直等待的策略</span></span><br><span class="line"><span class="comment">     * 3. 等待Leader线程执行完毕后才会唤醒其中一个线程，这个时候唤醒的线程就变成了Leader线程</span></span><br><span class="line"><span class="comment">     * 4. 所以说Leader-Follower模型的变体是始终都只有一个Leader线程，多个Follower线程</span></span><br><span class="line"><span class="comment">     * 总结：Leader-Follower模型的变体减少了不必要的等待时间</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 可执行的堆顶节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; take() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                    available.await();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) </span><br><span class="line">                        <span class="keyword">return</span> finishPoll(first); <span class="comment">//走到这里说明是可执行的任务</span></span><br><span class="line">                    first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line">                    <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                        available.await();</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        Thread thisThread = Thread.currentThread();</span><br><span class="line">                        leader = thisThread;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            available.awaitNanos(delay);<span class="comment">//Leader线程阻塞一定的延迟时间，注意该方法会释放锁</span></span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                                leader = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; queue[<span class="number">0</span>] != <span class="keyword">null</span>) <span class="comment">//始终都会有一个Leader线程</span></span><br><span class="line">                available.signal();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取可执行的堆顶节点</span></span><br><span class="line"><span class="comment">     * 可执行表示已到达执行任务的时间，若在指定时间内还未到达则返回null，所以等待时间最好大于延迟时间</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 1. 若nanos &lt; delay 最终会返回null，需要多次调用poll才能获取到可执行的任务</span></span><br><span class="line"><span class="comment">     * 2. 若nanos &gt; delay 最终只会等待延迟时间后就返回</span></span><br><span class="line"><span class="comment">     * 3. 当Leader != null时，说明已经有Leader线程在处理堆顶节点了，其他线程等着就是了</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 等待时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 可执行的堆顶节点或null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; poll(<span class="keyword">long</span> timeout, TimeUnit unit) <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        nanos = available.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> finishPoll(first);<span class="comment">//走到这里说明是可执行的任务</span></span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt; delay || leader != <span class="keyword">null</span>) <span class="comment">//若nanos &lt; delay 最终会返回null，需要多次调用poll才能获取到可执行的任务；若leader != null，说明有Leader线程获取了堆顶节点，其他线程等着就是了</span></span><br><span class="line">                        nanos = available.awaitNanos(nanos);</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        Thread thisThread = Thread.currentThread();</span><br><span class="line">                        leader = thisThread;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">long</span> timeLeft = available.awaitNanos(delay);</span><br><span class="line">                            nanos -= delay - timeLeft;<span class="comment">//计算剩余的等待时间</span></span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                                leader = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; queue[<span class="number">0</span>] != <span class="keyword">null</span>)</span><br><span class="line">                available.signal();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                RunnableScheduledFuture&lt;?&gt; t = queue[i];</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue[i] = <span class="keyword">null</span>;</span><br><span class="line">                    setIndex(t, -<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取可执行的堆顶节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 可执行的堆顶节点或null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> RunnableScheduledFuture&lt;?&gt; peekExpired() &#123;</span><br><span class="line">        <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line">        RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> (first == <span class="keyword">null</span> || first.getDelay(NANOSECONDS) &gt; <span class="number">0</span>) ?</span><br><span class="line">            <span class="keyword">null</span> : first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清除可执行的所有节点，并将这些节点放入集合中</span></span><br><span class="line"><span class="comment">     * 该方法会在调用ThreadPoolExecutor#shutdownNow时被调用，实际上最终队列中的任务都会被清除</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c 集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 可执行节点的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> Runnable&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RunnableScheduledFuture&lt;?&gt; first;</span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((first = peekExpired()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                c.add(first);   <span class="comment">// In this order, in case add() throws.</span></span><br><span class="line">                finishPoll(first);</span><br><span class="line">                ++n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清除可执行节点，并将这些节点放入集合中，与上面的方法相比控制了清除节点的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c 集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 可执行节点的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> Runnable&gt; c, <span class="keyword">int</span> maxElements)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (maxElements &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RunnableScheduledFuture&lt;?&gt; first;</span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n &lt; maxElements &amp;&amp; (first = peekExpired()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                c.add(first);   <span class="comment">// In this order, in case add() throws.</span></span><br><span class="line">                finishPoll(first);</span><br><span class="line">                ++n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用迭代器可获取队列中的任务，这里就不贴了...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><ul><li><p>当线程池处于SHUTDOWN时，是否继续执行队列中的任务，包括重复执行的任务与延迟的任务，针对这两者取决于continueExistingPeriodicTasksAfterShutdown与executeExistingDelayedTasksAfterShutdown属性</p></li><li><p>重复执行任务的原理：任务对象中有一个outerTask属性指向自身，在上一个任务执行完毕后会更新下一个任务的执行时间，并将下一个任务再次放入到队列中（上一个任务在执行前就已经从队列中移除了），重复此操作</p></li><li><p>scheduleAtFixedRate：按照一定的频率去执行任务，下一个任务的执行时间从上一个任务开始执行的时间开始算起，所以有可能导致已经到达下一个任务的执行了，但上一个任务还未执行结束的情况，直到上一个任务执行结束了，下一个任务立即被执行</p></li><li><p>scheduleWithFixedDelay：按照一定的周期去执行任务，下一个任务的执行时间从上一个任务执行结束后的时间开始算起，所以下一个任务的执行时间严重依赖于上一个任务</p></li><li><p>removeOnCancel：该属性表明当取消队列中的任务时是否立即将任务从队列中移除，建议设置成true，而默认情况下是false，这会造成时间成本上的浪费，简单来说，被取消的任务会更改其状态，除此之外，它仍会像其他任务一样被获取然后等待一定的延迟时间后，直到可执行了，那么此时去执行时发现它的状态不对，就只能不了了之了，要是延迟时间在长点…，不可想象了！</p></li><li><p>DelayedWorkQueue队列采用二叉堆（最小堆）数据结构，其中使用了Leader-Follower模型的变体，始终只有一个Leader线程在处理队列中的堆顶节点，其他Follower线程只能等待着</p></li><li><p>老版本的JDK中通常使用Timer，但其实该类存在一些<code>缺陷</code>：通过单线程来执行所有的任务，若其中一个任务执行时间过长，将会导致其他任务无法执行或者无法准时执行；若其中一个任务抛出异常，其他的任务将不会再运行；Timer的执行时间依赖于系统时间，也就是说针对不同的平台，比如Window、Linux平台下可能会有不同的行为，而ScheduledThreadPool中的now采用的System.nanoTime，该方法不关联系统时间，它代表了从某个固定时间点到现在所经过的毫秒数，该计算方式跟JVM有关系，不同的JVM可能固定时间点不同，对于不同的平台使用的JVM肯定是同一个，所以不管再哪个平台下任务的行为都是一样的</p></li></ul><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a><div><span>总结</span></div></h3><p>知识点过多，建议当作好几篇文章分开看，笔者断断续续花了应该有2个月时间，若有错误欢迎指出！</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><div><span>参考资料</span></div></h3><p>《Java编程思想》</p><p><a href="https://blog.csdn.net/chang_ge/article/details/80080382" target="_blank" rel="noopener">https://blog.csdn.net/chang_ge/article/details/80080382</a></p><p><a href="https://blog.csdn.net/lmj623565791/article/details/27109467" target="_blank" rel="noopener">https://blog.csdn.net/lmj623565791/article/details/27109467</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前奏&quot;&gt;&lt;a href=&quot;#前奏&quot; class=&quot;headerlink&quot; title=&quot;前奏&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前奏&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Executor&lt;/code&gt;是家族中的老大，其下还有ExecutorService、Executors、ThreadPoolExecutor、ScheduledThreadPoolExecutor和ForkJoinPool，对于ForkJoinPool是在JDK1.7中新增的，其中可能还涉及到诸多理论，故而打算会另起文章进行说明。不管是在工作还是面试中，难免会耳闻线程池，简单说下个人对线程池的理解，后续将对Executor的家族成员做一一介绍，让我们开始旅程吧，此次探索基于&lt;code&gt;JDK1.8&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;线程池&lt;/code&gt;：将创建好的线程放到一个池中进行使用、调度及管理，等到任务一提交后就可以直接运行了，省去了创建线程的时间，同时使用者不必考虑如何管理线程，让使用者更加专注于任务。线程池中会涉及到核心线程数（corePoolSize）、最大线程数（maximumPoolSize）、队列，假设线程个数小于核心线程数，对于新提交的任务会直接创建新线程，当线程个数超过核心线程数且队列未满时，将新任务放入到队列中，等到空闲线程后再去执行，万一要是队列满了且线程数不超过最大线程数时，则会创建新线程执行任务，哪天要是大于最大线程数，则任务将被拒绝，对于拒绝可指定不同的策略，后续将会详细介绍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;家族成员&quot;&gt;&lt;a href=&quot;#家族成员&quot; class=&quot;headerlink&quot; title=&quot;家族成员&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;家族成员&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p class=&quot;customize-img&quot;&gt;&lt;img src=&quot;/assets/blogImg/java/executor/executor-class-structure.png&quot; alt=&quot;Executor家族成员&quot;&gt;&lt;/p&gt;
&lt;p&gt;每个成员的地位很明确了，我们从Executors开始入手。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>认识堆</title>
    <link href="http://zlia.tech/2020/01/10/explain-binary-heap/"/>
    <id>http://zlia.tech/2020/01/10/explain-binary-heap/</id>
    <published>2020-01-10T03:00:30.000Z</published>
    <updated>2020-01-10T03:00:30.287Z</updated>
    
    <content type="html"><![CDATA[<h3 id="堆的概念"><a href="#堆的概念" class="headerlink" title="堆的概念"></a><div><span>堆的概念</span></div></h3><p>堆实际上是一颗树，只不过在其基础上又加上新的性质，常见的堆有：二叉堆、二项堆、斐波那契堆等，其性质如下：</p><ul><li><p>是一颗树，百度百科/维基百科上都说是一颗完全二叉树，但实际中二项堆并不是</p></li><li><p>父节点的值总是<code>大于或等于</code>（<code>小于或等于</code>）任何一个子节点的值，注意始终都没有说子节点之间的关系，也就是说子节点之间的关系并不重要</p></li></ul><p>针对性质二又可以分为<code>最大堆/大根堆</code>与<code>最小堆/小根堆</code>，解释如下：</p><blockquote><p><code>最大堆/大根堆</code>：堆中的父节点的值总是大于等于它的子节点</p></blockquote><blockquote><p><code>最小堆/小根堆</code>：堆中的父节点的值总是小于等于它的子节点</p></blockquote><blockquote><p><code>堆顶</code>：二叉树的第一个节点称为根节点，而二叉堆称为堆顶</p></blockquote><p>较为经常使用的是二叉堆，虽然通常说的堆结构即是指二叉堆，以至于两者的概念有点混淆，即使是百科也存在模糊不清，一会说是树又是完全二叉树？但我仍然还是想作一下区分，毕竟堆中还有其他的数据结构，而其数据结构必然符合堆的性质，所以我认为堆是一棵树！</p><a id="more"></a><h4 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h4><p>二叉堆是一颗<code>完全二叉树</code>，对于完全二叉树的定义可参看之前的<a href="http://zlia.tech/2019/09/11/explain-binarytree">文章</a>。二叉堆的存储结构一般用<code>数组</code>来表示，假设某一个节点的索引为：N，其左节点的索引应为：2N + 1，其右子节点的索引为：2N + 2，如下所示:</p><p class="customize-img"><img src="/assets/blogImg/algorithm/heap/binaryheap-structure-2.png" alt="二叉堆结构"></p><p>发现没有，它是按照二叉树的前序方式排列到数组中，所谓<code>前序</code>简单来说就是父节点放第一个，中序就是父节点放中间，后序自然就是父节点放最后一个了。还有一点需要注意下，二叉堆中并未要求左右子节点的值大小要求，也可以将值理解成<code>优先级</code>，对于最大堆来说，认为值越大说明优先级越高，位置更靠前，而对于最小堆来说，认定值越小优先级越高，这就看需要了！对于二叉树来说，通常左节点的值要比父节点小，而右子节点的值要比父节点大，但对于二叉堆来说，左右节点的值要么是大于等于父节点的值要么是小于等于。</p><h4 id="二项堆"><a href="#二项堆" class="headerlink" title="二项堆"></a>二项堆</h4><p>二项堆是二项树的集合，简单来说，就是在二项树的基础上加上了其他性质，二项树的性质如下：</p><ul><li><p>高/深度为K的树，根节点下有K个子节点，每个子节点的高/深度分别是K-1、K-2、…2、1、0</p></li><li><p>高/深度为K的树，共有有2<sup>K-1</sup>个节点，百科中认为高/深度是从0开始算起，有些书籍是从1开始算起，因为之前有关树的介绍文章中也是1，故而还是按照以前的说法！</p></li></ul><p>接下来说说二项堆的性质：</p><ul><li><p>每颗二项树都是<code>最小堆</code>，即父节点的值总是小于等于它的子节点</p></li><li><p>不能有两颗或以上的二项树有相同的高/深度，换句话说，具有高/深度的二项树有0或1个</p></li></ul><p>与二叉堆相比，其优势是可以快速合并两个堆，一般使用<code>链表</code>作为其存储结构，由于过于复杂直接引用了网上的图片，如下图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/heap/binomialheap-structure-3.png" alt="二项堆结构"></p><h4 id="斐波那契堆"><a href="#斐波那契堆" class="headerlink" title="斐波那契堆"></a>斐波那契堆</h4><p>网上资料，包括百科都解释地稀里糊涂，各种语言实现，我想说能先把概念描述清楚了在谈其他吗？基本上每篇文章都是照搬《算法导论》的知识点，我没看过这本书，所以不敢往下结论，只是在这里告诉读者有这么一种类型的堆！顺便附上网上引用的关于其存储结构的图片，如下图所示：</p><p class="customize-img"><img src="/assets/blogImg/algorithm/heap/fibonacciheap-4.png" alt="斐波那契堆结构"></p><h3 id="二叉堆的设计与实现"><a href="#二叉堆的设计与实现" class="headerlink" title="二叉堆的设计与实现"></a><div><span>二叉堆的设计与实现</span></div></h3><p>尝试手写了二叉堆，因为其较为常用，剩下两种数据结构比较难，对于基础不好或是不感兴趣的读者建议绕开！有兴趣的同学可以去github上观摩-<a href="https://github.com/JulianHang/little-java-project/blob/master/src/tech/zlia/interest/algorithm/tree/heap/MaximumBinaryHeap.java" target="_blank" rel="noopener">二叉堆设计</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><div><span>总结</span></div></h3><p>笔者也是第一次接触到关于堆的概念，所以此篇文章更多的是帮助读者去认识它！若有讲解不到位的地方欢迎指出，将积极改正。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;堆的概念&quot;&gt;&lt;a href=&quot;#堆的概念&quot; class=&quot;headerlink&quot; title=&quot;堆的概念&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;堆的概念&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;堆实际上是一颗树，只不过在其基础上又加上新的性质，常见的堆有：二叉堆、二项堆、斐波那契堆等，其性质如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;是一颗树，百度百科/维基百科上都说是一颗完全二叉树，但实际中二项堆并不是&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;父节点的值总是&lt;code&gt;大于或等于&lt;/code&gt;（&lt;code&gt;小于或等于&lt;/code&gt;）任何一个子节点的值，注意始终都没有说子节点之间的关系，也就是说子节点之间的关系并不重要&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;针对性质二又可以分为&lt;code&gt;最大堆/大根堆&lt;/code&gt;与&lt;code&gt;最小堆/小根堆&lt;/code&gt;，解释如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;最大堆/大根堆&lt;/code&gt;：堆中的父节点的值总是大于等于它的子节点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;最小堆/小根堆&lt;/code&gt;：堆中的父节点的值总是小于等于它的子节点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;堆顶&lt;/code&gt;：二叉树的第一个节点称为根节点，而二叉堆称为堆顶&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;较为经常使用的是二叉堆，虽然通常说的堆结构即是指二叉堆，以至于两者的概念有点混淆，即使是百科也存在模糊不清，一会说是树又是完全二叉树？但我仍然还是想作一下区分，毕竟堆中还有其他的数据结构，而其数据结构必然符合堆的性质，所以我认为堆是一棵树！&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="algorithm" scheme="http://zlia.tech/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>揭开面纱-ThreadGroup</title>
    <link href="http://zlia.tech/2019/12/12/explain-threadgroup-sourcecode/"/>
    <id>http://zlia.tech/2019/12/12/explain-threadgroup-sourcecode/</id>
    <published>2019-12-12T09:41:37.000Z</published>
    <updated>2019-12-15T03:56:12.410Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开门见山"><a href="#开门见山" class="headerlink" title="开门见山"></a><div><span>开门见山</span></div></h3><p>ThreadGroup在实际开发中很少用到，不过由于它跟Thread的关系比较密切，所以还是了解下为妙，揭开ThreadGroup的面纱是基于<code>JDK1.8</code>。通过阅读注释及相关文章，可以知道ThreadGroup的结构如下：</p><p class="customize-img"><img src="/assets/blogImg/java/thread-group/threadgroup-structure.png" alt="线程组结构"></p><p>除了初始线程组（JVM所属）以外，每个线程组都有一个父线程组及子线程组，父线程组中有个成员变量（groups）来记录它所有的子线程组，所以线程组之间的关系被看作是一棵<code>树</code>。线程组下有多个线程，我们可以将线程组理解成是对一组线程进行操作。</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadGroup</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//父线程组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程组的名称</span></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程组的最大优先级，该优先级不能大于父线程组的优先级</span></span><br><span class="line">    <span class="keyword">int</span> maxPriority;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程组是否已经销毁（清除）</span></span><br><span class="line">    <span class="keyword">boolean</span> destroyed;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//线程组是否是守护线程组</span></span><br><span class="line">    <span class="keyword">boolean</span> daemon;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//未启动的线程个数，即未调用start方法的线程个数</span></span><br><span class="line">    <span class="keyword">int</span> nUnstartedThreads = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//已启动的线程个数，即已调用start方法的线程个数</span></span><br><span class="line">    <span class="keyword">int</span> nthreads;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//已启动的线程个数，该数组会通过创建新数组拷贝源数组的方式进行扩容，新数组的容量是源数据的2倍</span></span><br><span class="line">    Thread threads[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子线程组的个数</span></span><br><span class="line">    <span class="keyword">int</span> ngroups;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储所有子线程组</span></span><br><span class="line">    ThreadGroup groups[];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造线程组，该构造方式通常是创建系统级别的线程组，如由底层C代码来构造初始线程组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"system"</span>;</span><br><span class="line">    <span class="keyword">this</span>.maxPriority = Thread.MAX_PRIORITY;</span><br><span class="line">    <span class="keyword">this</span>.parent = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 线程组的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadGroup</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Thread.currentThread().getThreadGroup(), name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造线程组并指定父线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parant 父线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 线程组的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadGroup</span><span class="params">(ThreadGroup parent, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(checkParentAccess(parent), parent, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造线程组并指定父线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unused 未使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parant 父线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 线程组的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadGroup</span><span class="params">(Void unused, ThreadGroup parent, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.maxPriority = parent.maxPriority;</span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.daemon;</span><br><span class="line">    <span class="keyword">this</span>.vmAllowSuspension = parent.vmAllowSuspension;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    parent.add(<span class="keyword">this</span>); <span class="comment">//指定父线程组后，要将其添加到父线程组所属的子线程组数组中，维护其关系</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程组的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程组的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程组的父线程组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ThreadGroup <span class="title">getParent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>)</span><br><span class="line">        parent.checkAccess();</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程组的最大优先级</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程组的最大优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getMaxPriority</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxPriority;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程组是否是守护线程组</span></span><br><span class="line"><span class="comment"> * 若当前线程组是守护线程组，则当线程组中的线程都终止了或其子线程组都终止了则会自动调用destroy方法</span></span><br><span class="line"><span class="comment"> * 实际上在线程终止底层后调用Thread#exit方法，通过该方法来终止守护线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否是守护线程组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isDaemon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> daemon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程组是否已销毁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否已销毁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isDestroyed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> destroyed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置线程组是否是守护线程组</span></span><br><span class="line"><span class="comment"> * true-属于守护线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> daemon 标志</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setDaemon</span><span class="params">(<span class="keyword">boolean</span> daemon)</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">this</span>.daemon = daemon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置线程组的最大优先级</span></span><br><span class="line"><span class="comment"> * 线程的优先级与线程组的最大优先级互不影响，也就是说即使线程的优先级比线程组的最大优先级还高也不影响</span></span><br><span class="line"><span class="comment"> * 当前线程组的最大优先级不能超过父线程组的最大优先级</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pri 最大优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setMaxPriority</span><span class="params">(<span class="keyword">int</span> pri)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ngroupsSnapshot;</span><br><span class="line">    ThreadGroup[] groupsSnapshot;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="keyword">if</span> (pri &lt; Thread.MIN_PRIORITY || pri &gt; Thread.MAX_PRIORITY) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxPriority = (parent != <span class="keyword">null</span>) ? Math.min(pri, parent.maxPriority) : pri; <span class="comment">//当前线程组的最大优先级不能超过父线程组的最大优先级</span></span><br><span class="line">        ngroupsSnapshot = ngroups;</span><br><span class="line">        <span class="keyword">if</span> (groups != <span class="keyword">null</span>) &#123;</span><br><span class="line">            groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i++) &#123;</span><br><span class="line">        groupsSnapshot[i].setMaxPriority(pri); <span class="comment">//递归更改其子线程组的最大优先级</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前线程组是否与指定线程组是同一个对象或是指定线程组的父线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> g 指定线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parentOf</span><span class="params">(ThreadGroup g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; g != <span class="keyword">null</span> ; g = g.parent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前线程组的活跃线程个数</span></span><br><span class="line"><span class="comment"> * 注意：线程组中还有子线程组，所以计算时也会包含子线程组</span></span><br><span class="line"><span class="comment"> * 该结果只是一个估算值，因为线程数一直在动态变化着，同时JVM也会有一些线程，所以可能会影响该计数结果</span></span><br><span class="line"><span class="comment"> * 该方法主要用来调试与监控</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程组的活跃线程个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">activeCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="keyword">int</span> ngroupsSnapshot;</span><br><span class="line">    ThreadGroup[] groupsSnapshot;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result = nthreads;</span><br><span class="line">        ngroupsSnapshot = ngroups;</span><br><span class="line">        <span class="keyword">if</span> (groups != <span class="keyword">null</span>) &#123;</span><br><span class="line">            groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i++) &#123;</span><br><span class="line">        result += groupsSnapshot[i].activeCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前线程组及其子线程组的活跃线程拷贝到指定数组中</span></span><br><span class="line"><span class="comment"> * 要严格确保指定数组的大小大于活跃线程的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tarray 指定数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程组的活跃线程个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">enumerate</span><span class="params">(Thread list[])</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">return</span> enumerate(list, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前线程组的活跃线程拷贝到指定数组中</span></span><br><span class="line"><span class="comment"> * 通过recurse参数来决定是否拷贝子线程组</span></span><br><span class="line"><span class="comment"> * 要严格确保指定数组的大小大于活跃线程的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tarray 指定数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> recurse 决定是否拷贝子线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程组的活跃线程个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">enumerate</span><span class="params">(Thread list[], <span class="keyword">boolean</span> recurse)</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">return</span> enumerate(list, <span class="number">0</span>, recurse);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前线程组的活跃线程拷贝到指定数组中</span></span><br><span class="line"><span class="comment"> * 通过recurse参数来决定是否拷贝子线程组</span></span><br><span class="line"><span class="comment"> * 要严格确保指定数组的大小大于活跃线程的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tarray 指定数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 从指定数组的指定起始索引开始添加</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> recurse 决定是否拷贝子线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程组的活跃线程个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">enumerate</span><span class="params">(Thread list[], <span class="keyword">int</span> n, <span class="keyword">boolean</span> recurse)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ngroupsSnapshot = <span class="number">0</span>;</span><br><span class="line">    ThreadGroup[] groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nt = nthreads;</span><br><span class="line">        <span class="keyword">if</span> (nt &gt; list.length - n) &#123; <span class="comment">//若指定数组的长度小于活跃线程的个数，则超过的活跃线程将被忽略</span></span><br><span class="line">            nt = list.length - n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nt; i++) &#123; <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (threads[i].isAlive()) &#123;</span><br><span class="line">                list[n++] = threads[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (recurse) &#123; <span class="comment">// 是否加入子线程组的活跃线程</span></span><br><span class="line">            ngroupsSnapshot = ngroups;</span><br><span class="line">            <span class="keyword">if</span> (groups != <span class="keyword">null</span>) &#123;</span><br><span class="line">                groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (recurse) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i++) &#123;</span><br><span class="line">            n = groupsSnapshot[i].enumerate(list, n, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前线程组的子线程组个数</span></span><br><span class="line"><span class="comment"> * 注意：当前线程组中还有子线程组，所以计算时也会包含子线程组</span></span><br><span class="line"><span class="comment"> * 该结果只是一个估算值，因为线程数一直在动态变化着</span></span><br><span class="line"><span class="comment"> * 该方法主要用来调试与监控</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程组的活跃线程个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">activeGroupCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ngroupsSnapshot;</span><br><span class="line">    ThreadGroup[] groupsSnapshot;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ngroupsSnapshot = ngroups;</span><br><span class="line">        <span class="keyword">if</span> (groups != <span class="keyword">null</span>) &#123;</span><br><span class="line">            groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = ngroupsSnapshot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i++) &#123;</span><br><span class="line">        n += groupsSnapshot[i].activeGroupCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前线程组及其子线程组的子线程组拷贝到指定数组中</span></span><br><span class="line"><span class="comment"> * 要严格确保指定数组的大小大于子线程组的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tarray 指定数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程组的子线程组个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">enumerate</span><span class="params">(ThreadGroup list[])</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">return</span> enumerate(list, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////其他enumerate方法就不做展示了，都是类似的/////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 终止当前线程组的所有线程，包括其子线程下的所有线程</span></span><br><span class="line"><span class="comment"> * 由于Thread#stop方法已废弃，故而该方法也是没啥用的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stopOrSuspend(<span class="keyword">false</span>))</span><br><span class="line">        Thread.currentThread().stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归挂起或终止当前线程组的所有线程，除了当前线程之外（会在调用方挂起或终止当前线程）</span></span><br><span class="line"><span class="comment"> * 同时也会挂起或终止其子线程组的所有线程</span></span><br><span class="line"><span class="comment"> * 该方法通过返回值来判断当前线程是否存在于当前线程组或子线程组中，若存在则在该方法返回后也会对当前线程进行挂机或终止，若不存在则不会进行任何操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> suspend true表示挂起  false表示终止</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 当前线程是否存在于当前线程组或子线程组中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">stopOrSuspend</span><span class="params">(<span class="keyword">boolean</span> suspend)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> suicide = <span class="keyword">false</span>;</span><br><span class="line">    Thread us = Thread.currentThread(); <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="keyword">int</span> ngroupsSnapshot;</span><br><span class="line">    ThreadGroup[] groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nthreads ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (threads[i]==us)</span><br><span class="line">                suicide = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (suspend)</span><br><span class="line">                threads[i].suspend();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                threads[i].stop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ngroupsSnapshot = ngroups;</span><br><span class="line">        <span class="keyword">if</span> (groups != <span class="keyword">null</span>) &#123;</span><br><span class="line">            groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i++)</span><br><span class="line">        suicide = groupsSnapshot[i].stopOrSuspend(suspend) || suicide;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> suicide;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中断当前线程组的所有线程，包括子线程组的所有线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ngroupsSnapshot;</span><br><span class="line">    ThreadGroup[] groupsSnapshot;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nthreads ; i++) &#123;</span><br><span class="line">            threads[i].interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        ngroupsSnapshot = ngroups;</span><br><span class="line">        <span class="keyword">if</span> (groups != <span class="keyword">null</span>) &#123;</span><br><span class="line">            groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i++) &#123;</span><br><span class="line">        groupsSnapshot[i].interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 销毁当前线程组及其子线程组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ngroupsSnapshot;</span><br><span class="line">    ThreadGroup[] groupsSnapshot;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="keyword">if</span> (destroyed || (nthreads &gt; <span class="number">0</span>)) &#123; <span class="comment">//如果还有运行中的线程则不允许销毁</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        ngroupsSnapshot = ngroups;</span><br><span class="line">        <span class="keyword">if</span> (groups != <span class="keyword">null</span>) &#123;</span><br><span class="line">            groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123; <span class="comment">//除了初始线程以外，线程组在销毁后需要清理资源</span></span><br><span class="line">            destroyed = <span class="keyword">true</span>;</span><br><span class="line">            ngroups = <span class="number">0</span>;</span><br><span class="line">            groups = <span class="keyword">null</span>;</span><br><span class="line">            nthreads = <span class="number">0</span>;</span><br><span class="line">            threads = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i += <span class="number">1</span>) &#123; <span class="comment">//销毁子线程组</span></span><br><span class="line">        groupsSnapshot[i].destroy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123; <span class="comment">//从父线程组中移除当前线程组，解除关系</span></span><br><span class="line">        parent.remove(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从当前线程组的子线程组中移除指定线程组</span></span><br><span class="line"><span class="comment"> * 若当前线程组是守护线程组，且不存在运行中及未启动的线程，且不不存在子线程组，相当于要移除的线程组是最后一个线程组，则销毁自身</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> g 指定线程组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadGroup g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroups ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (groups[i] == g) &#123;</span><br><span class="line">                ngroups -= <span class="number">1</span>;</span><br><span class="line">                System.arraycopy(groups, i + <span class="number">1</span>, groups, i, ngroups - i); <span class="comment">//在子线程组中移除指定线程组</span></span><br><span class="line">                groups[ngroups] = <span class="keyword">null</span>; <span class="comment">//手动置为null以便垃圾回收器能回收它</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nthreads == <span class="number">0</span>) &#123; <span class="comment">//这里我唯一想到的是可能有其他线程使用了当前对象锁</span></span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (daemon &amp;&amp; (nthreads == <span class="number">0</span>) &amp;&amp;  (nUnstartedThreads == <span class="number">0</span>) &amp;&amp; (ngroups == <span class="number">0</span>)) <span class="comment">//当前线程组是守护线程组，且不存在运行中及未启动的线程，且不存在子线程组</span></span><br><span class="line">        &#123;</span><br><span class="line">            destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对未启动的线程进行计数</span></span><br><span class="line"><span class="comment"> * 未启动的线程不会添加到线程组中，这样即使从未启动过的线程也会被收集，但是必须对它们进行计数，以便不会破坏守护线程组.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addUnstarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        nUnstartedThreads++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加已启动的线程到线程组中</span></span><br><span class="line"><span class="comment"> * 该方法可能会被JVM调用，因为有初始线程组要添加已启动的系统线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (threads == <span class="keyword">null</span>) &#123;</span><br><span class="line">            threads = <span class="keyword">new</span> Thread[<span class="number">4</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nthreads == threads.length) &#123;</span><br><span class="line">            threads = Arrays.copyOf(threads, nthreads * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        threads[nthreads] = t; <span class="comment">//添加已启动的线程</span></span><br><span class="line"></span><br><span class="line">        nthreads++; <span class="comment">//计数已启动的线程个数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为只有在线程启动后才会调用该方法，故而未启动的线程个数应该减去1</span></span><br><span class="line">        nUnstartedThreads--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定线程启动失败后会调用此方法</span></span><br><span class="line"><span class="comment"> * 线程启动失败后，应该对未启动的线程个数进行计数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t 指定线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadStartFailed</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        remove(t);</span><br><span class="line">        nUnstartedThreads++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从当前线程组中移除指定线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t 指定线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nthreads ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (threads[i] == t) &#123;</span><br><span class="line">                System.arraycopy(threads, i + <span class="number">1</span>, threads, i, --nthreads - i);</span><br><span class="line">                threads[nthreads] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定线程终止后调用此方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t 指定线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadTerminated</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        remove(t);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nthreads == <span class="number">0</span>) &#123; <span class="comment">//这里我唯一想到的是可能有其他线程使用了当前对象锁</span></span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (daemon &amp;&amp; (nthreads == <span class="number">0</span>) &amp;&amp; (nUnstartedThreads == <span class="number">0</span>) &amp;&amp; (ngroups == <span class="number">0</span>)) <span class="comment">//当前线程组是守护线程组，且不存在运行中及未启动的线程，且不存在子线程组</span></span><br><span class="line">        &#123;</span><br><span class="line">            destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印线程组的信息到标准输出，包括活跃的线程及其子线程组的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    list(System.out, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印线程组的信息到标准输出，包括活跃的线程及其子线程组的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">list</span><span class="params">(PrintStream out, <span class="keyword">int</span> indent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ngroupsSnapshot;</span><br><span class="line">    ThreadGroup[] groupsSnapshot;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; indent ; j++) &#123;</span><br><span class="line">            out.print(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        out.println(<span class="keyword">this</span>);</span><br><span class="line">        indent += <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nthreads ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; indent ; j++) &#123;</span><br><span class="line">                out.print(<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(threads[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ngroupsSnapshot = ngroups;</span><br><span class="line">        <span class="keyword">if</span> (groups != <span class="keyword">null</span>) &#123;</span><br><span class="line">            groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i++) &#123;</span><br><span class="line">        groupsSnapshot[i].list(out, indent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当线程未设置自定义异常处理器，则当线程发生异常时，会调用该方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t 当前发生异常的线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 异常信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123; </span><br><span class="line">        parent.uncaughtException(t, e); <span class="comment">//若线程未设置自定义异常处理器，则使用父线程组的异常</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Thread.UncaughtExceptionHandler ueh = Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">        <span class="keyword">if</span> (ueh != <span class="keyword">null</span>) &#123; <span class="comment">//线程是否设置了默认的异常处理器</span></span><br><span class="line">            ueh.uncaughtException(t, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> ThreadDeath)) &#123;</span><br><span class="line">            System.err.print(<span class="string">"Exception in thread \""</span> + t.getName() + <span class="string">"\" "</span>);</span><br><span class="line">            e.printStackTrace(System.err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">"[name="</span> + getName() + <span class="string">",maxpri="</span> + maxPriority + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>除了初始线程组以外，每个线程组都有一个父线程组及子线程组，这样子的关系被看作是一棵树</p></li><li><p>若线程组是守护线程组，则在满足一定的条件下会自动调用销毁方法</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;开门见山&quot;&gt;&lt;a href=&quot;#开门见山&quot; class=&quot;headerlink&quot; title=&quot;开门见山&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;开门见山&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;ThreadGroup在实际开发中很少用到，不过由于它跟Thread的关系比较密切，所以还是了解下为妙，揭开ThreadGroup的面纱是基于&lt;code&gt;JDK1.8&lt;/code&gt;。通过阅读注释及相关文章，可以知道ThreadGroup的结构如下：&lt;/p&gt;
&lt;p class=&quot;customize-img&quot;&gt;&lt;img src=&quot;/assets/blogImg/java/thread-group/threadgroup-structure.png&quot; alt=&quot;线程组结构&quot;&gt;&lt;/p&gt;
&lt;p&gt;除了初始线程组（JVM所属）以外，每个线程组都有一个父线程组及子线程组，父线程组中有个成员变量（groups）来记录它所有的子线程组，所以线程组之间的关系被看作是一棵&lt;code&gt;树&lt;/code&gt;。线程组下有多个线程，我们可以将线程组理解成是对一组线程进行操作。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>尽力去探究Thread的方方面面</title>
    <link href="http://zlia.tech/2019/12/11/explain-thread-sourcecode/"/>
    <id>http://zlia.tech/2019/12/11/explain-thread-sourcecode/</id>
    <published>2019-12-11T08:37:08.000Z</published>
    <updated>2020-01-02T09:35:56.385Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>接下来的这一段时间都将探索跟线程有关的内容，包括各种锁，对Thread的总结如下：</p><blockquote><p>线程具有<code>优先级</code>，高优先级的线程优先于低优先级的线程执行，当在某个线程中创建新线程时，新线程的优先级被设置成当前线程的优先级；JVM启动时，默认有一个非守护线程（调用某个类的main方法）；线程能被标记为<code>守护线程</code>，每个线程都可以<code>指定名称</code>，未指定的情况下将由底层帮其生成一个新名称；有两种方式来创建线程，如下所示：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 在只有一个实例的情况下只能创建一个线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"TestA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在只有一个实例的情况下可创建多个线程，这种方式更为常见</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestB</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"TestB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="方方面面"><a href="#方方面面" class="headerlink" title="方方面面"></a><div><span>方方面面</span></div></h3><p>探索Thread源码是基于<code>JDK1.8</code>，在探索之前先了解下<code>线程的状态</code>。</p><ul><li><p><code>新建（NEW）</code>：新创建一个对象，但还没有开始调start方法。</p></li><li><p><code>可运行（RUNNABLE）</code>：调用start方法后，该线程处于就绪状态，简单来就是还未运行，当线程调度器把时间片分配给该线程后变成了运行中状态。</p></li><li><p><code>阻塞（BLOCKED）</code>：等待同步控制方法或代码块上的对象锁，因为该对象锁已经被其他线程所占用。当线程处于阻塞状态时，线程调度器将忽略该线程，不会分配任何CPU时间，直到该线程进入到就绪状态，它才有可能执行操作。</p></li><li><p><code>等待（WAITING）</code>：等待另外一个线程执行特定的操作，如唤醒（通知）或终止，调用Object#wait、Thread#join、LockSupport#park后会处于该状态。</p></li><li><p><code>超时等待（TIMED_WAITING）</code>：该状态与等待有些类似，只不过它是有限时间内的等待，也就是说，当另外一个线程未执行特定的操作时，经过指定的时间后该线程将会变成该状态（此时未获取到锁），当获取到锁之后就会变成可运行状态（这个状态的转变是个人猜想的，Java规范与注释都未明确说明），调用Thread#sleep(long)、Object#wait(long)、Thread#join(long)、LockSupport#parkUntil可能会处于该状态。顺便提一下，若方法中的参数都为0，那么就相当于直接调用了wait方法，此时的状态会是等待</p></li><li><p><code>终止（TERMINATED）</code>：线程执行完成，指的是从run方法返回。</p></li></ul><p class="customize-img"><img src="/assets/blogImg/java/thread/thread-statue.png" alt="线程状态图"></p><p>简要阐述下几个<code>重要概念</code>，该内容摘抄自Java规范。</p><blockquote><p>Object#wait、Object#notify、Object#notify只能在同步控制方法或同步代码块（synchronized）中使用，否则即使能通过编译，但在运行时会抛出IllegalMonitorStateException异常，因为这些方法在调用时会操作锁，所以它必须先获取到锁。Thread#sleep与Thread#yield可以在非同步控制方法中调用，因为它们始终没有释放锁，更不用谈操作了。</p></blockquote><blockquote><p>针对Object#wait(long millisecs, int nanosecs)方法，注意nanosecs参数要在0-999999范围内（毫秒与纳秒单位换算是6个0），millisecs不能为负。</p></blockquote><blockquote><p>我们都知道每个对象都有一个关联的监视器，即通常所说的锁，除此之外，还具有一个关联的等待容器，很容易理解，里头存放的就是处于等待状态的线程（稍微纠结了一下，阻塞状态的线程不会处于该容器中，因为它是跟监视器有关的），也就是说当前线程调用Object#wait方法后，该线程会被添加到Object的等待容器中，并释放对象锁（不管此时有多少嵌套层级的锁都会得到释放，相当于将锁的计数减到0），处于等待容器中的线程不会执行任何其他指令。而当执行notify、notifyAll、interrupt或wait超时后，该线程可能会从等待容器中删除，在获取到对象锁后，该线程会使对象重新上锁（之前是多少嵌套，现在就会有多少嵌套，相当于做了恢复），在获到CPU时间片后从而继续执行。顺便提一下，对象内部持有对锁的计数（猜测），只有当该数量变成0后其他线程才能获取该对象锁。（<code>理解这点概念很重要</code>！！！否则概念多了容易乱）</p></blockquote><blockquote><p>notify<code>无法保证</code>在等待容量中选择哪个线程作为删除，notifyAll会将所有线程从等待容量中删除。</p></blockquote><blockquote><p>interrupt会在对象重新上锁（什么时候重新上锁上面提到过）后引发InterruptedException异常，在try-catch块中获取到的中断状态（isInterrupted）为false，更具体的信息可看方法说明。</p></blockquote><blockquote><p>如果线程在等待时既被通知（notify）又被中断（interrupt），则可能是先通知后中断，也有可能是先中断后通知。</p></blockquote><p>到这里应该对线程的状态有所了解了，读者可以发现实际上线程并没有<code>运行中</code>的状态，而在操作系统层面，它却有执行中的状态，这是为何？一个方面，CPU为每个线程分配时间片进行调度，时间片一般是几十毫秒，当其中一个线程执行一个时间片后会切换到下一个线程，在切换前会保存当前线程的状态，以便下次切换回来时可以加载该线程的状态，这样子的一个过程称为上下文切换，很显然线程之间的切换是非常快的，那么此时去区分运行中与就绪状态是没有多大意思的，有可能上一秒你看到的是运行中状态，可实际上还没等你反应过来后就变成了就绪状态，也许你只能看到这两个状态在互相闪烁着；另外一个方面，Thread注释中说：处于可运行状态下的线程正在JVM中执行，但它可能正在等待来自于操作系统的其他资源，比如处理器，JVM把那些资源都视作资源，比如CPU、各种硬件，有东西在为线程服务，它就认为线程在执行。对于操作系统来说它的侧重点是CPU，它必须要明确每个线程的具体状态，否则对于可运行状态来说，它怎么知道线程是否是可以调度的（部分观点摘自其他人的文章）。最后在提一点，JVM设置线程的状态是为了防止已经启动的线程被重新启动。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册本地方法，比如start0、stop0，至于做了什么只能说太过于底层了，不懂C、C++的可以忽略了</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程的名称</span></span><br><span class="line"><span class="comment">     * 为什么线程的名称要加上volatile关键词呢?</span></span><br><span class="line"><span class="comment">     * 首先volatile保证了内存的可见性，即其中一个线程修改了某个共享变量，其他的线程能够马上看到该变量修改后的值，更多的知识点将会另起文章阐述</span></span><br><span class="line"><span class="comment">     * 有可能多个线程共享该名称变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程的优先级</span></span><br><span class="line"><span class="comment">     * 注意：对于不同的平台可能优先级不同，有的是3个优先级、有的是10个优先级，所以在设置优先级时最好写Thread.MAX_PRIORITY</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> priority;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该线程是否是守护（后台）线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> daemon = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程要执行的任务，即最后会调用该任务的run方法 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Runnable target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程所属的线程组，一般情况下线程并未指定线程组的话默认是采用主线程的线程组，而主线程是从哪里的呢，这就要看JVM启动了...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ThreadGroup group;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类加载器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ClassLoader contextClassLoader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问控制，对访问控制进行操作或决定</span></span><br><span class="line"><span class="comment">     * 1. 决定是否允许还是拒绝对关键系统资源的访问 </span></span><br><span class="line"><span class="comment">     * 2. 特权代码，影响访问控制决定</span></span><br><span class="line"><span class="comment">     * 3. 可获取当前上下文，针对已保存的上下文做出来自不同上下文的访问控制决定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AccessControlContext inheritedAccessControlContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当线程没有指定线程名时，内部会帮助我们生成一个新名字-Thread-number，而其中的number会随着线程的增加而递增，如Thread-1、Thread-2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadInitNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每个线程都有自己的一个本地栈-ThreadLocal，ThreadLocal通过ThreadLocalMap来维护变量</span></span><br><span class="line"><span class="comment">     * ThreadLocalMap底层维护了一个数组，数组中维护了键值对的关系，其中键是当前ThreadLocal对象，也就是说，一个ThreadLocal只能绑定一个值，若是想绑定多个值的话就要定义多个ThreadLocal对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将当前线程的ThreadLocal设置到创建后的线程中，不知道使用的场景是哪里？</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置栈大小，在更底层的代码中用到，该属性依赖于不同的平台会有不同的行为</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> stackSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可中断对象，主要用来I/O阻塞的线程调用interrupt后，需要去唤醒selector</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Interruptible blocker;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 未处理异常的默认处理器，即异常没有被捕获，通常情况下为null，即直接在控制台打印异常堆栈信息</span></span><br><span class="line"><span class="comment">     * 若设置了默认处理器，则所有的线程都会应用该默认处理器，而如果又同时设置了自定义处理器，则指定线程只会应用自定义处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> UncaughtExceptionHandler defaultUncaughtExceptionHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常未处理的自定义处理器，当未指定该自定义处理器后会走默认的处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> UncaughtExceptionHandler uncaughtExceptionHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录线程ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为了生成线程ID，呈现递增趋势，一开始该值并不是0，因为JVM内部也会创建系统线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> threadSeqNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程的状态</span></span><br><span class="line"><span class="comment">     * 0-NEW  1-RUNNABLE 4-RUNNABLE 2-TERMINATED 16-WAITING  32-TIMED-WAITING 1024-BLOCKED</span></span><br><span class="line"><span class="comment">     * 其中1和4应该就是所谓的就绪与运行中，只不过哪个对应哪个就不可而知，操作系统的线程状态映射到JVM的线程状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> threadStatus = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最低优先级</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正常优先级</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大优先级</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化线程</span></span><br><span class="line"><span class="comment"> * 自动生成线程的名称，格式：Thread-i，i是个整数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化线程</span></span><br><span class="line"><span class="comment"> * 自动生成线程的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 指定任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化线程</span></span><br><span class="line"><span class="comment"> * 自动生成线程的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 指定任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> acc 访问控制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Thread(Runnable target, AccessControlContext acc) &#123;</span><br><span class="line">    init(<span class="keyword">null</span>, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>, acc, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化线程</span></span><br><span class="line"><span class="comment"> * 自动生成线程的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> group 线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 指定任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(ThreadGroup group, Runnable target)</span> </span>&#123;</span><br><span class="line">    init(group, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化线程，指定线程的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 线程的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, <span class="keyword">null</span>, name, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化线程，指定线程的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> group 线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 线程的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(ThreadGroup group, String name)</span> </span>&#123;</span><br><span class="line">    init(group, <span class="keyword">null</span>, name, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化线程，指定线程的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 指定任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 线程的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target, String name)</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, target, name, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化线程，指定线程的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> group 线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 指定任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 线程的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(ThreadGroup group, Runnable target, String name)</span> </span>&#123;</span><br><span class="line">    init(group, target, name, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化线程，指定线程的名称</span></span><br><span class="line"><span class="comment"> * stackSize依赖于不同的平台会有不同的值，所以使用该构造函数时要小心点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> group 线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 指定任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 线程的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stackSize 栈大小 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(ThreadGroup group, Runnable target, String name, <span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">    init(group, target, name, stackSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该方法主要使用在nio的selector中，这里是存储可中断的匿名类</span></span><br><span class="line"><span class="comment"> * 当在I/O阻塞中的线程调用interrupt时，需要去唤醒selector</span></span><br><span class="line"><span class="comment"> * 可全局搜索该方法的调用即可知道它的使用目的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> b 可中断对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blockedOn</span><span class="params">(Interruptible b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        blocker = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">nextThreadNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> threadInitNumber++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程ID</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextThreadID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++threadSeqNumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前线程的引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Thread <span class="title">currentThread</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每个线程都有一个CPU时间片，该方法指在自愿放弃CPU时间片，让其他线程能够更快的执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使线程进入指定时间的休眠，该方法不会释放锁，可以在非同步控制方法或同步块内使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> millis 休眠指定时间，毫秒为单位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使线程进入指定时间的休眠，该方法不会释放锁，可以在非同步控制方法或同步块内使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> millis 指定毫秒时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nanos 指定纳秒时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123; <span class="comment">//纳秒与毫秒的单位换算是6个0</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; millis == <span class="number">0</span>)) &#123;</span><br><span class="line">        millis++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(millis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> g 线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 指定任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 指定线程名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stackSize 线程的栈大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name, <span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">    init(g, target, name, stackSize, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> g 线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 指定任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 指定线程名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stackSize 线程的栈大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> acc 访问控制，如是否允许访问系统资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inheritThreadLocals 是否将当前线程的inheritableThreadLocals设置到创建后的线程中，类似于继承</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name, <span class="keyword">long</span> stackSize, AccessControlContext acc, <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    Thread parent = currentThread(); <span class="comment">//获取当前线程</span></span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = security.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = parent.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g.checkAccess(); <span class="comment">//确定当前正在运行的线程是否有权修改此线程组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g.addUnstarted(); <span class="comment">//记录未启动的线程个数，即未调用start方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.group = g;</span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon(); <span class="comment">//若创建线程的当前线程是后台（守护）线程，则创建后的线程也是个后台线程</span></span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority(); <span class="comment">//创建后的线程会被为当前线程的优先级</span></span><br><span class="line">    <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">    <span class="keyword">this</span>.inheritedAccessControlContext = acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">    tid = nextThreadID(); <span class="comment">//设置线程ID</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动线程，底层由JVM调用指定任务的run方法</span></span><br><span class="line"><span class="comment"> * 该方法只能调用一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>) <span class="comment">//threadStatus表示当前线程处于NEW状态</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">    group.add(<span class="keyword">this</span>); <span class="comment">//将当前线程添加到线程组，至少线程组到底做了什么可能需要另外起文章来探索</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0(); <span class="comment">//启动线程</span></span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123; <span class="comment">//若启动失败的话，需要去线程组中将其移除掉</span></span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动线程，底层将C++的线程与Java的线程进行了绑定，至于C++中的线程又做了什么就不得而知了，能猜到应该是跟操作系统打交道了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行任务</span></span><br><span class="line"><span class="comment"> * 若线程未调用start，直接调用run方法的话，那么就相当于执行一个方法，并未存在什么新线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 由JVM调用此方法，使线程在退出之前进行资源清理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (group != <span class="keyword">null</span>) &#123;</span><br><span class="line">        group.threadTerminated(<span class="keyword">this</span>);</span><br><span class="line">        group = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    threadLocals = <span class="keyword">null</span>;</span><br><span class="line">    inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">    inheritedAccessControlContext = <span class="keyword">null</span>;</span><br><span class="line">    blocker = <span class="keyword">null</span>;</span><br><span class="line">    uncaughtExceptionHandler = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 终止线程，即使已经启动的线程也会马上被终止</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1. 该方法已经被废弃了，为什么会被废弃呢？官方定义如下：</span></span><br><span class="line"><span class="comment"> * stop本质上是不安全的. 终止一个线程会造成该线程持有的锁得到释放（当ThreadDeath异常向上传播到堆栈时，锁将被释放）</span></span><br><span class="line"><span class="comment"> * 如果之前由这些锁保护的任何对象处于不一致状态，其他线程可能立即查看这些状态不一致的对象. 这样子的对象被认为已受损.</span></span><br><span class="line"><span class="comment"> * 当线程操作受损对象时会导致不可预测的行为，该行为可能很难被检测到. 不像非受查异常（Exception），ThreadDeath默默地杀死了线程（简单来说，我们无法从ThreadDeath异常上得到任何的消息）</span></span><br><span class="line"><span class="comment"> * 因此，用户没有警告其程序可能已损坏，该损坏是不可预测的.</span></span><br><span class="line"><span class="comment"> * 举个例子：</span></span><br><span class="line"><span class="comment"> * synchronized void f() &#123; </span></span><br><span class="line"><span class="comment"> *       x = 1; </span></span><br><span class="line"><span class="comment"> *       x = 2;</span></span><br><span class="line"><span class="comment"> *       x = 3;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * 不调用stop方法的情况下是可以正常运行的，但是在调用了stop方法后，程序立马被停止了，此时我们并不知道程序执行到了哪里，是 x = 1还是 x = 2 还是 x = 3</span></span><br><span class="line"><span class="comment"> * 所以即使其他线程获取到锁之后也无法确定x的值，第一次执行是1，第二次执行有可能是2，这就导致了结果的不可预测，这就相当于执行中的程序在任意时刻突然被破坏了</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2. 我不能捕捉ThreadDeath异常并修复受损的对象吗?</span></span><br><span class="line"><span class="comment"> *    线程可以在几乎任何地方抛出ThreadDeath异常，那我们怎么知道造成了对象的受损了，那就得慢慢分析每个抛出该异常的方法了.</span></span><br><span class="line"><span class="comment"> *    从第一个线程清除时（在catch或finally子句中），线程可以引发第二个ThreadDeath异常（最后要抛出ThreadDeath来确保线程被终止）. 必须重复进行清理，直到成功.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. 使用什么方式来代替stop?</span></span><br><span class="line"><span class="comment"> *    通过简单地修改变量的值来表明线程应该被终止，线程应定期检查该变量，如果该变量表明要终止运行，则应有序地从其run方法返回.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    方式一：</span></span><br><span class="line"><span class="comment"> *    private volatile Thread blinker;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *    public void stop() &#123;</span></span><br><span class="line"><span class="comment"> *       blinker = null;</span></span><br><span class="line"><span class="comment"> *    &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    public void run() &#123;</span></span><br><span class="line"><span class="comment"> *      Thread thisThread = Thread.currentThread();</span></span><br><span class="line"><span class="comment"> *      while(blinker == thisThread)&#123;</span></span><br><span class="line"><span class="comment"> *         try &#123;</span></span><br><span class="line"><span class="comment"> *              Thread.sleep(interval);</span></span><br><span class="line"><span class="comment"> *          &#125; catch(InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment"> *              </span></span><br><span class="line"><span class="comment"> *          &#125;</span></span><br><span class="line"><span class="comment"> *          repaint(); //业务逻辑</span></span><br><span class="line"><span class="comment"> *       &#125;</span></span><br><span class="line"><span class="comment"> *    &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    方式二：</span></span><br><span class="line"><span class="comment"> *    private final AtomicBoolean running = new AtomicBoolean(false);</span></span><br><span class="line"><span class="comment"> *    private int interval;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    public ControlSubThread(int sleepInterval) &#123;</span></span><br><span class="line"><span class="comment"> *       interval = sleepInterval;</span></span><br><span class="line"><span class="comment"> *    &#125;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *    public void stop() &#123;</span></span><br><span class="line"><span class="comment"> *       running.set(false);</span></span><br><span class="line"><span class="comment"> *    &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    public void run() &#123; </span></span><br><span class="line"><span class="comment"> *      running.set(true);</span></span><br><span class="line"><span class="comment"> *      while (running.get()) &#123;</span></span><br><span class="line"><span class="comment"> *         try &#123; </span></span><br><span class="line"><span class="comment"> *             Thread.sleep(interval); </span></span><br><span class="line"><span class="comment"> *         &#125; catch (InterruptedException e)&#123; </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *         &#125;</span></span><br><span class="line"><span class="comment"> *      &#125;</span></span><br><span class="line"><span class="comment"> *    &#125;</span></span><br><span class="line"><span class="comment"> *    </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread()) &#123;</span><br><span class="line">            security.checkPermission(SecurityConstants.STOP_THREAD_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>) &#123;</span><br><span class="line">        resume(); <span class="comment">//唤醒挂起的线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用程序中不能去catch ThreadDeath的实例，若真要catch，则处理完逻辑之后必须在重新抛出ThreadDeath异常对象，以便确定线程被终止</span></span><br><span class="line"><span class="comment">     * 线程中可以自定义异常处理器，只不过该异常处理器在针对ThreadDeath时不会打印任何消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    stop0(<span class="keyword">new</span> ThreadDeath()); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中断线程</span></span><br><span class="line"><span class="comment"> * 1. 若是调用wait、join、sleep方法时导致线程处于等待状态，可调用此方法来中断线程，即从这些方法处返回并抛出InterruptedException异常，同时清除中断状态</span></span><br><span class="line"><span class="comment"> * 2. 若是调用I/O操作导致线程处于阻塞状态，可调用此方法来将通道关闭，同时会抛出一个异常，及设置中断状态</span></span><br><span class="line"><span class="comment"> * 3. 若是调用selector.select导致线程处于阻塞状态，可调用此方法来使select立即返回，并设置中断状态</span></span><br><span class="line"><span class="comment"> * 4. 如果上述条件均不成立，则将设置该线程的中断状态.</span></span><br><span class="line"><span class="comment"> * 中断未启动的线程不会产生任何影响.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker; <span class="comment">//上面咱们提到了关于blocker的作用，主要用于nio中的selector</span></span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interrupt0();</span><br><span class="line">            b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();<span class="comment">// 1、2、4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中断线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">interrupt0</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前线程是否被中断，该方法会清除中断状态</span></span><br><span class="line"><span class="comment"> * 如果方法调用多次，则多次调用后会返回false，除了在多次调用后又发生中断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否被中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程是否被中断，该方法不会清除中断状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程是否被中断，是否清除中断状态取决于ClearInterrupted参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ClearInterrupted 是否清除中断状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该方法原先被设计为破坏线程，并未清理资源，也就是说线程持有的锁会继续持有，并未释放锁，幸好还未实现就已经被废弃了</span></span><br><span class="line"><span class="comment"> * 官方说若是实现了它，将与Thread#suspend方法一样容易导致死锁，锁未得到释放，其他线程无法访问</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程是否处于活动状态中，活动状态表示：线程已启动（已调用start）且尚未终结</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 挂起/暂停线程</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1. 该方法已废弃，为什么呢? 官方定义如下：</span></span><br><span class="line"><span class="comment"> * suspend本质上是容易死锁的. 当某个线程被挂起时，其任务还持有对关键系统资源的锁，其他线程都访问不了该资源.</span></span><br><span class="line"><span class="comment"> * 若有其他线程在调用resume之前尝试获取该锁，则会导致死锁（线程并未释放锁）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2. 使用什么方式来代替suspend?</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    private volatile boolean threadSuspended;</span></span><br><span class="line"><span class="comment"> *   </span></span><br><span class="line"><span class="comment"> *    public synchronized void mousePressed() &#123;</span></span><br><span class="line"><span class="comment"> *        //业务逻辑</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *        threadSuspended = !threadSuspended;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *         if (!threadSuspended) &#123;</span></span><br><span class="line"><span class="comment"> *            notify();</span></span><br><span class="line"><span class="comment"> *         &#125;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     public void run() &#123;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          wihle(true) &#123;  //这里并未退出该任务</span></span><br><span class="line"><span class="comment"> *              try &#123;</span></span><br><span class="line"><span class="comment"> *                  Thread.sleep(interval);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                  if(threadSuspended) &#123; //这样子的方式可以在线程没有被挂起的情况不用花费synchronized关键词引起的代价</span></span><br><span class="line"><span class="comment"> *                      synchronized(this) &#123;</span></span><br><span class="line"><span class="comment"> *                          while(threadSuspended) &#123;</span></span><br><span class="line"><span class="comment"> *                              wait();</span></span><br><span class="line"><span class="comment"> *                          &#125;</span></span><br><span class="line"><span class="comment"> *                      &#125;</span></span><br><span class="line"><span class="comment"> *                  &#125;</span></span><br><span class="line"><span class="comment"> *              &#125; catch(InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment"> *    </span></span><br><span class="line"><span class="comment"> *              &#125;</span></span><br><span class="line"><span class="comment"> *          &#125;</span></span><br><span class="line"><span class="comment"> *          //业务逻辑</span></span><br><span class="line"><span class="comment"> *    &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. stop与suspend结合</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    public void run() &#123;</span></span><br><span class="line"><span class="comment"> *      Thread thisThread = Thread.currentThread();</span></span><br><span class="line"><span class="comment"> *      while (blinker == thisThread) &#123; //调用stop后会正常退出</span></span><br><span class="line"><span class="comment"> *          try &#123;</span></span><br><span class="line"><span class="comment"> *              Thread.sleep(interval);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              synchronized(this) &#123;</span></span><br><span class="line"><span class="comment"> *                 while (threadSuspended &amp;&amp; blinker==thisThread)</span></span><br><span class="line"><span class="comment"> *                     wait();</span></span><br><span class="line"><span class="comment"> *             &#125;</span></span><br><span class="line"><span class="comment"> *          &#125; catch (InterruptedException e)&#123;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *         &#125;</span></span><br><span class="line"><span class="comment"> *          //业务逻辑</span></span><br><span class="line"><span class="comment"> *      &#125;</span></span><br><span class="line"><span class="comment"> *    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public synchronized void stop() &#123;</span></span><br><span class="line"><span class="comment">    blinker = null;</span></span><br><span class="line"><span class="comment">    notify();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">suspend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    suspend0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 挂起线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">suspend0</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 恢复线程</span></span><br><span class="line"><span class="comment"> * 该方法仅与suspend一起使用，但由于suspend容易造成死锁而被废弃了，故而resume也用不到了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    resume0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置线程的优先级</span></span><br><span class="line"><span class="comment"> * 1 &lt; newPriority &lt; g.maxPriority &lt;= 10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newPriority 指定优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">    ThreadGroup g;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((g = getThreadGroup()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">            newPriority = g.getMaxPriority();</span><br><span class="line">        &#125;</span><br><span class="line">        setPriority0(priority = newPriority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取优先级</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPriority</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> priority;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置线程的名称</span></span><br><span class="line"><span class="comment"> * 即使线程已经启动了依然还是可以设置线程的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 指定线程的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>) &#123; <span class="comment">// threadStatus != 0 表示线程已启动</span></span><br><span class="line">        setNativeName(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ThreadGroup <span class="title">getThreadGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> group;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前线程组的活跃线程个数</span></span><br><span class="line"><span class="comment"> * 注意：线程组中还有子线程组，所以计算时也会包含子线程组</span></span><br><span class="line"><span class="comment"> * 该结果只是一个估算值，因为线程数一直在动态变化着，同时JVM也会有一些线程，所以可能会影响该计数结果</span></span><br><span class="line"><span class="comment"> * 该方法主要用来调试与监控</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程组的活跃线程个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">activeCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().getThreadGroup().activeCount();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前线程组的活跃线程拷贝到指定数组中</span></span><br><span class="line"><span class="comment"> * 要严格确保指定数组的大小大于活跃线程的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tarray 指定数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程组的活跃线程个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">enumerate</span><span class="params">(Thread tarray[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().getThreadGroup().enumerate(tarray);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算线程的栈帧，何为栈帧? 这就涉及到JVM的知识了，笔者还在慢慢往上走呢.</span></span><br><span class="line"><span class="comment"> * 调用该方法时，线程应该被挂起，而suspend已被废弃了，故而该方法也没啥用了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">countStackFrames</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前线程最多等待指定时间</span></span><br><span class="line"><span class="comment"> * t1.join(time);</span></span><br><span class="line"><span class="comment"> * 这里指的当前线程并不是t1，而是执行这些所属的线程，也就是main线程，按照最上面的概念来说，应该是当前线程添加到了t1对象的等待容器中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> millis 指定毫秒时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay); <span class="comment">//等待状态下的线程若是调用interruput去中断的话则会直接抛出InterruptedException异常后恢复运行，若是使用notify的话，那么最终都会等待指定的millis时间才会恢复运行</span></span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前线程最多等待指定时间</span></span><br><span class="line"><span class="comment"> * 若指定时间设置为0，则会一直等下去</span></span><br><span class="line"><span class="comment"> * 做了一些参数校验</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> millis 指定毫秒时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nanos 指定纳秒数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; millis == <span class="number">0</span>)) &#123;</span><br><span class="line">        millis++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    join(millis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前线程处于等待状态中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印线程的堆栈到标准输出</span></span><br><span class="line"><span class="comment"> * 该方法仅用于调试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dumpStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Exception(<span class="string">"Stack trace"</span>).printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据传入的值来决定将线程变成后台线程还是用户线程</span></span><br><span class="line"><span class="comment"> * 当所有正在运行的线程都是后台线程时，JVM退出</span></span><br><span class="line"><span class="comment"> * 该方法必须在start之前调用</span></span><br><span class="line"><span class="comment"> * false-用户线程   true-后台线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> on 标志</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setDaemon</span><span class="params">(<span class="keyword">boolean</span> on)</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (isAlive()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">    &#125;</span><br><span class="line">    daemon = on;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程是否是后台（守护）线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否是后台线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isDaemon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> daemon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前线程是否有权限修改当前对象所属的线程，若没有权限则抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkAccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        security.checkAccess(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印线程的名称，优先级，线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadGroup group = getThreadGroup();</span><br><span class="line">    <span class="keyword">if</span> (group != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Thread["</span> + getName() + <span class="string">","</span> + getPriority() + <span class="string">","</span> + group.getName() + <span class="string">"]"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Thread["</span> + getName() + <span class="string">","</span> + getPriority() + <span class="string">","</span> + <span class="string">""</span> + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前线程是否持有指定对象锁</span></span><br><span class="line"><span class="comment"> * true-表示当前线程持有指定对象锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否持有指定对象锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">holdsLock</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取线程的ID</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 线程的ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前线程的状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 当前线程的状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sun.misc.VM.toThreadState(threadStatus);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置未处理异常的默认处理器</span></span><br><span class="line"><span class="comment"> * 若设置了默认处理器，则所有的线程都将应用到，相当于全局处理器，而如果同时设置了自定义处理器，那么指定线程只会应用自定义处理器（可看dispatchUncaughtException方法）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> eh 默认处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDefaultUncaughtExceptionHandler</span><span class="params">(UncaughtExceptionHandler eh)</span> </span>&#123;</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sm.checkPermission(</span><br><span class="line">            <span class="keyword">new</span> RuntimePermission(<span class="string">"setDefaultUncaughtExceptionHandler"</span>)</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">     defaultUncaughtExceptionHandler = eh;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取未处理异常的默认处理器</span></span><br><span class="line"><span class="comment"> * 返回null表示没有设置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 默认处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UncaughtExceptionHandler <span class="title">getDefaultUncaughtExceptionHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> defaultUncaughtExceptionHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取未处理异常的自定义处理器</span></span><br><span class="line"><span class="comment"> * 若未设置自定义处理器，则走线程组的异常处理，线程组中会获取默认处理器，若也未设置，则打印堆栈信息到控制台，若设置了则走默认处理器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 自定义处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UncaughtExceptionHandler <span class="title">getUncaughtExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uncaughtExceptionHandler != <span class="keyword">null</span> ? uncaughtExceptionHandler : group;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置自定义处理器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> eh 自定义处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUncaughtExceptionHandler</span><span class="params">(UncaughtExceptionHandler eh)</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    uncaughtExceptionHandler = eh;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下发异常到指定处理器上，该方法只会被JVM调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchUncaughtException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">    getUncaughtExceptionHandler().uncaughtException(<span class="keyword">this</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>创建线程有<code>两个方式</code>，一种是继承Thread，第二种是实现Runnable，第二种方式更为常见，且能够在只有一个任务实例的情况下创建多个线程。</p></li><li><p>线程的<code>6</code>个状态-新建、可运行、阻塞、等待、超时等待、终止。</p></li><li><p>wait的实现机制是通过对象的等待容器，更具体的描述可参考概念。</p></li><li><p>我们都知道每个线程都有一个本地栈，实际上是通过Thread对象中的threadLocals变量维护起来的，也就是说即使将ThreadLocal变量传入到不同的线程中也不会造成多线程之间共享同一个ThreadLocal，因为每个线程都有一个ThreadLocal对象，即上面提到的threadLocals变量，在为ThreadLocal设值时，每个线程都会检查当前线程下的threadLocals变量是否初始化了，若没有则初始化该变量。有一点需要注意下，ThreadLocal中通过维护一个Map来保存键值对的关系，而其中的键值就是当前的ThreadLocal对象，也就是说，将ThreadLocal传入到不同的线程中会造成它们的threadLocals变量所引用的键值是同一个，不过这丝毫不影响。</p></li><li><p>sleep、yield<code>不会</code>释放对象锁，可以在非同步控制方法或同步块中使用；wait、join、notify、notifyAll释放对象锁，必须在同步控制方法或同步块中使用，因为它们对锁进行了操作，故而需要先获取到锁才能操作。</p></li><li><p>stop：因为会造成数据的不完整，最终会导致不可预测的行为而废弃；suspend：因为始终都没有释放锁，容易造成死锁而废弃；destroy：官方说还未实现就已经废弃了，同样会造成死锁；resume：该方法仅与suspend一起使用，由于suspend已经被废弃了，那它也只好跟着牺牲了。</p></li><li><p>未处理异常的默认处理器与自定义处理器的使用。</p></li></ul><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a><div><span>重点</span></div></h3><p><code>线程的状态转变</code> <code>wait/join/notify/notify/sleep/yield</code></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><div><span>参考资料</span></div></h3><p>《Java编程思想》</p><p>《Java并发编程的艺术》</p><p><a href="https://www.javazhiyin.com/52519.html" target="_blank" rel="noopener">https://www.javazhiyin.com/52519.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;接下来的这一段时间都将探索跟线程有关的内容，包括各种锁，对Thread的总结如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;线程具有&lt;code&gt;优先级&lt;/code&gt;，高优先级的线程优先于低优先级的线程执行，当在某个线程中创建新线程时，新线程的优先级被设置成当前线程的优先级；JVM启动时，默认有一个非守护线程（调用某个类的main方法）；线程能被标记为&lt;code&gt;守护线程&lt;/code&gt;，每个线程都可以&lt;code&gt;指定名称&lt;/code&gt;，未指定的情况下将由底层帮其生成一个新名称；有两种方式来创建线程，如下所示：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 在只有一个实例的情况下只能创建一个线程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestA&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Thread&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;TestA&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 在只有一个实例的情况下可创建多个线程，这种方式更为常见&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestB&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Runnable&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;TestB&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>为入门操作系统而读-《计算机的心智-操作系统之哲学原理》</title>
    <link href="http://zlia.tech/2019/12/03/read-computer-mind/"/>
    <id>http://zlia.tech/2019/12/03/read-computer-mind/</id>
    <published>2019-12-03T10:27:16.000Z</published>
    <updated>2019-12-03T10:27:16.129Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>为什么会想着入门操作系统呢？还是跟Java有关系，在深入学习的过程中发现很多点都会涉及到操作系统底层的知识，特别是并发这块内容，而笔者我现在只是刚刚起步学习就已经要了解与操作系统相关的内容，所以还是早点入坑吧。为什么是先看这本书呢？当然了，我不会无缘无故随便看一本，是经过从前人的推荐到知识点的考察才最终定下来！《计算机的心智-操作系统之哲学原理》这本书出版于09年，也算是一本年代已久的书籍，不过相对于计算机的诞生时间来说，它的知识点应该不会显得过时，该书在商城上可能买不到了，笔者也是找的PDF，Google一下就有了。打算借着这本书的知识点来对操作系统的入门做一个总结，同时也希望能够帮助其他有缘人吧。</p><a id="more"></a><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a><div><span>概念</span></div></h3><ul><li><p><code>中断</code>：当你正在看电影时，突然心血来潮迫不及待想要听上一首周杰伦的新歌曲，看似很简单的操作，实际上CPU会打断正在执行的任务并保存当前任务的上下文信息，转而去帮你完成更重要的任务，等重要的任务完成后会根据之前保存的上下文信息进行任务的恢复，以便继续执行，不过若中断发生异常可能会直接导致任务终止。中断分为硬件中断与软件中断，两者都可以通过总线向CPU发送中断请求（CPU内部有个中断控制器负责接收），可能同时出现多个中断请求，但每次CPU只能响应其中一个，所以会根据预先设置好的优先级进行排队，等候CPU处理，所谓的处理就会转入相应的中断服务程序，也就是上面提到的更重要的任务。在多CPU中，有一个全局中断控制器负责将接收到的中断请求按照某个规则下发到指定CPU中。</p></li><li><p><code>内核态与用户态</code>：有的程序可以访问计算机的任何资源，而有的计算机只能访问非常受限的少量资源。操作系统作为计算机的管理者，它应该享有更多的方便或特权，否则怎么管理计算机？所以内核态就是拥有资源多的状态，或者说访问资源多的状态，我们也称之为特权态。相对来说，用户态就是非特权态，在此种状态下访问的资源将受到限制。计算机如何知道现在正在运行的程序是内核态还是用户态呢？CPU内部有一个状态位，通过设置该状态位来表示内核态与用户态，程序在运行时，CPU是什么态，这个程序就运行在什么态上。既然已经知道了某个程序是哪种状态了，那么如何通过状态来限制其访问的资源呢？要限制一个程序对资源的访问，需要对程序执行的每一条指令进行检查才能完成。而这种检查就是地址翻译，程序发出的每一条指令都要经过这个地址翻译过程，通过对翻译的控制，就可以限制程序对资源的访问，很明显这是针对用户态来说。对于内核态，程序可以绕过内存地址翻译而直接执行指令。</p></li><li><p><code>进程</code>：表示执行中的程序，一旦程序在计算机中运行起来，它就成为了一个进程。每个进程都有一个地址空间，该地址空间存储了可执行文件的代码与数据，进程可以创建子进程，子进程又可以创建进程，在Linux中这些进程称为进程组。系统对进程的管理通过进程表来实现，进程表里存放的是关于进程的一切信息。</p></li><li><p><code>线程</code>：程序执行流的最小单元。一个进程至少有一个线程，在多线程下可共享进程的资源，如全局变量、堆内存，但也有一些只有自身才能访问的资源，如栈内存、寄存器、线程本地存储（ThreadLocal）。</p></li><li><p><code>多线程的调度</code>：CPU通过给每个线程分配时间片来实现多线程的调度。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程，让我们感觉多个线程是同时执行，时间片一般是几十毫秒。CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务，可以再加载这个任务的状态，所以任务从保存到再加载的过程就是一次<code>上下文切换</code>。</p></li><li><p><code>内存架构</code>：由高速缓存、主存、磁盘等组成的一个内存架构。高速缓存的特点是低容量、高速度、高价格；主存的特点是中容量、中速度、中价格；磁盘则是大容量、地速度、低成本的存储媒介。</p></li><li><p><code>内存管理</code>：对内存架构进行管理，使程序在内存架构的任何一个层次上的存放对于用户来说都是一样的。用户无需担心自己的程序是存在高速缓存、主存、磁盘，反正运行、计算、输出的结果都是一样的。让内存管理实现这种媒介透明的手段就是<code>虚拟内存</code>。</p></li><li><p><code>虚拟内存</code>：程序在运行时会加载到主存中，但是主存的容量非常有限，这将限制我们只能编写很小的程序。加大主存？这显然不合理，无疑增加了更多的成本，所以这就诞生了虚拟内存：不增加成本的情况下扩大内存容量。虚拟内存的中心思想是将主存扩大到便宜、大容量的磁盘上，即将磁盘空间看作是主存空间的一部分。程序存放在磁盘上就相当于存放在主存内。程序既可以完全存放在主存，也可以完全存放在磁盘上，当然也可以部分存放在主存、部分存放在磁盘。而程序执行时，程序发出的地址到底是在主存还是在磁盘则由操作系统的内存管理模块负责判断，并到相应的地方进行读写操作。</p></li></ul><p>操作系统的概念是真的多，还有很多重要的概念并未提及，比如缓存一致性、多核、原子操作。</p><h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a><div><span>评价</span></div></h3><p>该书以一种通俗易懂的方式引出知识点，结合生活中的例子对知识点的原理进行一步步地深入分析，点到为止！很适合入门级的操作系统书籍。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;为什么会想着入门操作系统呢？还是跟Java有关系，在深入学习的过程中发现很多点都会涉及到操作系统底层的知识，特别是并发这块内容，而笔者我现在只是刚刚起步学习就已经要了解与操作系统相关的内容，所以还是早点入坑吧。为什么是先看这本书呢？当然了，我不会无缘无故随便看一本，是经过从前人的推荐到知识点的考察才最终定下来！《计算机的心智-操作系统之哲学原理》这本书出版于09年，也算是一本年代已久的书籍，不过相对于计算机的诞生时间来说，它的知识点应该不会显得过时，该书在商城上可能买不到了，笔者也是找的PDF，Google一下就有了。打算借着这本书的知识点来对操作系统的入门做一个总结，同时也希望能够帮助其他有缘人吧。&lt;/p&gt;
    
    </summary>
    
      <category term="essays" scheme="http://zlia.tech/categories/essays/"/>
    
    
      <category term="operating-system" scheme="http://zlia.tech/tags/operating-system/"/>
    
  </entry>
  
  <entry>
    <title>每日知识点20191107</title>
    <link href="http://zlia.tech/2019/11/26/core-java-knowledge-20191107/"/>
    <id>http://zlia.tech/2019/11/26/core-java-knowledge-20191107/</id>
    <published>2019-11-26T08:34:07.000Z</published>
    <updated>2019-11-26T08:34:07.855Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java"><a href="#java" class="headerlink" title="java"></a><div><span>java</span></div></h3><ul><li><p>Exception#fillInStackTrace：将当前调用栈信息填入到原来异常对象，相当于更新最新的抛出点（catch异常后又抛出的点）</p></li><li><p>try-finally某些情况下会吃掉抛出的异常</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>覆盖方法时，只能抛出在基类方法的异常说明里列出的那些异常或其子类或选择不抛出，但是此限制对构造器不起作用，派生类构造器可以抛出任何异常，只需要在异常说明中包含基类构造器的异常说明</p></li><li><p>Collections.nCopies能添加新元素，Collections.fill只能替换元素，无法添加新元素</p></li><li><p>通配符代表着持有具有某种具体类型的同构集合</p></li></ul><a id="more"></a><ul><li>下面的代码摘抄自编程思想P550</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestS</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标准输入、输出和错误IO流进行重定向</span></span><br><span class="line"><span class="comment">     * 一开始只有in.out中有数据，而test.out中是空内容，执行完程序后，test.out中的数据和in.out是一致的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        PrintStream console = System.out;</span><br><span class="line">        BufferedInputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"in.out"</span>));</span><br><span class="line">        PrintStream out = <span class="keyword">new</span> PrintStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"test.out"</span>)));</span><br><span class="line">        System.setIn(in);<span class="comment">//默认是从控制台读取数据，但是这里进行了重定向，于是从in.out中读取数据</span></span><br><span class="line">        System.setOut(out);<span class="comment">//默认是将数据写入到控制台，但是这里进行了重定向，于是写入到test.out中</span></span><br><span class="line">        System.setErr(out);<span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认情况下是从控制台读取数据，然而这里是读取in.out文件中的数据</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s ;</span><br><span class="line">        <span class="keyword">while</span>((s = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        out.close();</span><br><span class="line">        System.setOut(console);<span class="comment">//切换到默认情况下</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>容错：发生故障时，如何让系统继续运行</p></li><li><p>高可用：系统中断时，如何尽快恢复</p></li><li><p>灾备：系统毁灭时，如何抢救数据</p></li><li><p>TestA.class.isAssignableFrom(TestB.class)：TestA与TestB是同一个类类型或TestA是TestB的父类或TestA是TestB的父接口</p></li><li><p>java中采用高位优先（大端模式）进行存储字节数据，也就是高位存储在低地址，低位存储在高地址上</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java&quot;&gt;&lt;a href=&quot;#java&quot; class=&quot;headerlink&quot; title=&quot;java&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;java&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Exception#fillInStackTrace：将当前调用栈信息填入到原来异常对象，相当于更新最新的抛出点（catch异常后又抛出的点）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;try-finally某些情况下会吃掉抛出的异常&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RuntimeException();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;覆盖方法时，只能抛出在基类方法的异常说明里列出的那些异常或其子类或选择不抛出，但是此限制对构造器不起作用，派生类构造器可以抛出任何异常，只需要在异常说明中包含基类构造器的异常说明&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Collections.nCopies能添加新元素，Collections.fill只能替换元素，无法添加新元素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通配符代表着持有具有某种具体类型的同构集合&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="daily-konwledge-point-java" scheme="http://zlia.tech/tags/daily-konwledge-point-java/"/>
    
  </entry>
  
  <entry>
    <title>探索ByteBuffer底层实现</title>
    <link href="http://zlia.tech/2019/11/26/explain-bytebuffer-sourcecode/"/>
    <id>http://zlia.tech/2019/11/26/explain-bytebuffer-sourcecode/</id>
    <published>2019-11-26T08:27:15.000Z</published>
    <updated>2019-11-26T08:27:15.081Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>由于最近在了解IO相关知识，而正好看到了nio，这是我以前从来没接触过的，虽然它很早就出现了，所以先来看看有关于它的一些基础。探索<code>ByteBuffer</code>源代码是基于<code>JDK1.8</code>版本的，ByteBuffer的父类是<code>Buffer</code>，通过阅读注释后对Buffer总结如下：</p><blockquote><p>缓冲区是特定基本类型的元素的线性有限序列，除了内容之外，缓冲区的基本属性还包括<code>capacity</code>、<code>limit</code>、<code>position</code>、<code>mark</code>。假设缓冲区是一本1000页的书籍，你已经看到800页了，其中在500页处有个很重要的知识点，你做了个标记以便下次能够轻松找到它。那么capacity指代的就是1000，意思就是这本书的最大页数，缓冲区的最大容量，该属性值不会为负不会改变；limit指代的是800，意思是目前只学了这么多知识，可以理解为界限；position指代的是具体某一页，也就是你每看一页，position就会有所增加；mark很容易理解，指代的是我们标记到具体某一页。在实际代码中有读、写模式，我们将读模式比喻成复习，也就是说你可以从第0页复习到第800页，此时的postion从0-800，limit保持800不变，也可以从你所标记的点到第800页，此时的position从mark-800，但是切记不能从第0页复习而后直接跳到mark处，这样子就导致知识点的不连续性，简单来说<code>0 &lt;= mark &lt;= posiiton &lt;= limit &lt;= capacity</code>；将写模式比喻成继续学习新知识点，也就是从第801页继续往后看，position会逐步增加。对于只读缓冲区来说，不允许修改它的内容，但是limit、position、mark是可以变化的。最后一点是缓冲区属于非线程安全！</p></blockquote><p>提供一张图片方便理解。接下来在总结下ByteBuffer，以便对其有个大概性的了解。</p><p class="customize-img"><img src="/assets/blogImg/java/bytebuffer/bytebuffer-variable.png" alt="Buffer相关变量"></p><blockquote><p><code>字节缓冲区</code>，可创建视图缓冲区，视图缓冲区指的是包含其他基本类型值的缓冲区，如CharBuffer，视图缓冲区的索引不是以字节为单位，而是根据其值的特定类型的大小决定的，如CharBuffer是2个字节。字节缓冲区可分为直接或间接，直接缓冲区的内容存放在堆外内存，JVM将尽最大努力直接执行原生IO操作，而间接缓冲区存放在堆内存中，交由JVM操作，与操作系统并未直接交互，直接缓冲区通常比间接缓冲区具有更高的分配和释放成本，简单来说，对于大型缓冲区来说直接分配直接缓冲区。</p></blockquote><p>概念性的内容就阐述到这里了，接着就直接进入源码世界吧！</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><p>由于ByteBuffer是个抽象类，故方法可能涉及到多个类，先贴一张继承结构类图。</p><p class="customize-img"><img src="/assets/blogImg/java/bytebuffer/bytebuffer-hierarchy.png" alt="Buffer继承结构"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 抽象类没办法直接创建该对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuffer</span> <span class="keyword">extends</span> <span class="title">Buffer</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ByteBuffer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储缓冲区的内容</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] hb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓冲区的第一个元素在hb数组中索引</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓冲区是否是只读缓冲区</span></span><br><span class="line">    <span class="keyword">boolean</span> isReadOnly;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓冲区的字节顺序</span></span><br><span class="line">    <span class="keyword">boolean</span> bigEndian = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该属性定义在Buffer中，标记缓冲区中的某个位置  mark &lt;= position</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mark = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该属性定义在Buffer中，代表缓冲区中下一个读取或写入的元素的索引 position &lt;= limit</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该属性定义在Buffer中，代表着界限，该值在写模式下等于capacity，读模式下等于position写模式下的索引 limit &lt;= capacity</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该属性定义在Buffer中，代表着缓冲区的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化，设置属性值</span></span><br><span class="line"><span class="comment"> * 在初始化之前需要校验这些成员属性是否合法性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mark 标记缓冲区中的某个索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pos 下一个读取或写入的元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lim 界限-读模式下等于position写模式下的索引，简单来说就是记住最后写入内容的索引，以便知道读取结束了；写模式下等于capacity，以便知道缓冲区已经写满了，不能再写了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cap 缓冲区的容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hb 字节数组-存储缓冲区的内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> offset 缓冲区中第一个元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ByteBuffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap, <span class="keyword">byte</span>[] hb, <span class="keyword">int</span> offset) &#123;</span><br><span class="line">    <span class="keyword">super</span>(mark, pos, lim, cap);</span><br><span class="line">    <span class="keyword">this</span>.hb = hb;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mark 标记缓冲区中的某个索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pos 下一个读取或写入的元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lim 界限-读模式下等于position写模式下的索引，简单来说就是记住最后写入内容的索引，以便知道读取结束了；写模式下等于capacity，以便知道缓冲区已经写满了，不能再写了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cap 缓冲区的容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ByteBuffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap) &#123;</span><br><span class="line">    <span class="keyword">this</span>(mark, pos, lim, cap, <span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该构造函数中涉及到的知识点比较多，笔者也是不懂，借助别人分析的文章进行讲解</span></span><br><span class="line"><span class="comment"> * 申请堆外内存与设置释放堆外内存机制</span></span><br><span class="line"><span class="comment"> * 堆外内存是不受JVM管理，这导致了堆外内存没办法被JVM回收，所以它通过在堆内存中创建对象，当该对象被回收时，会先调用Cleaner#clean，而在该方法中调用了Deallocator#run，这样子就将堆外内存释放了</span></span><br><span class="line"><span class="comment"> * 这里涉及到了虚引用的使用，可参考Reference类中的代码，或者看有关文章</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cap 要申请的容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">DirectByteBuffer(<span class="keyword">int</span> cap) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="keyword">boolean</span> pa = VM.isDirectMemoryPageAligned(); <span class="comment">// 判断是否需要页面对齐，默认是false，何为页面对齐，目前我是不知道有什么用</span></span><br><span class="line">    <span class="keyword">int</span> ps = Bits.pageSize();</span><br><span class="line">    <span class="keyword">long</span> size = Math.max(<span class="number">1L</span>, (<span class="keyword">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap); <span class="comment">// 主要用于判断申请的堆外内存是否超过了最大值，这里的代码就不做深入了，要求大概能懂就行了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size); <span class="comment">// 申请堆外内存</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (<span class="keyword">byte</span>) <span class="number">0</span>); <span class="comment">// 初始化堆外内存空间为0</span></span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap)); <span class="comment">// 使用Cleaner机制回收堆外内存</span></span><br><span class="line">    att = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 校验并设置属性</span></span><br><span class="line"><span class="comment"> * 由于mark &lt;= position &lt;= limit 所以只要校验mark、position即可</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> limit 界限值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 当前对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">limit</span><span class="params">(<span class="keyword">int</span> newLimit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((newLimit &gt; capacity) || (newLimit &lt; <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    limit = newLimit;</span><br><span class="line">    <span class="keyword">if</span> (position &gt; limit) position = limit;</span><br><span class="line">    <span class="keyword">if</span> (mark &gt; limit) mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 校验并设置属性</span></span><br><span class="line"><span class="comment"> * 由于mark &lt;= position 所以只要校验mark即可</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newPosition 下一个读取或写入的元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 当前对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">position</span><span class="params">(<span class="keyword">int</span> newPosition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((newPosition &gt; limit) || (newPosition &lt; <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    position = newPosition;</span><br><span class="line">    <span class="keyword">if</span> (mark &gt; position) mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过申请堆外内存来构造直接缓冲区</span></span><br><span class="line"><span class="comment"> * 当该对象被回收时会出发释放堆外内存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity 申请的容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造间接缓冲区</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity 缓冲区的容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(capacity, capacity); <span class="comment">// 虽然这是另外一个类，实际上挺简单的，所以这里就不做继续阐述了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个包含指定字节数组的缓冲区</span></span><br><span class="line"><span class="comment"> * 若在外部修改该字节数组，对应的缓冲区内容也会变化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arry 指定字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> offset 下一个要读取或写入的元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length 指定写入或读取的元素的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] array, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(array, offset, length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException x) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个包含指定字节数组的缓冲区</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 指定字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> wrap(array, <span class="number">0</span>, array.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个包含从position到limit之间的源缓冲区内容的新缓冲区（HeapByteBuffer）</span></span><br><span class="line"><span class="comment"> * 源缓冲区与新缓冲区共享同一个字节数组，两者的属性position、limit、capacity是相互独立的</span></span><br><span class="line"><span class="comment"> * 在源缓冲区构建完后它的offset就已经确定下来了，而对于position来说，它会随着读或写不断的变化，但它始终 &gt;= offset，因为offset代表着缓冲区的第一个元素对应到字节数组上的索引</span></span><br><span class="line"><span class="comment"> * position相当于它离第一个元素多远，offset + position = 当前读或者写入的元素对应到字节数组上的索引，所以对于新缓冲区来说，它的第一个元素对应到字节数组上的索引就是position + offset，不知道说清楚没有</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0  1  2  3  4  5  6  7  8  9  10</span></span><br><span class="line"><span class="comment"> * 假设这是字节数组，1：offset  position：3（此时的3并不是指的3索引，而是指定离第一个元素有多远，那么position对应的索引应该是1 + 3 = 4索引）</span></span><br><span class="line"><span class="comment"> * 该类中的arrayOffset方法在第一次获取offset值时个人觉得写的不对，就好比我上面已经指定了position的值了，可惜返回的结果并不是我想要的，而在调用完slice完后再次通过arrayOffset获取offset，这次的结果确实正确的，于是我就有点纳闷了</span></span><br><span class="line"><span class="comment"> * 况且它的注释已经写的很明白了</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新缓冲区，与源缓冲区共享同一个字节数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">slice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(hb, -<span class="number">1</span>, <span class="number">0</span>, <span class="keyword">this</span>.remaining(), <span class="keyword">this</span>.remaining(), <span class="keyword">this</span>.position() + offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取缓冲区中剩余元素的数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 剩余元素的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">remaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> limit - position;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取position的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> position</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">position</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> position;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对于直接缓冲区来说，笔者不敢保证是否共享同一块内存区域，这块的知识点并不是很充裕</span></span><br><span class="line"><span class="comment"> * 注释上说，若调用该方法的是个直接缓冲区，那么新缓冲区将是个只读缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">slice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="keyword">this</span>.position();</span><br><span class="line">    <span class="keyword">int</span> lim = <span class="keyword">this</span>.limit();</span><br><span class="line">    <span class="keyword">assert</span> (pos &lt;= lim);</span><br><span class="line">    <span class="keyword">int</span> rem = (pos &lt;= lim ? lim - pos : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> off = (pos &lt;&lt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">assert</span> (off &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(<span class="keyword">this</span>, -<span class="number">1</span>, <span class="number">0</span>, rem, rem, off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 复制源缓冲区，包括其属性position、limit、capacity、offset</span></span><br><span class="line"><span class="comment"> * 源缓冲区与新缓冲区共享同一个字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">duplicate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(hb, <span class="keyword">this</span>.markValue(), <span class="keyword">this</span>.position(), <span class="keyword">this</span>.limit(), <span class="keyword">this</span>.capacity(), offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注释上说，若调用该方法的是个直接缓冲区，那么新缓冲区将是个只读缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">duplicate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(<span class="keyword">this</span>, <span class="keyword">this</span>.markValue(), <span class="keyword">this</span>.position(), <span class="keyword">this</span>.limit(), <span class="keyword">this</span>.capacity(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 复制源缓冲区，但是不允许新缓冲区修改内容，源缓冲区还是可以继续修改其内容，毕竟它不属于只读</span></span><br><span class="line"><span class="comment"> * HeapByteBufferR类中覆写了put方法，调用put方法都将抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">asReadOnlyBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBufferR(hb, <span class="keyword">this</span>.markValue(), <span class="keyword">this</span>.position(), <span class="keyword">this</span>.limit(), <span class="keyword">this</span>.capacity(), offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取缓冲区中position上的字节</span></span><br><span class="line"><span class="comment"> * 缓冲区中position会对应到字节数组中的索引来获取字节</span></span><br><span class="line"><span class="comment"> * 调用完该方法后position会自增</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 与该方法类似的直接缓冲区的知识点将尽量讲解，不懂的点我不会讲解！！！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 字节</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hb[ix(nextGetIndex())];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取下一个读取的元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 下一个读取的元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextGetIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position &gt;= limit)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line">    <span class="keyword">return</span> position++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取字节数组上对应的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 对应position</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 字节数组上对应的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">ix</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定字节写入到缓冲区中position位置上</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 指定字节</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">    hb[ix(nextPutIndex())] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取下一个写入的元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 下一个写入的元素的索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextPutIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position &gt;= limit)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    <span class="keyword">return</span> position++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取缓冲区中指定位置上的字节</span></span><br><span class="line"><span class="comment"> * 注意这里并没有修改position的值</span></span><br><span class="line"><span class="comment"> * 这里一直称作是指定位置，而不是指定索引，因为该位置并不是字节数组中的索引，而是缓冲区的指定位置对应到字节数组的指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定位置上的字节</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hb[ix(checkIndex(i))];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 校验指定索引是否超过界限</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">checkIndex</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((i &lt; <span class="number">0</span>) || (i &gt;= limit))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定字节写入到缓冲区中指定位置上</span></span><br><span class="line"><span class="comment"> * 注意这里并没有修改position的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 指定字节</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">    hb[ix(checkIndex(i))] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将缓冲区中的剩余元素复制指定数量，从指定字节数组的指定起始索引处开始复制缓冲区的内容</span></span><br><span class="line"><span class="comment"> * 校验字节数组的参数是否合法</span></span><br><span class="line"><span class="comment"> * 若所需数量大于缓冲区的剩余元素长度，则会抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dst 指定字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> offset 指定起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length 指定数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    checkBounds(offset, length, dst.length);</span><br><span class="line">    <span class="keyword">if</span> (length &gt; remaining())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line">    <span class="keyword">int</span> end = offset + length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = offset; i &lt; end; i++)</span><br><span class="line">        dst[i] = get();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将缓冲区中的剩余元素复制到指定字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dst 指定字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(dst, <span class="number">0</span>, dst.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定缓冲区的剩余元素复制到当前缓冲区</span></span><br><span class="line"><span class="comment"> * 若当前缓冲区是个只读，则抛出异常</span></span><br><span class="line"><span class="comment"> * 若当前的缓冲区的剩余元素个数小于指定缓冲区的剩余元素个数，简单来说，就是不够放了，那么抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src 指定缓冲区</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(ByteBuffer src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (src == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (isReadOnly())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ReadOnlyBufferException();</span><br><span class="line">    <span class="keyword">int</span> n = src.remaining();</span><br><span class="line">    <span class="keyword">if</span> (n &gt; remaining())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        put(src.get());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从指定字节数组的指定起始位置开始遍历指定数量，将遍历后的元素复制到缓冲区中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src 指定字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> offset 指定起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length 指定数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span>[] src, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    checkBounds(offset, length, src.length);</span><br><span class="line">    <span class="keyword">if</span> (length &gt; remaining())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    <span class="keyword">int</span> end = offset + length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = offset; i &lt; end; i++)</span><br><span class="line">        <span class="keyword">this</span>.put(src[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将字节数组的内容复制到缓冲区中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src 指定字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span>[] src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> put(src, <span class="number">0</span>, src.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否是可访问数组（缓冲区），代表非只读缓冲区已初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否是可访问数组（缓冲区）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (hb != <span class="keyword">null</span>) &amp;&amp; !isReadOnly;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取字节数组</span></span><br><span class="line"><span class="comment"> * 若修改缓冲区的内容，则返回的字节数组的内容也将跟着变化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 字节数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] array() &#123;</span><br><span class="line">    <span class="keyword">if</span> (hb == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    <span class="keyword">if</span> (isReadOnly)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ReadOnlyBufferException();</span><br><span class="line">    <span class="keyword">return</span> hb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取缓冲区的第一个元素对应到字节数组中的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">arrayOffset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hb == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    <span class="keyword">if</span> (isReadOnly)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ReadOnlyBufferException();</span><br><span class="line">    <span class="keyword">return</span> offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将缓冲区的剩余元素拷贝到缓冲区的起始位置</span></span><br><span class="line"><span class="comment"> * postion上的字节被拷贝到索引0上</span></span><br><span class="line"><span class="comment"> * 该方法最好在缓冲区写完数据后调用，防止数据不完整</span></span><br><span class="line"><span class="comment"> * positions设置到limit，limit设置到capacity，mark = -1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   buf.clear();</span></span><br><span class="line"><span class="comment"> *   while (in.read(buf) &gt;= 0 || buf.position != 0) &#123; // in.read(buf)：从channel读取数据到buf中 channel -&gt; buf</span></span><br><span class="line"><span class="comment"> *       buf.flip();  // 将limit设置到position, position = 0  实际上就是将写模式切换到读模式，一般在写完后要开始读取数据了调用</span></span><br><span class="line"><span class="comment"> *       out.write(buf);  // 将buf中的数据写入到channel中  buf -&gt; channel</span></span><br><span class="line"><span class="comment"> *       buf.compact();    // In case of partial write</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">compact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.arraycopy(hb, ix(position()), hb, ix(<span class="number">0</span>), remaining());</span><br><span class="line">    position(remaining());</span><br><span class="line">    limit(capacity());</span><br><span class="line">    discardMark(); <span class="comment">//mark = -1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否是直接缓冲区</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否是直接缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDirect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 比较两个缓冲区的剩余元素是否完全相同</span></span><br><span class="line"><span class="comment"> * 若有一处不同则直接返回结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> that 另一个缓冲区</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 比较结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ByteBuffer that)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">this</span>.position() + Math.min(<span class="keyword">this</span>.remaining(), that.remaining());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.position(), j = that.position(); i &lt; n; i++, j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = compare(<span class="keyword">this</span>.get(i), that.get(j));</span><br><span class="line">        <span class="keyword">if</span> (cmp != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> cmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.remaining() - that.remaining();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取缓冲区的字节顺序，默认是高位优先</span></span><br><span class="line"><span class="comment"> * 不同的机器可能会使用不同的字节排序方法来存储数据</span></span><br><span class="line"><span class="comment"> * 高位优先：高位字节存放在内存的低地址，低位字节存放在高地址</span></span><br><span class="line"><span class="comment"> * 低位优先：低位字节存放在内存的高地址，高位字节存放在低地址</span></span><br><span class="line"><span class="comment"> * 对于不同的基本类型的位数是不一样的</span></span><br><span class="line"><span class="comment"> * 高位  低位   </span></span><br><span class="line"><span class="comment"> * 0001 1111</span></span><br><span class="line"><span class="comment"> * 低地址 -----&gt; 高地址</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 代表字节顺序的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ByteOrder <span class="title">order</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bigEndian ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改缓冲区的字节顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ByteBuffer <span class="title">order</span><span class="params">(ByteOrder bo)</span> </span>&#123;</span><br><span class="line">    bigEndian = (bo == ByteOrder.BIG_ENDIAN);</span><br><span class="line">    nativeByteOrder = (bigEndian == (Bits.byteOrder() == ByteOrder.BIG_ENDIAN));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取缓冲区的position与position对应的字节，根据当前字节顺序将两个字节组成一个char值，然后将position + 2</span></span><br><span class="line"><span class="comment"> * 因为char类型是占用两个字节, 所以会将两个字节变成1个char类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 97 |  bytes</span></span><br><span class="line"><span class="comment"> * |       |       |       |   a    |  chars</span></span><br><span class="line"><span class="comment"> * |   0   |   0   |   0   |   97   |  shorts</span></span><br><span class="line"><span class="comment"> * |       0       |       97       |   ints</span></span><br><span class="line"><span class="comment"> * 以此类推....</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> char值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Bits.getChar(<span class="keyword">this</span>, ix(nextGetIndex(<span class="number">2</span>)), bigEndian);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定char值写入到缓冲区中指定位置上</span></span><br><span class="line"><span class="comment"> * 由于char占用两个字节，分为高位与低位，根据缓冲区中字节的顺序进行存储，默认情况是将高位存储在低地址，低位存储在高地址</span></span><br><span class="line"><span class="comment"> * 最终position会加2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 指定char值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">putChar</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">    Bits.putChar(<span class="keyword">this</span>, ix(nextPutIndex(<span class="number">2</span>)), x, bigEndian);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取缓冲区中指定位置上的char值</span></span><br><span class="line"><span class="comment"> * 注意这里并没有修改position的值</span></span><br><span class="line"><span class="comment"> * char值占用两个字节，所以会将position与position + 1上的字节进行组合，position放在高位、position + 1放在低位</span></span><br><span class="line"><span class="comment"> * 这里一直称作是指定位置，而不是指定索引，因为该位置并不是字节数组中的索引，而是缓冲区的指定位置对应到字节数组的指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定位置上的char值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getChar</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Bits.getChar(<span class="keyword">this</span>, ix(checkIndex(i, <span class="number">2</span>)), bigEndian);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定char值写入到缓冲区中指定位置上</span></span><br><span class="line"><span class="comment"> * 注意这里并没有修改position的值</span></span><br><span class="line"><span class="comment"> * char值可分成高低位，根据缓冲区中的字节顺序进行存放，默认情况下将高位存储在低地址，低位存储在高地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 指定位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 指定char值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">putChar</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">    Bits.putChar(<span class="keyword">this</span>, ix(checkIndex(i, <span class="number">2</span>)), x, bigEndian);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将字节缓冲区转换成字符缓冲区</span></span><br><span class="line"><span class="comment"> * 实际上内部还是通过字节缓冲区来操作，由于char占用两个字节，所以该对象对应的position、limit、capacity可能都会/2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 字符缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CharBuffer <span class="title">asCharBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">this</span>.remaining() &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> off = offset + position();</span><br><span class="line">    <span class="keyword">return</span> (bigEndian ? (CharBuffer)(<span class="keyword">new</span> ByteBufferAsCharBufferB(<span class="keyword">this</span>, -<span class="number">1</span>, <span class="number">0</span>, size, size, off)) : (CharBuffer)(<span class="keyword">new</span> ByteBufferAsCharBufferL(<span class="keyword">this</span>, -<span class="number">1</span>, <span class="number">0</span>, size, size, off)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于转换成其他类型，如short、int、float、double都是一样的道理，就不在做展示了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 相当于从写模式切换到读模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否缓冲区中还有剩余元素</span></span><br><span class="line"><span class="comment"> * 要么是写满缓冲区、要么是缓冲区的内容读完了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区是否还有剩余元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasRemaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> position &lt; limit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重新读取/写入缓冲区</span></span><br><span class="line"><span class="comment"> * 可重复读取缓冲区的内容，可重复写入来覆盖缓冲区的内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>缓冲区的基本属性有position、limit、capacity、mark，这些属性必须满足<code>0 &lt;= mark &lt;= posiiton &lt;= limit &lt;= capacity</code></p></li><li><p>可创建视图缓冲区，视图缓冲区指的是包含其他基本类型值的缓冲区，省去了类型转换的麻烦。但是千万记住视图缓冲区的索引不是以字节为单位，而是根据其值的特定类型的大小决定的</p></li><li><p>直接缓冲区建议还是了解下，不过本文没有讲的很详细，笔者能力有限</p></li><li><p>高低位、高地址、低地址，缓冲区的字节顺序</p></li><li><p>compact：将缓冲区的剩余元素拷贝到缓冲区的起始位置，修改position = limit，limit = capacity</p></li><li><p>slice：构造一个包含从position到limit之间的源缓冲区内容的新缓冲区，源缓冲区与新缓冲区共享同一个字节数组，但两者的基本属性是相互的独立</p></li><li><p>duplicate：复制源缓冲区的内容构造一个新缓冲区，包括复制基本属性，两个缓冲区共享同一个字节数组</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>基本属性</code> <code>compact、slice、duplicate</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;由于最近在了解IO相关知识，而正好看到了nio，这是我以前从来没接触过的，虽然它很早就出现了，所以先来看看有关于它的一些基础。探索&lt;code&gt;ByteBuffer&lt;/code&gt;源代码是基于&lt;code&gt;JDK1.8&lt;/code&gt;版本的，ByteBuffer的父类是&lt;code&gt;Buffer&lt;/code&gt;，通过阅读注释后对Buffer总结如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;缓冲区是特定基本类型的元素的线性有限序列，除了内容之外，缓冲区的基本属性还包括&lt;code&gt;capacity&lt;/code&gt;、&lt;code&gt;limit&lt;/code&gt;、&lt;code&gt;position&lt;/code&gt;、&lt;code&gt;mark&lt;/code&gt;。假设缓冲区是一本1000页的书籍，你已经看到800页了，其中在500页处有个很重要的知识点，你做了个标记以便下次能够轻松找到它。那么capacity指代的就是1000，意思就是这本书的最大页数，缓冲区的最大容量，该属性值不会为负不会改变；limit指代的是800，意思是目前只学了这么多知识，可以理解为界限；position指代的是具体某一页，也就是你每看一页，position就会有所增加；mark很容易理解，指代的是我们标记到具体某一页。在实际代码中有读、写模式，我们将读模式比喻成复习，也就是说你可以从第0页复习到第800页，此时的postion从0-800，limit保持800不变，也可以从你所标记的点到第800页，此时的position从mark-800，但是切记不能从第0页复习而后直接跳到mark处，这样子就导致知识点的不连续性，简单来说&lt;code&gt;0 &amp;lt;= mark &amp;lt;= posiiton &amp;lt;= limit &amp;lt;= capacity&lt;/code&gt;；将写模式比喻成继续学习新知识点，也就是从第801页继续往后看，position会逐步增加。对于只读缓冲区来说，不允许修改它的内容，但是limit、position、mark是可以变化的。最后一点是缓冲区属于非线程安全！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提供一张图片方便理解。接下来在总结下ByteBuffer，以便对其有个大概性的了解。&lt;/p&gt;
&lt;p class=&quot;customize-img&quot;&gt;&lt;img src=&quot;/assets/blogImg/java/bytebuffer/bytebuffer-variable.png&quot; alt=&quot;Buffer相关变量&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;字节缓冲区&lt;/code&gt;，可创建视图缓冲区，视图缓冲区指的是包含其他基本类型值的缓冲区，如CharBuffer，视图缓冲区的索引不是以字节为单位，而是根据其值的特定类型的大小决定的，如CharBuffer是2个字节。字节缓冲区可分为直接或间接，直接缓冲区的内容存放在堆外内存，JVM将尽最大努力直接执行原生IO操作，而间接缓冲区存放在堆内存中，交由JVM操作，与操作系统并未直接交互，直接缓冲区通常比间接缓冲区具有更高的分配和释放成本，简单来说，对于大型缓冲区来说直接分配直接缓冲区。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;概念性的内容就阐述到这里了，接着就直接进入源码世界吧！&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>深入理解String与new String</title>
    <link href="http://zlia.tech/2019/11/09/string-newString-compare/"/>
    <id>http://zlia.tech/2019/11/09/string-newString-compare/</id>
    <published>2019-11-09T15:41:06.000Z</published>
    <updated>2019-11-28T06:14:33.667Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>字符串是最常用的类型之一，趁此机会准备探索下它的源码。有关该类的注释作一个总结：</p><blockquote><p>String-字符串，是个常量，它们被创建后<code>其值</code>就不允许被改变，由于它是不可变的，所以它们可以被共享，在内部提供了多个方法来操作字符串。</p></blockquote><p>探索之前我曾看过其他人写的有关于此的文章，发现<code>JDK1.7版本前后的内存模型</code>不一样，而这部分的内容还没有排上行程，简单来说，我还不懂…所以不敢妄下结论，这篇文章的内容也不会从这方面展开来讲，此次探索是基于<code>JDK1.8</code>。</p><a id="more"></a><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a><div><span>原理</span></div></h3><p>字符串是存放在<code>常量池</code>中，至于什么是常量池不准备讨论它。先来个简单的示例方便分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String testOne = <span class="keyword">new</span> String(<span class="string">"testOne"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例就是这么简单…先让我们来看看仅仅是这么一句话，而它的底层都做了什么。紧接着反编译它的字节码文件，命令是<code>javap -v TestString</code>，输出的信息内容比较多，咱们只要常量池的内容，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/java/string/constant-pool-1.png" alt="常量池-1"></p><p>实际上我也看的不是很懂，但有几个点咱们是能确定的，也就是说<code>常量池中有testOne字符串</code>，而此时的字节码文件是编译而来的，并未实际上的运行，所以该字符串对象在堆内存中还未创建，这就说明了在编译阶段时字符串就存在于常量池中，同时也验证了一点：<code>常量池中的字符串对象</code>与运行时在<code>堆内存中创建的字符串对象</code>完全是两个对象，因为在编译时期堆内存中的对象还未出生呢，所以不可能引用到它…不知道我讲明白了没有。接着我们从另外一个角度去分析这段示例，因为后续的其他示例可能会羞涩难懂，所以先从简单的示例开始逐渐熟悉起来，最终也是希望读者能够理解这方面的知识。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    Constant pool:</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 编号  类型                值              注释            --------&gt; 这里的注释不一定对，只是作一个标记方便理解        </span></span><br><span class="line">    #1 = Methodref          #6.#22         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">    #2 = Class              #23            // java/lang/String</span><br><span class="line">    #3 = String             #18            // testOne</span><br><span class="line">    #4 = Methodref          #2.#24         // java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V</span><br><span class="line">    #5 = Class              #25            // test20190820/TestString</span><br><span class="line">    #6 = Class              #26            // java/lang/Object</span><br><span class="line">    #7 = Utf8               &lt;init&gt;</span><br><span class="line">    #8 = Utf8               ()V</span><br><span class="line">    #9 = Utf8               Code</span><br><span class="line">    #10 = Utf8               LineNumberTable</span><br><span class="line">    #11 = Utf8               LocalVariableTable</span><br><span class="line">    #12 = Utf8               this</span><br><span class="line">    #13 = Utf8               Ltest20190820/TestString;</span><br><span class="line">    #14 = Utf8               main</span><br><span class="line">    #15 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">    #16 = Utf8               args</span><br><span class="line">    #17 = Utf8               [Ljava/lang/String;</span><br><span class="line">    #18 = Utf8               testOne</span><br><span class="line">    #19 = Utf8               Ljava/lang/String;</span><br><span class="line">    #20 = Utf8               SourceFile</span><br><span class="line">    #21 = Utf8               TestString.java</span><br><span class="line">    #22 = NameAndType        #7:#8          // "&lt;init&gt;":()V</span><br><span class="line">    #23 = Utf8               java/lang/String</span><br><span class="line">    #24 = NameAndType        #7:#27         // "&lt;init&gt;":(Ljava/lang/String;)V</span><br><span class="line">    #25 = Utf8               test20190820/TestString</span><br><span class="line">    #26 = Utf8               java/lang/Object</span><br><span class="line">    #27 = Utf8               (Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><p>执行<code>javap -c TestString</code>获取底层代码执行逻辑，如图所示：</p><p class="customize-img"><img src="/assets/blogImg/java/string/constant-pool-2.png" alt="常量池-2"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test20190820</span>.<span class="title">TestString</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> test20190820.TestString(); <span class="comment">//这里是构造器的执行逻辑，咱们忽略它，毕竟不是重点</span></span><br><span class="line">        Code:</span><br><span class="line">        <span class="number">0</span>: aload_0</span><br><span class="line">        1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">        <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>; <span class="comment">//下面的内容涉及到字节码的指令，网上很多资料，可自行查阅</span></span><br><span class="line">    Code:</span><br><span class="line">    <span class="comment">// #2：对应常量池中编号#2，加上注释我们得出这里是创建字符串对象  -&gt; new String();</span></span><br><span class="line">    0: new           #2                  // class java/lang/String</span><br><span class="line">    <span class="comment">// dup：复制0序号中的引用并压入栈中  -&gt; 也就是将字符串对象的引用放入到栈中</span></span><br><span class="line">    <span class="number">3</span>: dup</span><br><span class="line">    <span class="comment">// ldc：从常量池中加载指定项的引用到栈  #3：同上，对应着常量池的编号#3 -&gt; 将"testOne"字符串的引用加载到栈中</span></span><br><span class="line">    4: ldc           #3                  // String testOne</span><br><span class="line">    <span class="comment">// invokespecial：初始化常量池中的指定项  -&gt; 调用字符串对象的初始化并将4序号中的引用作为参数传入，形成new String("testOne")</span></span><br><span class="line">    6: invokespecial #4                  // Method java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V</span><br><span class="line">    <span class="comment">// astore_n：将引用赋值给第n个局部变量  -&gt; 将6序号的引用赋值给第一个局部变量，String testOne = new String("testOne")，jvm中是有记录局部变量的信息</span></span><br><span class="line">    <span class="number">9</span>: astore_1</span><br><span class="line">    <span class="comment">// 退出方法的标志</span></span><br><span class="line">    <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的分析可以知道：<code>常量池中的字符串对象与在堆内存中创建的字符串对象是两个对象</code>，这一点很重要！接下来是各种示例，我们将采用上面的方式进行分析。</p><h4 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String testOne = <span class="keyword">new</span> String(<span class="string">"testOne"</span>);</span><br><span class="line">        String testOneAnother = <span class="string">"testOne"</span>;</span><br><span class="line">        System.out.println(testOne == testOneAnother); <span class="comment">//false -&gt; 上面说了testOne和testOneAnother是两个对象，所以很容易得出结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        String s2 = <span class="string">"a"</span>;</span><br><span class="line">        String s3 = <span class="string">"bc"</span>;</span><br><span class="line">        String s4 = s2 + s3; <span class="comment">// StringBuilder.append(a).append(bc) -&gt; StringBuilder.toString() -&gt; new String("abc")</span></span><br><span class="line">        System.out.println(s1 == s4); <span class="comment">//false, s1指向了常量池中的字符串abc，s4相当于生成了新的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里就不贴常量池的信息了，反正我们能确定的是在编译时期字符串已经加载到常量池中了，所以常量池中应该存在abc、a、bc字符串</span></span><br><span class="line"><span class="comment"> * 贴出代码的执行逻辑：</span></span><br><span class="line"><span class="comment"> *  public static void main(java.lang.String[]);</span></span><br><span class="line"><span class="comment"> *      Code:</span></span><br><span class="line"><span class="comment"> *          0: ldc           #2                  // String abc   -&gt;  ldc：从常量池中加载指定项的引用到栈</span></span><br><span class="line"><span class="comment"> *          2: astore_1                                          -&gt;  abstor_1：将引用赋值给第1个局部变量， 即 s1 = "abc"</span></span><br><span class="line"><span class="comment"> *          3: ldc           #3                  // String a</span></span><br><span class="line"><span class="comment"> *          5: astore_2                                          -&gt;  s2 = "a"</span></span><br><span class="line"><span class="comment"> *          6: ldc           #4                  // String bc</span></span><br><span class="line"><span class="comment"> *          8: astore_3                                          -&gt;  s3 = "bc"</span></span><br><span class="line"><span class="comment"> *          9: new           #5                  // class java/lang/StringBuilder    -&gt; 创建StringBuilder对象</span></span><br><span class="line"><span class="comment"> *          12: dup    -&gt;  复制StringBuilder对象的引用并压入栈中</span></span><br><span class="line"><span class="comment"> *          13: invokespecial #6                  // Method java/lang/StringBuilder."&lt;init&gt;":()V    -&gt; 初始化StringBuilder对象</span></span><br><span class="line"><span class="comment"> *          16: aload_2                            -&gt; 加载第二个局部变量的值</span></span><br><span class="line"><span class="comment"> *          17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;  -&gt; 调用常量池中指定项的方法，即调用StringBuilder对象中的append方法，并传入序号 *                                                                                                                                           16中的引用，所以最终是StringBuilder#append(a)</span></span><br><span class="line"><span class="comment"> *          20: aload_3</span></span><br><span class="line"><span class="comment"> *          21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line"><span class="comment"> *          24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;      -&gt; StringBuilder#toString, 可以看下该类的toString方法，生成了一个新的对象，该对象中的字符串不会再*                                                                                                                        常量池中生成</span></span><br><span class="line"><span class="comment"> *          27: astore        4                    -&gt; 将序号24中的引用赋值给第4个局部变量 s4 = StringBuilder.toString = new String()</span></span><br><span class="line"><span class="comment"> *          29: getstatic     #9                  // Field java/lang/System.out:Ljava/io/PrintStream;   -&gt; 下面的就讨论了，执行的是System.out.println代码片段了</span></span><br><span class="line"><span class="comment"> *          32: aload_1</span></span><br><span class="line"><span class="comment"> *          33: aload         4</span></span><br><span class="line"><span class="comment"> *          35: if_acmpne     42</span></span><br><span class="line"><span class="comment"> *          38: iconst_1</span></span><br><span class="line"><span class="comment"> *          39: goto          43</span></span><br><span class="line"><span class="comment"> *          42: iconst_0</span></span><br><span class="line"><span class="comment"> *          43: invokevirtual #10                 // Method java/io/PrintStream.println:(Z)V</span></span><br><span class="line"><span class="comment"> *          46: return</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 从上面的分析中我们得出结论：s1指向常量池中的字符串对象abc，而从序号16-27我们知道生成了新的对象，相当于是执行了new String("abc")，而这不就又回到了示例一了吗，结果自然是false</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        <span class="keyword">final</span> String s2 = <span class="string">"a"</span>;</span><br><span class="line">        <span class="keyword">final</span> String s3 = <span class="string">"bc"</span>;</span><br><span class="line">        String s4 = s2 + s3; <span class="comment">//由于s2、s3被final修饰了，故而直接替换变量的值，最后s4 = "abc"，直接使用了常量池中的字符串对象abc</span></span><br><span class="line">        System.out.println(s1 == s4); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同样贴出代码的执行逻辑：</span></span><br><span class="line"><span class="comment"> *  public static void main(java.lang.String[]);</span></span><br><span class="line"><span class="comment"> *      Code:</span></span><br><span class="line"><span class="comment"> *          0: ldc           #2                  // String abc  -&gt; ldc：从常量池中加载指定项的引用到栈</span></span><br><span class="line"><span class="comment"> *          2: astore_1                                         -&gt; s1 = "abc"</span></span><br><span class="line"><span class="comment"> *          3: ldc           #3                  // String a</span></span><br><span class="line"><span class="comment"> *          5: astore_2                                         -&gt; s2 = "a" </span></span><br><span class="line"><span class="comment"> *          6: ldc           #4                  // String bc</span></span><br><span class="line"><span class="comment"> *          8: astore_3                                         -&gt; s3 = "bc"</span></span><br><span class="line"><span class="comment"> *          9: ldc           #2                  // String abc</span></span><br><span class="line"><span class="comment"> *          11: astore        4                                 -&gt; s4 = "abc"  示例三与示例二的区别在于加了final修饰，被final修饰的变量会在编译阶段直接替换成对应的值，即"a" + "bc"，而这个在示例四中我们也会分析到，是直接采用</span></span><br><span class="line"><span class="comment"> *                                                                             字符串合并，而合并后的字符串abc在常量池中已经存在了，故直接使用</span></span><br><span class="line"><span class="comment"> *          13: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line"><span class="comment"> *          16: aload_1</span></span><br><span class="line"><span class="comment"> *          17: aload         4</span></span><br><span class="line"><span class="comment"> *          19: if_acmpne     26</span></span><br><span class="line"><span class="comment"> *          22: iconst_1</span></span><br><span class="line"><span class="comment"> *          23: goto          27</span></span><br><span class="line"><span class="comment"> *          26: iconst_0</span></span><br><span class="line"><span class="comment"> *          27: invokevirtual #6                  // Method java/io/PrintStream.println:(Z)V</span></span><br><span class="line"><span class="comment"> *          30: return</span></span><br><span class="line"><span class="comment"> * 从上面的分析中我们得出结论：s1指向了常量池中的字符串对象abc，s4也是指向了常量池中的字符串对象abc</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="示例四"><a href="#示例四" class="headerlink" title="示例四"></a>示例四</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        String s2 = <span class="string">"a"</span> + <span class="string">"bc"</span>; <span class="comment">//s1、s2指向同一个字符串</span></span><br><span class="line">        String s3 = <span class="string">"test"</span> + <span class="string">"One"</span>; <span class="comment">//说明常量池是直接存储合并后的字符串</span></span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里多贴出常量池的信息，为了说明s3的行为</span></span><br><span class="line"><span class="comment"> * Constant pool:</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * #30 = Utf8               abc</span></span><br><span class="line"><span class="comment"> * #31 = Utf8               testOne</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * 省略了一部分信息，说明常量池是直接存储合并后的字符串，而并分开存储，所以常量池中只会有"testOne"，并没有"test"或"One"</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  public static void main(java.lang.String[]);</span></span><br><span class="line"><span class="comment"> *       Code:</span></span><br><span class="line"><span class="comment"> *          0: ldc           #2                  // String abc</span></span><br><span class="line"><span class="comment"> *          2: astore_1                            -&gt; s1 = "abc" 指向常量池中#2的引用</span></span><br><span class="line"><span class="comment"> *          3: ldc           #2                  // String abc</span></span><br><span class="line"><span class="comment"> *          5: astore_2                            -&gt; s2 = "abc" 从常量池中#2的引用，可以看到引用的字符串对象是同一个</span></span><br><span class="line"><span class="comment"> *          6: ldc           #3                  // String testOne</span></span><br><span class="line"><span class="comment"> *          8: astore_3</span></span><br><span class="line"><span class="comment"> *          9: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line"><span class="comment"> *          12: aload_1</span></span><br><span class="line"><span class="comment"> *          13: aload_2</span></span><br><span class="line"><span class="comment"> *          14: if_acmpne     21</span></span><br><span class="line"><span class="comment"> *          17: iconst_1</span></span><br><span class="line"><span class="comment"> *          18: goto          22</span></span><br><span class="line"><span class="comment"> *          21: iconst_0</span></span><br><span class="line"><span class="comment"> *          22: invokevirtual #5                  // Method java/io/PrintStream.println:(Z)V</span></span><br><span class="line"><span class="comment"> *          25: return</span></span><br><span class="line"><span class="comment"> * 从上面的分析中我们得出结论：s1、s2指向了常量池中的同一个字符串对象</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="示例五"><a href="#示例五" class="headerlink" title="示例五"></a>示例五</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        String s2 = <span class="string">"a"</span>;</span><br><span class="line">        String s3 = s2 + <span class="string">"bc"</span>; <span class="comment">// StringBuilder.append(a).append(bc) -&gt; StringBuilder.toString() -&gt; new String("abc")</span></span><br><span class="line">        System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * public static void main(java.lang.String[]);</span></span><br><span class="line"><span class="comment"> *       Code:</span></span><br><span class="line"><span class="comment"> *          0: ldc           #2                  // String abc</span></span><br><span class="line"><span class="comment"> *          2: astore_1                             -&gt; s1 = "abc"</span></span><br><span class="line"><span class="comment"> *          3: ldc           #3                  // String a</span></span><br><span class="line"><span class="comment"> *          5: astore_2                             -&gt; s2 = "a"</span></span><br><span class="line"><span class="comment"> *          6: new           #4                  // class java/lang/StringBuilder   -&gt; 创建StringBuilder对象</span></span><br><span class="line"><span class="comment"> *          9: dup           -&gt;  复制StringBuilder对象的引用并压入栈中</span></span><br><span class="line"><span class="comment"> *          10: invokespecial #5                  // Method java/lang/StringBuilder."&lt;init&gt;":()V   -&gt; 初始化StringBuilder</span></span><br><span class="line"><span class="comment"> *          13: aload_2                             -&gt; 加载第二个局部变量的值</span></span><br><span class="line"><span class="comment"> *          14: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;   -&gt; StringBuilder.append("a")</span></span><br><span class="line"><span class="comment"> *          17: ldc           #7                  // String bc</span></span><br><span class="line"><span class="comment"> *          19: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;   -&gt; StringBuilder.append("bc")</span></span><br><span class="line"><span class="comment"> *          22: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;    -&gt; StringBuilder.toString</span></span><br><span class="line"><span class="comment"> *          25: astore_3                           -&gt; s3 = "abc"</span></span><br><span class="line"><span class="comment"> *          26: getstatic     #9                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line"><span class="comment"> *          29: aload_1</span></span><br><span class="line"><span class="comment"> *          30: aload_3</span></span><br><span class="line"><span class="comment"> *          31: if_acmpne     38</span></span><br><span class="line"><span class="comment"> *          34: iconst_1</span></span><br><span class="line"><span class="comment"> *          35: goto          39</span></span><br><span class="line"><span class="comment"> *          38: iconst_0</span></span><br><span class="line"><span class="comment"> *          39: invokevirtual #10                 // Method java/io/PrintStream.println:(Z)V</span></span><br><span class="line"><span class="comment"> *          42: return</span></span><br><span class="line"><span class="comment"> * 从上面的分析中我们得出结论：s1指向常量池中的字符串对象abc，而从序号9-25我们知道生成了新的对象，相当于是执行了new String("abc")，结果自然是false</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="示例六"><a href="#示例六" class="headerlink" title="示例六"></a>示例六</h4><p>先来看下String#intern方法作了什么动作，还是采用此分析方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String testOne = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"bc"</span>); <span class="comment">//常量池中存储字符串a、bc，最终testOne指向堆内存中的对象，而该对象对应的字符串是不会在常量池中存在</span></span><br><span class="line">        String testOneAnother = testOne.intern(); <span class="comment">//先去常量池中查询是否已经存在该字符串，如果存在，则返回常量池中的引用，若不存在则不会将该对象的字符串拷贝到常量池中，而是在常量池中持有对该对象的引用</span></span><br><span class="line">                                                  <span class="comment">//这里的引用没办法从该方式得出，可能需要看下native的方法，反正我是看了别人的分析，虽然我是知道原理但还是忍不住看了以下底层实现</span></span><br><span class="line">        System.out.println(testOne == testOneAnther) <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constant pool:</span></span><br><span class="line"><span class="comment"> *  ...</span></span><br><span class="line"><span class="comment"> * #31 = Utf8               a</span></span><br><span class="line"><span class="comment"> *  ...</span></span><br><span class="line"><span class="comment"> * #34 = Utf8               bc</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="示例七"><a href="#示例七" class="headerlink" title="示例七"></a>示例七</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"bc"</span>);</span><br><span class="line">        s1.intern(); <span class="comment">//执行方法前我们知道常量池中并未有abc字符串，执行该方法后，常量池中已经存在指向s1对象的引用，即"abc"字符串的引用</span></span><br><span class="line">        String s2 = <span class="string">"abc"</span>; <span class="comment">// 常量池中已经存在"abc"字符串的引用，即为s1对象的引用</span></span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * public static void main(java.lang.String[]);</span></span><br><span class="line"><span class="comment"> *      Code:</span></span><br><span class="line"><span class="comment"> *          0: new           #2                  // class java/lang/StringBuilder    -&gt; 创建StringBuilder对象</span></span><br><span class="line"><span class="comment"> *          3: dup                                -&gt; 复制StringBuilder对象的引用并压入栈中</span></span><br><span class="line"><span class="comment"> *          4: invokespecial #3                  // Method java/lang/StringBuilder."&lt;init&gt;":()V  -&gt; 初始化StringBuilder</span></span><br><span class="line"><span class="comment"> *          7: new           #4                  // class java/lang/String    -&gt; 创建字符串对象 new String()</span></span><br><span class="line"><span class="comment"> *          10: dup                               -&gt; 复制String对象的引用并压入栈中</span></span><br><span class="line"><span class="comment"> *          11: ldc           #5                  // String a</span></span><br><span class="line"><span class="comment"> *          13: invokespecial #6                  // Method java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V    -&gt; new String("a")</span></span><br><span class="line"><span class="comment"> *          16: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; -&gt; StringBuilder.append()</span></span><br><span class="line"><span class="comment"> *          19: new           #4                  // class java/lang/String    -&gt;  创建字符串对象 new String()</span></span><br><span class="line"><span class="comment"> *          22: dup                               -&gt; 复制String对象的引用并压入栈中</span></span><br><span class="line"><span class="comment"> *          23: ldc           #8                  // String bc</span></span><br><span class="line"><span class="comment"> *          25: invokespecial #6                  // Method java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V   -&gt; new String("bc")</span></span><br><span class="line"><span class="comment"> *          28: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; -&gt; StringBuilder.append()</span></span><br><span class="line"><span class="comment"> *          31: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;  -&gt; StringBuilder.toString()</span></span><br><span class="line"><span class="comment"> *          34: astore_1                          -&gt; s1 = "abc", 由StringBuilder#toString创建的字符串对象</span></span><br><span class="line"><span class="comment"> *          35: aload_1                           -&gt; 加载第一个局部变量的值</span></span><br><span class="line"><span class="comment"> *          36: invokevirtual #10                 // Method java/lang/String.intern:()Ljava/lang/String;  -&gt; s1.intern()</span></span><br><span class="line"><span class="comment"> *          39: pop                               -&gt; pop：移除栈顶的值</span></span><br><span class="line"><span class="comment"> *          40: ldc           #11                 // String abc</span></span><br><span class="line"><span class="comment"> *          42: astore_2                          -&gt; s2 = "abc"</span></span><br><span class="line"><span class="comment"> *          43: getstatic     #12                 // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line"><span class="comment"> *          46: aload_1</span></span><br><span class="line"><span class="comment"> *          47: aload_2</span></span><br><span class="line"><span class="comment"> *          48: if_acmpne     55</span></span><br><span class="line"><span class="comment"> *          51: iconst_1</span></span><br><span class="line"><span class="comment"> *          52: goto          56</span></span><br><span class="line"><span class="comment"> *          55: iconst_0</span></span><br><span class="line"><span class="comment"> *          56: invokevirtual #13                 // Method java/io/PrintStream.println:(Z)V</span></span><br><span class="line"><span class="comment"> *          59: return</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="示例八"><a href="#示例八" class="headerlink" title="示例八"></a>示例八</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>); <span class="comment">//生成两个对象，堆内存一个，常量池一个</span></span><br><span class="line">        s1.intern(); <span class="comment">//常量池中已经存在该字符串对象，故而直接返回</span></span><br><span class="line">        String s2 = <span class="string">"abc"</span>; <span class="comment">//指向常量池的字符串对象</span></span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//false  -&gt; s1指向堆内存中的对象，s2指向常量池的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>在编译阶段，字符串已经被存储与常量池中</p></li><li><p>new String(“abc”)：一共有两个不同的对象，一个在堆内存、一个在常量池</p></li><li><p>s2 + s3拼接（s2、s3未被final修饰）：底层创建StringBuilder对象，通过append拼接起来，最终调用toString生成一个新的对象</p></li><li><p>“a” + “bc”直接拼接：直接将拼接后的字符串存储于常量池中</p></li><li><p>s2 + “bc”拼接（s2未被final修饰）：底层创建StringBuilder对象，通过append拼接起来，最终调用toString生成一个新的对象</p></li><li><p>s.intern：若常量池中存在字符串，则直接返回引用，若不存在，则在常量池中生成指向该字符串对象的引用，后续若有声明此字符串，会返回指向该字符串对象的引用，也就是同一个引用（参考示例七、八）</p></li></ul><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a><div><span>重点</span></div></h3><p><code>new String与String的区别</code> <code>(s1 + s2)与(&quot;a&quot; + &quot;bc&quot;)的区别</code> <code>intern</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;字符串是最常用的类型之一，趁此机会准备探索下它的源码。有关该类的注释作一个总结：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;String-字符串，是个常量，它们被创建后&lt;code&gt;其值&lt;/code&gt;就不允许被改变，由于它是不可变的，所以它们可以被共享，在内部提供了多个方法来操作字符串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;探索之前我曾看过其他人写的有关于此的文章，发现&lt;code&gt;JDK1.7版本前后的内存模型&lt;/code&gt;不一样，而这部分的内容还没有排上行程，简单来说，我还不懂…所以不敢妄下结论，这篇文章的内容也不会从这方面展开来讲，此次探索是基于&lt;code&gt;JDK1.8&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Comparable VS Comparator</title>
    <link href="http://zlia.tech/2019/11/06/comparable-comparator-compare/"/>
    <id>http://zlia.tech/2019/11/06/comparable-comparator-compare/</id>
    <published>2019-11-06T10:45:42.000Z</published>
    <updated>2019-11-06T10:45:42.075Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>在阅读TreeMap源码时发现了Comparable与Comparator，光是名字看起来就很像，既然都是比较器，那有何区别呢？实际上我对于比较器的使用场景并不是很多，所以这篇还是借鉴了别人的想法。</p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a><div><span>比较</span></div></h3><p>通过下面的这段代码来说明问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Apple appleOne = <span class="keyword">new</span> Apple(<span class="number">1</span>, <span class="string">"red"</span>);</span><br><span class="line">        Apple appleTwo = <span class="keyword">new</span> Apple(<span class="number">2</span>, <span class="string">"green"</span>);</span><br><span class="line">        appleOne.compareTo(appleTwo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Apple</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    Apple(<span class="keyword">int</span> size, String color)&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Apple o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size &gt; o.size ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">//比较Apple的大小</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getter、setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>代码上挺简单的，只是比较了Apple的大小，现在来思考一下，哪一天突然想比较Apple的颜色了，那岂不是要改代码了，而对于新需求我们通常说现有代码尽量保持不变，通过新增类的方式来满足，所以Comparable的缺点很明显，一旦某个类指定了比较方式后就无法做修改（除非是修改代码…），即使能修改代码我们也不知道会不会造成新的问题或新的需求产生，所以这是行不通的。而对于Comparator来说，它就显得更加灵活了，支持多个比较器，只要新增类即可，看如下的代码展示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Apple appleOne = <span class="keyword">new</span> Apple(<span class="number">1</span>, <span class="string">"red"</span>);</span><br><span class="line">        Apple appleTwo = <span class="keyword">new</span> Apple(<span class="number">2</span>, <span class="string">"green"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较Apple的大小</span></span><br><span class="line">        AppleCompareSize acs = <span class="keyword">new</span> AppleCompareSize();</span><br><span class="line">        acs.compare(appleOne, appleTwo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较Apple的颜色</span></span><br><span class="line">        AppleCompareColor acc = <span class="keyword">new</span> AppleCompareColor();</span><br><span class="line">        acc.compare(appleOne, appleTwo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    Apple(<span class="keyword">int</span> size, String color) &#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getter、setter</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleCompareSize</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Apple</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Apple o1, Apple o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getSize() &gt; o2.getSize() ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleCompareColor</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Apple</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Apple o1, Apple o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getColor().compareTo(o2.getColor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该很容易就能看出效果了，即使别人已经写好了一个比较器，对于新需求，我们只要增加即可，并不会出现修改或污染其他人代码的情况。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><div><span>总结</span></div></h3><p>Comparator与Comaparable的最大区别在于<code>Comparator能够定义多种不同的比较策略</code>，即新增多个比较来，同时避免往比较对象（Apple）中添加其他代码（比较）</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;在阅读TreeMap源码时发现了Comparable与Comparator，光是名字看起来就很像，既然都是比较器，那有何区别呢？实际上我对于比较器的使用场景并不是很多，所以这篇还是借鉴了别人的想法。&lt;/p&gt;
&lt;h3 id=&quot;比较&quot;&gt;&lt;a href=&quot;#比较&quot; class=&quot;headerlink&quot; title=&quot;比较&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;比较&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;通过下面的这段代码来说明问题。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Apple appleOne = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Apple(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Apple appleTwo = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Apple(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        appleOne.compareTo(appleTwo);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Apple&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Comparable&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;Apple&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String color;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Apple(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; size, String color)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.size = size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.color = color;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;compareTo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Apple o)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; size &amp;gt; o.size ? &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; : &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//比较Apple的大小&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//getter、setter&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索LinkedHashSet底层实现</title>
    <link href="http://zlia.tech/2019/11/06/explain-linkedhashset-sourcecode/"/>
    <id>http://zlia.tech/2019/11/06/explain-linkedhashset-sourcecode/</id>
    <published>2019-11-06T06:24:42.000Z</published>
    <updated>2019-11-06T06:24:42.323Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>额… 底层实现了LinkedHashMap，它的数据结构是<code>数组 + 链表 + 红黑树</code>，内部通过一条<code>链表</code>来维护<code>有序性</code>，按照插入顺序进行排列。代码只有100行…</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定初始容量与加载因子来初始化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loadFactor 指定加载因子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定初始容量来初始化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">16</span>, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定集合来初始化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Math.max(<span class="number">2</span>*c.size(), <span class="number">11</span>), .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>LinkedHashSet底层基于LinkedHashMap</p></li><li><p>LinkedHashSet有序、不可重复、非线程安全</p></li><li><p>LinkedHashSet允许空元素</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>基于LinkedHashMap</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;额… 底层实现了LinkedHashMap，它的数据结构是&lt;code&gt;数组 + 链表 + 红黑树&lt;/code&gt;，内部通过一条&lt;code&gt;链表&lt;/code&gt;来维护&lt;code&gt;有序性&lt;/code&gt;，按照插入顺序进行排列。代码只有100行…&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索TreeSet底层实现</title>
    <link href="http://zlia.tech/2019/11/06/explain-treeset-sourcecode/"/>
    <id>http://zlia.tech/2019/11/06/explain-treeset-sourcecode/</id>
    <published>2019-11-06T03:20:51.000Z</published>
    <updated>2019-11-06T03:20:51.091Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>TreeSet的内部实现基于TreeMap，所以它的数据结构是<code>红黑树</code>。注释也不总结了，此探索是基于<code>JDK1.8</code>，直接进入正题。</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//存储元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//既然用了TreeMap就要考虑值应该存什么，就是它了，不管新增的元素是什么，它都作为值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定NavigableMap实现类来初始化</span></span><br><span class="line"><span class="comment"> * ConcurrentSkipListMap是NavigableMap的实现类！！！埋下伏笔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class="line">    <span class="keyword">this</span>.m = m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定比较器进行初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> comparator 比较器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;&gt;(comparator));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指定集合进行初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定Set集合进行初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s Set集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(SortedSet&lt;E&gt; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(s.comparator());</span><br><span class="line">    addAll(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.navigableKeySet().iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取按降序排列的迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 降序排列的迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.descendingKeySet().iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取按降序排列的Set集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 降序排列的Set集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">descendingSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeSet&lt;&gt;(m.descendingMap());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TreeSet集合的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TreeSet集合是否为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TreeSet是否包含指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.containsKey(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否新增成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量添加指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Use linear-time version if applicable</span></span><br><span class="line">    <span class="keyword">if</span> (m.size()==<span class="number">0</span> &amp;&amp; c.size() &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        c <span class="keyword">instanceof</span> SortedSet &amp;&amp;</span><br><span class="line">        m <span class="keyword">instanceof</span> TreeMap) &#123;</span><br><span class="line">        SortedSet&lt;? extends E&gt; set = (SortedSet&lt;? extends E&gt;) c;</span><br><span class="line">        TreeMap&lt;E,Object&gt; map = (TreeMap&lt;E, Object&gt;) m;</span><br><span class="line">        Comparator&lt;?&gt; cc = set.comparator();</span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> E&gt; mc = map.comparator();</span><br><span class="line">        <span class="keyword">if</span> (cc==mc || (cc != <span class="keyword">null</span> &amp;&amp; cc.equals(mc))) &#123;</span><br><span class="line">            map.addAllForTreeSet(set, PRESENT); <span class="comment">//指定集合来添加一颗红黑树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定起始元素与结束元素及是否包含起始、结束元素来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * 当前对象是已经排好序了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromElement 起始元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromInclusive 子集中是否包含起始元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toElement 结束元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toInclusive 子集中是否包含结束元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, <span class="keyword">boolean</span> fromInclusive, E toElement,   <span class="keyword">boolean</span> toInclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeSet&lt;&gt;(m.subMap(fromElement, fromInclusive, toElement, toInclusive));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定结束元素及是否包含结束元素来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * 当前对象是已经排好序了，相当于起始元素已经指定好了</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toElement 结束元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inclusive 子集中是否包含结束元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement, <span class="keyword">boolean</span> inclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeSet&lt;&gt;(m.headMap(toElement, inclusive));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定起始元素及是否包含起始元素来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * 相当于介绍元素已经指定好了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromElement 起始元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inclusive 子集中是否包含起始元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement, <span class="keyword">boolean</span> inclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeSet&lt;&gt;(m.tailMap(fromElement, inclusive));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定起始元素与结束元素来获取当前对象的子集</span></span><br><span class="line"><span class="comment"> * 包含起始元素、不包含结束元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromElement 起始元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toElement 结束元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 子集对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SortedSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, E toElement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> subSet(fromElement, <span class="keyword">true</span>, toElement, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取比较器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 比较器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator() &#123;</span><br><span class="line">    <span class="keyword">return</span> m.comparator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取排序后的第一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 排序后的第一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.firstKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取排序后的最后一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 排序后的最后一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">last</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.lastKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取小于指定元素的最大值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 小于指定元素的最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">lower</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.lowerKey(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取等于或小于指定元素的最大值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 等于或小于指定元素的最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">floor</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.floorKey(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取等于或大于指定元素的最小值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 等于或大于指定元素的最小值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">ceiling</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.ceilingKey(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取大于指定元素的最小值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 大于指定元素的最小值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">higher</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.higherKey(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取排序后的第一个元素并移除</span></span><br><span class="line"><span class="comment"> * 获取最左边的元素并移除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最左边的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map.Entry&lt;E,?&gt; e = m.pollFirstEntry();</span><br><span class="line">    <span class="keyword">return</span> (e == <span class="keyword">null</span>) ? <span class="keyword">null</span> : e.getKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取排序后的最后一个元素并移除</span></span><br><span class="line"><span class="comment"> * 获取最右边的元素并移除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最右边的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map.Entry&lt;E,?&gt; e = m.pollLastEntry();</span><br><span class="line">    <span class="keyword">return</span> (e == <span class="keyword">null</span>) ? <span class="keyword">null</span> : e.getKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>TreeSet底层是TreeMa，所以它的数据结构是红黑树</p></li><li><p>TreeSet有序、不可重复、非线程安全</p></li><li><p>TreeSet默认按照自然顺序排列元素，可指定比较器来自定义排序</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>基于TreeMap</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;TreeSet的内部实现基于TreeMap，所以它的数据结构是&lt;code&gt;红黑树&lt;/code&gt;。注释也不总结了，此探索是基于&lt;code&gt;JDK1.8&lt;/code&gt;，直接进入正题。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索HashSet底层实现</title>
    <link href="http://zlia.tech/2019/11/05/explain-hashset-sourcecode/"/>
    <id>http://zlia.tech/2019/11/05/explain-hashset-sourcecode/</id>
    <published>2019-11-05T12:59:05.000Z</published>
    <updated>2019-11-05T12:59:05.138Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>HashSet的底层实现依赖于HashMap，所以它的数据结构也是<code>数组 + 链表 + 红黑树</code>，而对于它的类注释也没什么好总结的，探索HashSet底层实现是基于<code>JDK1.8</code>。仔细一想，HashSet存在的意义是什么？有时候需要添加元素时，也就是只有单个对象，并没有所谓的键值对，或许还有些用处，可这ArrayList也能做到啊！可是相比之下，HashSet由于有HashMap撑腰，它的性能要高于ArrayList，所以我认为HashSet是List和Map独有的特性结合后的产物。</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//可序列化、可克隆</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接使用了HashMap来存储它的元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//既然用了HashMap就要考虑值应该存什么，就是它了，不管新增的元素是什么，它都作为值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定集合来初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量与加载因子来初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor 指定加载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量来初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定初始容量与加载因子来初始化</span></span><br><span class="line"><span class="comment"> * 对比上面这里构造了LinkedHashMap，说明它是有序的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 指定初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor 指定加载因子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dummy 无实际意义，为了与上面的构造函数区分开来</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取元素个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashSet是否为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashSet是否包含指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否新增成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 浅克隆</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        newSet.map = (HashMap&lt;E, Object&gt;) map.clone();</span><br><span class="line">        <span class="keyword">return</span> newSet;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>HashSet无序、不可重复、非线程安全</p></li><li><p>HashSet允许存放空元素</p></li><li><p>HashSet底层基于HashMap</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>基于HashMap</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;HashSet的底层实现依赖于HashMap，所以它的数据结构也是&lt;code&gt;数组 + 链表 + 红黑树&lt;/code&gt;，而对于它的类注释也没什么好总结的，探索HashSet底层实现是基于&lt;code&gt;JDK1.8&lt;/code&gt;。仔细一想，HashSet存在的意义是什么？有时候需要添加元素时，也就是只有单个对象，并没有所谓的键值对，或许还有些用处，可这ArrayList也能做到啊！可是相比之下，HashSet由于有HashMap撑腰，它的性能要高于ArrayList，所以我认为HashSet是List和Map独有的特性结合后的产物。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>比较Map实现类的不同点</title>
    <link href="http://zlia.tech/2019/11/05/map-different-compare/"/>
    <id>http://zlia.tech/2019/11/05/map-different-compare/</id>
    <published>2019-11-05T08:22:02.000Z</published>
    <updated>2019-11-05T13:10:22.159Z</updated>
    
    <content type="html"><![CDATA[<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a><div><span>比较</span></div></h3><p>趁热打铁！比较最近学习到的几个Map实现类，也正好总结下！此比较是基于<code>JDK1.8</code>，直接用表格展示。</p><table><thead><tr><th style="text-align:center">比较点</th><th style="text-align:center">HashMap</th><th style="text-align:center">Hashtable</th><th style="text-align:center">IdentityHashMap</th><th style="text-align:center">LinkedHashMap</th><th style="text-align:center">TreeMap</th><th style="text-align:center">WeakHashMap</th></tr></thead><tbody><tr><td style="text-align:center">数据结构</td><td style="text-align:center">数组<br>链表<br>红黑树</td><td style="text-align:center">数组<br>链表</td><td style="text-align:center">数组<br>（哈希探针表）</td><td style="text-align:center">数组<br>链表<br>红黑树</td><td style="text-align:center">红黑树</td><td style="text-align:center">数组<br>链表</td></tr><tr><td style="text-align:center">是否有序/可重复</td><td style="text-align:center">无序不可重复</td><td style="text-align:center">无序不可重复</td><td style="text-align:center">无序不可重复</td><td style="text-align:center">默认按插入顺序排列<br>可按访问顺序排列<br>不可重复</td><td style="text-align:center">默认按自然顺序<br>可指定比较器进行自定义排序<br>不可重复</td><td style="text-align:center">无序不可重复</td></tr><tr><td style="text-align:center">键值对为null</td><td style="text-align:center">允许</td><td style="text-align:center">不允许</td><td style="text-align:center">允许</td><td style="text-align:center">允许</td><td style="text-align:center">默认排序中键不允许，值允许<br>自定义排序中键值对都允许</td><td style="text-align:center">允许</td></tr><tr><td style="text-align:center">默认初始容量</td><td style="text-align:center">16</td><td style="text-align:center">11</td><td style="text-align:center">64</td><td style="text-align:center">16</td><td style="text-align:center"></td><td style="text-align:center">16</td></tr><tr><td style="text-align:center">默认加载因子</td><td style="text-align:center">0.75</td><td style="text-align:center">0.75</td><td style="text-align:center">1/3</td><td style="text-align:center">0.75</td><td style="text-align:center"></td><td style="text-align:center">0.75</td></tr><tr><td style="text-align:center">扩容策略</td><td style="text-align:center">2 * capacity</td><td style="text-align:center">2 * capacity + 1</td><td style="text-align:center">2 * capacity</td><td style="text-align:center">2 * capacity</td><td style="text-align:center"></td><td style="text-align:center">2 * capacity</td></tr><tr><td style="text-align:center">计算hash方式</td><td style="text-align:center">hash ^ (hash &gt;&gt;&gt; 16)</td><td style="text-align:center">hash &amp; 0x7FFFFFFF</td><td style="text-align:center">(hash &lt;&lt; 1) - (hash &lt;&lt; 8)</td><td style="text-align:center">hash ^ (hash &gt;&gt;&gt; 16)</td><td style="text-align:center"></td><td style="text-align:center">有点复杂，就不贴了</td></tr><tr><td style="text-align:center">计算索引</td><td style="text-align:center">hash &amp; (capacity - 1)</td><td style="text-align:center">hash % capacity</td><td style="text-align:center">hash &amp; (capacity - 1)</td><td style="text-align:center">hash &amp; (capacity - 1)</td><td style="text-align:center"></td><td style="text-align:center">hash &amp; (capacity - 1)</td></tr><tr><td style="text-align:center">新增节点</td><td style="text-align:center">尾插法</td><td style="text-align:center">头插法</td><td style="text-align:center"></td><td style="text-align:center">尾插法</td><td style="text-align:center"></td><td style="text-align:center">头插法</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;比较&quot;&gt;&lt;a href=&quot;#比较&quot; class=&quot;headerlink&quot; title=&quot;比较&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;比较&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;趁热打铁！比较最近学习到的几个Map实现类，也正好总结下！此比较是基于&lt;code&gt;JDK1.
      
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>探索EnumMap底层实现</title>
    <link href="http://zlia.tech/2019/11/05/explain-enummap-sourcecode/"/>
    <id>http://zlia.tech/2019/11/05/explain-enummap-sourcecode/</id>
    <published>2019-11-05T08:17:02.000Z</published>
    <updated>2019-11-05T09:28:40.140Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><div><span>前言</span></div></h3><p>EnumMap初次见面，请多多关照！对于该类的注释直接上总结：</p><blockquote><p>专门用于<code>枚举类型</code>的键的Map实现。EnumMap内部的数据结构是数组，按枚举常量的声明顺序排列它的键，与其他Map实现类不同的是，它的迭代器并不会抛出快速失败错误！</p></blockquote><p>该类的代码不到1000行，速速解决掉，探索EnumMap底层实现是基于<code>JDK1.8</code>。</p><a id="more"></a><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><div><span>数据结构</span></div></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumMap</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">K</span>&gt;, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 枚举类型的类类型</span></span><br><span class="line"><span class="comment">     * 为什么需要类类型呢? </span></span><br><span class="line"><span class="comment">     * 因为在一开始初始化时，EnumMap就会将枚举类的所有对象加载到数组中，所以每次添加节点时，实际上只是添加了值对象而已</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;K&gt; keyType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 包含枚举类的所有对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> K[] keyUniverse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储值对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Object[] vals;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点个数</span></span><br><span class="line"><span class="comment">     * vals数组中存储的值对象个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存entrySet方法的返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化键数组与值数组</span></span><br><span class="line"><span class="comment"> * 这个就是上面我们所说将枚举类型的所有对象存储到键数组中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keyType 枚举类型的类类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EnumMap</span><span class="params">(Class&lt;K&gt; keyType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.keyType = keyType;</span><br><span class="line">    keyUniverse = getKeyUniverse(keyType);<span class="comment">//该方法会将枚举类的所有对象按照声明的顺序存放</span></span><br><span class="line">    vals = <span class="keyword">new</span> Object[keyUniverse.length];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定EnumMap来初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m EnumMap对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EnumMap</span><span class="params">(EnumMap&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    keyType = m.keyType;</span><br><span class="line">    keyUniverse = m.keyUniverse;</span><br><span class="line">    vals = m.vals.clone();</span><br><span class="line">    size = m.size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定集合来初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EnumMap</span><span class="params">(Map&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m <span class="keyword">instanceof</span> EnumMap) &#123;</span><br><span class="line">        EnumMap&lt;K, ? extends V&gt; em = (EnumMap&lt;K, ? extends V&gt;) m;</span><br><span class="line">        keyType = em.keyType;</span><br><span class="line">        keyUniverse = em.keyUniverse;</span><br><span class="line">        vals = em.vals.clone();</span><br><span class="line">        size = em.size;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (m.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Specified map is empty"</span>);</span><br><span class="line">        keyType = m.keySet().iterator().next().getDeclaringClass();</span><br><span class="line">        keyUniverse = getKeyUniverse(keyType);</span><br><span class="line">        vals = <span class="keyword">new</span> Object[keyUniverse.length];</span><br><span class="line">        putAll(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 倘若值为null则采用NULL_KEY作为值</span></span><br><span class="line"><span class="comment"> * 正如方法名一样，隐藏Null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> NULL_KEY或指定值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">maskNull</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (value == <span class="keyword">null</span> ? NULL : value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 倘若值为NULL_KEY则返回null</span></span><br><span class="line"><span class="comment"> * 正如方法名一样，揭露Null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或指定值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">unmaskNull</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (V)(value == NULL ? <span class="keyword">null</span> : value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取节点个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 节点个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组中是否包含指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    value = maskNull(value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object val : vals)</span><br><span class="line">        <span class="keyword">if</span> (value.equals(val))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组中是否包含指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isValidKey(key) &amp;&amp; vals[((Enum&lt;?&gt;)key).ordinal()] != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键是否有效</span></span><br><span class="line"><span class="comment"> * 是否符合指定的类类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否有效</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; keyClass = key.getClass();</span><br><span class="line">    <span class="keyword">return</span> keyClass == keyType || keyClass.getSuperclass() == keyType; <span class="comment">//keyClass.getSuperclass这个判断语句没有什么意义，枚举类既不能继承其他类，也不能被继承，两个类就无法发生关系，那这个判断结果只会是false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组中是否包含指定键值对</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含键值对</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">containsMapping</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isValidKey(key) &amp;&amp; maskNull(value).equals(vals[((Enum&lt;?&gt;)key).ordinal()]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键获取值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (isValidKey(key) ? unmaskNull(vals[((Enum&lt;?&gt;)key).ordinal()]) : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增键值对</span></span><br><span class="line"><span class="comment"> * 可能会发生替换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    typeCheck(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = key.ordinal();</span><br><span class="line">    Object oldValue = vals[index];</span><br><span class="line">    vals[index] = maskNull(value);</span><br><span class="line">    <span class="keyword">if</span> (oldValue == <span class="keyword">null</span>)</span><br><span class="line">        size++;</span><br><span class="line">    <span class="keyword">return</span> unmaskNull(oldValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键移除值对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> null或旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isValidKey(key))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> index = ((Enum&lt;?&gt;)key).ordinal();</span><br><span class="line">    Object oldValue = vals[index];</span><br><span class="line">    vals[index] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldValue != <span class="keyword">null</span>)</span><br><span class="line">        size--;</span><br><span class="line">    <span class="keyword">return</span> unmaskNull(oldValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定键值对移除值对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除值对象成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">removeMapping</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isValidKey(key))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> index = ((Enum&lt;?&gt;)key).ordinal();</span><br><span class="line">    <span class="keyword">if</span> (maskNull(value).equals(vals[index])) &#123;</span><br><span class="line">        vals[index] = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量添加集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 指定集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123; <span class="comment">//枚举类之间无法继承，所以这里压根就只能指定K、V</span></span><br><span class="line">    <span class="keyword">if</span> (m <span class="keyword">instanceof</span> EnumMap) &#123;</span><br><span class="line">        EnumMap&lt;?, ?&gt; em = (EnumMap&lt;?, ?&gt;)m;</span><br><span class="line">        <span class="keyword">if</span> (em.keyType != keyType) &#123;</span><br><span class="line">            <span class="keyword">if</span> (em.isEmpty())</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException(em.keyType + <span class="string">" != "</span> + keyType);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; keyUniverse.length; i++) &#123;</span><br><span class="line">            Object emValue = em.vals[i];</span><br><span class="line">            <span class="keyword">if</span> (emValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vals[i] == <span class="keyword">null</span>)</span><br><span class="line">                    size++;</span><br><span class="line">                vals[i] = emValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.putAll(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中间省略了相关迭代器...较为简单相似，有兴趣的读者可自行查看</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空值数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Arrays.fill(vals, <span class="keyword">null</span>);</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取枚举类中所有对象的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keyType 枚举类类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含所有对象的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;K extends Enum&lt;K&gt;&gt; K[] getKeyUniverse(Class&lt;K&gt; keyType) &#123;</span><br><span class="line">    <span class="keyword">return</span> SharedSecrets.getJavaLangAccess().getEnumConstantsShared(keyType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>专门用于其键为<code>枚举类型</code>的Map实现</p></li><li><p>EnumMap的数据结构是数组，按枚举常量的声明顺序进行排列</p></li><li><p>EnumMap的键不允许为空，值允许为空</p></li><li><p>EnumMap的迭代器不会发生快速失败</p></li><li><p>EnumMap有序、不可重复、非线程安全</p></li><li><p>EnumMap在初始化时将枚举类中的所有对象存储到数组中，而后续的增删改查实际上都是对其值对象的操作</p></li></ul><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>内部实现机制</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;EnumMap初次见面，请多多关照！对于该类的注释直接上总结：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;专门用于&lt;code&gt;枚举类型&lt;/code&gt;的键的Map实现。EnumMap内部的数据结构是数组，按枚举常量的声明顺序排列它的键，与其他Map实现类不同的是，它的迭代器并不会抛出快速失败错误！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该类的代码不到1000行，速速解决掉，探索EnumMap底层实现是基于&lt;code&gt;JDK1.8&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
</feed>
