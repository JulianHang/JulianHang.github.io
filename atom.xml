<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>奇思妙想</title>
  
  <subtitle>越努力越幸运！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zlia.tech/"/>
  <updated>2018-05-22T17:08:37.246Z</updated>
  <id>http://zlia.tech/</id>
  
  <author>
    <name>zlia</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>尝尝markdown源码的味道</title>
    <link href="http://zlia.tech/2018/05/23/markdown-understand/"/>
    <id>http://zlia.tech/2018/05/23/markdown-understand/</id>
    <published>2018-05-22T16:16:23.000Z</published>
    <updated>2018-05-22T17:08:37.246Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一切动力源于好奇"><a href="#一切动力源于好奇" class="headerlink" title="一切动力源于好奇"></a><div><span>一切动力源于好奇</span></div></h3><p>为什么要写markdown的原理呢？因为markdown的语法本来就很有局限性，想要整个高大上的页面就显得很鸡肋，所以需要我们自己去定义一些语法来解析生成对应的标签。原本以为github或者google上应该有个现成什么的，至少也要有个大体的方向，可惜我是个菜鸟表示看不懂各位大神所描述的，看不懂看不懂，故打算自己看下源码，要求不高，大部分看懂就可以了，特地写了此篇文章来阐述自己对源码的理解，同时也为需要的人提供一些小小的帮助，嘻嘻！<a id="more"></a></p><h3 id="着手啃代码"><a href="#着手啃代码" class="headerlink" title="着手啃代码"></a><div><span>着手啃代码</span></div></h3><p>首先去github上clone个<a href="https://github.com/markedjs" target="_blank" rel="noopener">markdown源代码</a>，我在看源代码的时候喜欢先看大神写的小Demo，不知道其他大神是怎么欣赏别人文章的，好奇，也想学习学习。在项目中有个doc目录，打开它你就可以看到有个Demo目录，open it。只有100多行的代码，简单容易理解，所以建议大家也可以先看下Demo，先简单地浏览下。如果你是个有经验的前端开发者，我想你应该不会在我的文章里多呆一分钟吧，所以此篇文章的主要对象是初学者和不是从事前端开发的人员，因为我也不是个前端开发者，顶多是个业余的，惭愧惭愧，若接下来有什么理解错误的地方请谅解，若讲的不错请常来就好。你在浏览代码的过程中难免会发现有这么一个对象<code>marked</code>，为什么会是它呢？因为有这样一条语句<code>marked.parser</code>，其实就是解析的意思啦，好庸俗啊。。接着来，解析markdown语法的主要入口就是它，如果还不信的话可以在当前目录下打开index.html文件，打开后在其控制台（F12）下打印marked，会出现一个function对象，奇怪了，这是个什么鬼，双击后便可以看到另一个文件<code>marked.js</code>，这个文件在上一级目录lib下，它才是最主要的解析markdown语法的重点。回到刚才的Demo中，我们搜索下marked对象第一次出现的位置。</p><p class="customize-img"><img src="/assets/blogImg/markdown/marked-first.png" alt="lexer"></p><p>如果你认识lexer这个单词的话你应该就会明白这句话的意思是什么。<strong>词法分析器</strong>，实际上是根据是否匹配正则表达式从而进一步分析markdown的语法，最后组装好数据返回，这些数据主要是你用了哪些语法内容，如###之类，以及对应的值。接着来看下一步，parser方法是根据返回的数据解析成html，然后将内容innerHtml到页面上，最终的效果也就是你看到的页面。如果有同学觉得疑惑的话，你可以打开index.html页面进行调试便可以很容易的明白我所阐述的内容。</p><h3 id="深入代码内部击垮敌军"><a href="#深入代码内部击垮敌军" class="headerlink" title="深入代码内部击垮敌军"></a><div><span>深入代码内部击垮敌军</span></div></h3><p>现在我们只是大体的明白了markdown原理的表面，对于我们想要自定义语法来说，还远远不够，必须要深入到代码内部去，只有这样子才能彻底击垮敌军，来看看marked.js文件中的<code>lexer</code>方法。</p><p class="customize-img"><img src="/assets/blogImg/markdown/marked-internal-lexer.png" alt="internal-lexer"></p><p>在lexer方法中将制表符、换行等之类的表达式用对应的空格或者指定换行表达式来代替，以防后面解析时出现错误。在lexer内部中调用了<code>token</code>方法。在这个方法中，主要做的是根据markdown语法写的内容进行正则表达式匹配，图片只是截图了其中匹配标题（#{1,6}）的方式。</p><p class="customize-img"><img src="/assets/blogImg/markdown/marked-internal-token.png" alt="internal-token"></p><p>匹配到对应的规则之后进行数据的封装，封装的数据主要是类型、内容、具体匹配了哪一种（Depth指的是匹配了h1、h2、h3中的哪一种）。到这里Demo中的marked.lexer方法就结束了，它返回了匹配成功后的数据封装。下一步来到<code>marked.parse</code>，将之前的数据封装传入，并构建标签分析器，专业术语我不知道，因为这一步会生成一个html，故称之为标签分析器，接着开始执行<code>tok</code>方法。</p><p class="customize-img"><img src="/assets/blogImg/markdown/marked-internal-tok.png" alt="internal-tok"></p><p>走下一步到<code>output</code>，根据内容参数来匹配正则表达式，当然了，这其中发生了很多事，有<code>merger</code>方法，主要用来合并相关匹配标签的正则表达；有<code>edit</code>方法，主要用来将通用的正则整合在一起。其实这两种方法都是在对正则表达式进行操作，可见作者对正则的理解很高深，至少在我看来正则知识较为难学，会让人头都脑壳痛。因为内容有可能会出现标签，如div，在escape方法中将其转换成$lt、$gt等之类的标记，防止出现解析错误造成乱码。大家有注意到格式转换后都会去调用this.render.text或者其他类似的方法，在其对应的方法中返回由标签包围的内容的字符串形式，最后在将其字符串打入到页面中即可呈现你想要的效果。若有同学想要改变标签的表现形式即可根据所需来对<code>this.render</code>中的具体方法来做修改，不妨试一试。</p><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>lexe token parse output render</code></p><h3 id="战后总结"><a href="#战后总结" class="headerlink" title="战后总结"></a><div><span>战后总结</span></div></h3><p>表面上说是看了源码感觉很厉害的样子，但是里面的很多细节表示没有看懂或者理解不到位甚至是理解出错，顿时感觉自己的功力和水平还远远不够，难怪说程序员就是要一直学习下去，不然连个饭碗都端不起了，惭愧惭愧。有人说要想有所成长就必须要去看别人写的源码，看多了总会让人想吐，恶心，这还是一点点的代码，要是那种一片一片的代码，我想早就炸了，希望日后加强自身的知识储备，好好努力，加油！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一切动力源于好奇&quot;&gt;&lt;a href=&quot;#一切动力源于好奇&quot; class=&quot;headerlink&quot; title=&quot;一切动力源于好奇&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;一切动力源于好奇&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;为什么要写markdown的原理呢？因为markdown的语法本来就很有局限性，想要整个高大上的页面就显得很鸡肋，所以需要我们自己去定义一些语法来解析生成对应的标签。原本以为github或者google上应该有个现成什么的，至少也要有个大体的方向，可惜我是个菜鸟表示看不懂各位大神所描述的，看不懂看不懂，故打算自己看下源码，要求不高，大部分看懂就可以了，特地写了此篇文章来阐述自己对源码的理解，同时也为需要的人提供一些小小的帮助，嘻嘻！
    
    </summary>
    
      <category term="essays" scheme="http://zlia.tech/categories/essays/"/>
    
    
      <category term="markdown" scheme="http://zlia.tech/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>初识异常</title>
    <link href="http://zlia.tech/2018/05/06/exception-knowledge/"/>
    <id>http://zlia.tech/2018/05/06/exception-knowledge/</id>
    <published>2018-05-06T08:28:24.000Z</published>
    <updated>2018-05-22T14:15:30.222Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a><div><span>简介</span></div></h3><p>用户在运行程序的期间，往往有可能会出现各种各样的错误导致程序执行失败，其结果是用户数据丢失。出现这种情况的时候当然不能置之不理，要么就应该告诉用户该错误，要么是用户数据得到保存，否则用户流量将呈现下降的趋势。为了正确的处理错误，Java提供了一种称为：<code>异常处理的错误捕获机制处理</code>。该机制的任务就是将控制权从错误产生的地方转移给能够处理错误的处理器。当然了，想要正确的处理异常情况的前提是必须要研究程序中哪些地方会出现问题和错误。<a id="more"></a></p><blockquote><p>异常的处理机制就好比生活中较为常见的灾难预防措施，如在公共场所安防灭火器、洒水器。</p></blockquote><h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a><div><span>异常分类</span></div></h3><p>在Java程序设计语言中，异常对象都是派生于<code>Throwable</code>类的一个实例，若内置的异常类不能满足需求，则用户还可以创建自己的异常类。</p><p class="customize-img"><img src="/assets/blogImg/exception/throwable-hierarchy.png" alt="异常层次目录"></p><p>所有的异常都是由<code>Throwable</code>继承而来，在下一层又划分为两个分支：<code>Error</code>和<code>Exception</code>。</p><ul><li><code>Error</code>：描述了Java运行时系统的内部错误。在程序当中不应该抛出这种类型的错误，因为该错误除了通知用户之外，我们对它无能为力。</li><li><code>Exception</code>：<ul><li><code>IOException</code>：操作IO时出现的异常情况，如操作的文件不存在、试图在文件尾部后面读取数据。</li><li><code>RuntimeException</code>：由程序的错误编写而导致异常的出现，如错误的类型转换、数组角标越界。</li></ul></li></ul><h3 id="声明受查异常"><a href="#声明受查异常" class="headerlink" title="声明受查异常"></a><div><span>声明受查异常</span></div></h3><p>Java语言规范将派生于<code>Error</code>或<code>RuntimeException</code>的所有异常成为<code>非受查异常</code>，其他的所有异常称为<code>受查异常</code>。<br>为什么要声明异常呢？当你遇到无法处理的情况时是不是要告诉别人这件事我做不了你看着办，有点小尴尬的样子～至于为什么受查异常要声明而非受查异常不用声明呢？（声明了也不要紧，只是没必要）-见如下分析～</p><blockquote><p>处理文件时一般会先检查该文件是否存在，但是它是不是有可能在你检查完是否存在后就被删除了，所以受查异常更取决于环境而不只是代码。运行时异常（RuntimeException）出现的原因是由于代码编写的不规范而产生的，这完全是在我们的控制范围内，Java语言建议我们应该将更多的时间花费在修正程序中的错误上，而不是说明这些错误发生的可能性，所以非受查异常要么是我们无能为力的，要么是我们应该通过修正程序来避免发生。</p></blockquote><p>一个方法有可能要声明多个受查异常类型，那么就必须在方法的首部列出所有的异常类，每个异常类之间用逗号隔开。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.zlia.exception.knowledge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.EOFException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnimation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawImage</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">throws</span> FileNotFoundException , EOFException </span>&#123;</span><br><span class="line"><span class="comment">//do anything</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>Throwable RuntimeException IOException 受查异常 非受查异常</code></p><p><a href="https://github.com/JulianHang/core-java/tree/master/src/tech/zlia/exception" target="_blank" rel="noopener">源码下载</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;简介&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;用户在运行程序的期间，往往有可能会出现各种各样的错误导致程序执行失败，其结果是用户数据丢失。出现这种情况的时候当然不能置之不理，要么就应该告诉用户该错误，要么是用户数据得到保存，否则用户流量将呈现下降的趋势。为了正确的处理错误，Java提供了一种称为：&lt;code&gt;异常处理的错误捕获机制处理&lt;/code&gt;。该机制的任务就是将控制权从错误产生的地方转移给能够处理错误的处理器。当然了，想要正确的处理异常情况的前提是必须要研究程序中哪些地方会出现问题和错误。
    
    </summary>
    
      <category term="essays" scheme="http://zlia.tech/categories/essays/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
</feed>
