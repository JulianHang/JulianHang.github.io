<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>奇思妙想</title>
  
  <subtitle>越努力越幸运！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zlia.tech/"/>
  <updated>2019-08-16T09:00:00.461Z</updated>
  <id>http://zlia.tech/</id>
  
  <author>
    <name>zlia</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>探索ArrayList底层实现</title>
    <link href="http://zlia.tech/2019/08/16/explain-arraylist-sourcecode/"/>
    <id>http://zlia.tech/2019/08/16/explain-arraylist-sourcecode/</id>
    <published>2019-08-16T08:08:04.000Z</published>
    <updated>2019-08-16T09:00:00.461Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a><div><span>背景</span></div></h3><p>想进步，想学习了，反正面试都要问的，还不如早点看了好。探索<code>ArrayList</code>源代码是基于<code>JDK1.8</code>版本的，相比以前的版本不知道有没有优化，毕竟没看过之前版本的底层代码。</p><h3 id="简单说明下"><a href="#简单说明下" class="headerlink" title="简单说明下"></a><div><span>简单说明下</span></div></h3><p>一般看底层代码前我都习惯先阅读下该类的<code>注释说明</code>，也不知道在哪里养成的习惯。相信大家都写过应用代码，既然写过，那也深知注释对于一个使用者来说是多么的重要，决定了它是否能够正确的使用，所以这是一个好习惯。</p><h4 id="阅读注释"><a href="#阅读注释" class="headerlink" title="阅读注释"></a>阅读注释</h4><p class="customize-img"><img src="/assets/blogImg/java/arraylist/arraylist-comment-1.png" alt="ArrayList注释-1"></p><p>看到这不知道你们有没有很惊讶，反正我倒是一惊，所以我说看注释很重要！！！如果是你写代码给别人看，除了看具体代码之外，看注释就是最好的理解方式了，一语道破很多原理，要求不高的我都觉得可以不用看代码实现了，所以接下来会继续阅读注释。</p><a id="more"></a><p class="customize-img"><img src="/assets/blogImg/java/arraylist/arraylist-comment-2.png" alt="ArrayList注释-2"></p><p>这就变相地在说，ArrayList中的get/set效率比LinkedList高，这不正好验证了我们常说的ArryList<code>存取快，插入删除慢</code>，我想它的时间复杂度说明了一切，虽然这里只是给出了结论。在这里顺便提供下<a href="https://blog.csdn.net/qq_41523096/article/details/82142747" target="_blank" rel="noopener">有趣的时间复杂度</a>的介绍文章，便于理解。</p><p class="customize-img"><img src="/assets/blogImg/java/arraylist/arraylist-comment-3.png" alt="ArrayList注释-3"></p><p>简单地说数组会<code>自动扩容</code>。</p><p class="customize-img"><img src="/assets/blogImg/java/arraylist/arraylist-comment-4.png" alt="ArrayList注释-4"></p><p>在这里我将<code>amount</code>翻译成次数，这个单词本意是数量的意思。基于我对ArrayList的了解，当容量不足时，它是需要扩充容量的，就上面咱们提到的自动扩容，每次容量不足时都需要自动扩容，若一开始就设置好这个容量，那么就减少了自动扩容的次数，所以我将它翻译成次数。它的意思就是让你<code>提前设置好容量大小</code>，以便容量不足时需要消耗时间去自动扩容。</p><p class="customize-img"><img src="/assets/blogImg/java/arraylist/arraylist-comment-5.png" alt="ArrayList注释-5"></p><p>大致意思是ArrayList不是线程安全，所以在多线程环境下要在外部控制进行控制防止数据紊乱。</p><p class="customize-img"><img src="/assets/blogImg/java/arraylist/arraylist-comment-6.png" alt="ArrayList注释-6"></p><p>调用迭代器时注意并发操作ArrayList，不然会抛出异常。</p><p class="customize-img"><img src="/assets/blogImg/java/arraylist/arraylist-comment-7.png" alt="ArrayList注释-7"></p><p>fail-fast：快速失败，我也是第一次听说该术语，它仅仅用于检测BUG，说明不了什么问题。</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>按照顺序先来看下ArrayList都具有哪些<code>成员属性</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//支持序列化、可克隆、随机访问</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//序列化标识</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认初始值容量大小10</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空数组实例，主要用来做赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[]  EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空数组实例，当采用默认的空构造函数时采用该实例作为默认值</span></span><br><span class="line">    <span class="comment">//该实例与 EMPTY_ELEMENTDATA 被区分开来以便知道当第一个元素被添加时数组该扩充多大，简单来说该属性会参与到计算当中，而 EMPTY_ELEMENTDATA只是用作简单的赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ArrayList中的元素被添加到该数组中</span></span><br><span class="line">    <span class="comment">//ArrayList的容量大小是该数组的长度大小</span></span><br><span class="line">    <span class="comment">//空构造函数的 elementData被赋值为 DEFAULTCAPACITY_EMPTY_ELEMENTDATA，当添加第一个元素时，elementData数组大小将会被扩充到默认容量大小10</span></span><br><span class="line">    <span class="comment">//该对象加上 transient 修饰符表示不对该属性进行序列化</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ArrayList容量大小，意指它包含元素的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们都知道定义一个数组的大小是 int 类型，那么也就意味着最大的数组大小应该是Integer.MAX_VALUE，但是这里为啥要减去8呢？</span></span><br><span class="line">    <span class="comment">//查阅资源发现大部分的人都在说8个字节是用来存储数组的大小，半信半疑</span></span><br><span class="line">    <span class="comment">//分配最大数组，某些VM会在数组中存储header word，按照上面的说法指的应该是数组的大小</span></span><br><span class="line">    <span class="comment">//若尝试去分配更大的数组可能会造成 OutOfMemoryError: 定义的数组大小超过VM上限</span></span><br><span class="line">    <span class="comment">//不同的操作系统对于不同的JDK可能分配的内存会有所差异，所以8这个数字可能是为了保险起见</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ArrayList结构被修改的次数，也就是调用 add 或 remove方法的次数</span></span><br><span class="line">    <span class="comment">//修改结构指的是ArrayList的容量大小被改变了</span></span><br><span class="line">    <span class="comment">//若该属性被出乎意料的改变了，调用迭代器的相关方法，如 next、 remove、previous、set、add则会抛出 ConcurrentModificationException异常，该情况其实就是上面提到的fail-fast</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些成员属性都很容易理解，加上提供了注释，所以这边就不做多的阐述！</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>接下来介绍ArrayList提供的<code>构造函数</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个指定初始容量大小的空数组，相当于 new Object[initialCapacity]</span></span><br><span class="line"><span class="comment"> * 若入参initialCapacity大于0，则创建具有指定大小的空数组，并让elementData指向该数组</span></span><br><span class="line"><span class="comment"> * 若入参initialCapacity等于0，则elementData指向已经创建好的空数组</span></span><br><span class="line"><span class="comment"> * 若入参initialCapacity小于0，则抛出参数异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span> + initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个初始容量为10的空数组，并让elementData指向已经创建好的空数组</span></span><br><span class="line"><span class="comment"> * 初始容量并不是在这里设置，而是在添加第一个元素时进行初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayLlist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建一个包含执行collection集合的数组，ArrayList容量大小和该集合大小一致，这些元素按照迭代器的顺序排列</span></span><br><span class="line"><span class="comment"> * collection集合类型有Map、set、List等子类，所以入参可以是多种类型</span></span><br><span class="line"><span class="comment"> * collection集合转换成数组，elementData指向该数组，size成员属性被赋值为collection集合长度</span></span><br><span class="line"><span class="comment"> * 若该数组大小大于0，则判断数组类型是否是Ojbect[],若不是则创建一个新的数组，并拷贝elementData数组中的内容</span></span><br><span class="line"><span class="comment"> * 若该数组大小等于0，则elementData指向空数组</span></span><br><span class="line"><span class="comment"> * collection集合不可能创建长度为负数的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//c.toArray 可能不会返回正确的Object[]类型，这边可能会利用多态的性质，如 A a = new B()</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//空数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>若已经提前知道数组容量，则建议使用new ArrayList(initialCapacity)</p></li><li><p>若不知道数组容量的话，那就没办法了</p></li><li><p>ArrayList(Collection c)一般是在包含关系的情况下使用</p></li></ul><h4 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h4><p>接下来按照类的声明顺序介绍<code>方法</code>，有必要的情况下结合例子进行说明。</p><h5 id="缩小数组大小空间"><a href="#缩小数组大小空间" class="headerlink" title="缩小数组大小空间"></a>缩小数组大小空间</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缩小ArrayList对象的容量到当前数组的大小，应用可以调用该方法来最小化ArrayList对象的存储空间，简单来说就是节约空间，去掉没有用到的剩余数组空间</span></span><br><span class="line"><span class="comment"> * modCount 是记录ArrayList修改结构的次数，节约数组空间就是减少了数组的大小</span></span><br><span class="line"><span class="comment"> * size 是数组填充了元素的个数，实实在在的大小，而 elementData.length 是 数组的总容量大小，也就是说只有当填充/删除元素时size的大小才会变化</span></span><br><span class="line"><span class="comment"> * 而当进行扩容时 elementData.length 才会变化，毕竟数组的长度变大了</span></span><br><span class="line"><span class="comment"> * 若size小于elementData.length，则判断 size是否等于0</span></span><br><span class="line"><span class="comment"> * 若size等于0，则将 elementData 指向空数组</span></span><br><span class="line"><span class="comment"> * 若size不等于0，则创建一个大小为size的数组，并将elementData中原有的元素拷贝到新数组中，同时更新elementData指向新数组，从而完成节约数据空间的作用</span></span><br><span class="line"><span class="comment"> * size的长度是不可能大于elementData.length</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        elementData = (size == <span class="number">0</span>) ? EMPTY_ELEMENTDATA</span><br><span class="line">          : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="自定义容量-扩容机制"><a href="#自定义容量-扩容机制" class="headerlink" title="自定义容量 + 扩容机制"></a>自定义容量 + 扩容机制</h5><p>自定义容量可以在创建ArrayList对象时设置，若后期发现容量不足总不能手动去改数值吧，故而提供了其他方法去自定义容量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加ArrayList对象的容量，在必要情况下，入参minCapacity至少要确保能容纳元素的数量</span></span><br><span class="line"><span class="comment"> * 若 elementData 不等于空数组，则minExpand = 0，否则minExpand = DEFAULT_CAPACITY = 10</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 假设去掉设置minExpand的值的语句会造成的影响：</span></span><br><span class="line"><span class="comment"> * 若采用new ArrayList的方式创建对象，则表示在第一次添加元素时，自动将容量扩充到10，而若在此之前先手动扩充容量，如果该值小于10，则会扩容一次，而当容量不足时，</span></span><br><span class="line"><span class="comment"> * 又会扩容一次，总的来说会频繁的进行扩容，而为什么一开始要设置成10呢，微软工程师做过调研，认为该数字比较常用，实际上设置成其它值也是没问题的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 扩容机制为了保证所有的元素都能被容纳，自定义容量与自动扩容的数值会进行比较，取较大值作为扩容的参数，故而有了minCapacity与minExpand的比较</span></span><br><span class="line"><span class="comment"> * 若minCapacity大于minExpand，则调用ensureExplicitCapacity方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  minCapacity 手动扩充的容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span> <span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) ? <span class="number">0</span> : DEFAULT_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * modCount指的是记录修改结构的次数，但若是minCapacity 小于 elementData.length，则结构并没有修改，在这点上不是很难理解</span></span><br><span class="line"><span class="comment"> * 判断完需要扩容的参数，接下来应该判断该参数是否大于预先定义好的总容量大小，还是取较大值</span></span><br><span class="line"><span class="comment"> * 若minCapacity大于elementData.length，则调用grow方法开始扩容</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  minCapacity 手动扩充的容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * oldCapacity &gt;&gt; n：oldCapacity除以2的n次方</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 首先获取当前数组的容量大小，获取自动扩容时的容量大小为 oldCapacity + oldCapacity/2 = 1.5 * oldCapacity，也就是说两次扩容之间是1.5倍的关系</span></span><br><span class="line"><span class="comment"> * 判断手动扩充的容量是否大于自动扩充的容量</span></span><br><span class="line"><span class="comment"> * 若大于，则自动扩容的容量修改为手动扩充的容量，即 newCapacity = minCapacity，否则newCapacity不变，即采用自动扩充的容量</span></span><br><span class="line"><span class="comment"> * 为了防止内存溢出，扩容并不是无止境的扩充，当大于一个临界点MAX_ARRAY_SIZE时，就不允许在采用自动扩容的容量大小，而是取最大值或临界点</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 参考hugeCapacity方法：</span></span><br><span class="line"><span class="comment"> * 当程序执行到①时，我们可以知道 newCapacity &gt;= minCapacity（指的是赋值之后的关系）</span></span><br><span class="line"><span class="comment"> * 若MAX_ARRAY_SIZE大于newCapacity，则就开始创建长度为newCapacity的新数组，三者的关系为 MAX_ARRAY_SIZE &gt; newCapacity &gt;= minCapacity</span></span><br><span class="line"><span class="comment"> * 若MAX_ARRAY_SIZE小于newCapacity，则进入到hugeCapacity方法，但此时我们不知道minCapacity 与 MAX_ARRAY_SIZE的大小关系</span></span><br><span class="line"><span class="comment"> * 若minCapacity大于MAX_ARRAY_SIZE，则采用最大值，不允许无限制的手动设置扩充容量，不过最大值有可能会出现内存溢出</span></span><br><span class="line"><span class="comment"> * 三者关系为：newCapacity &gt;= minCapacity &gt; MAX_ARRAY_SIZE</span></span><br><span class="line"><span class="comment"> * 若minCapacity小于MAX_ARRAY_SIZE，则采用临界值，该临界值是保证在不同的操作系统下不会发生内存溢出， 三者关系为：newCapacity &gt; MAX_ARRAY_SIZE &gt; minCapacity</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 得出结论：</span></span><br><span class="line"><span class="comment"> * 添加元素时会先到底临界值，此时不会发生内存溢出，若在往上增长则达到最大值，最大值有可能发生内存溢出</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  minCapacity 手动扩充的容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;      --------------------&gt; ① 手动添加</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断入参minCapacity 是否大于 MAX_ARRAY_SIZE</span></span><br><span class="line"><span class="comment"> * 若 minCapacity &gt; MAX_ARRAY_SIZE，则返回值是最大值</span></span><br><span class="line"><span class="comment"> * 若 minCapacity &lt;= MAX_ARRAY_SIZE，则返回值是临界值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  minCapacity 手动扩充的容量大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 容量大小结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算出要扩充的容量大小并扩容</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  minCapacity 手动扩充的容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只有在采用new ArrayList()的方式创建对象后，elementData才会等于DEFAULTCAPACITY_EMPTY_ELEMENTDATA，而以其他方式创建对象后都具有一定的容量大小</span></span><br><span class="line"><span class="comment"> * 若 elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA，比较手动扩容与自动扩容的容量大小，取较大值</span></span><br><span class="line"><span class="comment"> * 若不相等，则采用手动扩容容量大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> elementData 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity 手动扩充的容量大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 容量大小结果值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>什么情况下会扩容</code></p><ul><li>这个问题有点白问，当然了是数组不够用了才需要扩充容量了，不过它不是一个一个的扩充，而是采用一定的规则去扩充，回答的也有点傻！</li></ul><p><code>自动扩容机制</code></p><ul><li>每次自动扩容都以<code>1.5倍</code>的关系进行增长，如果期间手动扩充容量，则会比较手动扩充的容量大小与1.5倍的容量大小，取较大值进行扩容。</li><li>扩容是比较耗时的，应该尽力去避免，所以在初始化时就应该提供一个容量参数。</li></ul><p><code>容量最大值</code></p><ul><li>最大值是Interger.MAX_VALUE，但容易造成内存溢出，保险起见在容量等于Integer.MAX_VALUE - 8 的时候就应该停止扩充容量。</li></ul><h5 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组中指定索引的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 索引对应的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改数组中指定索引的值</span></span><br><span class="line"><span class="comment"> * rangCheck检查角标是否越界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 新元素，替换索引对应的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 旧元素，索引对应的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加-插入元素"><a href="#添加-插入元素" class="headerlink" title="添加/插入元素"></a>添加/插入元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素到数组尾部，添加元素之前会先进行扩容判断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 新元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素到数组中的指定位置，添加元素之前会先进行扩容和角标越界判断</span></span><br><span class="line"><span class="comment"> * 插入过程中将index索引位置及后续的所有元素都将向右移动一格，并当前索引位置的值（null）修改成新值</span></span><br><span class="line"><span class="comment"> * 数组扩容跟size属性没有任何关系，size只负责数组中有多少个元素，插入元素后故而 + 1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element  新元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加数组到另外一个数组中，从尾部开始追加</span></span><br><span class="line"><span class="comment"> * 相当于合并两个数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组中的元素是否添加到另外一个数组中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加数组到另外一个数组中，从指定索引出开始添加</span></span><br><span class="line"><span class="comment"> * 插入过程中将index索引位置及后续的任何元素都将往右移动 numNew 格，相当于是批量插入</span></span><br><span class="line"><span class="comment"> * 相当于在插入前先将原有的元素都往右移动，预先留出空位来给后面要添加的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组中的元素是否添加到另外一个数组中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除数组中指定索引的值，移除元素之前会先进行角标越界判断</span></span><br><span class="line"><span class="comment"> * 移除过程中将index索引位置后续的所有元素都将向左移动一格</span></span><br><span class="line"><span class="comment"> * 为了能让GC尽可能地回收资源，主动将尾部位置设置成null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 移除的旧值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                            numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除数组中第一次出现的指定值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否删除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除从指定起始索引到指定结束索引之间的所有元素</span></span><br><span class="line"><span class="comment"> * 移除包含fromIndex索引对应的值，但不包括toIndex索引对应的值</span></span><br><span class="line"><span class="comment"> * 移除过程中将toIndex索引位置及其后续的所有元素往左移动 toIndex - fromIndex 格</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 看到这里的时候有些理解难题，在移除元素后索引位置上的元素主动设置成null，我明白这一点，不好理解的点在于算法</span></span><br><span class="line"><span class="comment"> * 假设如下：</span></span><br><span class="line"><span class="comment"> *             f           t</span></span><br><span class="line"><span class="comment"> * 1     2     3     4     5     6     7     8</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 移除3后的结果，注意4是不会被移除的：</span></span><br><span class="line"><span class="comment"> * 1     2     6     7     8     9     null  null</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 根据需求，我们知道要将8位置上的值设置成null，那么问题就在于我怎么才能知道7位置上的索引是多少呢？哦，是7，这个不算，算法应该怎么写呢？</span></span><br><span class="line"><span class="comment"> * 所以我很好奇怎么是这个答案：size - (toIndex-fromIndex)，后面着重理解了一下：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *             f           t</span></span><br><span class="line"><span class="comment"> * 1     2     6     7     8     9     null  null</span></span><br><span class="line"><span class="comment"> * &lt;=             size                         =&gt;</span></span><br><span class="line"><span class="comment"> *                                     &lt;= t-f =&gt;</span></span><br><span class="line"><span class="comment"> * &lt;=               ?                   =&gt;</span></span><br><span class="line"><span class="comment"> * 求?的值，也就是在求null的索引是多少，看上面的图就应该比较好理解了（不知道看的懂不），size - (toIndex-fromIndex)就刚好是索引的值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromIndex 起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toIndex 结束索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - toIndex;</span><br><span class="line">    System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">                     numMoved);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> newSize = size - (toIndex-fromIndex);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize; i &lt; size; i++) &#123;</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    size = newSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量移除数组中的指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定移除的元素集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移除元素让我想到一个问题，看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Object[] o = <span class="keyword">new</span> Object[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">System.arraycopy(o, <span class="number">2</span>, o , <span class="number">1</span>, o.length - <span class="number">1</span> - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (Object i :o) &#123;</span><br><span class="line">    System.out.print(i + <span class="string">","</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看下输出结果1,3,4,5,6,6, 前面几个元素应该都明白，但是有一个点：<code>元素你虽然移除了，但是数组的长度依然没变化</code>。当元素往左移动一格后，那最后的索引位置上应该是个什么值，按道理来说，6应该也是往前移动了，所以它的这个位置应该空出来的才对，但是输出结果告诉我们：最后一个位置应该是类似复制操作导致了最后两个元素一样的值，要是不信的话，你可以多试几个值，而在ArrayList中如果不主动设置null的话会造成元素紊乱，就莫名其妙多了一个元素。</p><h5 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组中的元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否是空元素数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组中指定元素第一次出现的索引值</span></span><br><span class="line"><span class="comment"> * 采用正向遍历的方式开始一一判断</span></span><br><span class="line"><span class="comment"> * 若找不到指定元素则返回 -1</span></span><br><span class="line"><span class="comment"> * 方法中通过equals判断两对象是否相等，若是调用Object#equals方法，是在判断两者的地址是否指向同一个</span></span><br><span class="line"><span class="comment"> * 若对象中已经覆写了Object#equals，则应该引起注意！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组中指定元素第一次出现的索引值</span></span><br><span class="line"><span class="comment"> * 采用反向遍历的方式开始一一判断</span></span><br><span class="line"><span class="comment"> * 若找不到指定元素则返回 -1</span></span><br><span class="line"><span class="comment"> * 方法中通过equals判断两对象是否相等，若是调用Object#equals方法，是在判断两者的地址是否指向同一个</span></span><br><span class="line"><span class="comment"> * 若对象中已经覆写了Object#equals，则应该引起注意！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用该clone之前，该类要实现Cloneable，不然会抛出异常</span></span><br><span class="line"><span class="comment"> * 数组默认已经实现了Cloneable接口，直接调用方法即可，而且直接返回对应的类型，不需要向下转型，同时包含数组元素</span></span><br><span class="line"><span class="comment"> * 浅拷贝与深拷贝，举个例子吧</span></span><br><span class="line"><span class="comment"> * 比如A类中包含基本类型与B类，当调用A类clone方法后，两个A对象肯定是不一致，不然就不叫做拷贝了，不过这不是关键</span></span><br><span class="line"><span class="comment"> * 若A1对象中的B对象与A2对象中的B对象指向同一个对象，则认为它是浅拷贝，认为B没有被拷贝新的一份</span></span><br><span class="line"><span class="comment"> * 若两者指向不相等的话，则认为深拷贝，认为B重新拷贝了一份，不过这通常需要我们自定义代码，就像下面的方法一样</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">        v.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个包含所有列表元素的有序（按照添加顺序）数组</span></span><br><span class="line"><span class="comment"> * 此方法是创建一个新数组，方便使用者能够随便操作新数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注意：T类型要么是数组中数据的相同类型，要么是数组中数据的父类型，运用多态性质</span></span><br><span class="line"><span class="comment"> * 若传入的新数组容量 &lt; 列表容量，则取它的类类型来创建一个包含列表元素的新数组，并返回</span></span><br><span class="line"><span class="comment"> * 若传入的新数组容量 &gt; 列表容量，则将列表中的元素按照顺序拷贝到新数组中，同时将新数组中索引为size的值设置成null</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 一开始我也好奇为啥要在索引为size上设置个null呢？</span></span><br><span class="line"><span class="comment"> * 看了注释加上自我的理解，若传入的新数组是个空数组的话，那么除了拷贝列表元素后剩余的所有空间的值都为null，此时在给索引为size的值设置成null似乎没有多大</span></span><br><span class="line"><span class="comment"> * 意思；另外一种情况是若传入的新数组不是个空数组，那这个设置就有意义了，传入的新数组的某些元素会被列表元素覆盖，同时有个null，剩下的才是自己本身的数据，呈现这样子一种效果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment"> * list.add(11);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Integer[] str = new Integer[]&#123;1,2,3,4,5,6,7,8,9,10&#125;;</span></span><br><span class="line"><span class="comment"> * Integer[] s1 = list.toArray(str);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * for (Integer s : s1) &#123;</span></span><br><span class="line"><span class="comment"> *     System.out.println(s + ",");</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输出结果：11,null,3,4,5,6,7,8,9,10,</span></span><br><span class="line"><span class="comment"> * 那么设置这个null的意义就在于能够确定列表中元素个数（长度），目前我只有想到这一种情况下有用！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组中指定索引中的值</span></span><br><span class="line"><span class="comment"> * E：泛型类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断角标是否越界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断角标是否越界，该方法专门针对add 和 addAll方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本质上该方法与移除元素没啥区别</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空元素，主动将数组中的元素设置为null方便GC回收垃圾</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集合与数组取交集</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组元素是否被修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量删除元素</span></span><br><span class="line"><span class="comment"> * 若集合是否包含指定元素的结果与入参complement比较，</span></span><br><span class="line"><span class="comment"> * 若complement是false，移除数组与集合共有的元素</span></span><br><span class="line"><span class="comment"> * 若complement是true，保留数组与集合共有的元素，即交集</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> complement 比较值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数组元素是否被修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">            <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                elementData[w++] = elementData[r];</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></span><br><span class="line">        <span class="comment">// even if c.contains() throws.</span></span><br><span class="line">        <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">            System.arraycopy(elementData, r,</span><br><span class="line">                             elementData, w,</span><br><span class="line">                             size - r);</span><br><span class="line">            w += size - r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">                elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">            modCount += size - w;</span><br><span class="line">            size = w;</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义序列化</span></span><br><span class="line"><span class="comment"> * 若写入过程中数组结构被修改则会抛出异常</span></span><br><span class="line"><span class="comment"> * 如果采用默认的序列化机制，空余的空间会作为null写入本地文件或者在网络中传输，耗费了不必要的资源</span></span><br><span class="line"><span class="comment"> * 故而使用自定义序列化机制，仅写入索引为【0，size）的有效元素以节省资源</span></span><br><span class="line"><span class="comment"> * 默认的序列化机制会将非静态与非瞬时（非transient修饰）写入流中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 输出流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="comment">//执行默认序列化过程</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入元素个数</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按顺序写入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义反序列化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 输入流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行默认的反序列化过程</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//要写读一个字节，因为是按顺序写入</span></span><br><span class="line">    <span class="comment">//因为已经执行了默认的反序列化过程，已经为size赋值了，故不用再次赋值</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> capacity = calculateCapacity(elementData, size);</span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);</span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将流中的元素写入到数组中</span></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定条件移除元素</span></span><br><span class="line"><span class="comment"> * 笔者对BitSet也是第一次接触，针对本文章它显的不是很重要，故而大概了解了一下</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 该方法中将满足条件的元素索引存放到BitSet中，同时记录移除元素的个数removeCount</span></span><br><span class="line"><span class="comment"> * 紧接着BitSet调用 nextClearBit方法，该方法根据指定的索引获取没有在BitSet中存放的下一个索引，直接上个例子吧</span></span><br><span class="line"><span class="comment"> * BitSet removeSet = new BitSet();</span></span><br><span class="line"><span class="comment"> * removeSet.set(1)</span></span><br><span class="line"><span class="comment"> * removeSet.set(2)</span></span><br><span class="line"><span class="comment"> * System.out.println(removeSet.nextClearBit(1))  --&gt; 3</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 一开始已经在BitSet中存放了要移除的元素的索引，当调用nextClearBit方法循环遍历获取到的索引就是要保留的元素的索引</span></span><br><span class="line"><span class="comment"> * 故而直接获取元素的值将其存放到数组中，最后的数组是按照保留元素的顺序进行存放的</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 函数式接口中不能调用修改结构的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filter 使用指定条件来过滤元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> E&gt; filter)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(filter);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> removeCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> BitSet removeSet = <span class="keyword">new</span> BitSet(size);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="keyword">final</span> E element = (E) elementData[i];</span><br><span class="line">        <span class="keyword">if</span> (filter.test(element)) &#123;</span><br><span class="line">            removeSet.set(i);</span><br><span class="line">            removeCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// shift surviving elements left over the spaces left by removed elements</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> anyToRemove = removeCount &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (anyToRemove) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> newSize = size - removeCount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) &#123;</span><br><span class="line">            i = removeSet.nextClearBit(i);</span><br><span class="line">            elementData[j] = elementData[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=newSize; k &lt; size; k++) &#123;</span><br><span class="line">            elementData[k] = <span class="keyword">null</span>;  <span class="comment">// Let gc do its work</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.size = newSize;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> anyToRemove;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定规则替换所有旧元素</span></span><br><span class="line"><span class="comment"> * operator.apply方法：旧元素作为入参传入，根据规则返回新元素，然后进行替换</span></span><br><span class="line"><span class="comment"> * operator.apply方法中不能调用修改结构的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> operator 指定规则，函数式接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(operator);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        elementData[i] = operator.apply((E) elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定规则对数组中的元素进行排序</span></span><br><span class="line"><span class="comment"> * 若没有指定规则则使用默认的升序进行排序</span></span><br><span class="line"><span class="comment"> * 指定规则后会调用自定义比较器中的compare方法进行比较排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 自定义比较器，覆写compare方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    Arrays.sort((E[]) elementData, <span class="number">0</span>, size, c);</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个包含指定索引到结尾之间的元素的列表迭代器</span></span><br><span class="line"><span class="comment"> * 元素之间按照顺序排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含元素的列表迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个包含所有元素的列表迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 包含元素的列表迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代器，正向迭代</span></span><br><span class="line"><span class="comment"> * 通过判断是否存在下一个元素，若有则获取，若没有则说明迭代结束</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> E 元素类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//下一个元素的索引</span></span><br><span class="line">    <span class="keyword">int</span> cursor;</span><br><span class="line">    <span class="comment">//当前元素的索引</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否存在下一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否存在下一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个元素的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个元素的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除迭代过程中当前索引的元素</span></span><br><span class="line"><span class="comment">     * 初始化时当前索引为 -1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">            cursor = lastRet;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历元素，只能遍历一次</span></span><br><span class="line"><span class="comment">     * 在遍历过程中不能调用remove方法，会抛出IllegalStateException异常</span></span><br><span class="line"><span class="comment">     * 因为在移除过程中 lastRet 成员变量始终是 -1，故而会抛出异常</span></span><br><span class="line"><span class="comment">     * 与forEach的区别在于：可以遍历多次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> consumer 函数式接口，声明如何处理元素的函数</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * List&lt;String&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">     * list.add("1");</span></span><br><span class="line"><span class="comment">     * list.add("2");</span></span><br><span class="line"><span class="comment">     * list.iterator().forEachRemaining(str -&gt; &#123;</span></span><br><span class="line"><span class="comment">     *   System.out.println("str:" + str);</span></span><br><span class="line"><span class="comment">     * &#125;);</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * List&lt;String&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">     * list.add("1");</span></span><br><span class="line"><span class="comment">     * list.add("2");</span></span><br><span class="line"><span class="comment">     * list.add("3");</span></span><br><span class="line"><span class="comment">     * list.add("4");</span></span><br><span class="line"><span class="comment">     * list.add("5");</span></span><br><span class="line"><span class="comment">     * Iterator&lt;String&gt; iterator = list.iterator();</span></span><br><span class="line"><span class="comment">     * while (iterator.hasNext()) &#123;</span></span><br><span class="line"><span class="comment">     *  String nextValue = iterator.next();</span></span><br><span class="line"><span class="comment">     *  if (nextValue.equals("3")) &#123;</span></span><br><span class="line"><span class="comment">     *      iterator.forEachRemaining(str -&gt; &#123;</span></span><br><span class="line"><span class="comment">     *          System.out.println("内层：" + str);</span></span><br><span class="line"><span class="comment">     *      &#125;);</span></span><br><span class="line"><span class="comment">     *  &#125;</span></span><br><span class="line"><span class="comment">     *  System.out.println("外层：" + nextValue);</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(consumer);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = ArrayList.<span class="keyword">this</span>.size;</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">            consumer.accept((E) elementData[i++]); <span class="comment">//迭代过程中依次传入元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        cursor = i;</span><br><span class="line">        lastRet = i - <span class="number">1</span>;</span><br><span class="line">        checkForComodification();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化时 modCount 与 expectedModCount 是相等的</span></span><br><span class="line"><span class="comment">     * 但如果在遍历的过程修改数组结构的话，此时 modCount 会有所变化，导致两者不相等，故而抛出异常，也就是我们上面提到的fast-failed异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 列表迭代器，正向迭代</span></span><br><span class="line"><span class="comment"> * 可获取上一个元素、下一个元素及索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        cursor = index;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否有前一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否有前一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个元素的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个元素的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取上一个元素的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 上一个元素的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取上一个元素</span></span><br><span class="line"><span class="comment">     * 在获取过程中会判断该数组结构是否被修改</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 上一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">int</span> i = cursor - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        cursor = i;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随着遍历，索引是会向前移动，用指定元素替换索引处的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 指定元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList.<span class="keyword">this</span>.set(lastRet, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随着遍历，索引是会向前移动，将指定元素添加到下一个索引位置上</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 指定元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            ArrayList.<span class="keyword">this</span>.add(i, e);</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要理解迭代器，很关键的一个点就是<code>cursor</code>，它的位置决定了你调用方法的结果！</p><h5 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取指定起始索引到指定结束索引之间的元素，简称获取指定子集</span></span><br><span class="line"><span class="comment"> * 指定区间中的元素包括起始索引，不包括结束索引</span></span><br><span class="line"><span class="comment"> * 若起始索引与结束索引相等，则返回空元素</span></span><br><span class="line"><span class="comment"> * 对子集的操作，即调用set、add、remove等方法将会影响到整个数组</span></span><br><span class="line"><span class="comment"> * 但在先获取子集后，又对整个数组的结构进行修改，这时在遍历子集则会导致报错，而对于整体的非结构性修改则不会报错，不过依然会影响到子集</span></span><br><span class="line"><span class="comment"> * 所以在获取子集后最好不要修改数组的结构</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromIndex 起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toIndex 结束索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定区间中的所有元素，称为子集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SubList(<span class="keyword">this</span>, <span class="number">0</span>, fromIndex, toIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断起始索引与结束索引</span></span><br><span class="line"><span class="comment"> * 该判断在子集中又获取子集时显得较为重要</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromIndex 起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toIndex 结束索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> size 数组大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">subListRangeCheck</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"fromIndex = "</span> + fromIndex);</span><br><span class="line">    <span class="keyword">if</span> (toIndex &gt; size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"toIndex = "</span> + toIndex);</span><br><span class="line">    <span class="keyword">if</span> (fromIndex &gt; toIndex)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"fromIndex("</span> + fromIndex +</span><br><span class="line">                                           <span class="string">") &gt; toIndex("</span> + toIndex + <span class="string">")"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子集对象，支持随机访问</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  List&lt;String&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment"> *  list.add("1"); //0</span></span><br><span class="line"><span class="comment"> *  list.add("2"); //1</span></span><br><span class="line"><span class="comment"> *  list.add("3"); //2</span></span><br><span class="line"><span class="comment"> *  list.add("4"); //3</span></span><br><span class="line"><span class="comment"> *  list.add("5"); //4</span></span><br><span class="line"><span class="comment"> *  list.add("6"); //5</span></span><br><span class="line"><span class="comment"> *  list.add("7"); //6</span></span><br><span class="line"><span class="comment"> *  list.add("8"); //7</span></span><br><span class="line"><span class="comment"> *  list.add("9"); //8</span></span><br><span class="line"><span class="comment"> *  list.add("10"); //9</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  List&lt;String&gt; sub = list.subList(1,9);</span></span><br><span class="line"><span class="comment"> *  0,1,2,3,4,5,6,7</span></span><br><span class="line"><span class="comment"> *  2,3,4,5,6,7,8,9</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  sub.subList(2,8);</span></span><br><span class="line"><span class="comment"> *  0,1,2,3,4,5</span></span><br><span class="line"><span class="comment"> *  4,5,6,7,8,9</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 以上提供的方法只要是帮助大家去理解子集又获取子集的例子，其中加入了索引（上）及索引对应的元素（下）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SubList</span> <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指向调用者的引用，该变量特别是在子集中又子集时很关键，决定了是否理解该功能的重要因素</span></span><br><span class="line"><span class="comment">     * ArrayList -&gt; subList -&gt; subList</span></span><br><span class="line"><span class="comment">     * 当第一次调用subList获取子集时，为了方便理解，称为子集1，这个时候子集1中的parent指向了ArrayList，这点比较好理解</span></span><br><span class="line"><span class="comment">     * 当子集1又获取子集时，称为子集2，这个时候子集2中的parent指向了子集1，依次类推</span></span><br><span class="line"><span class="comment">     * 如果你仔细看了下面的方法后，你会知道它是如何调用的？例如子集2中调用add方法</span></span><br><span class="line"><span class="comment">     * 子集2#add -&gt; parent#add = 子集1#add -&gt; parent#add = ArrayList#add，最终都会调用到最上层类</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 那么为什么要这么设计呢？何不子集2#add -&gt; ArrayList#add 这样子的调用呢？</span></span><br><span class="line"><span class="comment">     * 理由在于modCount，它是指数组结构被修改的次数，这边就不再阐述何为结构被修改，假设下若按照 子集2#add -&gt; ArrayList#add这样子的顺序调用的话</span></span><br><span class="line"><span class="comment">     * ArrayList#modCount会正常变化，子集2#modCount也会正常变化，可参考add方法中的 this.modCount = parent.modCount 代码片段，</span></span><br><span class="line"><span class="comment">     * 按照上面的假设，此时只有ArrayList与子集2的modCount正常变化，但是子集1却没有变化，那当你在遍历子集1时，它会首先判断子集1的modCount是否与ArrayList的modCount相等</span></span><br><span class="line"><span class="comment">     * 若不相等，则抛出异常，具体可看 checkForComodification 方法，所以子集2#add时，也必须同时修改子集1的modCount，故而如此设计</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 有一个点关键，我们说是因为modCount，而只有结构修改了modCount才会变化，才需要如此调用，那么如果modCount没有被修改呢？</span></span><br><span class="line"><span class="comment">     * 那就不需要那么麻烦了，调用流程就是我们所假设的如此了 子集2#add -&gt; ArrayList#add</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 所以两种设计就用到了两个变量：parentOffset、offset</span></span><br><span class="line"><span class="comment">     * 两个变量分别针对两种方式去调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AbstractList&lt;E&gt; parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前子集索引与父子集索引的偏移量，简单地说就是子集2与子集1的索引偏移量，有一个等式</span></span><br><span class="line"><span class="comment">     * index2：子集2的索引  parentOffset2：子集2的属性</span></span><br><span class="line"><span class="comment">     * index1：子集1的索引  parentOffset1：子集1的属性</span></span><br><span class="line"><span class="comment">     * index3:ArrayList的索引</span></span><br><span class="line"><span class="comment">     * parentOffset2 + index2 = index1 + parentOffset1 = index3</span></span><br><span class="line"><span class="comment">     * 做了那么多，无非就是把子集1与子集2与ArrayList三者关联起来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parentOffset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前子集索引与ArrayList索引的偏移量，简单地说就是子集2与ArrayList的索引偏移量</span></span><br><span class="line"><span class="comment">     * 在创建子集2时，会把子集1与ArrayList的索引偏移量传给子集2，接着在加上子集2与子集1的索引偏移量就可以得到子集2与ArrayList的索引偏移量</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * offset2：子集2与子集1的索引偏移量（fromIndex）</span></span><br><span class="line"><span class="comment">     * offset1：子集1与ArrayList的索引偏移量（offset）</span></span><br><span class="line"><span class="comment">     * offset：当前子集，也就是子集2与ArrayList的索引偏移量</span></span><br><span class="line"><span class="comment">     * offset2 + offset1 = offset</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子集的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent 调用者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> offset 当前子集与ArrayList的索引偏移量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fromIndex 子集的起始索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> toIndex 子集的结束索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SubList(AbstractList&lt;E&gt; parent,</span><br><span class="line">            <span class="keyword">int</span> offset, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex) &#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        <span class="keyword">this</span>.parentOffset = fromIndex;</span><br><span class="line">        <span class="keyword">this</span>.offset = offset + fromIndex;</span><br><span class="line">        <span class="keyword">this</span>.size = toIndex - fromIndex;</span><br><span class="line">        <span class="keyword">this</span>.modCount = ArrayList.<span class="keyword">this</span>.modCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定元素替换子集中的指定索引</span></span><br><span class="line"><span class="comment">     * 指定索引的大小是相对于子集，故而加上offset</span></span><br><span class="line"><span class="comment">     * 由于该方法并没有修改结构，故而直接调用ArrayList的对应方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 相对于子集的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 指定元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 旧元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        E oldValue = ArrayList.<span class="keyword">this</span>.elementData(offset + index);</span><br><span class="line">        ArrayList.<span class="keyword">this</span>.elementData[offset + index] = e;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取子集中指定索引对应的元素</span></span><br><span class="line"><span class="comment">     * 指定索引的大小是相对于子集，故而加上offset</span></span><br><span class="line"><span class="comment">     * 由于该方法并没有修改结构，故而直接调用ArrayList的对应方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 相对于子集的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 指定索引对应的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">return</span> ArrayList.<span class="keyword">this</span>.elementData(offset + index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取子集的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子集中指定索引上添加元素</span></span><br><span class="line"><span class="comment">     * 由于该方法修改了数组结构，故而先调用上层子集的add方法，若没有子集则直接是ArrayList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 相对于子集的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 添加的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        parent.add(parentOffset + index, e);</span><br><span class="line">        <span class="keyword">this</span>.modCount = parent.modCount;</span><br><span class="line">        <span class="keyword">this</span>.size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除子集中指定索引位置的元素</span></span><br><span class="line"><span class="comment">     * 由于该方法修改了数组结构，故而先调用上层子集的remove方法，若没有子集则直接是ArrayList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 相对于子集的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        E result = parent.remove(parentOffset + index);</span><br><span class="line">        <span class="keyword">this</span>.modCount = parent.modCount;</span><br><span class="line">        <span class="keyword">this</span>.size--;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除子集中指定索引范围的所有元素</span></span><br><span class="line"><span class="comment">     * 由于该方法修改了数组结构，故而先调用上层子集的removeRange方法，若没有子集则直接是ArrayList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fromIndex 相对于子集的起始索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> toIndex 相对于子集的结束索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        parent.removeRange(parentOffset + fromIndex,</span><br><span class="line">                           parentOffset + toIndex);</span><br><span class="line">        <span class="keyword">this</span>.modCount = parent.modCount;</span><br><span class="line">        <span class="keyword">this</span>.size -= toIndex - fromIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子集末尾上追加集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c 集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addAll(<span class="keyword">this</span>.size, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子集中指定索引上添加集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 相对于子集的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c 集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        <span class="keyword">int</span> cSize = c.size();</span><br><span class="line">        <span class="keyword">if</span> (cSize==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        checkForComodification();</span><br><span class="line">        parent.addAll(parentOffset + index, c);</span><br><span class="line">        <span class="keyword">this</span>.modCount = parent.modCount;</span><br><span class="line">        <span class="keyword">this</span>.size += cSize;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取子集迭代器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 子集迭代器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> listIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取子集列表迭代器</span></span><br><span class="line"><span class="comment">     * 列表迭代器中的元素是从指定索引开始到结束索引</span></span><br><span class="line"><span class="comment">     * 这里就不对子集列表迭代器中的方法做再次解释了，毕竟它跟ArrayList是类似的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 相对于子集的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="keyword">this</span>.offset;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListIterator&lt;E&gt;() &#123;</span><br><span class="line">            <span class="keyword">int</span> cursor = index;</span><br><span class="line">            <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> expectedModCount = ArrayList.<span class="keyword">this</span>.modCount;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cursor != SubList.<span class="keyword">this</span>.size;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                checkForComodification();</span><br><span class="line">                <span class="keyword">int</span> i = cursor;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= SubList.<span class="keyword">this</span>.size)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">                Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">                <span class="keyword">if</span> (offset + i &gt;= elementData.length)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                cursor = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> (E) elementData[offset + (lastRet = i)];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cursor != <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                checkForComodification();</span><br><span class="line">                <span class="keyword">int</span> i = cursor - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">                Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">                <span class="keyword">if</span> (offset + i &gt;= elementData.length)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                cursor = i;</span><br><span class="line">                <span class="keyword">return</span> (E) elementData[offset + (lastRet = i)];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span> </span>&#123;</span><br><span class="line">                Objects.requireNonNull(consumer);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> size = SubList.<span class="keyword">this</span>.size;</span><br><span class="line">                <span class="keyword">int</span> i = cursor;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">final</span> Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">                <span class="keyword">if</span> (offset + i &gt;= elementData.length) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">                    consumer.accept((E) elementData[offset + (i++)]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// update once at end of iteration to reduce heap write traffic</span></span><br><span class="line">                lastRet = cursor = i;</span><br><span class="line">                checkForComodification();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cursor;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cursor - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">                checkForComodification();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    SubList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">                    cursor = lastRet;</span><br><span class="line">                    lastRet = -<span class="number">1</span>;</span><br><span class="line">                    expectedModCount = ArrayList.<span class="keyword">this</span>.modCount;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">                checkForComodification();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ArrayList.<span class="keyword">this</span>.set(offset + lastRet, e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">                checkForComodification();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = cursor;</span><br><span class="line">                    SubList.<span class="keyword">this</span>.add(i, e);</span><br><span class="line">                    cursor = i + <span class="number">1</span>;</span><br><span class="line">                    lastRet = -<span class="number">1</span>;</span><br><span class="line">                    expectedModCount = ArrayList.<span class="keyword">this</span>.modCount;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (expectedModCount != ArrayList.<span class="keyword">this</span>.modCount)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取子集</span></span><br><span class="line"><span class="comment">     * 子集中又获取子集</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fromIndex 相对于子集的起始索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> toIndex 相对于子集的结束索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 子集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SubList(<span class="keyword">this</span>, offset, fromIndex, toIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验索引是否超出范围</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 相对于子集的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>.size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验索引是否超出范围</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 相对于子集的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="keyword">this</span>.size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 索引超出范围的错误信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 相对于子集的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 错误信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">outOfBoundsMsg</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Index: "</span>+index+<span class="string">", Size: "</span>+<span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验子集的结构修改次数是否与ArrayList一致</span></span><br><span class="line"><span class="comment">     * 若先获取子集后，接着在ArrayList上修改了结构，则会报错</span></span><br><span class="line"><span class="comment">     * 因为子集的modCount并没有随着ArrayList结构的修改而变化，导致了两个变量不一致</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ArrayList.<span class="keyword">this</span>.modCount != <span class="keyword">this</span>.modCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由于该方法涉及到另外一个接口，会另外新起一篇文章来讲解该内容，这里就不做阐述</span></span><br><span class="line"><span class="comment">     * 附上文章地址：http://zlia.tech/2019/07/19/explain-arraylist-spliterator-sourcecode/</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayListSpliterator&lt;E&gt;(ArrayList.<span class="keyword">this</span>, offset,</span><br><span class="line">                                           offset + <span class="keyword">this</span>.size, <span class="keyword">this</span>.modCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Arrays</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拷贝指定数组到新数组中，根据指定的长度缩短或使用null扩充新数组</span></span><br><span class="line"><span class="comment">     * 新数组与原始数组的数据类型是完全一样的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">        <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拷贝指定数组到新数组中，根据指定的长度缩短或使用null扩充新数组</span></span><br><span class="line"><span class="comment">     * 新数组的数据类型由入参newType决定</span></span><br><span class="line"><span class="comment">     * 判断入参newType是否是Ojbect[]类型</span></span><br><span class="line"><span class="comment">     * 若newType是Object[]类型，则创建一个长度为newLength的新数组，并向下转型为T[]类型</span></span><br><span class="line"><span class="comment">     * 若newType不是Object[]类型，则创建一个长度为newLength的新数组，但由于Array.newInstance返回值是Object，故而向下转型为T[]类型</span></span><br><span class="line"><span class="comment">     * Array.newInstance与System.arraycopy属于C底层代码，故而查看不了具体实现</span></span><br><span class="line"><span class="comment">     * System.arraycopye(param1, param2, param3, param4, param5)</span></span><br><span class="line"><span class="comment">     * param1：原始数组； param2：原始数组复制元素的起始角标； param3：新数组； param4：复制元素到新数组的起始角标处；param5：原始数组要从起始角标开始拷贝多少个元素到新数组</span></span><br><span class="line"><span class="comment">     * 从原始数组param1的角标为param2开始复制param5个元素，到新数组param3的角标为param4作为复制元素的起始点</span></span><br><span class="line"><span class="comment">     * 返回新数组，此时已经填充好数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * System.arraycopy性能趋势：当数组大小在百万到千万级别之间时所花费的时间差别不大，但是当达到亿级别后，所花费的时间就会差很多</span></span><br><span class="line"><span class="comment">     * 所以这也就导致了当数组容量达到亿级别后，手动调用ensureCapacity来预先设置容量大小所带来的效率比自动扩容的销量要低很多</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) <span class="keyword">new</span> Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">        System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>, Math.min(original.length, newLength));</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>写的内容有点过多，这里总结一下，方便获取<code>直接获取结果</code>！</p><ul><li><p>ArrayList允许存放Null。</p></li><li><p>ArrayList内部通过数组实现，大体上和Vector类似，除了是非线程安全。</p></li><li><p>ArrayList中的size、isEmpty、get、set、iterator、listIterator的时间复杂度是O(1)，而add操作的时间复杂度是O(n)。</p></li><li><p>由于ArrayList是非线程安全，所以多线程情况下要在外部控制线程安全或使用Collections.synchronizedList也行。</p></li><li><p>获取迭代器后，不允许进行结构修改操作，因为会 expectedModCount 与 modCount 是否相等。</p></li><li><p>创建空参数的ArrayList对象时，默认的初始容量是10，当容量不足时，以1.5倍速度增长。</p></li><li><p>ArrayList对象中通过modCount变量来计算数组结构改变的次数。</p></li><li><p>在构建ArrayList对象时，最好能预先设置容量大小，以免减少后期扩容花费的时间。</p></li><li><p>ArrayList容量的临界值是最大值 - 8，这个数字8是因为在数组中除了存储元素之外还会存储数组的长度，而这些数据都在内存中，不同操作系统对内存的分配可能有所差异，减去8更多的是为了防止内存溢出。</p></li><li><p>ArrayList的Iterator迭代器中的forEachRemaining方法只能调用一次，且在该方法中不能调用remove方法</p></li><li><p>ArrayList的ListIterator迭代器可反向遍历列表</p></li><li><p>在获取ArrayList的子集后不能在做结构上的修改</p></li></ul><h4 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a>重点关注</h4><p><code>自动扩容机制</code> <code>非线程安全</code> <code>默认初始扩容值10</code> <code>get/set时间复杂度O(1)，add时间复杂度O(n)</code> <code>fail-fast</code> <code>底层是通过数组存储元素，故是有序可重复集合</code> <code>移除元素后ArrayList主动将索引位置的值设置成null</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;想进步，想学习了，反正面试都要问的，还不如早点看了好。探索&lt;code&gt;ArrayList&lt;/code&gt;源代码是基于&lt;code&gt;JDK1.8&lt;/code&gt;版本的，相比以前的版本不知道有没有优化，毕竟没看过之前版本的底层代码。&lt;/p&gt;
&lt;h3 id=&quot;简单说明下&quot;&gt;&lt;a href=&quot;#简单说明下&quot; class=&quot;headerlink&quot; title=&quot;简单说明下&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;简单说明下&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;一般看底层代码前我都习惯先阅读下该类的&lt;code&gt;注释说明&lt;/code&gt;，也不知道在哪里养成的习惯。相信大家都写过应用代码，既然写过，那也深知注释对于一个使用者来说是多么的重要，决定了它是否能够正确的使用，所以这是一个好习惯。&lt;/p&gt;
&lt;h4 id=&quot;阅读注释&quot;&gt;&lt;a href=&quot;#阅读注释&quot; class=&quot;headerlink&quot; title=&quot;阅读注释&quot;&gt;&lt;/a&gt;阅读注释&lt;/h4&gt;&lt;p class=&quot;customize-img&quot;&gt;&lt;img src=&quot;/assets/blogImg/java/arraylist/arraylist-comment-1.png&quot; alt=&quot;ArrayList注释-1&quot;&gt;&lt;/p&gt;
&lt;p&gt;看到这不知道你们有没有很惊讶，反正我倒是一惊，所以我说看注释很重要！！！如果是你写代码给别人看，除了看具体代码之外，看注释就是最好的理解方式了，一语道破很多原理，要求不高的我都觉得可以不用看代码实现了，所以接下来会继续阅读注释。&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Photoshop CC 2014 安装、破解、完全卸载</title>
    <link href="http://zlia.tech/2019/07/19/photoshop-knowledge-1/"/>
    <id>http://zlia.tech/2019/07/19/photoshop-knowledge-1/</id>
    <published>2019-07-19T14:43:22.000Z</published>
    <updated>2019-07-19T14:48:19.317Z</updated>
    
    <content type="html"><![CDATA[<h3 id="先下载在说"><a href="#先下载在说" class="headerlink" title="先下载在说"></a><div><span>先下载在说</span></div></h3><p>废话少说点，上个链接，先下载着在文章。<br><code>安装包下载地址</code>：<a href="https://pan.baidu.com/s/1jijJZpNanLOhZY_yNUJQww" target="_blank" rel="noopener">Photoshop CC 2014 64位安装包</a> 提取码：u3cm。<br><code>破解补丁</code>：<a href="https://pan.baidu.com/s/1r7AFcb32LrRrzWtJb9PD7A" target="_blank" rel="noopener">Photoshop CC 2014 补丁</a> 提取码：cz1c<br>现在都2019年了，为啥还是2014年的版本呢？好老啊！怪作者没有一点基础，有个版本先学着就不错了，莫怪莫怪！</p><a id="more"></a><h3 id="轻松卸载PS"><a href="#轻松卸载PS" class="headerlink" title="轻松卸载PS"></a><div><span>轻松卸载PS</span></div></h3><p>为什么写这个小主题呢？还是吃了没有经验的亏，还以为应该挺好破解的，没想到全程都不能联网，可惜我已经在装好的路上不能回头了，嗯…只好卸载了重新安装了。<br>我也是看了别人写的帖子，这边就不复制粘贴了，没啥意思，以下是<a href="http://www.sucaijishi.com/2016/articles_0318/135.html" target="_blank" rel="noopener">卸载方式</a>，亲测过，很好用，一次成功。<br>不知道该网站作者提供的卸载工具是不是永久有效的，反正我现在使用是可以的，以防万一我在提供个永久有效链接。<br><code>卸载工具地址</code>：<a href="https://pan.baidu.com/s/1mbBytXwsWTq2sUQnJKhpPw" target="_blank" rel="noopener">卸载工具</a> 提取码：19t5。<br>回头一想，万一我提供的网址保个500错误，那我这篇文章岂不是没用了，不行不行，要有它存在的价值，勉强复制下它的内容，哈哈哈。</p><ul><li><p>先像正常软件卸载方式一样卸载它。</p></li><li><p>在使用卸载工具前，先删除以下路径的文件夹：</p><ul><li>C:\Program Files (x86)\Common Files\Adobe</li><li>C:\Program Files\Common Files\Adobe</li><li>C:\ProgramData\Adobe 此目录默认为隐藏目录，先设置系统显示隐藏的文件</li></ul></li><li><p>接着下载卸载工具，这是解压后的目录结构，使用前请先关闭杀毒、卫士等软件。<br><img src="/assets/blogImg/essays/ps/ps-uninstall-tools.png" alt="卸载PS工具目录结构"></p></li></ul><p><code>注意：该卸载工具可以卸载photoshop多个版本，需要卸载哪个版本就选择哪个</code></p><ul><li>紧接着开始扣图了，就按照图片的顺序一一执行就OK了：</li></ul><p class="customize-img"><img src="/assets/blogImg/essays/ps/ps-uninstall-step-1.png" alt="卸载PS步骤-1"></p><p class="customize-img"><img src="/assets/blogImg/essays/ps/ps-uninstall-step-2.png" alt="卸载PS步骤-2"></p><p class="customize-img"><img src="/assets/blogImg/essays/ps/ps-uninstall-step-3.png" alt="卸载PS步骤-3"></p><p class="customize-img"><img src="/assets/blogImg/essays/ps/ps-uninstall-step-4.png" alt="卸载PS步骤-4"></p><p class="customize-img"><img src="/assets/blogImg/essays/ps/ps-uninstall-step-5.png" alt="卸载PS步骤-5"></p><p class="customize-img"><img src="/assets/blogImg/essays/ps/ps-uninstall-step-6.png" alt="卸载PS步骤-6"></p><p><code>清除成功后，别忘记了重启下电脑，这步是不可或缺的!</code>。</p><h3 id="安装与破解"><a href="#安装与破解" class="headerlink" title="安装与破解"></a><div><span>安装与破解</span></div></h3><p>不照搬别人的成果了，安装的文章有很多，这边提供一个<a href="https://ke.qq.com/course/60897?taid=151401892212193&amp;dialog=1" target="_blank" rel="noopener">安装视频链接</a>，该视频中提到的补丁工具我没找到，所以上面只能提供一个补丁，你把下载下来的<code>amtlib.dll</code>补丁放到你安装PS的目录，它会进行替换。</p><p class="customize-img"><img src="/assets/blogImg/essays/ps/ps-crack-patch.png" alt="替换文件"></p><p><code>怎么验证破解成功？当你重启PS时，不会在弹出30天试用期窗口时就代表成功了，恭喜你！</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;先下载在说&quot;&gt;&lt;a href=&quot;#先下载在说&quot; class=&quot;headerlink&quot; title=&quot;先下载在说&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;先下载在说&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;废话少说点，上个链接，先下载着在文章。&lt;br&gt;&lt;code&gt;安装包下载地址&lt;/code&gt;：&lt;a href=&quot;https://pan.baidu.com/s/1jijJZpNanLOhZY_yNUJQww&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Photoshop CC 2014 64位安装包&lt;/a&gt; 提取码：u3cm。&lt;br&gt;&lt;code&gt;破解补丁&lt;/code&gt;：&lt;a href=&quot;https://pan.baidu.com/s/1r7AFcb32LrRrzWtJb9PD7A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Photoshop CC 2014 补丁&lt;/a&gt; 提取码：cz1c&lt;br&gt;现在都2019年了，为啥还是2014年的版本呢？好老啊！怪作者没有一点基础，有个版本先学着就不错了，莫怪莫怪！&lt;/p&gt;
    
    </summary>
    
      <category term="essays" scheme="http://zlia.tech/categories/essays/"/>
    
    
      <category term="photoshop" scheme="http://zlia.tech/tags/photoshop/"/>
    
  </entry>
  
  <entry>
    <title>探索Integer.toBinaryString源码</title>
    <link href="http://zlia.tech/2019/06/25/explain-binary-code/"/>
    <id>http://zlia.tech/2019/06/25/explain-binary-code/</id>
    <published>2019-06-25T11:56:40.000Z</published>
    <updated>2019-06-25T12:02:55.531Z</updated>
    
    <content type="html"><![CDATA[<h3 id="不解驱动着你"><a href="#不解驱动着你" class="headerlink" title="不解驱动着你"></a><div><span>不解驱动着你</span></div></h3><p>一般情况下我是不会主动去看源码的，除非是写专门的主题或者是遇到不懂的难题。果然了，于是带着好奇心尝试理解下源码，一会我先抛出问题，要是有同学一下子就明白了那就可以不用往下看了！还有一个前提就是最好对原码、补码、反码有所了解，因为计算机操作的数据就是以二进制的形式存在的，准确的说是用补码的形式来计算的！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URShift</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(i));</span><br><span class="line"></span><br><span class="line">        i &gt;&gt;&gt;= <span class="number">10</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(i));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> l = -<span class="number">1</span>;</span><br><span class="line">        System.out.println(Long.toBinaryString(l));</span><br><span class="line"></span><br><span class="line">        l &gt;&gt;&gt;= <span class="number">10</span>;</span><br><span class="line">        System.out.println(Long.toBinaryString(l));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">short</span> s = -<span class="number">1</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(s));</span><br><span class="line"></span><br><span class="line">        s &gt;&gt;&gt;= <span class="number">10</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(s));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span> b = -<span class="number">1</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(b));</span><br><span class="line"></span><br><span class="line">        b &gt;&gt;&gt;= <span class="number">10</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11111111111111111111111111111111</span></span><br><span class="line"><span class="number">1111111111111111111111</span></span><br><span class="line"><span class="number">1111111111111111111111111111111111111111111111111111111111111111</span></span><br><span class="line"><span class="number">111111111111111111111111111111111111111111111111111111</span></span><br><span class="line"><span class="number">11111111111111111111111111111111</span></span><br><span class="line"><span class="number">11111111111111111111111111111111</span></span><br><span class="line"><span class="number">11111111111111111111111111111111</span></span><br><span class="line"><span class="number">11111111111111111111111111111111</span></span><br></pre></td></tr></table></figure><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a><div><span>源码</span></div></h3><p><code>Integer.toBinaryString</code>内部实现的方法主要有两个：<code>numberOfLeadingZeros</code> <code>formatUnsignedInt</code>，剩下的就无关紧要了，所以接下来的内容主要围绕着两个方法来讲。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberOfLeadingZeros</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;&gt;&gt; <span class="number">16</span> == <span class="number">0</span>) &#123; n += <span class="number">16</span>; i &lt;&lt;= <span class="number">16</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;&gt;&gt; <span class="number">24</span> == <span class="number">0</span>) &#123; n +=  <span class="number">8</span>; i &lt;&lt;=  <span class="number">8</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;&gt;&gt; <span class="number">28</span> == <span class="number">0</span>) &#123; n +=  <span class="number">4</span>; i &lt;&lt;=  <span class="number">4</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;&gt;&gt; <span class="number">30</span> == <span class="number">0</span>) &#123; n +=  <span class="number">2</span>; i &lt;&lt;=  <span class="number">2</span>; &#125;</span><br><span class="line">    n -= i &gt;&gt;&gt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始之前在复习下计算机的原码、补码、反码的相关计算，举个简单的例子。</p><table><thead><tr><th style="text-align:center">数值</th><th style="text-align:center">原码</th><th style="text-align:center">反码</th><th style="text-align:center">补码</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0000 0000 0000 0000 0000 0000 0000 0001</td><td style="text-align:center">0000 0000 0000 0000 0000 0000 0000 0001</td><td style="text-align:center">0000 0000 0000 0000 0000 0000 0000 0001</td></tr><tr><td style="text-align:center">-1</td><td style="text-align:center">1000 0000 0000 0000 0000 0000 0000 0001</td><td style="text-align:center">1111 1111 1111 1111 1111 1111 1111 1110</td><td style="text-align:center">1111 1111 1111 1111 1111 1111 1111 1111</td></tr></tbody></table><p>为了方便理解，我们采用假设的方式来引导读者。针对<code>numberOfLeadingZeros</code>方法假设入参<code>i = 1</code>，以下分多个步骤来分析该方法，在分析方法之前先跟读者说下该方法的主要作用是：<code>获取该二进制从左侧开始数连续0的个数</code>，有了这个个数就能构建数组的大小去存储有效的数据，二进制中前置位为0的话是不会存储的。</p><ul><li><p>① 判断i是否等于0，结果很明显，此时<code>i = 1，n = 1</code>；</p></li><li><p>② 判断i左移16位后是否等于0，计算如下：</p></li></ul><table><thead><tr><th style="text-align:center">数值</th><th style="text-align:center">计算前</th><th style="text-align:center">移位</th><th style="text-align:center">计算后</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0000 0000 0000 0000 0000 0000 0000 0001</td><td style="text-align:center">左移16</td><td style="text-align:center">0000 0000 0000 0000 0000 0000 0000 0000</td></tr></tbody></table><p>很显然，结果是等于0，故此时<code>n = 17</code>，而i又做了计算，如下：</p><table><thead><tr><th style="text-align:center">数值</th><th style="text-align:center">计算前</th><th style="text-align:center">移位</th><th style="text-align:center">计算后</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0000 0000 0000 0000 0000 0000 0000 0001</td><td style="text-align:center">右移16</td><td style="text-align:center">0000 0000 0000 0001 0000 0000 0000 0000</td></tr></tbody></table><ul><li><p>③ <code>不管是byte还是short类型，它们在移位之前都会被转换成int类型，再进行计算，所以它们的位数也是32位</code>。好奇的地方来了，为啥要左移16位呢，而相等后又要右移16位呢？一开始我也不太懂要这么做，后面看了一片文章觉得应该跟算法有关系，准确的说用的是<code>二分法</code>，就比如有10位数字，利用10位的一半5来做为开头，而后做完逻辑后又取剩下位数的一半来继续做逻辑运算，直接结束。有了以上的两个前提，所以先左移16位，若等于0的话，则说明该二进制左侧<code>至少有连续的16个0</code>，相当于32位中的前16位已经计算好了，接下来就应该计算剩下的16位，因为目前连续的0个数是至少有16位，还有剩下16位不知道情况，所以有可能有更多的0连续。那么问题来了，怎么才能知道后16位的情况呢？准确的来说应该是怎么知道后16位有多少个连续0，这就很明确了，直接计算后16位等于多少不就可以知道结果了吗？是的，就是这么回事，利用二分法，应该是后16位中取前8位来计算，也就是 0000 0000 0000 0000 <u>0000 0000</u> 0000 0001 计算下划线的数字中包含几位连续的0，一般想的话直接会把上面下划线中的数字直接右移8位即可得到结果，可以是可以，只不过写的代码会有很多重复，你要判断多个if-else，而if里头又有if-else，看着很恶心，所以还是算法吊，这边的右移16位是为了跟下一个判断做一个对应。</p></li><li><p>④ 判断i左移24位后是否等于0，相当于计算上面提到的下划线中的数据内容，计算如下：</p></li></ul><table><thead><tr><th style="text-align:center">数值</th><th style="text-align:center">计算前</th><th style="text-align:center">移位</th><th style="text-align:center">计算后</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0000 0000 0000 0001 0000 0000 0000 0001</td><td style="text-align:center">右移24</td><td style="text-align:center">0000 0000 0000 0000 0000 0000 0000 0000</td></tr></tbody></table><p>结果等于0，此时<code>n = 25</code>,而i又做了计算，如下：</p><table><thead><tr><th style="text-align:center">数值</th><th style="text-align:center">计算前</th><th style="text-align:center">移位</th><th style="text-align:center">计算后</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0000 0000 0000 0001 0000 0000 0000 0001</td><td style="text-align:center">右移24</td><td style="text-align:center">0000 0001 0000 0000 0000 0000 0000 0000</td></tr></tbody></table><p>相当于准备要计算最后的8位了，那么就看下一个判断语句了。</p><ul><li><p>⑤ 判断i左移28位，这边就不在一一做运算了，结果<code>n = 29</code>。</p></li><li><p>⑥ 判断i左移30，结果<code>n = 31</code>。</p></li></ul><table><thead><tr><th style="text-align:center">数值</th><th style="text-align:center">结果值</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0100 0000 0000 0000 0000 0000 0000 0000</td></tr></tbody></table><ul><li>⑦ 计算 n = n - i &gt;&gt;&gt; 31，i右移31位后等于0，所以n最终等于31位，刚好说明从左侧开始有连续的31个0。</li></ul><p>接下来讨论另外一个方法<code>formatUnsignedInt</code>，紧接着上面假设后得出的结果，所以<code>mag = 1</code>，表示该数值的有效位是1位，故将会构建长度为1的数组，对于任意数据，最小的长度就是1，而对于最大的长度就要看具体的数值了。好了，<code>formatUnsignedInt</code>方法中入参为<code>val = 1, shift = 1, buf = new char[1], offset = 0, len = 1</code>。在分析之前先说下该方法的主要作用，其实也没啥可说的，就是<code>将数组解析成二进制后并放入到数组中</code>。</p><ul><li><p>① <code>charPos = 1</code>表示有效位的个数，<code>radix = 2</code>表示要转换成二进制的基数，若是要转换后八进制，则radix=8,同理，十六进制radix=16，不过你们也知道二进制的数只有0、1，同理就不阐述其他进制了，<code>mask = 1</code>,一般我们要将十进制转换成其他进制的话，只需要&amp;(与)上对应的进制基数即可得到结果，就好比是八进制的话就&amp;7、十六进制的话就&amp;15，这是最快得到十六进制表示的数值。</p></li><li><p>② 由于要将数组转换成二进制，故&amp;1，根据得到的索引值查找数组当中对应的某个值，然后在数组的最高位上进行存储，相当于越低位应该放在越高位上，正好与二进制的格式相对应，相信不难理解。</p></li><li><p>③ 计算完上一个数后，开始右移动，对于八进制的话应该是右移3位，因为3位数表示1位八进制，同理，对于十六进制应该是右移4位，因为4位数表示1位十六进制，这边是二进制，故右移1位。</p></li><li><p>④ 判断移位后数值是否等于0，毕竟等于0的话咱们就没必要计算了，所以结果会依次循环计算该数值并移位，直到最后。</p></li><li><p>⑤ 每次计算都是把计算结果放到数组当中去，所以<code>buf</code>就是最后的结果，最后在将其转成字符串输出。</p></li></ul><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a><div><span>结束语</span></div></h3><p>源码在适当的情况下还是需要去看的，笔者正在一步一步往这里靠近，努力加强自己的硬实力！加油自己，加油每一个人！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;不解驱动着你&quot;&gt;&lt;a href=&quot;#不解驱动着你&quot; class=&quot;headerlink&quot; title=&quot;不解驱动着你&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;不解驱动着你&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;一般情况下我是不会主动去看源码的，除非是写专门的主题或者是遇到不懂的难题。果然了，于是带着好奇心尝试理解下源码，一会我先抛出问题，要是有同学一下子就明白了那就可以不用往下看了！还有一个前提就是最好对原码、补码、反码有所了解，因为计算机操作的数据就是以二进制的形式存在的，准确的说是用补码的形式来计算的！&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;URShift&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(Integer.toBinaryString(i));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        i &amp;gt;&amp;gt;&amp;gt;= &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(Integer.toBinaryString(i));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; l = -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(Long.toBinaryString(l));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        l &amp;gt;&amp;gt;&amp;gt;= &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(Long.toBinaryString(l));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;short&lt;/span&gt; s = -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(Integer.toBinaryString(s));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        s &amp;gt;&amp;gt;&amp;gt;= &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(Integer.toBinaryString(s));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt; b = -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(Integer.toBinaryString(b));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        b &amp;gt;&amp;gt;&amp;gt;= &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(Integer.toBinaryString(b));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>推荐初级程序员书单</title>
    <link href="http://zlia.tech/2019/06/08/primary-programmer-book-list/"/>
    <id>http://zlia.tech/2019/06/08/primary-programmer-book-list/</id>
    <published>2019-06-08T07:02:17.000Z</published>
    <updated>2019-06-25T11:50:50.142Z</updated>
    
    <content type="html"><![CDATA[<h3 id="有点菜"><a href="#有点菜" class="headerlink" title="有点菜"></a><div><span>有点菜</span></div></h3><p>嗯…怎么说好呢？由于笔者自我认为还是个初级程序员，所以以下的内容基本上是围绕着我个人的经历来写的。笔者毕业两年了，看过的书籍不是很多，因为刚出来的时候也像你们一样在百度上搜索着程序员书单之类的关键词，然后一一列举下来，做的好一点的呢会去看看书单中每一本书的目录都包含什么及收集一些看过这些书的人的观点，不适合自己的当然是果断排除点！如今自己也看了几本书，觉得都还可以，只不过是针对<code>初级程序员</code>，当然这只是目前情况，笔者还在学习，陆陆续续也会推荐更多的书单介绍。</p><a id="more"></a><h3 id="入门级别"><a href="#入门级别" class="headerlink" title="入门级别"></a><div><span>入门级别</span></div></h3><p>由于笔者对<code>java8</code>有很大的浓厚兴趣，所以我的第一本书籍就是<code>Java核心技术 卷1</code>，市面上有讲java8的书籍应该不是很多吧。这本书的大致内容都是围绕着基础知识来讲，同时涵盖了一些java8的知识内容，比较适合入门不久的同学，遗憾的是对于数据结构这方面的知识只是点到为止，简单介绍而已，这方面的知识不应该也是属于核心技术吗？这我就不懂了，还专门写了swing这块的知识，我直接跳过了，个人觉得知识点不是很重要的块最好可以跳过以免浪费时间，既然看完了卷1，那顺便把卷二也看了吧，哈哈。卷二说实话没有卷一写的好，前面的知识讲的倒一般般，java8 stream的各种使用，后面讲的内容很繁琐，连续跳过了好几个章节，而且给我的感觉是讲的内容很老，当然了，这毕竟是几年前的书了，也难怪！</p><h3 id="入门增强"><a href="#入门增强" class="headerlink" title="入门增强"></a><div><span>入门增强</span></div></h3><p>所谓的入门增强就是在你了解基础知识后进一步的巩固加强它，比如一些原理性的知识能够很大程度的帮助你理解，如果这方面你掌握的很好以后对于框架层源码方面的理解会更容易理解，并且很多公司都注重基础知识，程序员强不强不是看他懂了几个框架，而是你的基础知识，原理性的东西才是最牛逼的，所以笔者一直在各种巩固自己这方面的知识，目前正在看的书籍是<code>java编程思想</code>，具备了前面的基础知识，看这本书会比较容易，该书多数以理论知识来讲解，代码内容不多，更注重于原理方面的知识，非常建议同学去看，只不过可惜的是没有讲到java8，唉，毕竟java8不论是在效率上还是安全性上都增强了，但是具体的理论知识我是想知道的！</p><h3 id="未读书籍"><a href="#未读书籍" class="headerlink" title="未读书籍"></a><div><span>未读书籍</span></div></h3><p>上面提到的书最好能理解透了在过，不然效果没那么明显，或者可以选择看第二遍。以下介绍的书单虽然我还没有看过，但是都是做过功课筛选出来的，罪过罪过。</p><ol><li><code>大话设计模式</code>：重复代码敲多了难免会觉得没意思，来点高大上的代码设计才能冲击你的成就感。</li><li><code>重构改善既有代码的设计</code>：光看这本书的名字就觉得应该很吊，哈哈哈。</li><li><code>数据结构与算法</code>：数据结构这方面的知识一定要下功夫。</li><li><code>java并发编程实战</code>：一样，下功夫吧。</li><li>未完待续。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;有点菜&quot;&gt;&lt;a href=&quot;#有点菜&quot; class=&quot;headerlink&quot; title=&quot;有点菜&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;有点菜&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;嗯…怎么说好呢？由于笔者自我认为还是个初级程序员，所以以下的内容基本上是围绕着我个人的经历来写的。笔者毕业两年了，看过的书籍不是很多，因为刚出来的时候也像你们一样在百度上搜索着程序员书单之类的关键词，然后一一列举下来，做的好一点的呢会去看看书单中每一本书的目录都包含什么及收集一些看过这些书的人的观点，不适合自己的当然是果断排除点！如今自己也看了几本书，觉得都还可以，只不过是针对&lt;code&gt;初级程序员&lt;/code&gt;，当然这只是目前情况，笔者还在学习，陆陆续续也会推荐更多的书单介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="essays" scheme="http://zlia.tech/categories/essays/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>每日知识点20190415</title>
    <link href="http://zlia.tech/2019/05/30/core-java-knowledge-20190415/"/>
    <id>http://zlia.tech/2019/05/30/core-java-knowledge-20190415/</id>
    <published>2019-05-30T15:21:44.000Z</published>
    <updated>2019-06-08T05:40:33.375Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java"><a href="#java" class="headerlink" title="java"></a><div><span>java</span></div></h3><ul><li><p>String v = map.putIfAbsent(“a”, “1”)：若map中不存在指定的key值(a)，则使用指定的key(a)和指定的value(1)进行填充，但此时返回的数据是<code>旧值</code>，所以是null，即v=null，当你真正调用map.get(“a”)时才返回指定的value值，即1.</p></li><li><p>String v = map.computeIfAbsent(“a”, “1”)：若map中不存在指定的key值(a)，则使用指定的key(a)和指定的value(1)进行填充，但此时返回的数据是<code>新值</code>，即v=1.</p></li><li><p>DateTimeFormatter.parse()：可以解析LocalDate、LocalTime、LocalDateTime.</p></li><li><p>MessageFormat：消息格式化，如MessageFormat.format(“hi, my name is {0}”, “zhangsan”)，不仅如此，占位符后面还可以跟一个类型和一个风格，它们之间用逗号隔开.单独将choice拿出来先讲讲，{1,choice,0#no house| 1#one hose | 2#two houses}，一个选择格式是由一个序列对构成的，每一个对包括一个<code>下限</code>和一个<code>格式字符串</code>，下面的列表中是其他的类型.</p></li></ul><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">风格</th></tr></thead><tbody><tr><td style="text-align:center">number</td><td style="text-align:center">integer、currency、percent、$</td></tr><tr><td style="text-align:center">time/date</td><td style="text-align:center">short、medium、long、full、yyyy-MM-dd</td></tr></tbody></table><ul><li>注解中的所有元素值必须是编译期常量.</li></ul><a id="more"></a><ul><li><p>Cannot annotate class literal、Cannot annotate import.</p></li><li><p>注解类型有：基本类型、String、Class、enum类型、注解类型、有前面所述类型组成的数组.</p></li><li><p>引导类加载器负责加载系统类，通常是用C语言来实现的.</p></li><li><p>扩展类加载器用于加载jre/lib/ext目录，即使没有配置任何类路径，它也可以找到其中的各个类.</p></li><li><p>系统类加载器用于加载应用类，查找类路径中的目录或者jar/zip文件里查找这些类.</p></li><li><p>对泛型上下限的理解：<br>  先说个前提，在类型参数确定的情况是可以add具体的对象及子类，个人理解而已.<br>  假设： 苹果 extends 水果、香蕉 extends 水果、其他<br>  <code>? extends 水果</code>：可以指定类型参数为<code>水果或水果的子类</code>，所以<code>类型参数可能是水果也可能是苹果也可能是香蕉</code>，不能确定具体的类型参数，更别说要添加什么类型的对象了，所以是不允许add操作，但是不管类型参数是什么，总之它就是水果，水果是它的最大类型参数，得出结论<code>该语句不能add，但是可以确定返回值</code>.<br>  <code>? super 水果</code>：可以指定类型参数为<code>水果或水果的父类或Object</code>，因为编译器不知道你传入的类型参数是什么，所以不能add水果的父类，否则很容易造成类型参数与值不匹配，但至少有一点是确定的，不管你传入的类型参数是什么，它的子类都有水果，所以不管你传入的类型参数是什么，它都可以添加水果及水果的子类，毕竟水果是确定的一个最小类型参数，但是对于返回值就要看最大类型参数，那就是Object，得出结论<code>该语句能add指定类型参数及子类，但是返回值是Object</code>.<br>  无意中想到的一个快速理解的语句：<code>能不能add看最小类型参数确定没，就能add，没确定就不能，返回值是什么看最大类型参数是什么那返回值就是什么</code>.</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java&quot;&gt;&lt;a href=&quot;#java&quot; class=&quot;headerlink&quot; title=&quot;java&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;java&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;String v = map.putIfAbsent(“a”, “1”)：若map中不存在指定的key值(a)，则使用指定的key(a)和指定的value(1)进行填充，但此时返回的数据是&lt;code&gt;旧值&lt;/code&gt;，所以是null，即v=null，当你真正调用map.get(“a”)时才返回指定的value值，即1.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;String v = map.computeIfAbsent(“a”, “1”)：若map中不存在指定的key值(a)，则使用指定的key(a)和指定的value(1)进行填充，但此时返回的数据是&lt;code&gt;新值&lt;/code&gt;，即v=1.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;DateTimeFormatter.parse()：可以解析LocalDate、LocalTime、LocalDateTime.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MessageFormat：消息格式化，如MessageFormat.format(“hi, my name is {0}”, “zhangsan”)，不仅如此，占位符后面还可以跟一个类型和一个风格，它们之间用逗号隔开.单独将choice拿出来先讲讲，{1,choice,0#no house| 1#one hose | 2#two houses}，一个选择格式是由一个序列对构成的，每一个对包括一个&lt;code&gt;下限&lt;/code&gt;和一个&lt;code&gt;格式字符串&lt;/code&gt;，下面的列表中是其他的类型.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;类型&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;风格&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;number&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;integer、currency、percent、$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;time/date&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;short、medium、long、full、yyyy-MM-dd&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;注解中的所有元素值必须是编译期常量.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="daily-konwledge-point-java" scheme="http://zlia.tech/tags/daily-konwledge-point-java/"/>
    
  </entry>
  
  <entry>
    <title>每日知识点20190226</title>
    <link href="http://zlia.tech/2019/04/14/core-java-knowledge-20190226/"/>
    <id>http://zlia.tech/2019/04/14/core-java-knowledge-20190226/</id>
    <published>2019-04-14T05:02:06.000Z</published>
    <updated>2019-04-15T02:58:41.968Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java"><a href="#java" class="headerlink" title="java"></a><div><span>java</span></div></h3><ul><li><p>java Test &lt; 1.txt表示将1.txt中的内容作为其前面命令的输入.</p></li><li><p>java Test &gt; 1.txt表示将Test的结果输出到1.txt中.</p></li><li><p>双端队列，可以在头部和尾部添加或删除元素，但不支持在队列中间添加元素.</p></li><li><p>coll1.retainAll(coll2)：会从coll1中删除所有未在coll2中出现的元素.</p></li><li><p>方法引用所引用的方法的参数列表必须要和函数式接口中抽象方法的参数列表相同（完全一致），构造引用也是如此.</p></li><li><p>方法引用所引用的方法的的返回值必须要和函数式接口中抽象方法的返回值相同（完全一致），构造引用也是如此.</p><a id="more"></a></li><li><p>Optional作用：它在值不存在的情况下会使用替代物，而只有值存在的情况下才会使用这个值.</p></li><li><p>大家都推荐看核心技术卷1和卷2，为啥我觉得写的不是很通俗易懂呢？很多知识点的内容并没有讲的很明确，比如泛型、通配符这块。</p></li><li><p>对象序列化时序列号的作用是为了标识之前保存过的对象。如一个带有序列号为1的对象之前就被序列化过，那么另外的对象引用了该对象，此时只要在其中保存该对象的序列号即可，就可以引用到该对象.</p></li><li><p>Path类中的normalize方法将移除所有冗余的.和..部件。例如：规范化后/home/cay/../fred/./myprog将产生/home/cay/fred/myprog.</p></li><li><p>通过cmd命令来打包java程序时，可通过jar cvfe TestDemo.jar TestDemo TestDemo.class的方式完成，加上<code>e</code>参数可以在MANIFEST.MF文件中加入<code>Main-Class</code>来指定执行jar包时运行的类，俗称启   动类，如运行java -jar TestDemo.jar时，则会自动去跑TestDemo这个类.</p></li><li><p>p.resolve(q)按照下列规则返回一个路径：</p><ul><li>如果q是绝对路径，则结果就是q.</li><li>否则，根据文件系统的规则，将p后面跟着q作为结果.</li></ul></li><li><p>p.resolveSibling(q)：通过解析指定路径的父路径产生其兄弟路径.</p></li><li><p>Files.createDirectory(path)：其中，路径中除最后一个部件外，其他部分都必须是已存在的。要创建路径中的中间目录，应该使用Files.createDirectories(path).</p></li><li><p>内存映射文件：将一个文件或文件的一部分映射到内存中，然后这个文件就可以当作是内存数组一样地访问，比传统的文件操作要快很多.</p></li><li><p>buffer.flip()是将写模式转成读模式.</p></li><li><p>channel.lock()、channel.tryLock()：第一个调用会阻塞直至可获得锁，而第二个调用将立即返回，要么返回锁，要么在锁不可获得的情况下返回null.</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java&quot;&gt;&lt;a href=&quot;#java&quot; class=&quot;headerlink&quot; title=&quot;java&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;java&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;java Test &amp;lt; 1.txt表示将1.txt中的内容作为其前面命令的输入.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;java Test &amp;gt; 1.txt表示将Test的结果输出到1.txt中.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;双端队列，可以在头部和尾部添加或删除元素，但不支持在队列中间添加元素.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;coll1.retainAll(coll2)：会从coll1中删除所有未在coll2中出现的元素.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;方法引用所引用的方法的参数列表必须要和函数式接口中抽象方法的参数列表相同（完全一致），构造引用也是如此.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;方法引用所引用的方法的的返回值必须要和函数式接口中抽象方法的返回值相同（完全一致），构造引用也是如此.&lt;/p&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="daily-konwledge-point-java" scheme="http://zlia.tech/tags/daily-konwledge-point-java/"/>
    
  </entry>
  
  <entry>
    <title>我叫Spi，新成员</title>
    <link href="http://zlia.tech/2019/04/14/explain-spi-knowledge/"/>
    <id>http://zlia.tech/2019/04/14/explain-spi-knowledge/</id>
    <published>2019-04-14T05:01:40.000Z</published>
    <updated>2019-06-08T06:12:29.709Z</updated>
    
    <content type="html"><![CDATA[<h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a><div><span>自我介绍</span></div></h3><p>Spi，Service Provider Interface，是java提供的一套用来被第三方实现或扩展的API，它可以用来启用框架扩展或替换相应的组件。简单来说就是我提供标准，你按照我的标准提供实现就可以了，当然了，这个实现可以是可以有多个，你想选择哪个都可以，不过前提是你要知道所有的实现才能选择，这操作属于java中的策略模式，而所有的实现都被放在一个配置文件中，所以Spi基本上就是一个<code>接口</code> + <code>策略模式</code> + <code>配置文件</code>组合而成的动态加载机制。在面向对象的设计里，模块之间基于接口编程，模块之间不对实现类硬编码，在不同的场景下需要动态的指明实现类，这就需要一个服务发现的机制，Spi提供这样子的一个机制，为某个接口寻找服务实现的机制，将硬编码移到程序之外，也就是配置文件中，Spi的核心思想就是<code>解耦</code>。<a id="more"></a></p><h3 id="模拟Spi"><a href="#模拟Spi" class="headerlink" title="模拟Spi"></a><div><span>模拟Spi</span></div></h3><p>既然是标准，那么肯定有一些必须要遵守的规范：</p><ol><li>定义服务接口与服务接口的实现类，若是jar包则要在jar包的META-INF/services目录下创建一个以<code>接口全限定名</code>为文件名的文本文件，该文本文件的内容即<code>服务接口实现类的全限定名</code>。</li><li>该jar包记得加入到classpath中。</li><li>服务接口的实现类必须有一个不带参数的构造方法，即默认的构造方法。</li></ol><p>接下来看几个截图，具体的代码实现已经上传到github上了，有兴趣的读者可以看看，菜鸟级别的水平不要见怪！</p><p class="customize-img"><img src="/assets/blogImg/essays/spi/example-spi-1.png" alt="Spi例子-1"></p><p><code>请注意</code>，创建META-INF/service目录后最好看一下目录结构，<code>META-INF是一个目录，而service是它的子目录，这不是只有一层目录</code>，当时就被自己给坑了。</p><p class="customize-img"><img src="/assets/blogImg/essays/spi/example-spi-2.png" alt="Spi例子-2"></p><p>看了以上的内容咱们顺便在说下Spi的优缺点，不对，优点就是一开始说的解耦，将业务代码分离，简单说下缺点吧。看到上面的截图中采用的是ServiceLoader类来加载实现类，源码当中采用的是懒加载的方式，只有当我们去遍历配置文件中的实现类时才会一一实例化，缺点很明显，<code>只能通过遍历的方式去获取每个实现类，若你不想用某个实现类，它最终还是会被实例化，这势必造成了资源的浪费</code>，没有提供通过传入某个参数来获取到指定的实现类，不够灵活。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><div><span>总结</span></div></h3><p>网上有人说很多框架当中使用了Spi机制，比如JDBC加载不同的类型数据库的驱动、不同的日志实现类、Dubbo，虽然这些我都没有看过，但解耦是每个程序都需要的，这也奠定了Spi的重要性。Spi的缺点很明显，<code>可以在它的基础上在包装一层，这部分例子我从其他地方拷贝了过来，挺实用的，而正好是后期完善的，所以上面的截图中并没有显示这些内容，不过我已经放到了github上了</code>，有兴趣可以看看。最后加油自己，加油每一个人。</p><p><a href="https://github.com/JulianHang/little-mvn-project.git" target="_blank" rel="noopener">源码下载</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;自我介绍&quot;&gt;&lt;a href=&quot;#自我介绍&quot; class=&quot;headerlink&quot; title=&quot;自我介绍&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;自我介绍&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;Spi，Service Provider Interface，是java提供的一套用来被第三方实现或扩展的API，它可以用来启用框架扩展或替换相应的组件。简单来说就是我提供标准，你按照我的标准提供实现就可以了，当然了，这个实现可以是可以有多个，你想选择哪个都可以，不过前提是你要知道所有的实现才能选择，这操作属于java中的策略模式，而所有的实现都被放在一个配置文件中，所以Spi基本上就是一个&lt;code&gt;接口&lt;/code&gt; + &lt;code&gt;策略模式&lt;/code&gt; + &lt;code&gt;配置文件&lt;/code&gt;组合而成的动态加载机制。在面向对象的设计里，模块之间基于接口编程，模块之间不对实现类硬编码，在不同的场景下需要动态的指明实现类，这就需要一个服务发现的机制，Spi提供这样子的一个机制，为某个接口寻找服务实现的机制，将硬编码移到程序之外，也就是配置文件中，Spi的核心思想就是&lt;code&gt;解耦&lt;/code&gt;。
    
    </summary>
    
      <category term="essays" scheme="http://zlia.tech/categories/essays/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>我叫QPS，初次见面</title>
    <link href="http://zlia.tech/2019/04/07/explain-qps-knowledge/"/>
    <id>http://zlia.tech/2019/04/07/explain-qps-knowledge/</id>
    <published>2019-04-07T05:33:52.000Z</published>
    <updated>2019-06-08T06:12:19.385Z</updated>
    
    <content type="html"><![CDATA[<h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a><div><span>自我介绍</span></div></h3><p>QPS，query per second，<code>每秒的请求数</code>。当我看到这里的时候很不明白，每秒？按照我的理解应该是计算开始的时间到1秒钟这中间的请求数，但是怎么算是开始的时间，是指服务启动的时间还是第一次请求开始的时间，至少对于我来说讲述的并不是很明确。在比如，有一个时间线，第二秒的后500ms到第三秒的前500ms这样子也算是一个每秒的区间，那这之间的请求数算是咋回事呢？在说说QPS的目的，有人说是为了防止恶意刷取，增加项目负载，既然是控制刷取，那么我觉得这个控制应该是从别人第一次请求的时间开始算起，当它在1秒内多次请求达到上限后被服务限制了，这才算是合理的，所以我觉得应该是<code>从第一次请求开始的时间经过1秒后的请求数</code>，纯属个人理解。最近接触的项目中有提到QPS，说是恶意刷取，更准确的讲应该是用来做<code>流量控制</code>，这个词语给人的感觉更专业！而它算的时间也是从第一次请求开始算起的。 <a id="more"></a></p><h3 id="模拟QPS"><a href="#模拟QPS" class="headerlink" title="模拟QPS"></a><div><span>模拟QPS</span></div></h3><p>方便理解，模拟了一个场景来实现QPS的流量控制效果。<br>假设控制在1秒内不多于Limit个请求，Limit代表请求上限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkQps</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; limit ) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        total++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (System.nanoTime() - start &gt; duration) &#123;</span><br><span class="line">        total++;</span><br><span class="line">        reset();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这只是其中的一部分代码，也是最主要的，要想看所有的可到该文章的底部点击源码下载即可跳转到相应的位置。</p><h3 id="再见朋友"><a href="#再见朋友" class="headerlink" title="再见朋友"></a><div><span>再见朋友</span></div></h3><p>QPS是很多网站来衡量<code>吞吐量</code>的其中一个因素，基本上都会有一个统计图或者曲线图之类的，和QPS有关系的是另外一个朋友-<code>并发数</code>，目前笔者还没有去了解它，对于并发这块的知识点还远远不够，所以还早呢。又到了说几句鸡汤的时候了，技术是永远也学不完的，慢慢来，有一点点的进步总比呆坐着好，加油自己，加油每一个人。</p><p><a href="https://github.com/JulianHang/little-java-project/blob/master/src/tech/zlia/interest/example/FlowControlQpsTest.java" target="_blank" rel="noopener">源码下载</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;自我介绍&quot;&gt;&lt;a href=&quot;#自我介绍&quot; class=&quot;headerlink&quot; title=&quot;自我介绍&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;自我介绍&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;QPS，query per second，&lt;code&gt;每秒的请求数&lt;/code&gt;。当我看到这里的时候很不明白，每秒？按照我的理解应该是计算开始的时间到1秒钟这中间的请求数，但是怎么算是开始的时间，是指服务启动的时间还是第一次请求开始的时间，至少对于我来说讲述的并不是很明确。在比如，有一个时间线，第二秒的后500ms到第三秒的前500ms这样子也算是一个每秒的区间，那这之间的请求数算是咋回事呢？在说说QPS的目的，有人说是为了防止恶意刷取，增加项目负载，既然是控制刷取，那么我觉得这个控制应该是从别人第一次请求的时间开始算起，当它在1秒内多次请求达到上限后被服务限制了，这才算是合理的，所以我觉得应该是&lt;code&gt;从第一次请求开始的时间经过1秒后的请求数&lt;/code&gt;，纯属个人理解。最近接触的项目中有提到QPS，说是恶意刷取，更准确的讲应该是用来做&lt;code&gt;流量控制&lt;/code&gt;，这个词语给人的感觉更专业！而它算的时间也是从第一次请求开始算起的。
    
    </summary>
    
      <category term="essays" scheme="http://zlia.tech/categories/essays/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>每日知识点20190211</title>
    <link href="http://zlia.tech/2019/02/24/core-java-knowledge-20190211/"/>
    <id>http://zlia.tech/2019/02/24/core-java-knowledge-20190211/</id>
    <published>2019-02-24T04:09:16.000Z</published>
    <updated>2019-02-24T04:13:32.696Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java"><a href="#java" class="headerlink" title="java"></a><div><span>java</span></div></h3><ul><li>在同一个catch语句中可以捕获多个<code>不存在子类关系</code>的异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(FileNotFoundException | UnknowHostException e)&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>java中原来有提供<code>断言</code>，学到了学到了.</p></li><li><p>泛型类、泛型方法</p></li><li><p>一个类型变量或通配符可以有多个限定.限定类型用&amp;分隔，而逗号用来分隔类型变量.</p></li></ul><a id="more"></a><ul><li>对于编译器来说，用方法名+参数列表来确定一个方法签名.而对于虚拟机来说，用参数类型+返回类型来确定一个方法，编译器不允许开发者编码出方法名一致，返回值却不同的方法，而它自己却可以自动生成这种操作（产生两个仅返回类型不同的方法字节码）并交给虚拟机来处理.这种操作在泛型中称为<code>桥方法</code>，它主要用来避免类型变量擦除所带来的多态灾难.</li></ul><p class="customize-img"><img src="/assets/blogImg/daliy-konwledge-point/20190217/generic-method.png" alt="桥方法"></p><ul><li>运行时类型查询只适用于原始类型.意思是泛型不支持类型检查.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该类型检查会得到一个编译器错误</span></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Test&lt;String&gt;)&#123;</span><br><span class="line">    <span class="comment">//something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>不能使用像new T()、new T[]、T.class这样子表达式中的类型变量.</p></li><li><p>泛型类的静态上下文中类型变量无效.</p></li><li><p>不能抛出或捕获泛型类的实例.</p></li><li><p>带有超类型限定的通配符可以向泛型对象写入，带有子类型限定的通配符可以从泛型对象读取.</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java&quot;&gt;&lt;a href=&quot;#java&quot; class=&quot;headerlink&quot; title=&quot;java&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;java&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在同一个catch语句中可以捕获多个&lt;code&gt;不存在子类关系&lt;/code&gt;的异常&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt;(FileNotFoundException | UnknowHostException e)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;java中原来有提供&lt;code&gt;断言&lt;/code&gt;，学到了学到了.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;泛型类、泛型方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个类型变量或通配符可以有多个限定.限定类型用&amp;amp;分隔，而逗号用来分隔类型变量.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="daily-konwledge-point-java" scheme="http://zlia.tech/tags/daily-konwledge-point-java/"/>
    
  </entry>
  
  <entry>
    <title>每日知识点20181216</title>
    <link href="http://zlia.tech/2019/02/24/core-java-knowledge-20181216/"/>
    <id>http://zlia.tech/2019/02/24/core-java-knowledge-20181216/</id>
    <published>2019-02-24T04:08:59.000Z</published>
    <updated>2019-02-24T04:08:59.355Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java"><a href="#java" class="headerlink" title="java"></a><div><span>java</span></div></h3><ul><li><p>Arrays.deepToString(a)：打印二维数组.</p></li><li><p>Java8开始时间使用Date类，日期使用<code>LocalDate</code>类.</p></li><li><p>包内的类不能引用默认包中的类.</p></li><li><p>内部类可以是私有类（private），而常规类只可以具有包可见性（default）或公有可见性（public）.</p></li><li><p>内部类不能有static方法.</p></li><li><p>局部类不能用public或private访问说明符进行声明.</p></li></ul><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> flag)</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">FatherInner</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    System.out.println(flag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该段代码编译后生成Father.class与Father$1FatherInner.class文件.反编译Father$1FatherInner.class后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>$1<span class="title">Inner</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Father$<span class="number">1</span>Inner(Father var1,<span class="keyword">boolean</span> var2)&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span> = var1;</span><br><span class="line">        <span class="keyword">this</span>.val$flag = var2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.val$flag)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.val$flag)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> val$flag;</span><br><span class="line">    <span class="keyword">final</span> Father <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>由于构造器的名字与类名相同，而匿名类没有类名，所以匿名类不能有构造器.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java&quot;&gt;&lt;a href=&quot;#java&quot; class=&quot;headerlink&quot; title=&quot;java&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;java&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Arrays.deepToString(a)：打印二维数组.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Java8开始时间使用Date类，日期使用&lt;code&gt;LocalDate&lt;/code&gt;类.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;包内的类不能引用默认包中的类.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内部类可以是私有类（private），而常规类只可以具有包可见性（default）或公有可见性（public）.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内部类不能有static方法.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;局部类不能用public或private访问说明符进行声明.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="daily-konwledge-point-java" scheme="http://zlia.tech/tags/daily-konwledge-point-java/"/>
    
  </entry>
  
  <entry>
    <title>每日知识点20181213</title>
    <link href="http://zlia.tech/2018/12/14/core-java-knowledge-20181213/"/>
    <id>http://zlia.tech/2018/12/14/core-java-knowledge-20181213/</id>
    <published>2018-12-13T16:18:38.000Z</published>
    <updated>2019-02-26T10:38:17.699Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java"><a href="#java" class="headerlink" title="java"></a><div><span>java</span></div></h3><ul><li><p>s.substring(a,b)的长度：b-a.</p></li><li><p>String.join(“/“,”a”,”b”,”c”)：a/b/c.</p></li><li><p><code>字符串常量</code>是共享的，而+或substring等操作产生的结果并不是共享的，所以会导致拼接后的结果随便相同，但引用的地址却不是同一个.</p></li><li><p>Scanner in = new Scanner(System.in),String name = in.next(); //该方法以空格为分隔符，即空格符的之间的内容需要多次获取.</p></li><li><p>上面的读取控制台输入不适合密码，毕竟是明文，所以可采用Console类.但是Console不能在Eclipse或ide中的控制台使用，会报错.必须使用原始控制台，如在终端中编译运行Java代码即可使用.</p></li><li><p>float用<code>24</code>位来表示精确度，int用<code>32</code>位来表示精确度，故当将int转换成float时可能会丢失精度.</p></li><li><p>如果将一个类声明为final，只有其中的方法自动地成为final，而不包括域.</p></li><li><p>编译器对带有文件分割符和扩展名.java的文件进行操作，而java解释器加载类（带有分隔符）.</p></li></ul><a id="more"></a><ul><li><p>最好不要读取在初始化块后面的域</p></li><li><p>自动装箱：<code>Integer.valueOf(int i)</code>.自动装箱规范要求boolean、byte、char&lt;=127，介于-128~127之间的short和int被包装到固定的对象中.在Integer.valueOf(int i)中[-128,127]区间的Integer对象已经被初始化好了，每次调用只会从缓存中取，如果越过了这个区间则会创建新的对象，所以会导致超过了这个区间的Integer对象不相等.</p></li><li><p>装箱和拆箱是<code>编译器</code>认可的，而不是虚拟机.编译器在生成类的字节码时，插入必要的方法调用.虚拟机只是执行这些字节码.</p></li><li><p>整型数组类型int[]可以被转换成Object，但不能转换成对象数组Object[].</p></li><li><p><code>invoke</code>方法访问对象中的静态方法时，第一个参数可以被忽略，即可以将它设置为null.</p></li><li><p>在Java8中接口可以有默认方法和静态方法.</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java&quot;&gt;&lt;a href=&quot;#java&quot; class=&quot;headerlink&quot; title=&quot;java&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;java&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;s.substring(a,b)的长度：b-a.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;String.join(“/“,”a”,”b”,”c”)：a/b/c.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;字符串常量&lt;/code&gt;是共享的，而+或substring等操作产生的结果并不是共享的，所以会导致拼接后的结果随便相同，但引用的地址却不是同一个.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Scanner in = new Scanner(System.in),String name = in.next(); //该方法以空格为分隔符，即空格符的之间的内容需要多次获取.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;上面的读取控制台输入不适合密码，毕竟是明文，所以可采用Console类.但是Console不能在Eclipse或ide中的控制台使用，会报错.必须使用原始控制台，如在终端中编译运行Java代码即可使用.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;float用&lt;code&gt;24&lt;/code&gt;位来表示精确度，int用&lt;code&gt;32&lt;/code&gt;位来表示精确度，故当将int转换成float时可能会丢失精度.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果将一个类声明为final，只有其中的方法自动地成为final，而不包括域.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;编译器对带有文件分割符和扩展名.java的文件进行操作，而java解释器加载类（带有分隔符）.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="daily-konwledge-point-java" scheme="http://zlia.tech/tags/daily-konwledge-point-java/"/>
    
  </entry>
  
  <entry>
    <title>每日知识点20181212</title>
    <link href="http://zlia.tech/2018/12/12/core-java-knowledge-20181212/"/>
    <id>http://zlia.tech/2018/12/12/core-java-knowledge-20181212/</id>
    <published>2018-12-12T14:40:05.000Z</published>
    <updated>2019-01-16T15:16:27.469Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java"><a href="#java" class="headerlink" title="java"></a><div><span>java</span></div></h3><ul><li><p>jdk-8u191-windows-x64：Java SE 8的第<code>191次更新</code>.</p></li><li><p>OpenJDK：Java SE的一个免费的开源实现，不包含浏览器集成或JavaFX（用于图形化界面）.</p></li><li><p>从Java 7开始，数字字面量加下划线：<code>1_000_000</code>，Java编译器会去除这些下划线.</p></li><li><p>Double.isNaN(x)：判断是否是非数值.</p></li><li><p>整型值和布尔值之间不能进行相互转换.</p></li><li><p>Character.isJavaIdentifierStart：指定的字符是否允许作为Java标识符的<code>首字母</code>.</p></li><li><p>Character.isJavaIdentifierPart：指定的字符是否允许作为Java标识符的<code>一部分</code>.</p></li></ul><a id="more"></a><ul><li><p>15.0/2 = 7.5.</p></li><li><p>int -&gt; float：int包含的位数比float所能够表达的<code>位数多</code>，在转换过程中可能会丢失一定的精度.</p></li><li><p>数值类型之间的转换优先级：double &gt; float &gt; long &gt; int.</p></li><li><p>(byte)300 = 44，300是int类型，有32个bits（0000 0000 0001 0010 1100），而byte字节只有<code>8个bits</code>，所以最终取得后8位，即为44.</p></li><li><p>a += b += c：a +=(b += c).</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java&quot;&gt;&lt;a href=&quot;#java&quot; class=&quot;headerlink&quot; title=&quot;java&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;java&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;jdk-8u191-windows-x64：Java SE 8的第&lt;code&gt;191次更新&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;OpenJDK：Java SE的一个免费的开源实现，不包含浏览器集成或JavaFX（用于图形化界面）.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从Java 7开始，数字字面量加下划线：&lt;code&gt;1_000_000&lt;/code&gt;，Java编译器会去除这些下划线.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Double.isNaN(x)：判断是否是非数值.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;整型值和布尔值之间不能进行相互转换.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Character.isJavaIdentifierStart：指定的字符是否允许作为Java标识符的&lt;code&gt;首字母&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Character.isJavaIdentifierPart：指定的字符是否允许作为Java标识符的&lt;code&gt;一部分&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="daily-konwledge-point-java" scheme="http://zlia.tech/tags/daily-konwledge-point-java/"/>
    
  </entry>
  
  <entry>
    <title>搭建基于leancloud的评论系统</title>
    <link href="http://zlia.tech/2018/11/18/leancloud-build/"/>
    <id>http://zlia.tech/2018/11/18/leancloud-build/</id>
    <published>2018-11-18T07:11:42.000Z</published>
    <updated>2019-06-08T06:13:13.216Z</updated>
    
    <content type="html"><![CDATA[<h3 id="博客都有个评论系统"><a href="#博客都有个评论系统" class="headerlink" title="博客都有个评论系统"></a><div><span>博客都有个评论系统</span></div></h3><p>没啥好说的，但凡是个博客都应该有个评论系统。一开始找了个<code>多说</code>还是啥来着，要填写备案信息，好扯，只好绕路。又换了一个，<code>来必力</code>,搜了好几篇文章，都说不错不错，实际上给我的体验一般般，至少它的管理页面让我觉得不爽，当然了，我还是尝试了一波，因为懒，哈哈，结果居然不行！网上的一篇篇博客都TM是复制粘贴的，很难看出谁才是原创作者，没啥意思，真不知道是为了什么？别人的博客可以参考，复制就过分了，把我给气的，所以我的博客并没有放到百度的搜索库中，只有谷歌才能搜到，我宁愿别人没有看到自己的博客，也不想看着自己的成果被人一个个吞噬。后面又看了几篇文章，发现<code>leanCloud</code>这个评论系统是做的真可以，不是我吹牛，不管是文档还是管理端都很符合我的要求，脑子里一下子决定就是它了！当然了，它也没白白让我失望，花了2个晚上的时间就基本搞定了，体验真的好，它是免费的，啥都不用做，就只需要注册登录进去配置内容即可。<a id="more"></a></p><h3 id="动手开始干吧"><a href="#动手开始干吧" class="headerlink" title="动手开始干吧"></a><div><span>动手开始干吧</span></div></h3><p>因为我搭建该评论系统的时候也是参照着别人写好的博客来操作，关键是你提问作者还会准时回答的你，让我很佩服，更加重了我要搭建此评论系统的决心，真的赞！所以这里就贴出两个我觉得很好的博客文章，从零开始搭建的一个教程吧，它们是基于<code>yilia</code>主题来搭建的，因为我的博客应用的便是该主题。这两篇文章加起来刚好很完整，有代码层面的也有配置层面的，当然了，如果你看不懂也是可以在下方进行评论的，我就是其中的一个留言者！</p><p><a href="https://www.xxwhite.com/2017/Valine.html" target="_blank" rel="noopener">yilia主题配置leancloud</a> &amp; <a href="https://panjunwen.com/valine-admin-document/" target="_blank" rel="noopener">leancloud管理端配置</a></p><p><code>这里我在补充一些关键信息，也是非常重要的内容</code>，当初就是该错误让我找不到方向，上面提到的文章的作者也没能给我很好的回答，要是你仔细看评论的话可能会发现我留下的足迹，哈哈，整了2天都是因为该问题，都想放弃了，不够真心觉得它不错所以又拾起来了。按照上面提供的文章配置完毕后，你应该会在你的管理端中发现有这样子的内容，请看截图！</p><p class="customize-img"><img src="/assets/blogImg/leancloud/leancloud-build-1.png" alt="leancloud管理端"></p><p>当初配置完毕后就是少了<code>Comment Count</code>这两张表导致控制台一直报<code>https://xfc3sns5.api.lncld.net/1.1/classes/Comment?····</code>错误，我就想不通了，咋就这样子呢，有人让我创建一个，但我总得知道这表的数据结构吧，我去哪里找呢，肯定不好找，还是找了有一段时间，不好找，于是于是，报着尝试的心里将<code>原有的应用删除掉重新建了一个</code>，果然果然，这两张表有了，是<code>系统帮我们已经创建好的</code>，也就是说之所以第一次没生成成功是因为<code>leancloud</code>系统内部的原因，当然了你看不到内部有啥原因，只是存粹的猜测而已，反正第二次是成功了，开心开心，将内容重新发布后就可以了，控制台也没有报错了，哇！有兴趣的同学可以看下我的博客哈，菜鸟一枚，只为了提高自己来幸福自己！ <a href="http://zlia.tech/">zlia博客</a></p><p>最后的最后，我简单截下我配置后的效果图，里头也加上了评论邮箱通知功能。</p><p class="customize-img"><img src="/assets/blogImg/leancloud/leancloud-build-2.png" alt="配置leancloud管理端-2"></p><p class="customize-img"><img src="/assets/blogImg/leancloud/leancloud-build-3.png" alt="配置leancloud管理端-3"></p><p class="customize-img"><img src="/assets/blogImg/leancloud/leancloud-build-4.png" alt="配置leancloud管理端-4"></p><p class="customize-img"><img src="/assets/blogImg/leancloud/leancloud-build-5.png" alt="配置leancloud管理端-5"></p><p>截的图是相对比较重要的内容，其他像部署库和应用key参考提供的两篇文章就可以解决了，很简单。</p><h3 id="早点实现你想做的事"><a href="#早点实现你想做的事" class="headerlink" title="早点实现你想做的事"></a><div><span>早点实现你想做的事</span></div></h3><p>为啥会是这个小标题呢？好像跟博客没啥毛关系呢，其实是由于搭建了评论系统而进一步完善了博客，基本的东西都拥有了，倘若若干年后我在来回顾自己所写的博客文章，一定会越看越笑，就仿佛吃了蜜一样开心，一步一个脚印建立起来的，很有成就感！我想每个搭建博客的作者都应该会有这样子的感想吧。所以早点去做自己想做的事你就可以早点看到体验到什么叫做成功的人生，哈哈！无奈，感慨了一把！</p><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><a href="https://www.xxwhite.com/2017/Valine.html" target="_blank" rel="noopener">yilia主题配置leancloud</a> &amp; <a href="https://panjunwen.com/valine-admin-document/" target="_blank" rel="noopener">leancloud管理端配置</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;博客都有个评论系统&quot;&gt;&lt;a href=&quot;#博客都有个评论系统&quot; class=&quot;headerlink&quot; title=&quot;博客都有个评论系统&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;博客都有个评论系统&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;没啥好说的，但凡是个博客都应该有个评论系统。一开始找了个&lt;code&gt;多说&lt;/code&gt;还是啥来着，要填写备案信息，好扯，只好绕路。又换了一个，&lt;code&gt;来必力&lt;/code&gt;,搜了好几篇文章，都说不错不错，实际上给我的体验一般般，至少它的管理页面让我觉得不爽，当然了，我还是尝试了一波，因为懒，哈哈，结果居然不行！网上的一篇篇博客都TM是复制粘贴的，很难看出谁才是原创作者，没啥意思，真不知道是为了什么？别人的博客可以参考，复制就过分了，把我给气的，所以我的博客并没有放到百度的搜索库中，只有谷歌才能搜到，我宁愿别人没有看到自己的博客，也不想看着自己的成果被人一个个吞噬。后面又看了几篇文章，发现&lt;code&gt;leanCloud&lt;/code&gt;这个评论系统是做的真可以，不是我吹牛，不管是文档还是管理端都很符合我的要求，脑子里一下子决定就是它了！当然了，它也没白白让我失望，花了2个晚上的时间就基本搞定了，体验真的好，它是免费的，啥都不用做，就只需要注册登录进去配置内容即可。
    
    </summary>
    
      <category term="essays" scheme="http://zlia.tech/categories/essays/"/>
    
    
      <category term="leancloud" scheme="http://zlia.tech/tags/leancloud/"/>
    
  </entry>
  
  <entry>
    <title>不蒜子更换域名通告</title>
    <link href="http://zlia.tech/2018/11/14/busuanzi-latest-notice/"/>
    <id>http://zlia.tech/2018/11/14/busuanzi-latest-notice/</id>
    <published>2018-11-14T13:52:06.000Z</published>
    <updated>2018-11-14T13:54:27.006Z</updated>
    
    <content type="html"><![CDATA[<h3 id="想要告诉不知道的人"><a href="#想要告诉不知道的人" class="headerlink" title="想要告诉不知道的人"></a><div><span>想要告诉不知道的人</span></div></h3><p>你有博客吗？有的话继续往下看，没有的话就再见吧！有博客的人都是有故事的…废话不多说了，由于博客中会用到文章阅读量与网站访问人数的统计，我这边引用的是<code>不蒜子</code>插件。前几天发现控制台不断报与不蒜子相关的404错误，一看就知道肯定有蹊跷，果然，<code>原来它域名更改了</code>！官网都贴出了通告了！<a id="more"></a></p><p class="customize-img"><img src="/assets/blogImg/notice/busuanzi/busuanzi-1.png" alt="不蒜子更换域名通告"></p><p>作者的博客采用的主题为<code>yilia</code>，故这里贴出该主题的解决办法，其实就改个域名重新发布就OK了。</p><p>只需更改该目录下的<code>after-footer.ejs</code>文件即可。</p><p class="customize-img"><img src="/assets/blogImg/notice/busuanzi/busuanzi-2.png" alt="文件目录"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js••"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>更改为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p class="customize-img"><img src="/assets/blogImg/notice/busuanzi/busuanzi-3.png" alt="更改域名"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;想要告诉不知道的人&quot;&gt;&lt;a href=&quot;#想要告诉不知道的人&quot; class=&quot;headerlink&quot; title=&quot;想要告诉不知道的人&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;想要告诉不知道的人&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;你有博客吗？有的话继续往下看，没有的话就再见吧！有博客的人都是有故事的…废话不多说了，由于博客中会用到文章阅读量与网站访问人数的统计，我这边引用的是&lt;code&gt;不蒜子&lt;/code&gt;插件。前几天发现控制台不断报与不蒜子相关的404错误，一看就知道肯定有蹊跷，果然，&lt;code&gt;原来它域名更改了&lt;/code&gt;！官网都贴出了通告了！
    
    </summary>
    
      <category term="essays" scheme="http://zlia.tech/categories/essays/"/>
    
    
      <category term="notice" scheme="http://zlia.tech/tags/notice/"/>
    
  </entry>
  
  <entry>
    <title>简单喵下ActiveMQ生产者源码</title>
    <link href="http://zlia.tech/2018/09/02/explain-activemq-soucecod/"/>
    <id>http://zlia.tech/2018/09/02/explain-activemq-soucecod/</id>
    <published>2018-09-02T01:00:21.000Z</published>
    <updated>2019-06-08T06:12:11.886Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a><div><span>前提</span></div></h3><p>前提前提大前提！准备一份源码呗，activemq生产者的源码。何为生产者？就是发消息的源头，谁来发送消息谁就是生产者。有了生产者自然就会有消费者，今天着重看看生产者的故事，后面的几篇文章咱们都会一一进行讲解，包括服务端、消费者以及<code>ACK</code>模式，<code>消息的传送机制</code>，至于其他的内容还有待发掘，因为目前我也只是了解了部分！生产者的源码大伙可以从网上百度下，只要能跑起来就可以了，如果可以的话最好知道对方写了什么，对代码有个简单的理解，否则下面讲解的内容可能跟你的需求会有很大的出入，也帮助不了你哈，另一方面也是浪费了作者的苦心啦！自我迷恋中，切勿当真，哈哈。最好最好或者你有兴趣的话，可以clone下我的代码，里面都添加了对应的注释，<a href="https://github.com/JulianHang/activemq-client.git" target="_blank" rel="noopener">源码下载</a>。最后一个前提，作者使用的代码工具是<code>IDEA</code>，采用DEBUG模式来查看源码，所以读者对工具的操作最好有个简单的了解。好了，不啰嗦了！<a id="more"></a></p><h3 id="先看客户端如何连接到服务端"><a href="#先看客户端如何连接到服务端" class="headerlink" title="先看客户端如何连接到服务端"></a><div><span>先看客户端如何连接到服务端</span></div></h3><p>作者采用的代码工具是IDEA，所以不熟悉的读者最好先简单熟悉下！作者采取对象开始实例化时作为入口。</p><p class="customize-img"><img src="/assets/blogImg/activemq-producer/connectionFac-part-1.png" alt="实例化连接工厂"></p><p>由于代码跳转过于频繁，固采用择重点部分来讲解，同时用红色方块标记！这样子方便读者理解讲的是什么，毕竟看源码很容易迷失在代码的海洋中，甚至还会头晕，罪过罪过！要知道代码做了什么之前，先理解某个类是做什么用的，加深印象，鉴于理解，而读者只要翻译头部的英文即可大致明白，其他的类也是一个道理。该类是用来创建连接对象，对象有分队列、主题！说到这个，又得提一个点，咱们讲的内容都是基于主题来讲解的。</p><p>进入到内部代码中。</p><p class="customize-img"><img src="/assets/blogImg/activemq-producer/connectionFac-part-2.png" alt="连接工厂对象"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置账号、密码，为啥需要账号密码呢？连接服务端时可能需要提供账号密码来进行授权验证，默认是不需要的，可以在服务端的配置文件中增加授权验证功能</span></span><br><span class="line">setUserName(userName);</span><br><span class="line">setPassword(password);</span><br><span class="line"><span class="comment">//设置URL</span></span><br><span class="line">setBrokerURL(brokerURL);</span><br></pre></td></tr></table></figure><p class="customize-img"><img src="/assets/blogImg/activemq-producer/connectionFac-part-3.png" alt="连接对象"></p><p class="customize-img"><img src="/assets/blogImg/activemq-producer/connectionFac-part-4.png" alt="连接对象内部操作-1"></p><p class="customize-img"><img src="/assets/blogImg/activemq-producer/connectionFac-part-5.png" alt="连接对象内部操作-2"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将URL中QueryString的参数添加到Map中，如tcp://127.0.0.1:61614?wireFormat.cacheEnabled=false&amp;wireFormat.tightEncodingEnabled=false</span></span><br><span class="line"><span class="comment">//QueryString即为wireFormat.cacheEnabled=false&amp;wireFormat.tightEncodingEnabled=false，存入时以wireFormat.cacheEnabled为key，以false为value</span></span><br><span class="line">Map&lt;String, String&gt; options = <span class="keyword">new</span> HashMap&lt;String, String&gt;(URISupport.parseParameters(location));</span><br><span class="line"><span class="comment">//传输协议的配置信息对象，官方解释：专为在线路上的性能和大小而设计，具有更高的性能和更低的网络带宽</span></span><br><span class="line">WireFormat wf = createWireFormat(options);</span><br><span class="line"><span class="comment">//创建传输协议对象,如Tcp,同时将配置信息对象应用到该对象当中</span></span><br><span class="line">Transport transport = createTransport(location, wf);</span><br><span class="line"><span class="comment">//将QueryString中的参数配置应用到传输协议的配置信息对象当中，同时为每个过滤器设置相关联的传输协议对象来形成链条，以便后续对消息进行逐一处理</span></span><br><span class="line"><span class="comment">//链条的顺序：MutexTransport-&gt;WireFormatNegotiator-&gt;InactivityMonitor-&gt;TcpTransport</span></span><br><span class="line">Transport rc = configure(transport, wf, options);</span><br></pre></td></tr></table></figure><p class="customize-img"><img src="/assets/blogImg/activemq-producer/connectionFac-part-6.png" alt="连接对象内部操作-3"></p><p class="customize-img"><img src="/assets/blogImg/activemq-producer/connectionFac-part-7.png" alt="连接对象内部操作-4"></p><p>只是选择了部分代码进行讲解，因为有些代码官方并没有给出详细的说明！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...<span class="comment">//省略代码</span></span><br><span class="line"><span class="comment">//创建连接对象来存储连接信息，包括是否是异步发送，超时时间</span></span><br><span class="line"><span class="keyword">this</span>.info = <span class="keyword">new</span> ConnectionInfo(<span class="keyword">new</span> ConnectionId(uniqueId));</span><br><span class="line"><span class="comment">//创建连接会话对象，填充随机生成的连接ID，在同一个连接下的所有生产者消费者均采用同一个会话，多个生产者通过随机生成ID来区分</span></span><br><span class="line"><span class="keyword">this</span>.connectionSessionId = <span class="keyword">new</span> SessionId(info.getConnectionId(), -<span class="number">1</span>);</span><br><span class="line"><span class="comment">//设置监听，与服务端通信，包括发送连接信息、收发消息都会经过上面提到的链条逐一处理</span></span><br><span class="line"><span class="keyword">this</span>.transport.setTransportListener(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><h3 id="终于看到底层代码了"><a href="#终于看到底层代码了" class="headerlink" title="终于看到底层代码了"></a><div><span>终于看到底层代码了</span></div></h3><p class="customize-img"><img src="/assets/blogImg/activemq-producer/connectionFac-part-8.png" alt="连接对象内部操作-5"></p><p>我想大多数人都知道，实现连接底层的代码无非就是用的<code>socket</code>！好了，客户端到服务端的连接实现咱们已经阐述的差不多了，当然了，其中还有很多细节，包括涉及到模式，其实我到现在还不是很明白设计那些链条的意义都是什么？很疑惑，是出于什么情况下的考虑吗？就仿佛生产线一样，一个产品都需要经过每一个流程加工后才能到下一步，否则就是个废品！今天写的内容大多数以图片为主，主要讲几个重要的点通过代码加注释的方式点出来，一方面是希望读者能去详细查看内部代码做更进一步的了解，另一方面是其他的内容对于今天的主题来说可有可无，感兴趣的可以去了解下！下一步讲客户端如何开启事务及几种<code>ACK</code>模式。</p><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>链条</code></p><p><a href="https://github.com/JulianHang/activemq-client.git" target="_blank" rel="noopener">源码下载</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;前提&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;前提前提大前提！准备一份源码呗，activemq生产者的源码。何为生产者？就是发消息的源头，谁来发送消息谁就是生产者。有了生产者自然就会有消费者，今天着重看看生产者的故事，后面的几篇文章咱们都会一一进行讲解，包括服务端、消费者以及&lt;code&gt;ACK&lt;/code&gt;模式，&lt;code&gt;消息的传送机制&lt;/code&gt;，至于其他的内容还有待发掘，因为目前我也只是了解了部分！生产者的源码大伙可以从网上百度下，只要能跑起来就可以了，如果可以的话最好知道对方写了什么，对代码有个简单的理解，否则下面讲解的内容可能跟你的需求会有很大的出入，也帮助不了你哈，另一方面也是浪费了作者的苦心啦！自我迷恋中，切勿当真，哈哈。最好最好或者你有兴趣的话，可以clone下我的代码，里面都添加了对应的注释，&lt;a href=&quot;https://github.com/JulianHang/activemq-client.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源码下载&lt;/a&gt;。最后一个前提，作者使用的代码工具是&lt;code&gt;IDEA&lt;/code&gt;，采用DEBUG模式来查看源码，所以读者对工具的操作最好有个简单的了解。好了，不啰嗦了！
    
    </summary>
    
      <category term="mq" scheme="http://zlia.tech/categories/mq/"/>
    
    
      <category term="activemq" scheme="http://zlia.tech/tags/activemq/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ的简单使用</title>
    <link href="http://zlia.tech/2018/08/18/activemq-understand/"/>
    <id>http://zlia.tech/2018/08/18/activemq-understand/</id>
    <published>2018-08-18T10:51:45.000Z</published>
    <updated>2018-09-02T01:07:12.801Z</updated>
    
    <content type="html"><![CDATA[<h3 id="接触消息队列"><a href="#接触消息队列" class="headerlink" title="接触消息队列"></a><div><span>接触消息队列</span></div></h3><p>原本一开始是打算直接从activemq的客户端讲起的，但是忽然发现，既然对activemq有了些许了解之后，至少应该知道消息队列是什么？或者是它的由来和一些应用场景，可是我并不知道。我觉得更多的人更倾向于该技术怎么使用，而并不关心它为什么会出现，也很难静得下心来看它的理念以及应用场景，包括我。因为我觉得那些概念看着看着就可能让我失去了兴趣，也就果断地放弃学些了，哈哈。当然了，现在还是个小小的程序员，等升了职位后就该去考虑了，偷懒了偷懒了！不过这里我也简单地看了一下几篇<code>消息队列</code>的文章，着实不错，有各种高级的架构啊，所以分享给各位<a href="https://blog.csdn.net/dj2008/article/details/78872889" target="_blank" rel="noopener">消息队列的使用场景</a>。有打破砂锅问到底心态的朋友可以去观望观望，定不会让你失望。<a id="more"></a></p><h3 id="ActiveMQ服务端跑起来吧"><a href="#ActiveMQ服务端跑起来吧" class="headerlink" title="ActiveMQ服务端跑起来吧"></a><div><span>ActiveMQ服务端跑起来吧</span></div></h3><p>既然有客户端，那就一定要先有服务端，那我们就先让服务端跑起来吧！acitvemq官网下载地址：<a href="http://activemq.apache.org/activemq-5155-release.html" target="_blank" rel="noopener">http://activemq.apache.org/activemq-5155-release.html</a> 。官网提供了Linux和window的版本，由于没有Linux环境故下载了window版本。</p><p class="customize-img"><img src="/assets/blogImg/activemq/download-activemq.png" alt="下载AcitveMQ服务器window版本"></p><p>下载好了就直接解压即可。在跑起来之前先来认识下每个目录的用处以便后续的开发：</p><p class="customize-img"><img src="/assets/blogImg/activemq/activemq-catalog.png" alt="下载AcitveMQ服务器window版本"></p><ul><li>bin：存放用来启动<code>服务器的脚本文件</code>，可以用普通用户或管理员的权限来启动。</li><li>conf：存放<code>服务器的相关配置文件</code>、管理端的配置文件以及安全权限控制。多说几句，<code>activmemq.xml</code>是用来配置服务器相关协议的端口、地址和相关属性，还有消息存储方式以及集群方式等等。</li><li>data：存放<code>消息存储的文件</code>以及日志文件。</li><li>docs：ActiveMQ的相关文档。</li><li>examples：服务器相关协议的客户端例子。</li><li>lib：存放ActiveMQ相关jar包。</li><li>webapps/webapps-demo：存放ActiveMQ管理端的相关文件。</li></ul><p>来吧！开始跑起来~进入到bin目录中并双击activemq.bat文件，若出现如下图所示则说明启动成功了！</p><p class="customize-img"><img src="/assets/blogImg/activemq/start-activemq.png" alt="启动AcitveMQ服务器"></p><p>这里就不带大家去看管理端长啥样了，要是有兴趣的话可以私底下去观摩观摩，管理端的默认账号密码都是<code>admin</code>。</p><h3 id="开始造人了，生产者与消费者"><a href="#开始造人了，生产者与消费者" class="headerlink" title="开始造人了，生产者与消费者"></a><div><span>开始造人了，生产者与消费者</span></div></h3><p>既然服务器都搭建完成了，那么就开始着手造生产者与消费者了。先创建一个简单的Java项目，这里之所以创建的是Java项目，是因为笔者是直接通过引入ActiveMQ Jar包的方式来进行开发的。当然了，也可以用Maven来进行操作，不过鉴于有些用户不会用maven，所以干脆来个最简单的使用方式。</p><p class="customize-img"><img src="/assets/blogImg/activemq/create-activemq.png" alt="创建ActiveMQ项目"></p><p>啥都没有，空空如也。有用户可能会觉得还要去下载个Jar来引入，好麻烦啊，我才不想去下载，但是如果够细心的话，其实刚才在讲解ActiveMQ目录结构的时候最底下就有一个<code>activemq-all-5.9.0.jar</code>文件，一看名字就知道是ActiveMQ的所有Jar包，哈哈！将其该Jar包引入到项目中去。</p><p class="customize-img"><img src="/assets/blogImg/activemq/import-activemq.png" alt="引入ActiveMQ包"></p><p>Jar包引入了，那就速速开始开发吧！具体的代码内容就不做展示了，若有需要请在最下面点击<code>源码下载</code>即可到Github上获取所需。开发的差不多了，就来看看效果吧，首先启动消费者，在启动生产者，结果如图所示。</p><p class="customize-img"><img src="/assets/blogImg/activemq/producer-result.png" alt="生产者结果"><br><img src="/assets/blogImg/activemq/consumer-result.png" alt="消费者结果"></p><p>是否感觉很简单很容易，但是越往后你就会发现越来越多坑，哈哈，就很敲代码一样！不过，这都是必经之路，否则难成大神。好了，今天的分享就到这里了~</p><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>activemq.xml 生产者与消费者 ActiveMQ管理端</code></p><p><a href="https://github.com/JulianHang/activemq-client.git" target="_blank" rel="noopener">源码下载</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;接触消息队列&quot;&gt;&lt;a href=&quot;#接触消息队列&quot; class=&quot;headerlink&quot; title=&quot;接触消息队列&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;接触消息队列&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;原本一开始是打算直接从activemq的客户端讲起的，但是忽然发现，既然对activemq有了些许了解之后，至少应该知道消息队列是什么？或者是它的由来和一些应用场景，可是我并不知道。我觉得更多的人更倾向于该技术怎么使用，而并不关心它为什么会出现，也很难静得下心来看它的理念以及应用场景，包括我。因为我觉得那些概念看着看着就可能让我失去了兴趣，也就果断地放弃学些了，哈哈。当然了，现在还是个小小的程序员，等升了职位后就该去考虑了，偷懒了偷懒了！不过这里我也简单地看了一下几篇&lt;code&gt;消息队列&lt;/code&gt;的文章，着实不错，有各种高级的架构啊，所以分享给各位&lt;a href=&quot;https://blog.csdn.net/dj2008/article/details/78872889&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;消息队列的使用场景&lt;/a&gt;。有打破砂锅问到底心态的朋友可以去观望观望，定不会让你失望。
    
    </summary>
    
      <category term="mq" scheme="http://zlia.tech/categories/mq/"/>
    
    
      <category term="activemq" scheme="http://zlia.tech/tags/activemq/"/>
    
  </entry>
  
  <entry>
    <title>读懂Javascript中的作用域链</title>
    <link href="http://zlia.tech/2018/06/03/js-scope/"/>
    <id>http://zlia.tech/2018/06/03/js-scope/</id>
    <published>2018-06-03T13:08:06.000Z</published>
    <updated>2018-08-18T07:32:37.303Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安静安静的看会书都不行"><a href="#安静安静的看会书都不行" class="headerlink" title="安静安静的看会书都不行"></a><div><span>安静安静的看会书都不行</span></div></h3><p>咦，咱们的文章标题是不是写错了。。其实是有原因的，以前没看到犀牛书以为应该是本通俗易懂的好书，不管是走到哪里都会看到有人推荐这本书。拿到这本书的时候我是很兴奋的，加上右下角又写着<code>淘宝前端译</code>，顿时觉得不愧是本好书！可惜啊，在看了不到两天后觉得这里头的语句何止是不通顺，甚至是读不懂，一开始以为我是不是很久没读书了，理解能力都下降了。好，继续读，天啊！大牛们这是直接翻译英文还是加上理解后在翻译呢，压力大的很，正好我也刚看到了作用域，身心觉得不能在放过了，要不就废了。于是，我借鉴了网上的相关知识并加上自己的理解来进行升级。<a id="more"></a></p><h3 id="犀牛书上关于作用域链的原话"><a href="#犀牛书上关于作用域链的原话" class="headerlink" title="犀牛书上关于作用域链的原话"></a><div><span>犀牛书上关于作用域链的原话</span></div></h3><p>在JavaScript的最顶层代码中，作用域链由一个全局对象组成。在不包含嵌套的函数体内，作用域链上有两个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象。在一个嵌套的函数体内，作用域链上至少有三个对象。当定义一个函数时，它实际上保存一个作用域链。当调用这个函数时，它创建一个新的对象来存储它的局部变量，并将这个对象添加至保存的那个作用域链上，同时创建一个新的更长的表示函数调用作用域的“链”。就这么几句话就想概括了这块的知识点，我服！不管它了，在理解这块知识点前先来介绍几个专业术语。</p><ul><li><code>执行环境</code>：定义了变量或函数，决定了它们各自的行为。每个执行环境中都有一个与之关联的执行上下文对象，该环境中的所有变量和函数都由这个对象来创建。而当执行环境中的代码被执行完毕后就会进入到销毁阶段，该环境中的变量和函数也会跟随着消失。<code>全局执行环境</code>是最外围的一个执行环境，在浏览器中，它的执行上下文对象是window，因此所有的变量以及函数都由window对象来创建成属性或方法。<code>每个函数都有执行环境</code>：当一个函数被调用时，该函数就会被推入到堆栈中，由于window是最先被推入的，所以该堆栈中最底部的环境永远是window。</li></ul><p class="customize-img"><img src="/assets/blogImg/js/execution-context.png" alt="执行环境"></p><p>执行环境的建立分两个阶段：<code>建立执行上下文对象</code>和<code>代码执行阶段</code>。</p><ul><li><code>执行上下文对象</code>：该对象是在函数被调用时，但还未执行代码时被创建的。在该对象中主要创建了作用域链、变量、函数、参数、this的指向对象，来看个具体的例子。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'hello'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//something</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>那么在调用foo(22)时，具体的建立阶段如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fooEexecutionContext = &#123;</span><br><span class="line">variableObject: &#123;</span><br><span class="line"><span class="built_in">arguments</span>: &#123;</span><br><span class="line"><span class="number">0</span>: <span class="number">22</span>,</span><br><span class="line">length: <span class="number">1</span></span><br><span class="line">&#125;,</span><br><span class="line">i: <span class="number">22</span>,</span><br><span class="line">b: pointer to <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)，//函数引用</span></span><br><span class="line"><span class="function"><span class="title">a</span>: <span class="title">undefined</span></span></span><br><span class="line"><span class="function">&#125;,</span></span><br><span class="line"><span class="function"><span class="title">scopeChain</span>: </span>&#123;&#125;,</span><br><span class="line"><span class="keyword">this</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由此可见，在创建执行上下文对象时，除了arguments、函数、参数被赋予了具体的值之外，其他的变量默认都是undefined。建立阶段结果后就进入到了具体的代码执行阶段，在代码执行完成后，执行上下文对象经过了如下的变化。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fooEexecutionContext = &#123;</span><br><span class="line">variableObject: &#123;</span><br><span class="line"><span class="built_in">arguments</span>: &#123;</span><br><span class="line"><span class="number">0</span>: <span class="number">22</span>,</span><br><span class="line">length: <span class="number">1</span></span><br><span class="line">&#125;,</span><br><span class="line">i: <span class="number">22</span>,</span><br><span class="line">b: pointer to <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)，//函数引用</span></span><br><span class="line"><span class="function"><span class="title">a</span>: '<span class="title">hello</span>'</span></span><br><span class="line"><span class="function">&#125;,</span></span><br><span class="line"><span class="function"><span class="title">scopeChain</span>: </span>&#123;&#125;,</span><br><span class="line"><span class="keyword">this</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到这里你会知道，函数中的变量只有在具体代码的执行阶段才会被真正的赋值，这也正好解释了js当中的声明提前机制，即使变量声明在变量使用的后面依然可以打印出变量值，只不过该值是undefined。</p><ul><li><code>活动对象</code>：当函数被调用的时候，一个对象将会被创建，即活动对象。该活动对象之后便会作为执行上下文对象来使用。</li></ul><h3 id="作用域链详解"><a href="#作用域链详解" class="headerlink" title="作用域链详解"></a><div><span>作用域链详解</span></div></h3><p>上面已经解释到，当函数被调用时，创建相应的执行环境、执行上下文对象并将其添加到作用链中，其实也就是执行环境被推入到堆栈中，该作用域的底部永远都是全局的执行上下文对象，因为它是最先被加载的。以下通过图片的形式来更为形象的说明。</p><p class="customize-img"><img src="/assets/blogImg/js/function-detail.png" alt="函数执行过程"></p><p>声明father函数时，会创建一个预先包含全局执行上下文对象的作用域链，这个作用域链会被保存在内部的属性中。当调用father函数时，会为函数创建一个执行环境，同时构建起执行环境的带有全局执行上下文对象的作用域链。紧接着，创建该函数的执行上下文对象并将其添加到该作用域中，也就是作用域当中最终有两个执行上下文对象，若是函数当中嵌套着函数，则对象的作用域应当有三个执行上下文对象，当最顶端的执行上下文对象被执行完成后，下一个即为包含该函数的执行上下文对象，就是外部函数，就这样一直延续到全局执行上下文对象。作用域链本质上是一个指向执行上下文对象的指针列表，每调用一个不同的函数都会创建一个作用域链，其用途是保证执行环境中的变量及函数被有序访问。</p><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>执行环境 执行上下文环境 函数执行过程图</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;安静安静的看会书都不行&quot;&gt;&lt;a href=&quot;#安静安静的看会书都不行&quot; class=&quot;headerlink&quot; title=&quot;安静安静的看会书都不行&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;安静安静的看会书都不行&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;咦，咱们的文章标题是不是写错了。。其实是有原因的，以前没看到犀牛书以为应该是本通俗易懂的好书，不管是走到哪里都会看到有人推荐这本书。拿到这本书的时候我是很兴奋的，加上右下角又写着&lt;code&gt;淘宝前端译&lt;/code&gt;，顿时觉得不愧是本好书！可惜啊，在看了不到两天后觉得这里头的语句何止是不通顺，甚至是读不懂，一开始以为我是不是很久没读书了，理解能力都下降了。好，继续读，天啊！大牛们这是直接翻译英文还是加上理解后在翻译呢，压力大的很，正好我也刚看到了作用域，身心觉得不能在放过了，要不就废了。于是，我借鉴了网上的相关知识并加上自己的理解来进行升级。
    
    </summary>
    
      <category term="frontend" scheme="http://zlia.tech/categories/frontend/"/>
    
    
      <category term="js" scheme="http://zlia.tech/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>尝尝markdown源码的味道</title>
    <link href="http://zlia.tech/2018/05/23/markdown-understand/"/>
    <id>http://zlia.tech/2018/05/23/markdown-understand/</id>
    <published>2018-05-22T16:16:23.000Z</published>
    <updated>2019-06-08T06:13:19.684Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一切动力源于好奇"><a href="#一切动力源于好奇" class="headerlink" title="一切动力源于好奇"></a><div><span>一切动力源于好奇</span></div></h3><p>为什么要写md的原理呢？因为md的语法本来就很有局限性，想要整个高大上的页面就显得很鸡肋，所以需要我们自己去定义一些语法来解析生成对应的标签。原本以为github或者google上应该有个现成什么的，至少也要有个大体的方向，可惜我是个菜鸟表示看不懂各位大神所描述的，看不懂看不懂，故打算自己看下源码，要求不高，大部分看懂就可以了，特地写了此篇文章来阐述自己对源码的理解，同时也为需要的人提供一些小小的帮助，嘻嘻！<a id="more"></a></p><h3 id="着手啃代码"><a href="#着手啃代码" class="headerlink" title="着手啃代码"></a><div><span>着手啃代码</span></div></h3><p>首先去github上clone个<a href="https://github.com/markedjs" target="_blank" rel="noopener">markdown源代码</a>，我在看源代码的时候喜欢先看大神写的小Demo，不知道其他大神是怎么欣赏别人文章的，好奇，也想学习学习。在项目中有个doc目录，打开它你就可以看到有个Demo目录，open it。只有100多行的代码，简单容易理解，所以建议大家也可以先看下Demo，先简单地浏览下。如果你是个有经验的前端开发者，我想你应该不会在我的文章里多呆一分钟吧，所以此篇文章的主要对象是初学者和不是从事前端开发的人员，因为我也不是个前端开发者，顶多是个业余的，惭愧惭愧，若接下来有什么理解错误的地方请谅解，若讲的不错请常来就好。你在浏览代码的过程中难免会发现有这么一个对象<code>marked</code>，为什么会是它呢？因为有这样一条语句<code>marked.parser</code>，其实就是解析的意思啦，好庸俗啊。。接着来，解析md语法的主要入口就是它，如果还不信的话可以在当前目录下打开index.html文件，打开后在其控制台（F12）下打印marked，会出现一个function对象，奇怪了，这是个什么鬼，双击后便可以看到另一个文件<code>marked.js</code>，这个文件在上一级目录lib下，它才是最主要的解析md语法的重点。回到刚才的Demo中，我们搜索下marked对象第一次出现的位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lexed = marked.lexer($inputElem.value);</span><br></pre></td></tr></table></figure><p>如果你认识lexer这个单词的话你应该就会明白这句话的意思是什么。<strong>词法分析器</strong>，实际上是根据是否匹配正则表达式从而进一步分析md的语法，最后组装好数据返回，这些数据主要是你用了哪些语法内容，如###之类，以及对应的值。接着来看下一步，parser方法是根据返回的数据解析成html，然后将内容innerHtml到页面上，最终的效果也就是你看到的页面。如果有同学觉得疑惑的话，你可以打开index.html页面进行调试便可以很容易的明白我所阐述的内容。</p><h3 id="深入代码内部击垮敌军"><a href="#深入代码内部击垮敌军" class="headerlink" title="深入代码内部击垮敌军"></a><div><span>深入代码内部击垮敌军</span></div></h3><p>现在我们只是大体的明白了md原理的表面，对于我们想要自定义语法来说，还远远不够，必须要深入到代码内部去，只有这样子才能彻底击垮敌军，来看看marked.js文件中的<code>lexer</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lexer.prototype.lex = <span class="function"><span class="keyword">function</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  src = src</span><br><span class="line">    .replace(<span class="regexp">/\r\n|\r/g</span>, <span class="string">'\n'</span>)</span><br><span class="line">    .replace(<span class="regexp">/\t/g</span>, <span class="string">'    '</span>)</span><br><span class="line">    .replace(<span class="regexp">/\u00a0/g</span>, <span class="string">' '</span>)</span><br><span class="line">    .replace(<span class="regexp">/\u2424/g</span>, <span class="string">'\n'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.token(src, <span class="literal">true</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在lexer方法中将制表符、换行等之类的表达式用对应的空格或者指定换行表达式来代替，以防后面解析时出现错误。在lexer内部中调用了<code>token</code>方法。在这个方法中，主要做的是根据md语法写的内容进行正则表达式匹配，其中的部分代码是匹配标题（#{1,6}）的方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// heading</span></span><br><span class="line">   <span class="keyword">if</span> (cap = <span class="keyword">this</span>.rules.heading.exec(src)) &#123;</span><br><span class="line">     src = src.substring(cap[<span class="number">0</span>].length);</span><br><span class="line">     <span class="keyword">this</span>.tokens.push(&#123;</span><br><span class="line">       type: <span class="string">'heading'</span>,</span><br><span class="line">       depth: cap[<span class="number">1</span>].length,</span><br><span class="line">       text: cap[<span class="number">2</span>]</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>匹配到对应的规则之后进行数据的封装，封装的数据主要是类型、内容、具体匹配了哪一种（Depth指的是匹配了h1、h2、h3中的哪一种）。到这里Demo中的marked.lexer方法就结束了，它返回了匹配成功后的数据封装。下一步来到<code>marked.parse</code>，将之前的数据封装传入，并构建标签分析器，专业术语我不知道，因为这一步会生成一个html，故称之为标签分析器，接着开始执行<code>tok</code>方法，部分代码用来匹配标题的方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'heading'</span>: &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.renderer.heading(</span><br><span class="line">       <span class="keyword">this</span>.inline.output(<span class="keyword">this</span>.token.text),</span><br><span class="line">       <span class="keyword">this</span>.token.depth,</span><br><span class="line">       <span class="built_in">unescape</span>(<span class="keyword">this</span>.inlineText.output(<span class="keyword">this</span>.token.text)));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>走下一步到<code>output</code>，根据内容参数来匹配正则表达式，当然了，这其中发生了很多事，有<code>merger</code>方法，主要用来合并相关匹配标签的正则表达；有<code>edit</code>方法，主要用来将通用的正则整合在一起。其实这两种方法都是在对正则表达式进行操作，可见作者对正则的理解很高深，至少在我看来正则知识较为难学，会让人头都脑壳痛。因为内容有可能会出现标签，如div，在escape方法中将其转换成$lt、$gt等之类的标记，防止出现解析错误造成乱码。大家有注意到格式转换后都会去调用this.render.text或者其他类似的方法，在其对应的方法中返回由标签包围的内容的字符串形式，最后在将其字符串打入到页面中即可呈现你想要的效果。若有同学想要改变标签的表现形式即可根据所需来对<code>this.render</code>中的具体方法来做修改，不妨试一试。</p><h3 id="战后总结"><a href="#战后总结" class="headerlink" title="战后总结"></a><div><span>战后总结</span></div></h3><p>表面上说是看了源码感觉很厉害的样子，但是里面的很多细节表示没有看懂或者理解不到位甚至是理解出错，顿时感觉自己的功力和水平还远远不够，难怪说程序员就是要一直学习下去，不然连个饭碗都端不起了，惭愧惭愧。有人说要想有所成长就必须要去看别人写的源码，看多了总会让人想吐，恶心，这还是一点点的代码，要是那种一片一片的代码，我想早就炸了，希望日后加强自身的知识储备，好好努力，加油！</p><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>lexe token parse output render</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一切动力源于好奇&quot;&gt;&lt;a href=&quot;#一切动力源于好奇&quot; class=&quot;headerlink&quot; title=&quot;一切动力源于好奇&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;一切动力源于好奇&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;为什么要写md的原理呢？因为md的语法本来就很有局限性，想要整个高大上的页面就显得很鸡肋，所以需要我们自己去定义一些语法来解析生成对应的标签。原本以为github或者google上应该有个现成什么的，至少也要有个大体的方向，可惜我是个菜鸟表示看不懂各位大神所描述的，看不懂看不懂，故打算自己看下源码，要求不高，大部分看懂就可以了，特地写了此篇文章来阐述自己对源码的理解，同时也为需要的人提供一些小小的帮助，嘻嘻！
    
    </summary>
    
      <category term="essays" scheme="http://zlia.tech/categories/essays/"/>
    
    
      <category term="markdown" scheme="http://zlia.tech/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>初识异常</title>
    <link href="http://zlia.tech/2018/05/06/exception-knowledge/"/>
    <id>http://zlia.tech/2018/05/06/exception-knowledge/</id>
    <published>2018-05-06T08:28:24.000Z</published>
    <updated>2019-06-08T06:12:04.776Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a><div><span>简介</span></div></h3><p>用户在运行程序的期间，往往有可能会出现各种各样的错误导致程序执行失败，其结果是用户数据丢失。出现这种情况的时候当然不能置之不理，要么就应该告诉用户该错误，要么是用户数据得到保存，否则用户流量将呈现下降的趋势。为了正确的处理错误，Java提供了一种称为：<code>异常处理的错误捕获机制处理</code>。该机制的任务就是将控制权从错误产生的地方转移给能够处理错误的处理器。当然了，想要正确的处理异常情况的前提是必须要研究程序中哪些地方会出现问题和错误。<a id="more"></a></p><blockquote><p>异常的处理机制就好比生活中较为常见的灾难预防措施，如在公共场所安防灭火器、洒水器。</p></blockquote><h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a><div><span>异常分类</span></div></h3><p>在Java程序设计语言中，异常对象都是派生于<code>Throwable</code>类的一个实例，若内置的异常类不能满足需求，则用户还可以创建自己的异常类。</p><p class="customize-img"><img src="/assets/blogImg/exception/throwable-hierarchy.png" alt="异常层次目录"></p><p>所有的异常都是由<code>Throwable</code>继承而来，在下一层又划分为两个分支：<code>Error</code>和<code>Exception</code>。</p><ul><li><code>Error</code>：描述了Java运行时系统的内部错误。在程序当中不应该抛出这种类型的错误，因为该错误除了通知用户之外，我们对它无能为力。</li><li><code>Exception</code>：<ul><li><code>IOException</code>：操作IO时出现的异常情况，如操作的文件不存在、试图在文件尾部后面读取数据。</li><li><code>RuntimeException</code>：由程序的错误编写而导致异常的出现，如错误的类型转换、数组角标越界。</li></ul></li></ul><h3 id="声明受查异常"><a href="#声明受查异常" class="headerlink" title="声明受查异常"></a><div><span>声明受查异常</span></div></h3><p>Java语言规范将派生于<code>Error</code>或<code>RuntimeException</code>的所有异常成为<code>非受查异常</code>，其他的所有异常称为<code>受查异常</code>。<br>为什么要声明异常呢？当你遇到无法处理的情况时是不是要告诉别人这件事我做不了你看着办，有点小尴尬的样子～至于为什么受查异常要声明而非受查异常不用声明呢？（声明了也不要紧，只是没必要）-见如下分析～</p><blockquote><p>处理文件时一般会先检查该文件是否存在，但是它是不是有可能在你检查完是否存在后就被删除了，所以受查异常更取决于环境而不只是代码。运行时异常（RuntimeException）出现的原因是由于代码编写的不规范而产生的，这完全是在我们的控制范围内，Java语言建议我们应该将更多的时间花费在修正程序中的错误上，而不是说明这些错误发生的可能性，所以非受查异常要么是我们无能为力的，要么是我们应该通过修正程序来避免发生。</p></blockquote><p>一个方法有可能要声明多个受查异常类型，那么就必须在方法的首部列出所有的异常类，每个异常类之间用逗号隔开。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.zlia.exception.knowledge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.EOFException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnimation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawImage</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">throws</span> FileNotFoundException , EOFException </span>&#123;</span><br><span class="line"><span class="comment">//do anything</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a><div><span>重点关注</span></div></h3><p><code>Throwable RuntimeException IOException 受查异常 非受查异常</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;&lt;div&gt;&lt;span&gt;简介&lt;/span&gt;&lt;/div&gt;&lt;/h3&gt;&lt;p&gt;用户在运行程序的期间，往往有可能会出现各种各样的错误导致程序执行失败，其结果是用户数据丢失。出现这种情况的时候当然不能置之不理，要么就应该告诉用户该错误，要么是用户数据得到保存，否则用户流量将呈现下降的趋势。为了正确的处理错误，Java提供了一种称为：&lt;code&gt;异常处理的错误捕获机制处理&lt;/code&gt;。该机制的任务就是将控制权从错误产生的地方转移给能够处理错误的处理器。当然了，想要正确的处理异常情况的前提是必须要研究程序中哪些地方会出现问题和错误。
    
    </summary>
    
      <category term="rearend" scheme="http://zlia.tech/categories/rearend/"/>
    
    
      <category term="java" scheme="http://zlia.tech/tags/java/"/>
    
  </entry>
  
</feed>
